<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
    
  
  <link href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






  

<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="js,前端,Vue," />








  <link rel="shortcut icon" type="image/x-icon" href="/images/liliicon.png?v=5.1.0" />






<meta name="description" content="看到朋友圈里要么是风景要么是美食，我就知道我离他们不远了——鸟哥哥
前前后后大约一个多月的时间，中间几经波折，几经修改原型，也曾想过认怂，好在凭借自己坚韧的毅力和默默地坚持，终于算是完成了项目一稿（前期掉了好几斤肉…）。现在趁着国庆期间，好好总结中间踩过的坑。据说国庆之后的第四季度是公司最忙的时候，估计以后又要每天加班，与代码为伴了，有点可怜的feel。(加班没关系，身体最重要！虽然很年轻，但我也">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue2.0项目总结(前端)">
<meta property="og:url" content="http://niaogege.cn/2017/10/03/Vue项目总结-前端/index.html">
<meta property="og:site_name" content="开到荼蘼">
<meta property="og:description" content="看到朋友圈里要么是风景要么是美食，我就知道我离他们不远了——鸟哥哥
前前后后大约一个多月的时间，中间几经波折，几经修改原型，也曾想过认怂，好在凭借自己坚韧的毅力和默默地坚持，终于算是完成了项目一稿（前期掉了好几斤肉…）。现在趁着国庆期间，好好总结中间踩过的坑。据说国庆之后的第四季度是公司最忙的时候，估计以后又要每天加班，与代码为伴了，有点可怜的feel。(加班没关系，身体最重要！虽然很年轻，但我也">
<meta property="og:image" content="http://niaogege.cn/images/vuex.png">
<meta property="og:updated_time" content="2017-11-10T13:16:16.955Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vue2.0项目总结(前端)">
<meta name="twitter:description" content="看到朋友圈里要么是风景要么是美食，我就知道我离他们不远了——鸟哥哥
前前后后大约一个多月的时间，中间几经波折，几经修改原型，也曾想过认怂，好在凭借自己坚韧的毅力和默默地坚持，终于算是完成了项目一稿（前期掉了好几斤肉…）。现在趁着国庆期间，好好总结中间踩过的坑。据说国庆之后的第四季度是公司最忙的时候，估计以后又要每天加班，与代码为伴了，有点可怜的feel。(加班没关系，身体最重要！虽然很年轻，但我也">
<meta name="twitter:image" content="http://niaogege.cn/images/vuex.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '6332298555788625000',
      author: '鸟哥哥'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://niaogege.cn/2017/10/03/Vue项目总结-前端/"/>





  <title> Vue2.0项目总结(前端) | 开到荼蘼 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?5c8875c34741910bdcebbf0b0dc5541c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=60320485";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">开到荼蘼</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <h1 class="site-subtitle" itemprop="description">幸福就像花季，开到荼蘼</h1>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
	  
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://niaogege.cn/2017/10/03/Vue项目总结-前端/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="鸟哥哥">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/cpp.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="开到荼蘼">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="开到荼蘼" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                Vue2.0项目总结(前端)
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-03T17:27:00+08:00">
                2017-10-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index">
                    <span itemprop="name">vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/03/Vue项目总结-前端/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/10/03/Vue项目总结-前端/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><blockquote class="blockquote-center" style="color:#2d9fb3;">看到朋友圈里要么是风景要么是美食，我就知道我离他们不远了<br>——鸟哥哥</blockquote></p>
<p style="text-indent:20px">前前后后大约一个多月的时间，中间几经波折，几经修改原型，也曾想过认怂，好在凭借自己坚韧的毅力和默默地坚持，终于算是完成了项目一稿（前期掉了好几斤肉…）。现在趁着国庆期间，好好总结中间踩过的坑。据说国庆之后的第四季度是公司最忙的时候，估计以后又要每天加班，与代码为伴了，有点可怜的feel。(加班没关系，身体最重要！虽然很年轻，但我也不能过度的耗损自己的身体。)<br><br>说重点，本项目是一个小型的关于文档操作的系统，技术栈主要采用<code style="background:#2d9fb3;color:white;">Vue2.0+Vuex+vue-router+ES6+vue-resource</code>。为什么选择了vue作为前端框架?一是可维护性，技术学习曲线，二是项目本身很小，采用ng这种重量级框架有点大材小用。最终选择Vue还是很感激涛哥（谢谢大神，后面在好好感激一番）</p>

<a id="more"></a>
<h3 id="Vue基础使用"><a href="#Vue基础使用" class="headerlink" title="Vue基础使用"></a>Vue基础使用</h3><h4 id="components"><a href="#components" class="headerlink" title="components"></a>components</h4><p>在 Vue 中，父子组件的关系可以总结为<code style="background:#2d9fb3;color:white;"> props down, events up</code>。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。看看它们是怎么工作的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#### parent component父组件：引用子组件，向子组件传递数据</div><div class="line">&lt;mine-search</div><div class="line">  :searchClick=&quot;searchClick&quot;</div><div class="line">  :myMessage=&quot;parentMsg&quot;</div><div class="line">  :isDisplayBtnGroup = &apos;isDisplayBtnGroup&apos;</div><div class="line">  @displayList=&quot;fileFolderFn&quot;</div><div class="line">  @getListFn=&quot;getListFn&quot;</div><div class="line">  &gt;</div><div class="line">&lt;/mine-search&gt;</div><div class="line">#### child component 子组件</div><div class="line">export default &#123;</div><div class="line">  data()&#123;&#125;,</div><div class="line">  props:[&apos;myMessage&apos;,&apos;isDisplayBtnGroup&apos;],</div><div class="line">  methods:&#123;</div><div class="line">    addFolderChild ()&#123;</div><div class="line">      this.$emit(&apos;addFolderParent&apos;)</div><div class="line">    &#125;,</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>我们知道，父组件是使用 props 传递数据给子组件，但子组件怎么跟父组件通信呢？这个时候 Vue 的自定义事件系统就派得上用场了。<br>使用 $on(eventName) 监听事件;使用 $emit(eventName) 触发事件</p>
</blockquote>
<h4 id="slot-vue官网"><a href="#slot-vue官网" class="headerlink" title="slot (vue官网)"></a>slot (vue官网)</h4><p>为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为内容分发 (或“transclusion”如果你熟悉 Angular)</p>
<h5 id="单个插槽-slot"><a href="#单个插槽-slot" class="headerlink" title="单个插槽 slot"></a>单个插槽 slot</h5><h5 id="具名插槽-元素可以用一个特殊的属性-name-来配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应-slot-特性的元素。"><a href="#具名插槽-元素可以用一个特殊的属性-name-来配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应-slot-特性的元素。" class="headerlink" title="具名插槽  元素可以用一个特殊的属性 name 来配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应 slot 特性的元素。"></a>具名插槽 <slot> 元素可以用一个特殊的属性 name 来配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应 slot 特性的元素。</slot></h5><h5 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h5><p>作用域插槽是一种特殊类型的插槽，用作一个替换已渲染元素的 (能被传递数据的) 可重用模板。<br>作用域插槽更具代表性的用例是列表组件，允许组件自定义应该如何渲染列表每一项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#### parent 父组件：</div><div class="line">&lt;my-awesome-list :items=&quot;items&quot;&gt;</div><div class="line">  &lt;!-- 作用域插槽也可以是具名的 --&gt;</div><div class="line">  &lt;template slot=&quot;item&quot; scope=&quot;props&quot;&gt;</div><div class="line">    &lt;li class=&quot;my-fancy-item&quot;&gt;&#123;&#123; props.text &#125;&#125;&lt;/li&gt;</div><div class="line">  &lt;/template&gt;</div><div class="line">&lt;/my-awesome-list&gt;</div><div class="line">#### 子组件：</div><div class="line">&lt;ul&gt;</div><div class="line">  &lt;slot name=&quot;item&quot;</div><div class="line">    v-for=&quot;item in items&quot;</div><div class="line">    :text=&quot;item.text&quot;&gt;</div><div class="line">    &lt;!-- 这里写入备用内容 --&gt;</div><div class="line">  &lt;/slot&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure>
<h4 id="this-set"><a href="#this-set" class="headerlink" title="this.$set()"></a>this.$set()</h4><p>Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var vm = new Vue(&#123;</div><div class="line">  data:&#123;</div><div class="line">  a:1</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">// `vm.a` 是响应的</div><div class="line">vm.b = 2</div><div class="line">// `vm.b` 是非响应的</div></pre></td></tr></table></figure></p>
<p>Vue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)。然而它可以使用<code style="background:#2d9fb3;color:white;"> Vue.set(object, key, value)</code> 方法将响应属性添加到嵌套的对象上：</p>
<pre>Vue.set(vm.someObject, 'b', 2)</pre>或者
<pre>this.$set(this.objectA,'b',2)</pre>

<h4 id="watch-computed"><a href="#watch-computed" class="headerlink" title="watch/computed"></a>watch/computed</h4><h5 id="computed-这就是对于任何复杂逻辑，你都应当使用计算属性的原因"><a href="#computed-这就是对于任何复杂逻辑，你都应当使用计算属性的原因" class="headerlink" title="computed:这就是对于任何复杂逻辑，你都应当使用计算属性的原因"></a>computed:这就是对于任何复杂逻辑，你都应当使用计算属性的原因</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">   // a computed getter</div><div class="line">   reversedMessage: function () &#123;</div><div class="line">     // `this` points to the vm instance</div><div class="line">     return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h5 id="computed-Vs-methods"><a href="#computed-Vs-methods" class="headerlink" title="computed Vs methods"></a>computed Vs methods</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/p&gt;</div><div class="line"></div><div class="line">// in component</div><div class="line">methods: &#123;</div><div class="line">  reversedMessage: function () &#123;</div><div class="line">    return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值,相比之下，每当触发重新渲染时，方法的调用方式将总是再次执行函数。</p>
<h5 id="computed-VS-watch"><a href="#computed-VS-watch" class="headerlink" title="computed VS watch"></a>computed VS watch</h5><p>Vue确实提供了一种更通用的方式来观察和响应Vue实例上的数据变动：watch属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的想法是使用计算属性而不是命令式的 watch 回调。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">watch: &#123;</div><div class="line">   firstName: function (val) &#123;</div><div class="line">     this.fullName = val + &apos; &apos; + this.lastName</div><div class="line">   &#125;,</div><div class="line">   lastName: function (val) &#123;</div><div class="line">     this.fullName = this.firstName + &apos; &apos; + val</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line"> ##### 通常更好的想法是使用计算属性而不是命令式的 watch 回调</div><div class="line"> computed: &#123;</div><div class="line">   fullName: function () &#123;</div><div class="line">     return this.firstName + &apos; &apos; + this.lastName</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h5 id="watch观察者"><a href="#watch观察者" class="headerlink" title="watch观察者"></a>watch观察者</h5><p>当你想要在数据变化响应时，执行异步操作或开销较大的操作，这是很有用的，比如在用到vuex状态管理器时，从state返回的mapGetters属性当中，检测其变化，用到watch是很好的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">copmuted:&#123;</div><div class="line">  ...mapGetters(</div><div class="line">    &apos;question&apos;:question</div><div class="line">    )</div><div class="line">&#125;</div><div class="line">watch: &#123;</div><div class="line">   // 如果 question 发生改变，这个函数就会运行</div><div class="line">   question: function (newQuestion) &#123;</div><div class="line">     this.answer = &apos;Waiting for you to stop typing...&apos;</div><div class="line">     this.getAnswer()</div><div class="line">   &#125;</div><div class="line"> &#125;,</div><div class="line"> methods: &#123; // _.debounce 是一个通过 lodash 限制操作频率的函数。</div><div class="line">   getAnswer: _.debounce(</div><div class="line">     function () &#123;</div><div class="line">       this.answer = &apos;Thinking...&apos;</div><div class="line">       var vm = this</div><div class="line">       axios.get(&apos;https://yesno.wtf/api&apos;)</div><div class="line">         .then(function (response) &#123;</div><div class="line">           vm.answer = _.capitalize(response.data.answer)</div><div class="line">         &#125;)</div><div class="line">         .catch(function (error) &#123;&#125;)</div><div class="line">     &#125;,</div><div class="line">     // 这是我们为用户停止输入等待的毫秒数</div><div class="line">     500</div><div class="line">   )</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h4 id="life-cycle-生命周期函数"><a href="#life-cycle-生命周期函数" class="headerlink" title="life-cycle(生命周期函数)"></a>life-cycle(生命周期函数)</h4><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。通俗说就是 Vue 实例从创建到销毁的过程，就是生命周期。<br>在Vue的整个生命周期中，它提供了一些生命周期钩子，给了我们执行自定义逻辑的机会。<br>一般用的比较多的是：</p>
<h5 id="created"><a href="#created" class="headerlink" title="created"></a>created</h5><p>实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算，watch/event事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。初始化方法可以在这个阶段执行</p>
<h5 id="beforeUpdate-update"><a href="#beforeUpdate-update" class="headerlink" title="beforeUpdate/update"></a>beforeUpdate/update</h5><p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁</p>
<h5 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h5><p>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。(只会运行一次)<br>注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用<code style="background:#2d9fb3;color:white;"> vm.$nextTick </code>替换掉 mounted：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mounted: function () &#123;</div><div class="line">  this.$nextTick(function () &#123;</div><div class="line">    // Code that will run only after the</div><div class="line">    // entire view has been rendered</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="Vuex-状态管理器"><a href="#Vuex-状态管理器" class="headerlink" title="Vuex(状态管理器)"></a>Vuex(状态管理器)</h3><p><img src="/images/vuex.png"></p>
<h4 id="Vue-Components："><a href="#Vue-Components：" class="headerlink" title="Vue Components："></a>Vue Components：</h4><p>Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。</p>
<h4 id="dispatch："><a href="#dispatch：" class="headerlink" title="dispatch："></a>dispatch：</h4><p>操作行为触发方法，是唯一能执行action的方法。在组件中定义dispatch()</p>
<h4 id="actions："><a href="#actions：" class="headerlink" title="actions："></a>actions：</h4><p>操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。</p>
<h4 id="commit："><a href="#commit：" class="headerlink" title="commit："></a>commit：</h4><p>状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。</p>
<h4 id="mutations："><a href="#mutations：" class="headerlink" title="mutations："></a>mutations：</h4><p>状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。</p>
<ul>
<li><p>Mutation 需遵守 Vue 的响应规则:<br><code>.</code>最好提前在你的 store 中初始化好所有所需属性。2当需要在对象上添加新属性时，你应该使用 Vue.set(obj, ‘newProp’, 123), 或者以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写：<br>state.obj = { …state.obj, newProp: 123</p>
</li>
<li><p>在组件中提交 Mutation</p>
</li>
</ul>
<p>你可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，或者使用<code style="background:#2d9fb3;color:white;"> mapMutations</code> 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import &#123; mapMutations &#125; from &apos;vuex&apos;</div><div class="line">export default &#123;</div><div class="line">  // ...</div><div class="line">  methods: &#123;</div><div class="line">    ...mapMutations([</div><div class="line">      &apos;increment&apos;, // 将 `this.increment()` 映射为 `this.$store.commit(&apos;increment&apos;)`</div><div class="line">      // `mapMutations` 也支持载荷：</div><div class="line">      &apos;incrementBy&apos; // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&apos;incrementBy&apos;, amount)`</div><div class="line">    ])</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="state："><a href="#state：" class="headerlink" title="state："></a>state：</h4><p>页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。(我们又滥用<code style="background:#2d9fb3;color:white;">state</code>)</p>
<h4 id="getters："><a href="#getters：" class="headerlink" title="getters："></a>getters：</h4><p>state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。</p>
<blockquote>
<p>通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护。这就是 Vuex 背后的基本思想，借鉴了 Flux、Redux、和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。</p>
</blockquote>
<hr>
<h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><p>用 Vue.js + vue-router 创建单页应用，是非常简单的。使用 Vue.js ，我们已经可以通过组合组件来组成应用程序，当你要把 vue-router 添加进来，我们需要做的是，将组件(components)映射到路由(routes)，然后告诉 vue-router 在哪里渲染它们。<br>个人感觉vue-router做的还是蛮细心的，你项目需要的各种关于路由层面的需求，vue-router基本都能满足!!</p>
<h4 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h4><p>一个『路径参数』使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 <code style="background:#2d9fb3;color:white;">this.$route.params</code>，可以在每个组件内使用。于是，我们可以更新 User 的模板，输出当前用户的 ID：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">html:</div><div class="line">&lt;router-link :to=&quot;&#123;name:&apos;通知详情&apos;,query:&#123;id:item.id,mark:&apos;mess&apos;&#125;&#125;&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/router-link&gt;</div><div class="line">&lt;span class=&quot;notice_time&quot;&gt;&#123;&#123;item.created_at&#125;&#125;&lt;/span&gt;</div><div class="line">//js:</div><div class="line">    this.params = &#123;</div><div class="line">        id:this.$route.query.id,</div><div class="line">        mark:&apos;mess&apos;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h4 id="动态修改-document-title"><a href="#动态修改-document-title" class="headerlink" title="动态修改 document title"></a>动态修改 document title</h4><p>全局钩子:使用 <code style="background:#2d9fb3;color:white;">router.beforeEach</code> 注册一个全局的 before 钩子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">router.beforeEach((to,from,next) =&gt; &#123;</div><div class="line">      document.title =  DEFINE.LEFTROUTEINFO.data.title+&apos;_&apos;+to.meta.title     //页面标题</div><div class="line">        if(to.matched.some( item =&gt; item.meta.requiresAuth))&#123;    //对权限进行验证</div><div class="line">          //对路由进行验证</div><div class="line">            if(localStorage.getItem(&apos;auth&apos;))&#123;</div><div class="line">              next()</div><div class="line">            &#125;else&#123;</div><div class="line">              next(&#123;path:&apos;/login&apos; &#125;)</div><div class="line">            &#125;</div><div class="line">        &#125;else&#123;</div><div class="line">          next()</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">)</div></pre></td></tr></table></figure></p>
<h4 id="动态修改路由名称"><a href="#动态修改路由名称" class="headerlink" title="动态修改路由名称"></a>动态修改路由名称</h4><p>只需在公共组件中watch监测 this.$router的变化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">watch:&#123;</div><div class="line">  //实时监测路由变化，显示当前名称</div><div class="line">  &apos;$route&apos;:function(val,oldval)&#123;</div><div class="line">    this.titleLEFT = val.name</div><div class="line">  &#125;</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<h4 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h4><p>当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// For single component, we can use the AMD shorthand</div><div class="line">// require([&apos;dep&apos;], dep =&gt; &#123; ... &#125;)</div><div class="line">const Foo = resolve =&gt; require([&apos;./Foo.vue&apos;], resolve)</div><div class="line">// If using Webpack 2, you can also do:</div><div class="line">// const Foo = () =&gt; System.import(&apos;./Foo.vue&apos;)</div></pre></td></tr></table></figure></p>
<p> 把组件按组分块</p>
<p>有时候我们想把某个路由下的所有组件都打包在同个异步块(chunk)中。只需要使用 命名 chunk,一个特殊的注释语法来提供chunk name(需要webpack &gt; 2.4)(看来我的这个项目必须升级到2.4以上的版本了)<br>const Foo = () =&gt; import(/<em> webpackChunkName: “group-foo” </em>/ ‘./Foo.vue’)<br>webpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中。</p>
<h4 id="前端登录拦截和响应"><a href="#前端登录拦截和响应" class="headerlink" title="前端登录拦截和响应"></a>前端登录拦截和响应</h4><p>这一块用到的知识挺多的，俺现在只能是略知一二；<br>1.全局钩子<br>你可以使用 router.beforeEach 注册一个全局的 before 钩子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const router = new VueRouter(&#123; ... &#125;)</div><div class="line">router.beforeEach((to, from, next) =&gt; &#123;</div><div class="line">  // ...</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>当一个导航触发时，全局的 before 钩子按照创建顺序调用。钩子是异步解析执行，此时导航在所有钩子 resolve 完之前一直处于 等待中。<br>每个钩子方法接收三个参数：<br>to: Route: 即将要进入的目标 路由对象<br>from: Route: 当前导航正要离开的路由<br>next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。<br>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。<br>next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到from路由对应的地址。</p>
<p>next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。<br>确保要调用 next 方法，否则钩子就不会被 resolved。</p>
<p>2.因为现在的登录存放在cookie中，不用手动添加到localStorage或者sessionStorage。但如果假设一种场景，cookie失效或者手动去掉cookie的话，现在你看到的样子就是已经登录过了，但是没有任何数据，用户也不知道这是什么情况，还以为程序出错了呢，我们开发人员会看network，原来是需要登录，这时候需要用到前端对于所以的响应进行拦截,这个单词应该是<code style="background:#2d9fb3;color:white;">Interceptors（劫持）</code>，响应劫持和请求拦截。<br>我们的解决方案是前后端商量好，在header字段加一个标志，然后前端根据这个字段是否是某一个值来判断当前是否登录，同时如果是cookier失效需要重新登录，这之后还要干掉登录来的权限，不然会跳进死循环的，完整代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Vue.http.interceptors.push(function(request, next)&#123;</div><div class="line">          next(function(res)&#123;</div><div class="line">           let TOKEN = res.headers.map.token</div><div class="line">           if(TOKEN == &apos;ISLOGIN&apos;)&#123;</div><div class="line">               localStorage.removeItem(&apos;auth&apos;)</div><div class="line">               localStorage.removeItem(&quot;truename&quot;)</div><div class="line">               localStorage.removeItem(&quot;role_name&quot;)</div><div class="line">               router.push(&#123;path:&apos;/login&apos;&#125;)</div><div class="line">           &#125;</div><div class="line">         &#125;)</div><div class="line"> &#125;)</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><p>es6博大精深，我感觉自己只是会一点基础用法，深层次的东西还很欠缺，所以，有事没事的话还得多看官方文档和实战。</p>
<h4 id="const-let-var"><a href="#const-let-var" class="headerlink" title="const/let/var"></a>const/let/var</h4><h5 id="let"><a href="#let" class="headerlink" title="let"></a>let</h5><p>1.let用来声明变量，只在let命令所在的代码块有效,即在{}内;<br>2.for循环中，如果使用let，声明的变量仅在块级作用域内有效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = [];</div><div class="line">for (let i = 0; i &lt; 10; i++) &#123;</div><div class="line">  a[i] = function () &#123;</div><div class="line">    console.log(i);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">a[6](); // 6</div></pre></td></tr></table></figure></p>
<p>3.使用let 不存在变量提升，let声明的变量一定要在声明后使用，否则报错。<br>4.“暂时性死区”（temporal dead zone，简称 TDZ）,在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">  // TDZ开始</div><div class="line">  tmp = &apos;abc&apos;; // ReferenceError</div><div class="line">  console.log(tmp); // ReferenceError</div><div class="line">  let tmp; // TDZ结束</div><div class="line">  console.log(tmp); // undefined</div><div class="line">  tmp = 123;</div><div class="line">  console.log(tmp); // 123</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5.不允许重复声明变量，在相同作用域内</p>
<h5 id="const"><a href="#const" class="headerlink" title="const"></a>const</h5><p>1.声明常量，一旦声明就不能改变，const一旦声明变量，就必须立即初始化，不能留到以后赋值。<br>2.const的作用域与let命令相同：只在声明所在的块级作用域内有效。<br>3.const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。<br>4.const保证的不是变量的值不动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。（<a href="http://es6.ruanyifeng.com/#docs/let#const-命令" target="_blank" rel="external">摘自阮一峰的ES6入门</a>）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const foo = &#123;&#125;;</div><div class="line">// 为 foo 添加一个属性，可以成功</div><div class="line">foo.prop = 123;</div><div class="line">foo.prop // 123</div><div class="line">// 将 foo 指向另一个对象，就会报错</div></pre></td></tr></table></figure></p>
<p>上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><h5 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h5><p>ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var promise = new Promise(function(resolve, reject) &#123;</div><div class="line">  // ... some code</div><div class="line">  if (/* 异步操作成功 */)&#123;</div><div class="line">    resolve(value);</div><div class="line">  &#125; else &#123;</div><div class="line">    reject(error);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是<code style="background:#2d9fb3;color:white;">resolve和reject</code><br>resolve的作用是Promise对象的状态从pending 变成 resolved，即从‘未完成’变为‘成功’，在异步操作成功时调用，并将异步操作的结果作为参数传递出去。<br>reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>vue2项目中在vuex中获取后端数据的时候，即在action中可以这么用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">const url = getUri(&apos;laji&apos;, &apos;file&apos;)</div><div class="line">let myFirstPromise = new Promise(function(resolve,reject)&#123;</div><div class="line">  const resp = Vue.http.get(url,&#123;params:param&#125;);</div><div class="line">  resolve(resp);</div><div class="line">  reject(new Error(`请求错误`))</div><div class="line">&#125;);</div><div class="line">myFirstPromise.then( json =&gt; &#123;</div><div class="line">    commit(types.REQUEST_END,&apos;file&apos;)</div><div class="line">    const data = json.data</div><div class="line">    commit(types.INITIAL_DATA_PUBLIC, &#123; data &#125;)</div><div class="line">&#125;).</div><div class="line">catch( error =&gt; console.warn(error))</div></pre></td></tr></table></figure></p>
<p>这段代码与下面的用法结果是一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const url = getUri(&apos;laji&apos;, &apos;file&apos;)</div><div class="line">Vue.http.get(url,&#123;params:param&#125;)</div><div class="line">.then( json =&gt; &#123;</div><div class="line">    commit(types.REQUEST_END,&apos;file&apos;)</div><div class="line">    const data = json.data</div><div class="line">    commit(types.INITIAL_DATA_PUBLIC, &#123; data &#125;)</div><div class="line">&#125;).</div><div class="line">catch( error =&gt; console.warn(error))</div></pre></td></tr></table></figure></p>
<p>下面是一个用Promise对象实现的 Ajax 操作的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var getJSON = function(url) &#123;</div><div class="line">  var promise = new Promise(function(resolve, reject)&#123;</div><div class="line">    var client = new XMLHttpRequest();</div><div class="line">    client.open(&quot;GET&quot;, url);</div><div class="line">    client.onreadystatechange = handler;</div><div class="line">    client.responseType = &quot;json&quot;;</div><div class="line">    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);</div><div class="line">    client.send();</div><div class="line">    function handler() &#123;</div><div class="line">      if (this.readyState !== 4) &#123;</div><div class="line">        return;</div><div class="line">      &#125;</div><div class="line">      if (this.status === 200) &#123;</div><div class="line">        resolve(this.response);</div><div class="line">      &#125; else &#123;</div><div class="line">        reject(new Error(this.statusText));</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;);</div><div class="line">  return promise;</div><div class="line">&#125;;</div><div class="line">getJSON(&quot;/posts.json&quot;).then(function(json) &#123;</div><div class="line">  console.log(&apos;Contents: &apos; + json);</div><div class="line">&#125;, function(error) &#123;</div><div class="line">  console.error(&apos;出错了&apos;, error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h5 id="Promise-all-当有一个ajax请求，它的参数需要另外2个甚至更多请求都有返回结果之后才能确定，那么这个时候，就需要用到Promise-all来帮助我们应对这个场景。"><a href="#Promise-all-当有一个ajax请求，它的参数需要另外2个甚至更多请求都有返回结果之后才能确定，那么这个时候，就需要用到Promise-all来帮助我们应对这个场景。" class="headerlink" title="Promise.all() 当有一个ajax请求，它的参数需要另外2个甚至更多请求都有返回结果之后才能确定，那么这个时候，就需要用到Promise.all来帮助我们应对这个场景。"></a>Promise.all() 当有一个ajax请求，它的参数需要另外2个甚至更多请求都有返回结果之后才能确定，那么这个时候，就需要用到Promise.all来帮助我们应对这个场景。</h5><p>Promise.all接收一个Promise对象组成的数组作为参数，当这个数组所有的Promise对象状态都变成resolved或者rejected的时候，它才会去调用then方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var url = &apos;https://&apos;;</div><div class="line">var url1 = &apos;https://&apos;;</div><div class="line">function renderAll() &#123;</div><div class="line">    return Promise.all([getJSON(url), getJSON(url1)]);</div><div class="line">&#125;</div><div class="line">renderAll().then(function(value) &#123;</div><div class="line">    // 建议大家在浏览器中看看这里的value值</div><div class="line">    console.log(value);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>用Promise.all来执行，all接收一个数组参数，里面的值最终都算返回Promise对象。这样，三个异步操作的并行执行的，等到它们都执行完后才会进到then里面。</p>
<h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h5><p>all方法的效果实际上是<code style="background:#2d9fb3;color:white;">「谁跑的慢，以谁为准执行回调」</code>，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是race方法，这个词本来就是赛跑的意思.与Promise.all相似的是，Promise.race都是以一个Promise对象组成的数组作为参数，不同的是，只要当数组中的其中一个Promsie状态变成resolved或者rejected时，就可以调用.then方法了。而传递给then方法的值也会有所不同，大家可以再浏览器中运行下面的例子与上面的例子进行对比。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function renderRace() &#123;</div><div class="line">    return Promise.race([getJSON(url), getJSON(url1)]);</div><div class="line">&#125;</div><div class="line">renderRace().then(function(value) &#123;</div><div class="line">    console.log(value);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h4 id="async／await"><a href="#async／await" class="headerlink" title="async／await"></a>async／await</h4><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>async函数返回一个<code style="background:#2d9fb3;color:white;"> Promise</code> 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function timeout(ms) &#123;</div><div class="line">  return new Promise((resolve) =&gt; &#123;</div><div class="line">    setTimeout(resolve, ms);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line">async function asyncPrint(value, ms) &#123;</div><div class="line">  await timeout(ms);</div><div class="line">  console.log(value);</div><div class="line">&#125;</div><div class="line">asyncPrint(&apos;hello world&apos;, 50);</div></pre></td></tr></table></figure></p>
<p>由于async函数返回的是 Promise 对象，可以作为await命令的参数。所以，上面的例子也可以写成下面的形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">async function timeout(ms) &#123;</div><div class="line">  await new Promise((resolve) =&gt; &#123;</div><div class="line">    setTimeout(resolve, ms);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line">async function asyncPrint(value, ms) &#123;</div><div class="line">  await timeout(ms);</div><div class="line">  console.log(value);</div><div class="line">&#125;</div><div class="line">asyncPrint(&apos;hello world&apos;, 50);</div></pre></td></tr></table></figure></p>
<p>async 函数有多种使用形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 函数声明</div><div class="line">async function foo() &#123;&#125;</div><div class="line">// 函数表达式</div><div class="line">const foo = async function () &#123;&#125;;</div><div class="line">// 对象的方法</div><div class="line">let obj = &#123; async foo() &#123;&#125; &#125;;</div><div class="line">obj.foo().then(...)</div><div class="line">// Class 的方法</div><div class="line">class Storage &#123;</div><div class="line">  constructor() &#123;</div><div class="line">    this.cachePromise = caches.open(&apos;avatars&apos;);</div><div class="line">  &#125;</div><div class="line">  async getAvatar(name) &#123;</div><div class="line">    const cache = await this.cachePromise;</div><div class="line">    return cache.match(`/avatars/$&#123;name&#125;.jpg`);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">const storage = new Storage();</div><div class="line">storage.getAvatar(&apos;jake&apos;).then(…);</div><div class="line">// 箭头函数</div><div class="line">const foo = async () =&gt; &#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>项目中，主要是在异步获取数据的时候用到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.addNoticeParam = await Vue.http.get(url,&#123;params:&#123;id:id&#125;&#125;).then( data =&gt; data.data.data)</div></pre></td></tr></table></figure></p>
<p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try…catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">async function f()&#123;</div><div class="line">  try&#123;</div><div class="line">      await Promise.reject(&apos;出错了&apos;)</div><div class="line">  &#125;catch(e)&#123;</div><div class="line"></div><div class="line">  &#125;;</div><div class="line">  return await Promise.reslove(&apos;hello&apos;)</div><div class="line">&#125;;</div><div class="line">f().then().catch()</div><div class="line">//或者</div><div class="line">async function f() &#123;</div><div class="line">  await Promise.reject(&apos;出错了&apos;)</div><div class="line">    .catch(e =&gt; console.log(e));</div><div class="line">  return await Promise.resolve(&apos;hello world&apos;);</div><div class="line">&#125;</div><div class="line">f().then(v =&gt; console.log(v))</div></pre></td></tr></table></figure></p>
<h4 id="module"><a href="#module" class="headerlink" title="module"></a>module</h4><p>模块功能主要有两个命令：<br>export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>
<h5 id="export"><a href="#export" class="headerlink" title="export"></a>export</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 写法一</div><div class="line">export var m = 1;</div><div class="line">// 写法二</div><div class="line">var m = 1;</div><div class="line">export &#123;m&#125;;</div><div class="line">// 写法三</div><div class="line">var n = 1;</div><div class="line">export &#123;n as m&#125;;</div></pre></td></tr></table></figure>
<p>上面三种写法都是正确的，规定了对外的接口m。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。<br>项目中采用的都是这种输出变量的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">export default &#123;</div><div class="line">  state,</div><div class="line">  getters,</div><div class="line">  actions,</div><div class="line">  mutations</div><div class="line">&#125;</div><div class="line">//</div><div class="line">export default &#123;</div><div class="line">  components: &#123;collectList&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="import"><a href="#import" class="headerlink" title="import"></a>import</h5><p>使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。<br>// main.js<br>import {firstName, lastName, year} from ‘./profile’;<br>function setName(element) {<br>  element.textContent = firstName + ‘ ‘ + lastName;<br>}<br>上面代码的import命令，用于加载profile.js文件，并从中输入变量。import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import Vue from &apos;vue&apos;</div><div class="line">import &#123;getUri&#125; from &apos;./../../config/config.js&apos;</div></pre></td></tr></table></figure></p>
<p>由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 报错</div><div class="line">import &#123; &apos;f&apos; + &apos;oo&apos; &#125; from &apos;my_module&apos;;</div><div class="line">// 报错</div><div class="line">let module = &apos;my_module&apos;;</div><div class="line">import &#123; foo &#125; from module;</div><div class="line">// 报错</div><div class="line">if (x === 1) &#123;</div><div class="line">  import &#123; foo &#125; from &apos;module1&apos;;</div><div class="line">&#125; else &#123;</div><div class="line">  import &#123; foo &#125; from &apos;module2&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="模块的整体加载"><a href="#模块的整体加载" class="headerlink" title="模块的整体加载"></a>模块的整体加载</h5><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export const RECEIVE_MINE = &apos;RECEIVE_MINE&apos;</div><div class="line">export const VIEW_SUBMIT = &apos;VIEW_SUBMIT&apos;</div><div class="line">export const DELETE_MINE = &apos;DELETE_MINE&apos;</div></pre></td></tr></table></figure>
<p>导入的时候可以这么用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// mutatin-type.js</div><div class="line">import * as types from &apos;../mutation-types&apos;</div></pre></td></tr></table></figure></p>
<p> export default<br>从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。<br>每个模块只能有一个默认的导出值。<br>default 表示这是一个默认的导出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 导出默认值</div><div class="line">export default function(a, b) &#123;</div><div class="line">    return a + b;</div><div class="line">&#125;</div><div class="line">也可以是：</div><div class="line">// 导出默认值</div><div class="line">function sum(a, b) &#123;</div><div class="line">    return a + b;</div><div class="line">&#125;</div><div class="line">export default sum;</div><div class="line">如果要导入默认值的话，就不能加大括号了：</div><div class="line">import sum from &apos;./example.js&apos;;</div><div class="line">如果文件中既有默认值，也有非默认值：</div><div class="line"> export let age = 18;</div><div class="line"> export default function(a, b) &#123;</div><div class="line">     return a + b;</div><div class="line"> &#125;</div><div class="line">那么导入的时候就需要这样写：</div><div class="line">import add, &#123; age &#125; from &apos;./example.js&apos;;</div><div class="line">// 在 import 语句中，默认值必须排在非默认值之前</div></pre></td></tr></table></figure></p>
<p>看实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 第一组</div><div class="line">export default function crc32() &#123; // 输出</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line">import crc32 from &apos;crc32&apos;; // 输入</div><div class="line">// 第二组</div><div class="line">export function crc32() &#123; // 输出</div><div class="line">  // ...</div><div class="line">&#125;;</div><div class="line">import &#123;crc32&#125; from &apos;crc32&apos;; // 输入</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="vue-resource"><a href="#vue-resource" class="headerlink" title="vue-resource"></a>vue-resource</h3><p>官方已经宣布不会更新vue-resource,推荐采用更加成熟的axios作为请求的第三方资源。不管是vue-resource还是axios或者之前的ng里的$http,很多用法都是一样的，大差不差，但都要严格按照官网的用法来。举一个项目用到的例子：<br>下载文件夹，想想用到的一般都是Post请求，然后其他的自己当时就想不到了。就在下载这块，自己卡顿了半天，不知道如何下手，好在涛哥给予指点，其中一点教育我自己去看官网，很感谢涛哥，让我自生自灭，自己一点点磨官网。第一次看vue-resource文档的时候就直接百度，后来慢慢发现，像这种post请求必须看官网，看官网的实例才能请求到数据，因为不管是vue-resource还是axios版本更新迭代才快，网上有的实例不知道是哪个版本的，或许你看到的这个版本已经废弃了。<br>这里，点击下载，我们需要掌握的是：<br>1.post 请求，需要传递的Body实体，确定是什么类型，官网给的是Object, FormData, string，在这里我用的是string<br>2.headers头部，因为我们这里最终的结果是下载的文件，根据http请求头，我们需要响应的头部是二进制，也就是需要设置<code style="background:#2d9fb3;color:white;">headers：{‘Content-type’: ‘application/octet-stream’}</code><br>3.如何承载文件，用到的是Blob()<br>完整的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">function downloadFile(blob, fileName) &#123;</div><div class="line">  var link = document.createElement(&apos;a&apos;);</div><div class="line">  link.href = window.URL.createObjectURL(blob);</div><div class="line">  link.download = fileName;</div><div class="line">  link.style.display = &apos;none&apos;;</div><div class="line">  // 触发点击</div><div class="line">  document.body.appendChild(link);</div><div class="line">  link.click();</div><div class="line">  // 然后移除</div><div class="line">  document.body.removeChild(link);</div><div class="line">&#125;;</div><div class="line">fileDownloadFn(&#123;commit&#125;,&#123;param&#125;) &#123;</div><div class="line">  commit(types.REQUEST_START,&apos;file&apos;)</div><div class="line">  const url = getUri(&apos;fileDownload&apos;,&apos;file&apos;)</div><div class="line">  const paramPath = &#123;path:param[&apos;path&apos;]&#125;</div><div class="line">  var fileName = param[&apos;name&apos;]</div><div class="line">  Vue.http.get(url ,&#123;</div><div class="line">      params:paramPath,</div><div class="line">      responseType: &apos;blob&apos;,</div><div class="line">      headers:&#123;&apos;Content-type&apos;: &apos;application/octet-stream&apos;&#125;</div><div class="line">  &#125;)</div><div class="line">  .then( json =&gt; &#123;</div><div class="line">    let idParam = &#123; &#125;</div><div class="line">    const data = json.data</div><div class="line">    commit(types.REQUEST_END,&apos;file&apos;)</div><div class="line">    var blob = new Blob([data])</div><div class="line">    downloadFile(blob,fileName)</div><div class="line">    commit(types.FILEDOWN,&#123;data&#125;)</div><div class="line">  &#125;)</div><div class="line">  .catch()</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="Webpack-基本配置"><a href="#Webpack-基本配置" class="headerlink" title="Webpack 基本配置"></a>Webpack 基本配置</h3><p>现在遇到的一个问题就是，生产环境中的bundle.js已经压缩编译过了，但体积还是达到了2.2M，这对于性能一般的网站来说就是个灾难，为了干掉这个bug,不得不去好好学习webPack的相关知识以及基本配置。明天我将单独写篇文章叙说webpack，未完待续</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基本上算是完整了跟了一个前端项目，总结一个多月的实战，唯一想说的是<br>1.多看文档，多实战。不要怕新东西，尤其是ES6,我们要展开双臂，迎接新的js时代的到来。不要落伍，就只能硬啃！！<br>2.理清思路在敲代码,自己不要慌，不要乱，用本子记录一下思考的过程。尤其是自己写的代码出现Bug的时候，涛哥说就是自己理思路的一个过程，想想自己的思路是咋样，然后一步步debugger，这样问题很快就排查出来<br>3.说的最多的一点就是要多总结，但自己确实比较lazy(懒到家了！！)</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechat-reward-image.jpg" alt="鸟哥哥 WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay-reward-image.jpg" alt="鸟哥哥 Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/js/" rel="tag"># js</a>
          
            <a href="/tags/前端/" rel="tag"># 前端</a>
          
            <a href="/tags/Vue/" rel="tag"># Vue</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/09/关于Http中的四种Header-Fields-首部字段/" rel="next" title="关于Http中的四种Header Fields(首部字段)">
                <i class="fa fa-chevron-left"></i> 关于Http中的四种Header Fields(首部字段)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/10/14/webpack学习笔记性能优化/" rel="prev" title="Webpack学习笔记之性能优化">
                Webpack学习笔记之性能优化 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>

          
          </div>
          

  <p>热评文章</p>
  <div class="ds-top-threads" data-range="weekly" data-num-items="4"></div>


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/10/03/Vue项目总结-前端/"
           data-title="Vue2.0项目总结(前端)" data-url="http://niaogege.cn/2017/10/03/Vue项目总结-前端/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/cpp.png"
               alt="鸟哥哥" />
          <p class="site-author-name" itemprop="name">鸟哥哥</p>
          <p class="site-description motion-element" itemprop="description">要有最朴素的生活和最遥远的梦想</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">35</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/niaogege" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://juejin.im/user/581497d90ce4630058449f1d" target="_blank" title="掘金">
                  
                    <i class="fa fa-fw fa-jsfiddle"></i>
                  
                  掘金
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://segmentfault.com/u/niaogege" target="_blank" title="Segmentfault">
                  
                    <i class="fa fa-fw fa-stack-overflow"></i>
                  
                  Segmentfault
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/niaogege66" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://jeffjade.com/" title="晚晴幽草轩" target="_blank">晚晴幽草轩</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://github.com/NsNe/blog" title="NsNe" target="_blank">NsNe</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue基础使用"><span class="nav-number">1.</span> <span class="nav-text">Vue基础使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#components"><span class="nav-number">1.1.</span> <span class="nav-text">components</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slot-vue官网"><span class="nav-number">1.2.</span> <span class="nav-text">slot (vue官网)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#单个插槽-slot"><span class="nav-number">1.2.1.</span> <span class="nav-text">单个插槽 slot</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#具名插槽-元素可以用一个特殊的属性-name-来配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应-slot-特性的元素。"><span class="nav-number">1.2.2.</span> <span class="nav-text">具名插槽  元素可以用一个特殊的属性 name 来配置如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应 slot 特性的元素。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#作用域插槽"><span class="nav-number">1.2.3.</span> <span class="nav-text">作用域插槽</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this-set"><span class="nav-number">1.3.</span> <span class="nav-text">this.$set()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#watch-computed"><span class="nav-number">1.4.</span> <span class="nav-text">watch/computed</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#computed-这就是对于任何复杂逻辑，你都应当使用计算属性的原因"><span class="nav-number">1.4.1.</span> <span class="nav-text">computed:这就是对于任何复杂逻辑，你都应当使用计算属性的原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#computed-Vs-methods"><span class="nav-number">1.4.2.</span> <span class="nav-text">computed Vs methods</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#computed-VS-watch"><span class="nav-number">1.4.3.</span> <span class="nav-text">computed VS watch</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#watch观察者"><span class="nav-number">1.4.4.</span> <span class="nav-text">watch观察者</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#life-cycle-生命周期函数"><span class="nav-number">1.5.</span> <span class="nav-text">life-cycle(生命周期函数)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#created"><span class="nav-number">1.5.1.</span> <span class="nav-text">created</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#beforeUpdate-update"><span class="nav-number">1.5.2.</span> <span class="nav-text">beforeUpdate/update</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mounted"><span class="nav-number">1.5.3.</span> <span class="nav-text">mounted</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vuex-状态管理器"><span class="nav-number">2.</span> <span class="nav-text">Vuex(状态管理器)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Vue-Components："><span class="nav-number">2.1.</span> <span class="nav-text">Vue Components：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatch："><span class="nav-number">2.2.</span> <span class="nav-text">dispatch：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#actions："><span class="nav-number">2.3.</span> <span class="nav-text">actions：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#commit："><span class="nav-number">2.4.</span> <span class="nav-text">commit：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mutations："><span class="nav-number">2.5.</span> <span class="nav-text">mutations：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#state："><span class="nav-number">2.6.</span> <span class="nav-text">state：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getters："><span class="nav-number">2.7.</span> <span class="nav-text">getters：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue-router"><span class="nav-number">3.</span> <span class="nav-text">vue-router</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态路由匹配"><span class="nav-number">3.1.</span> <span class="nav-text">动态路由匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态修改-document-title"><span class="nav-number">3.2.</span> <span class="nav-text">动态修改 document title</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态修改路由名称"><span class="nav-number">3.3.</span> <span class="nav-text">动态修改路由名称</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#路由懒加载"><span class="nav-number">3.4.</span> <span class="nav-text">路由懒加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#前端登录拦截和响应"><span class="nav-number">3.5.</span> <span class="nav-text">前端登录拦截和响应</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6"><span class="nav-number">4.</span> <span class="nav-text">ES6</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#const-let-var"><span class="nav-number">4.1.</span> <span class="nav-text">const/let/var</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#let"><span class="nav-number">4.1.1.</span> <span class="nav-text">let</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#const"><span class="nav-number">4.1.2.</span> <span class="nav-text">const</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise"><span class="nav-number">4.2.</span> <span class="nav-text">Promise</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基础知识："><span class="nav-number">4.2.1.</span> <span class="nav-text">基础知识：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Promise-all-当有一个ajax请求，它的参数需要另外2个甚至更多请求都有返回结果之后才能确定，那么这个时候，就需要用到Promise-all来帮助我们应对这个场景。"><span class="nav-number">4.2.2.</span> <span class="nav-text">Promise.all() 当有一个ajax请求，它的参数需要另外2个甚至更多请求都有返回结果之后才能确定，那么这个时候，就需要用到Promise.all来帮助我们应对这个场景。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Promise-race"><span class="nav-number">4.2.3.</span> <span class="nav-text">Promise.race</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#async／await"><span class="nav-number">4.3.</span> <span class="nav-text">async／await</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本用法"><span class="nav-number">4.3.1.</span> <span class="nav-text">基本用法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#module"><span class="nav-number">4.4.</span> <span class="nav-text">module</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#export"><span class="nav-number">4.4.1.</span> <span class="nav-text">export</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#import"><span class="nav-number">4.4.2.</span> <span class="nav-text">import</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#模块的整体加载"><span class="nav-number">4.4.3.</span> <span class="nav-text">模块的整体加载</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue-resource"><span class="nav-number">5.</span> <span class="nav-text">vue-resource</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Webpack-基本配置"><span class="nav-number">6.</span> <span class="nav-text">Webpack 基本配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">鸟哥哥</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动

 </div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>

</div>



<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
 </script>



        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"niaogege"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="//cdn.jsdelivr.net/ua-parser.js/0.7.10/ua-parser.min.js"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  












  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  

  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
