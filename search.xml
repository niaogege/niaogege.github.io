<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>webpack进阶:loader和plugin插件学习</title>
      <link href="/2021/01/09/webpack%E8%BF%9B%E9%98%B6-loader%E5%92%8Cplugin%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/01/09/webpack%E8%BF%9B%E9%98%B6-loader%E5%92%8Cplugin%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack-loader和plugin配置项"><a href="#webpack-loader和plugin配置项" class="headerlink" title="webpack loader和plugin配置项"></a>webpack loader和plugin配置项</h2><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><h3 id="loader前置知识"><a href="#loader前置知识" class="headerlink" title="loader前置知识"></a>loader前置知识</h3><h3 id="手写loader"><a href="#手写loader" class="headerlink" title="手写loader"></a>手写loader</h3><h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><h3 id="plugin前置知识"><a href="#plugin前置知识" class="headerlink" title="plugin前置知识"></a>plugin前置知识</h3><h3 id="手写plugin"><a href="#手写plugin" class="headerlink" title="手写plugin"></a>手写plugin</h3><h2 id="发布loader和plugin到npm上"><a href="#发布loader和plugin到npm上" class="headerlink" title="发布loader和plugin到npm上"></a>发布loader和plugin到npm上</h2><h2 id="参考文件"><a href="#参考文件" class="headerlink" title="参考文件"></a>参考文件</h2>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
          <category> node </category>
          
          <category> loader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> webpack </tag>
            
            <tag> loader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法基础-排序</title>
      <link href="/2021/01/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/01/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法基础: 链表</title>
      <link href="/2021/01/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/01/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的，每个元素由<strong>一个存储元素本身的节点和一个指向下一个元素</strong>的引用组成。<br>相当于传统数组，链表的好处在于，<em>添加或者移除元素的时候不需要移动</em>其他元素。然而链表需要使用指针，因此实现链表时要额外注意。在数组中，我们阔以访问任何位置的任何元素，而想要访问链表中的一个元素，则需要<strong>从头开始迭代链表</strong>直到找到所需的元素。</p><h3 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h3><h4 id="前置基础"><a href="#前置基础" class="headerlink" title="前置基础"></a>前置基础</h4><p>表示链表中的第一个以及其他元素，需要一个 助手类 Node</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Node &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="comment">// this.element = element</span></span><br><span class="line">    <span class="comment">// this.next = undefined</span></span><br><span class="line">    [<span class="keyword">this</span>.element, <span class="keyword">this</span>.next] = [element, <span class="literal">null</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defaultEquals</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a === b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建链表-1"><a href="#创建链表-1" class="headerlink" title="创建链表"></a>创建链表</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> LinkedList &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">equalsFn = defaultEquals</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.head = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.equalsFn = equalsFn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表尾部添加元素"><a href="#链表尾部添加元素" class="headerlink" title="链表尾部添加元素"></a>链表尾部添加元素</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">push(element) &#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element)</span><br><span class="line">  <span class="keyword">let</span> current</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.head = node</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">while</span>(current.next != <span class="literal">null</span>) &#123;</span><br><span class="line">      current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    current.next = nide</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.count ++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表中移除元素"><a href="#链表中移除元素" class="headerlink" title="链表中移除元素"></a>链表中移除元素</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">removeAt(index) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">this</span>.count ) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.head = current.next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> previous</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; index; i ++) &#123;</span><br><span class="line">        previous = current</span><br><span class="line">        current = current.next</span><br><span class="line">      &#125;</span><br><span class="line">      previous.next = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count --</span><br><span class="line">    <span class="keyword">return</span> current.element</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环迭代链表直到找到目标位置"><a href="#循环迭代链表直到找到目标位置" class="headerlink" title="循环迭代链表直到找到目标位置"></a>循环迭代链表直到找到目标位置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getElementAt(index) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">this</span>.count ) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; index;  i++) &#123;</span><br><span class="line">      current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重构下remove方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">removeAt(index) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">this</span>.count ) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.head = current.next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> previous = <span class="keyword">this</span>.getElementAt(index)</span><br><span class="line">      current = previous.next</span><br><span class="line">      previous.next = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count --</span><br><span class="line">    <span class="keyword">return</span> current.element</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在任意位置插入元素"><a href="#在任意位置插入元素" class="headerlink" title="在任意位置插入元素"></a>在任意位置插入元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">insert(element, index) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">this</span>.count) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element) </span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = <span class="keyword">this</span>.head</span><br><span class="line">      node.next = current</span><br><span class="line">      <span class="keyword">this</span>.head = node</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> previous = <span class="keyword">this</span>.getElementAt(index - <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">const</span> current = previous.next</span><br><span class="line">      node.next = current</span><br><span class="line">      previous.next = node</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count ++</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回一个元素的位置"><a href="#返回一个元素的位置" class="headerlink" title="返回一个元素的位置"></a>返回一个元素的位置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">indexOf(element) &#123;</span><br><span class="line">  <span class="keyword">const</span> current = <span class="keyword">this</span>.head</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.count &amp;&amp; current != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.equalsFn(element, current.element)) &#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    current = current.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从链表中移除元素"><a href="#从链表中移除元素" class="headerlink" title="从链表中移除元素"></a>从链表中移除元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">remove(element) &#123;</span><br><span class="line">  <span class="keyword">const</span> index = <span class="keyword">this</span>.indexOf(element);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.removeAt(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>和普通链表的区别在于，在链表中 一个节点只有链向下一个节点的链接，而双向链表中，链接是双向的，一个链向下一个元素，一个链向前一个元素</p><p>工具类Node需要拓展DoublyLinkedList</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">DoublyNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element, next, prev) &#123; <span class="comment">// next好像没啥用</span></span><br><span class="line">    <span class="keyword">super</span>(element)</span><br><span class="line">    <span class="keyword">this</span>.prev = prev</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">DoublyLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(equalsFn = defaultEquals) &#123;</span><br><span class="line">    <span class="keyword">super</span>(equalsFn)</span><br><span class="line">    <span class="keyword">this</span>.tail = <span class="literal">undefined</span>; <span class="comment">// 最后一个元素的引用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="向链表尾部添加元素"><a href="#向链表尾部添加元素" class="headerlink" title="向链表尾部添加元素"></a>向链表尾部添加元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">push(element) &#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> DoublyNode(element);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.head = node;</span><br><span class="line">    <span class="keyword">this</span>.tail = node; <span class="comment">// NEW</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// attach to the tail node // NEW</span></span><br><span class="line">    <span class="keyword">this</span>.tail.next = node;</span><br><span class="line">    node.prev = <span class="keyword">this</span>.tail;</span><br><span class="line">    <span class="keyword">this</span>.tail = node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在任意位置插入新元素"><a href="#在任意位置插入新元素" class="headerlink" title="在任意位置插入新元素"></a>在任意位置插入新元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">insert(element, index) &#123;</span><br><span class="line">  <span class="keyword">if</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="keyword">this</span>.count) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> DoublyNode(element)</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="comment">// 起点位置插入一个新元素</span></span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果双向链表为空 只需要把head和tail执行这个新节点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.head = node</span><br><span class="line">        <span class="keyword">this</span>.tail = node</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// current变量将是链表中第一个元素的引用</span></span><br><span class="line">        node.next = <span class="keyword">this</span>.head</span><br><span class="line">        current.prev = node</span><br><span class="line">        <span class="keyword">this</span>.head = node</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="keyword">this</span>.count) &#123;</span><br><span class="line">      current = <span class="keyword">this</span>.tail</span><br><span class="line">      current.next = node</span><br><span class="line">      node.prev = current</span><br><span class="line">      <span class="keyword">this</span>.tail = node</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> previous = <span class="keyword">this</span>.getElementAt(index - <span class="number">1</span>)</span><br><span class="line">      current = previous.next</span><br><span class="line">      node.next = current</span><br><span class="line">      previous.next = node</span><br><span class="line">      node.prev = previous</span><br><span class="line">      current.prev = node</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count ++</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表尾部的next引用指向头部节点，定义<em>CircularLinkedList</em>类的insert方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(equalsFn = defaultEquals) &#123;</span><br><span class="line">    <span class="keyword">super</span>(equalsFn)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 链表尾部的next指向head</span></span><br><span class="line">  insert(element, index) &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="keyword">this</span>.count) &#123;</span><br><span class="line">      <span class="keyword">let</span> node = <span class="keyword">new</span> DoublyNode(element)</span><br><span class="line">      <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">      <span class="comment">// 起点位置插入一个新元素</span></span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果双向链表为空 只需要把head和tail执行这个新节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.head = node</span><br><span class="line">          node.next = <span class="keyword">this</span>.head</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// current变量将是链表中第一个元素的引用</span></span><br><span class="line">          node.next = current</span><br><span class="line">          current = <span class="keyword">this</span>.getElementAt(<span class="keyword">this</span>.size())</span><br><span class="line">          <span class="keyword">this</span>.head = node</span><br><span class="line">          current.next = <span class="keyword">this</span>.head</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> previous = <span class="keyword">this</span>.getElementAt(index - <span class="number">1</span>)</span><br><span class="line">        node.next = previous.next</span><br><span class="line">        previous.next = node</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.count ++</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从任意位置移除元素"><a href="#从任意位置移除元素" class="headerlink" title="从任意位置移除元素"></a>从任意位置移除元素</h4><p>考虑修改循环链表的head元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">removeAt(index) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="keyword">this</span>.count) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.size() === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="literal">undefined</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> removed = <span class="keyword">this</span>.head</span><br><span class="line">        current = <span class="keyword">this</span>.getElementAt(<span class="keyword">this</span>.size())</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next</span><br><span class="line">        current.next = <span class="keyword">this</span>.head</span><br><span class="line">        current = removed</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> previous = <span class="keyword">this</span>.getElementAt(index - <span class="number">1</span>)</span><br><span class="line">      current = previous.next</span><br><span class="line">      previous.next = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count --</span><br><span class="line">    <span class="keyword">return</span> current.element</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有序链表"><a href="#有序链表" class="headerlink" title="有序链表"></a>有序链表</h3><p>保持元素有序的链表结构,除了使用排序算法之外，我们还阔以将元素插入到正确的位置来保证链表的有序性</p><ul><li>声明SortedLinkedList类</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Compare = &#123;</span><br><span class="line">  LESS_THAN: <span class="number">-1</span>,</span><br><span class="line">  BIGGER_THAN: <span class="number">1</span>,</span><br><span class="line">  EQUALS: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defaultCompare</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a === b) &#123;</span><br><span class="line">    <span class="keyword">return</span> Compare.EQUALS</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(equalsFn = defaultEquals, compareFn = defaultCompare) &#123;</span><br><span class="line">    <span class="keyword">super</span>(equalsFn)</span><br><span class="line">    <span class="keyword">this</span>.equalsFn = equalsFn;</span><br><span class="line">    <span class="keyword">this</span>.compareFn = compareFn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有序插入元素"><a href="#有序插入元素" class="headerlink" title="有序插入元素"></a>有序插入元素</h4><p>会用下面代码覆盖insert方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">getIndexNextSortedElement(element) &#123;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; <span class="keyword">this</span>.size() &amp;&amp; current; i ++) &#123;</span><br><span class="line">    <span class="keyword">const</span> comp = <span class="keyword">this</span>.compareFn(element, current.element)</span><br><span class="line">    <span class="keyword">if</span> (comp === Compare.LESS_THAN) &#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    current = current.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">insert(element, index = <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.insert(element, index === <span class="number">0</span> ? index : <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> pos = <span class="keyword">this</span>.getIndexNextSortedElement(element) </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.insert(element, pos)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表内是否存在环"><a href="#链表内是否存在环" class="headerlink" title="链表内是否存在环"></a>链表内是否存在环</h3><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://github.com/PacktPublishing/Learning-JavaScript-Data-Structures-and-Algorithms-Third-Edition" target="_blank" rel="noopener">Learning-JavaScript-Data-Structures</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶-大杂烩2</title>
      <link href="/2021/01/01/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E5%A4%A7%E6%9D%82%E7%83%A92/"/>
      <url>/2021/01/01/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E5%A4%A7%E6%9D%82%E7%83%A92/</url>
      
        <content type="html"><![CDATA[<p>虽然早有准备，但还是被无情按在地上摩擦摩擦</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域是指程序源代码中定义变量的区域。<br>作用域规定了<em>如何查找变量</em>，也就是确定当前执行代码对<strong>变量的访问权限</strong>。<br>JavaScript 采用<em>词法作用域(lexical scoping)</em>，也就是静态作用域</p><h3 id="词法作用域-需要安静的理解下"><a href="#词法作用域-需要安静的理解下" class="headerlink" title="词法作用域(需要安静的理解下)"></a>词法作用域(需要安静的理解下)</h3><p>词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将<strong>变量和块作用域</strong>写在哪里来决定的，不是在执行它们的作用域里运行，因此当词法分析器处理代码时会保持作用域不变(大部分情况下是这样的)。而JavaScript采用的就是词法作用域，也称为<em>静态作用域</em>。<br>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够完全知道全部标识符在哪里以及如何声明的，从而能够预测在执行过程中如何对他们进行查找</p><p>因为 JavaScript 采用的是词法作用域，函数的作用域在<em>函数定义</em>的时候就决定了。</p><p>而与词法作用域相对的是动态作用域，函数的作用域是在<em>函数调用</em>的时候才决定的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Mr.Han'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(name);<span class="comment">//undefined</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'Mrs.Han'</span>;</span><br><span class="line">    alert(name);<span class="comment">//'Mrs.Han'</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();<span class="comment">//1</span></span><br></pre></td></tr></table></figure><ul><li>假设JavaScript采用静态作用域，让我们分析下执行过程：</li></ul><p>执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。</p><p>假设JavaScript采用动态作用域，让我们分析下执行过程：</p><p>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</p><p>前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。</p><h3 id="闭包特性"><a href="#闭包特性" class="headerlink" title="闭包特性"></a>闭包特性</h3><h3 id="如何阻止冒泡"><a href="#如何阻止冒泡" class="headerlink" title="如何阻止冒泡"></a>如何阻止冒泡</h3><h3 id="实现new操作符"><a href="#实现new操作符" class="headerlink" title="实现new操作符"></a>实现new操作符</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现</span></span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">const</span> newOperator = <span class="function">(<span class="params">ctor: <span class="built_in">Function</span>, ...args: <span class="built_in">any</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> ctor !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span>(<span class="string">'第一个参数必须为函数'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建一个对象，同时继承构造函数上的原型属性</span></span><br><span class="line">  <span class="keyword">const</span> newObj = <span class="built_in">Object</span>.create(ctor.prototype);</span><br><span class="line">  <span class="comment">// 调用构造函数，绑定到构造函数上this对象上，并且传入剩余的参数</span></span><br><span class="line">  <span class="keyword">const</span> returnObj = ctor.apply(newObj, args)</span><br><span class="line">  <span class="comment">// 默认返回this，如果手动定义返回原始值不影响，返回对象需要正常处理</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> returnObj === <span class="string">'object'</span> ? returnObj : newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 vue文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; mockNewFn, newOperator &#125; <span class="keyword">from</span> <span class="string">'../utils/mockBind'</span></span><br><span class="line"><span class="keyword">const</span> girl3 = newOperator(Girl, <span class="string">'测试下我的小女生3'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'gril3 —————— newOperator'</span>, girl3, girl3.greetName());</span><br></pre></td></tr></table></figure><h3 id="模拟实现apply-call"><a href="#模拟实现apply-call" class="headerlink" title="模拟实现apply/call"></a>模拟实现apply/call</h3><p>两者区别在于apply第二个参数传入的是数组，而call是一个一个参数传入的</p><p>模拟的时候注意:</p><ul><li>this 参数可以传 null，当为 null 的时候，视为指向 window</li><li>函数是可以有返回值的！</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟实现apply</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mockApply = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, thisArg: <span class="built_in">any</span>, rest: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>&#125;</span>.mockApply is not a function`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> newObj = <span class="built_in">Object</span>.create(thisArg) || <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// 首先要获取调用apply的函数，用this可以获取</span></span><br><span class="line">  newObj[<span class="string">'anyFn'</span>] = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> res = newObj[<span class="string">'anyFn'</span>](...rest)</span><br><span class="line">  <span class="keyword">delete</span> newObj[<span class="string">'anyFn'</span>]</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟实现call</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mockCall = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, thisArg: <span class="built_in">any</span>, ...rest: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>&#125;</span>.mockCall is not a function`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> newObj = <span class="built_in">Object</span>.create(thisArg) || <span class="built_in">window</span>;</span><br><span class="line">  newObj[<span class="string">'anyFn'</span>] = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> res = newObj[<span class="string">'anyFn'</span>](...rest)</span><br><span class="line">  <span class="keyword">delete</span> newObj[<span class="string">'anyFn'</span>]</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="keyword">import</span> &#123; mockApply, mockCall &#125; <span class="keyword">from</span> <span class="string">'../utils/mockBind'</span></span><br><span class="line"></span><br><span class="line">(<span class="built_in">Function</span>.prototype <span class="keyword">as</span> <span class="built_in">any</span>).mockApply = mockApply;</span><br><span class="line">(<span class="built_in">Function</span>.prototype <span class="keyword">as</span> <span class="built_in">any</span>).mockCall = mockCall;</span><br><span class="line"><span class="keyword">const</span> test1 = (sayName <span class="keyword">as</span> <span class="built_in">any</span>).mockApply(TestObj, [<span class="string">'chendaoeng mockApply'</span>, <span class="number">30</span>])</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test1- mockApply'</span>, test1);</span><br><span class="line"><span class="keyword">const</span> testMockCall = (sayName <span class="keyword">as</span> <span class="built_in">any</span>).mockCall(TestObj, <span class="string">'chendaoeng mockCall'</span>, <span class="number">30</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'testMockCall- mockCall'</span>, testMockCall);</span><br></pre></td></tr></table></figure><h3 id="实现bind函数"><a href="#实现bind函数" class="headerlink" title="实现bind函数"></a>实现bind函数</h3><p>bind函数: bind()会创建一个方法，当这个新函数被调用的时候，bind()的第一个参数将作为它运行时的this,之后的序列参数会在传入的实参前传入作为它的参数。<br>需要理解下，bind函数有两种；</p><h4 id="手写mockBind"><a href="#手写mockBind" class="headerlink" title="手写mockBind"></a>手写mockBind</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mockBind = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, obj: <span class="built_in">any</span>, ...firstArgs: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>&#125;</span>.bind is not a function`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> context = obj || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> bindFn = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, ...bindFnArg: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 作为构造函数 this指向实例 self 指向绑定函数 this,因为下面一句 bindFn.prototype = this.prototype 已经修改了bindFn.prototype为绑定函数的prototype</span></span><br><span class="line">    <span class="comment">// instanceof self: true this指向实例</span></span><br><span class="line">    <span class="comment">// 作为普通函数 this指向window self 指向绑定函数 this instanceof self: false</span></span><br><span class="line">    <span class="comment">// instanceof self: true this指向window</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'context传入的————'</span>, context);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this————'</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'self————'</span>, self);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this instanceof self'</span>, <span class="keyword">this</span> <span class="keyword">instanceof</span> self);</span><br><span class="line">    <span class="keyword">return</span> self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> self ? <span class="keyword">this</span> : context, [...firstArgs, ...bindFnArg])</span><br><span class="line">  &#125;</span><br><span class="line">  bindFn.prototype = <span class="keyword">this</span>.prototype</span><br><span class="line">  <span class="keyword">return</span> bindFn</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TestObj = &#123;</span><br><span class="line">  name: <span class="string">'cpp'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str =  <span class="string">`我的名字是<span class="subst">$&#123;name&#125;</span>,年龄是<span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    tip: str</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="built_in">Function</span>.prototype <span class="keyword">as</span> <span class="built_in">any</span>).mockBind = mockBind</span><br><span class="line"><span class="keyword">const</span> bindName = sayName.bind(TestObj, <span class="string">'niaogege bind'</span>);</span><br><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">const</span> testBind1 = bindName(<span class="number">29</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'第一种'</span>, testBind1); <span class="comment">// &#123;tip: "我的名字是niaogege bind,年龄是29"&#125;</span></span><br><span class="line"><span class="keyword">const</span> bindName2 = (sayName <span class="keyword">as</span> <span class="built_in">any</span>).mockBind(TestObj, <span class="string">'niaogege bind'</span>);</span><br><span class="line"><span class="keyword">const</span> testBind2 = bindName2(<span class="number">29</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'第一种'</span>, testBind2); <span class="comment">// &#123;tip: "我的名字是niaogege bind,年龄是29"&#125;</span></span><br></pre></td></tr></table></figure><h4 id="mockBind之后new操作符调用"><a href="#mockBind之后new操作符调用" class="headerlink" title="mockBind之后new操作符调用"></a>mockBind之后new操作符调用</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">const</span> newTestBind1 = <span class="keyword">new</span> (bindName <span class="keyword">as</span> <span class="built_in">any</span>)(<span class="number">30</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newTestBind1, <span class="string">'newTestBind1'</span>, <span class="built_in">Object</span>.prototype.toString.call(newTestBind1))</span><br><span class="line"><span class="keyword">const</span> mockBindName = (sayName <span class="keyword">as</span> <span class="built_in">any</span>).mockBind(TestObj, <span class="string">'niaogege mockBind'</span>)</span><br><span class="line"><span class="keyword">const</span> newTestBind2 = <span class="keyword">new</span> mockBindName(<span class="number">30</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newTestBind2, <span class="string">'newTestBind2'</span>, <span class="built_in">Object</span>.prototype.toString.call(newTestBind2));</span><br></pre></td></tr></table></figure><h3 id="vue渲染原理"><a href="#vue渲染原理" class="headerlink" title="vue渲染原理"></a>vue渲染原理</h3><h3 id="vue数据双向绑定"><a href="#vue数据双向绑定" class="headerlink" title="vue数据双向绑定"></a>vue数据双向绑定</h3><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://segmentfault.com/a/1190000009257663" target="_blank" rel="noopener">JavaScript深入之call和apply的模拟实现</a></li><li><a href="https://mp.weixin.qq.com/s/TG87bWiLyv1b8Ho4afaNUA" target="_blank" rel="noopener">面试系列——手写代码实现（一）</a></li><li><a href="https://segmentfault.com/a/1190000009271416" target="_blank" rel="noopener">JavaScript深入之bind的模拟实现</a></li><li><a href="https://segmentfault.com/a/1190000008972987" target="_blank" rel="noopener">JavaScript深入之词法作用域和动态作用域</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础: Iterator</title>
      <link href="/2020/12/29/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-Iterator/"/>
      <url>/2020/12/29/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-Iterator/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>遍历器(Iterator)是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就阔以完成遍历操作；</p><h4 id="模拟next方法返回值的例子"><a href="#模拟next方法返回值的例子" class="headerlink" title="模拟next方法返回值的例子"></a>模拟next方法返回值的例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">it.next() <span class="comment">// &#123;value: 'a', done: false&#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123;value: 'b', done: false&#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &lt; array.length ?</span><br><span class="line">      &#123;<span class="attr">value</span>: array[index++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">      &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认-Iterator-接口"><a href="#默认-Iterator-接口" class="headerlink" title="默认 Iterator 接口"></a>默认 Iterator 接口</h3><p>Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即<strong>for…of</strong>循环。当使用for…of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。<br>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。<br>ES6 规定，默认的 Iterator 接口部署在数据结构的<strong>Symbol.iterator</strong>属性，或者说，一个数据结构只要具有<strong>Symbol.iterator</strong>属性，就可以认为是<em>可遍历的</em>（iterable）。<br>Symbol.iterator本身是一个函数，数据结构默认的遍历器生成函数，执行这个函数就会返回一个遍历器。<br>原生具备 Iterator 接口的数据结构如下:</p><ul><li><p>Array</p></li><li><p>Set</p></li><li><p>Arguments</p></li><li><p>Map</p></li><li><p>String</p></li><li><p>NodeList对象</p></li><li><p>typedArray</p><p>对于类似数组的对象（存在数值键名和length属性），部署 Iterator 接口，有一个简便方法，就是Symbol.iterator方法直接引用数组的 Iterator 接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> it = arr[<span class="built_in">Symbol</span>.iterator](); <span class="comment">// 得到遍历器对象</span></span><br><span class="line">it.next()</span><br><span class="line">it.next()</span><br><span class="line">it.next()</span><br></pre></td></tr></table></figure><p>变量arr是一个数组，原生就具有遍历器接口，部署在arr的Symbol.iterator属性上面。所以，调用这个属性，就得到<strong>遍历器对象</strong>。</p></li></ul><p>类似数组的对象调用数组的Symbol.iterator方法的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iterable = &#123;</span><br><span class="line"> <span class="number">0</span>: <span class="string">'a'</span>,</span><br><span class="line"> <span class="number">1</span>: <span class="string">'b'</span>,</span><br><span class="line"> <span class="number">2</span>: <span class="string">'c'</span>,</span><br><span class="line"> length: <span class="number">3</span>,</span><br><span class="line"> [<span class="built_in">Symbol</span>.iterator]: [][<span class="built_in">Symbol</span>.iterator]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item, <span class="string">'eee'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a eee</span></span><br><span class="line"><span class="comment">// b eee</span></span><br><span class="line"><span class="comment">// c eee</span></span><br></pre></td></tr></table></figure><p>若没有部署[].Symbol.iterator则会报错 <em>iterable is not iterable</em></p><h4 id="普通对象部署数组的Symbol-iterator方法无效"><a href="#普通对象部署数组的Symbol-iterator方法无效" class="headerlink" title="普通对象部署数组的Symbol.iterator方法无效"></a>普通对象部署数组的Symbol.iterator方法无效</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iterable = &#123;</span><br><span class="line"> a: <span class="string">'a'</span>,</span><br><span class="line"> b: <span class="string">'b'</span>,</span><br><span class="line"> c: <span class="string">'c'</span>,</span><br><span class="line"> length: <span class="number">3</span>,</span><br><span class="line"> [<span class="built_in">Symbol</span>.iterator]: [][<span class="built_in">Symbol</span>.iterator]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item, <span class="string">'eee'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// undefined "eee"</span></span><br></pre></td></tr></table></figure><blockquote><p>手动部署iterator属性的时候记得是 [Symbol.iterator]: [][Symbol.iterator] 这种写法</p></blockquote><h3 id="手写实现一个遍历器"><a href="#手写实现一个遍历器" class="headerlink" title="手写实现一个遍历器"></a>手写实现一个遍历器</h3><p>目的: 定义一个对象，通过调用类Iterator实现可遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">"a"</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">"b"</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">"c"</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  Uncaught TypeError: obj is not iterable</span></span><br></pre></td></tr></table></figure><p>如何调用类Iterator实现可遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIterator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(obj) &#123;</span><br><span class="line">      <span class="keyword">this</span>.obj = obj;</span><br><span class="line">      <span class="keyword">this</span>.length = <span class="built_in">Object</span>.keys(obj).length;</span><br><span class="line">      <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;<span class="keyword">return</span> <span class="keyword">this</span>&#125;</span><br><span class="line">  next() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.index &lt; <span class="keyword">this</span>.length</span><br><span class="line">      ? &#123;<span class="attr">value</span>: <span class="keyword">this</span>.obj[<span class="keyword">this</span>.index ++], <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">      : &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">"a"</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">"b"</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">"c"</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> <span class="keyword">new</span> MyIterator(obj)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法），除了下文会介绍的for…of循环，还有其他场合</p><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">set</span> = new Set().add('a').add('b').add('c')</span><br><span class="line">var [x, ...y] = <span class="keyword">set</span>;</span><br><span class="line">console.log(x, y) // a ['b', 'c']</span><br></pre></td></tr></table></figure><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">[<span class="string">'a'</span>, ...arr, <span class="string">'d'</span>] <span class="comment">// a b c d</span></span><br></pre></td></tr></table></figure><p>上面代码的扩展运算符内部就调用 Iterator 接口。<br>只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</p><h4 id="yield"><a href="#yield" class="headerlink" title="yield*"></a>yield*</h4><p>yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ge = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">55</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ite = ge();</span><br><span class="line">ite.next() <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">ite.next() <span class="comment">// &#123;value: [2, 3, 4], done: false&#125;</span></span><br><span class="line">ite.next() <span class="comment">// &#123;value: 55, done: false&#125;</span></span><br><span class="line">ite.next() <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>思考 如何让第二个next里的数据遍历呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ge = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">55</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ite = ge();</span><br></pre></td></tr></table></figure><h4 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h4><p>由于数组的遍历回调用遍历器接口，所以任何接受数组作为参数的场景都会调用遍历器</p><ul><li>for…of</li><li>Array.from()</li><li>Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])）</li><li>Promise.all()</li><li>Promise.race()</li></ul><h3 id="字符串的-Iterator-接口"><a href="#字符串的-Iterator-接口" class="headerlink" title="字符串的 Iterator 接口"></a>字符串的 Iterator 接口</h3><p>字符串是一个类似数组的对象，也原生具有 Iterator 接口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someString = <span class="string">"hi"</span>;</span><br><span class="line"><span class="keyword">typeof</span> someString[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line"><span class="comment">// "function"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = someString[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: "h", done: false &#125;</span></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: "i", done: false &#125;</span></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中 调用<strong>Symbol.iterator</strong>方法返回一个遍历器对象，在这个遍历器上可以调用 <strong>next</strong> 方法，实现对于字符串的遍历</p><h3 id="Iterator与Generator"><a href="#Iterator与Generator" class="headerlink" title="Iterator与Generator"></a>Iterator与Generator</h3><p>Symbol.iterator()方法的最简单实现</p><ul><li>第一种<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = &#123;</span><br><span class="line">   [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log([...it]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li>第二种<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it2 = &#123;</span><br><span class="line">    * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(...it2) <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h3><p>一个结构只要部署了Symbol.iterator属性，就被视为具体Iterator接口，就能用for of 循环遍历成员，也就是for of 循环内部调用的是数据结构的Symbol.iterator属性</p><p>for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、Generator 对象，以及字符串</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://es6.ruanyifeng.com/#docs/iterator" target="_blank" rel="noopener">Iterator 和 for…of 循环</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> Iterator </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> es6 </tag>
            
            <tag> Iterator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: generator-1</title>
      <link href="/2020/12/29/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-generator-1/"/>
      <url>/2020/12/29/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-generator-1/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Generator(生成器) 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p><p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><p>形式上，Generator 函数是一个普通函数，但是有两个特征。</p><ul><li>function关键字与函数名之间有一个<strong>星号</strong></li><li>函数体内部使用<strong>yield</strong>表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'cpp'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'专注'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hG = hello()</span><br><span class="line"><span class="built_in">console</span>.log(hG, <span class="built_in">Object</span>.prototype.toString.call(hG)); <span class="comment">// hello &#123;&lt;suspended&gt;&#125;  "[object Generator]"</span></span><br><span class="line">hG.next() <span class="comment">// &#123;value: "hello", done: false&#125;</span></span><br></pre></td></tr></table></figure><h3 id="yield-表达式，暂停标记"><a href="#yield-表达式，暂停标记" class="headerlink" title="yield 表达式，暂停标记"></a>yield 表达式，暂停标记</h3><p>由于 Generator 函数返回的遍历器对象，只有调用<strong>next</strong>方法才会遍历下一个内部状态<br>遍历器对象的next方法的运行逻辑如下。</p><ul><li>遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</li><li>下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。</li><li>如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</li><li>如果该函数没有return语句，则返回的对象的value属性值为undefined。</li></ul><blockquote><p>另外需要注意，yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。</p></blockquote><p>yield表达式如果用在另一个表达式之中，必须放在圆括号里面;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">hello2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>+ (<span class="keyword">yield</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'专注'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hG = hello2()</span><br><span class="line">hG.next(); <span class="comment">// &#123;value: undefined, done: false&#125;</span></span><br><span class="line">hG.next(); <span class="comment">// helloundefined &#123;value: "专注", done: true&#125;</span></span><br><span class="line">hG.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><h4 id="return-amp-yield区别"><a href="#return-amp-yield区别" class="headerlink" title="return &amp; yield区别"></a>return &amp; yield区别</h4><ul><li>相似之处在于，都能返回紧跟在语句后面的那个表达式的值</li><li>不同:<br>a: return语句不具备位置记忆的功能,每次遇到yield函数暂停执行，并将紧跟yield后面的表达式的值作为返回对象的value属性值<br>b：一个函数只能执行一个return语句，而能执行多个yield语句</li></ul><h4 id="如何模拟-yield关键词？"><a href="#如何模拟-yield关键词？" class="headerlink" title="如何模拟 yield关键词？"></a>如何模拟 yield关键词？</h4><h3 id="与-Iterator-接口的关系"><a href="#与-Iterator-接口的关系" class="headerlink" title="与 Iterator 接口的关系"></a>与 Iterator 接口的关系</h3><p>Iterator Generator<br>It/Gen erator 从命名上有点关系哈</p><p>任意一个对象的<strong>Symbol.iterator</strong>方法 === 该对象的遍历器生成函数Generator，调用该函数会生成该对象的遍历器对象.<br>Generator函数就是遍历器生成函数，因此能把Generator赋值给对象的Symbol.iterator属性，从而使该对象具有iterator接口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterator = &#123;&#125;</span><br><span class="line">myIterator[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log([...myIterator]) <span class="comment">//  [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>Generator函数执行后返回一个遍历器对象，该对象本身也具有Symbol.iterator属性，所以执行后返回自身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> gg = gen()</span><br><span class="line">gg[<span class="built_in">Symbol</span>.iterator]() === gg <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> gg = (<span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;&#125;)()</span><br><span class="line">gg[<span class="built_in">Symbol</span>.iterator]() === gg</span><br></pre></td></tr></table></figure><h3 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a>next 方法的参数</h3><p>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作<strong>上一个yield</strong>表达式的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> reset = <span class="keyword">yield</span> i; <span class="comment">// yield i 上一次的结果</span></span><br><span class="line">    <span class="keyword">if</span>(reset) &#123; i = <span class="number">-1</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f();</span><br><span class="line"></span><br><span class="line">g.next() <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next(<span class="literal">true</span>) <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br></pre></td></tr></table></figure><p>当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。</p><p>注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的<br>再看一个通过next方法的参数，向 Generator 函数内部输入值的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">dataConsumer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Started'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`1. <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`2. <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'result'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> genObj = dataConsumer();</span><br><span class="line">genObj.next(); <span class="comment">// started &#123;value: undefined, done: false&#125;</span></span><br><span class="line">genObj.next(<span class="string">'a'</span>); <span class="comment">//  1. a &#123;value: undefined, done: false&#125;</span></span><br><span class="line">genObj.next(<span class="string">'b'</span>); <span class="comment">// 2. b  &#123;value: "result", done: true&#125;</span></span><br></pre></td></tr></table></figure><h3 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for of 循环"></a>for of 循环</h3><p>for of 阔以自动遍历Generator函数生成的遍历器对象，不需要next方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'end'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的end，不包括在for…of循环之中。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">Generator 函数的语法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> generator </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> es6 </tag>
            
            <tag> generator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶-手写promise</title>
      <link href="/2020/12/27/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E6%89%8B%E5%86%99promise/"/>
      <url>/2020/12/27/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E6%89%8B%E5%86%99promise/</url>
      
        <content type="html"><![CDATA[<p>promise基本用法以及手写</p><h2 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h2><h3 id="20行手写promise"><a href="#20行手写promise" class="headerlink" title="20行手写promise"></a>20行手写promise</h3><p>目前见过最容易理解的promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Promise resolve时的回调函数集</span></span><br><span class="line">  <span class="keyword">this</span>.callbacks = []</span><br><span class="line">  <span class="keyword">const</span> resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 注意promise的then函数需要异步执行</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.data = val;</span><br><span class="line">      <span class="comment">// cbs里用户传入的函数执行一遍</span></span><br><span class="line">      <span class="keyword">this</span>.callbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">        cb(val)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  executor(resolve)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// promise2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this指的是promise1</span></span><br><span class="line">    <span class="keyword">this</span>.callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// onResolved对应用户在then里传入的函数</span></span><br><span class="line">      <span class="keyword">const</span> res = onResolved(<span class="keyword">this</span>.data)</span><br><span class="line">      <span class="keyword">if</span> (res <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">        <span class="comment">// 只有promise2被resolve以后</span></span><br><span class="line">        <span class="comment">// then下面的链式调用函数才会继续执行</span></span><br><span class="line">        res.then(resolve)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// onResolved</span></span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">2</span>);</span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="built_in">console</span>.log);</span><br><span class="line">  <span class="comment">// 500s后输出 1</span></span><br><span class="line">  <span class="comment">// 500s后输出 2</span></span><br></pre></td></tr></table></figure><h2 id="面试版"><a href="#面试版" class="headerlink" title="面试版"></a>面试版</h2><p>在基础版基础上增加reject部分功能; </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进阶版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cppPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 收集链式调用的函数集合cb</span></span><br><span class="line">  <span class="keyword">this</span>.onResolvedCallbacks = [];</span><br><span class="line">  <span class="keyword">this</span>.onRejectedCallbacks = [];</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">this</span>.reason = <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">this</span>.status = <span class="string">'pending'</span></span><br><span class="line">  <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.status = <span class="string">'fulfilled'</span></span><br><span class="line">      <span class="keyword">this</span>.value = value</span><br><span class="line">      <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">        cb(<span class="keyword">this</span>.value)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> reject = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.status = <span class="string">'rejected'</span></span><br><span class="line">      <span class="keyword">this</span>.reason = val</span><br><span class="line">      <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">        cb(<span class="keyword">this</span>.reason)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  executor(resolve, reject)</span><br><span class="line">&#125;</span><br><span class="line">handleResolve(resolve, reject, onFulledFn) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> cppPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = onFulledFn(<span class="keyword">this</span>.value);</span><br><span class="line">        <span class="keyword">if</span> (res <span class="keyword">instanceof</span> cppPromise) &#123;</span><br><span class="line">          res.then(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(res)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">handleReject(resolve, reject, onRejectedFn) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> cppPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = onRejectedFn(<span class="keyword">this</span>.reason);</span><br><span class="line">        <span class="keyword">if</span> (res <span class="keyword">instanceof</span> cppPromise) &#123;</span><br><span class="line">          res.then(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(res)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">cppPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulledFn, onRejectedFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> cppPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 收集成功的回调</span></span><br><span class="line">      <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        handleResolve(resolve, reject, onFulledFn)</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 收集失败的回调</span></span><br><span class="line">      <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        handleReject(resolve, reject, onRejectedFn)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'fulfilled'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> cppPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        handleResolve(resolve, reject, onFulledFn)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> cppPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        handleReject(resolve, reject, onRejectedFn)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例调用2</span></span><br><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> cppPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'promise1'</span>, promise1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'promise2'</span>, promise2)</span><br></pre></td></tr></table></figure><h2 id="专业版1"><a href="#专业版1" class="headerlink" title="专业版1"></a>专业版1</h2><h3 id="手写MockPromise"><a href="#手写MockPromise" class="headerlink" title="手写MockPromise"></a>手写MockPromise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.status = <span class="string">'pending'</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.onResolvedCallbacks = []</span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallbacks = []</span><br><span class="line">    <span class="comment">// 定义resolve</span></span><br><span class="line">    <span class="keyword">let</span> resolve = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'resolve'</span></span><br><span class="line">        <span class="keyword">this</span>.value = data</span><br><span class="line">        <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reject</span></span><br><span class="line">    <span class="keyword">let</span> reject = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'reject'</span></span><br><span class="line">        <span class="keyword">this</span>.reason = data</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description </span>then函数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;function&#125;</span> </span>onFufilled </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;function&#125;</span> </span>onRejected </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  then(onFufilled, onRejected) &#123;</span><br><span class="line">    <span class="comment">// console.log(`onFufilled`, onFufilled);</span></span><br><span class="line">    <span class="comment">// console.log(`onRejected`, onRejected);</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> onFufilled !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      onFufilled = <span class="function"><span class="params">res</span> =&gt;</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      onRejected = <span class="function"><span class="params">res</span> =&gt;</span> MockPromise.reject(res)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> promise2</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'resolve'</span>) &#123;</span><br><span class="line">      promise2 = <span class="keyword">new</span> MockPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onFufilled(<span class="keyword">this</span>.value)</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'reject'</span>) &#123;</span><br><span class="line">      promise2 = <span class="keyword">new</span> MockPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      promise2 = <span class="keyword">new</span> MockPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onFufilled(<span class="keyword">this</span>.value);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">` onFufilled x pending`</span>, x);</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">` onRejected x pending`</span>, x);</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span>(cb) &#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">this</span>.constructor</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">      val =&gt; P.resolve(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> val),</span><br><span class="line">      reason = P.reject(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> resolve(val) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MockPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      resolve(val)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MockPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      reject(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当数组中每个实例都成功时才会返回，返回的也是一个数组，每个参数为对应的promise返回的结果，如果有一项失败了，all方法都会返回失败</span></span><br><span class="line">  <span class="comment">// 谁跑得慢以谁为准 如果有一个失败 则返回失败结果</span></span><br><span class="line">  <span class="keyword">static</span> all(promiseList) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MockPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">      <span class="keyword">const</span> results = []</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promiseList.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">const</span> item = promiseList[i]</span><br><span class="line">        <span class="keyword">if</span> (!item <span class="keyword">instanceof</span> MockPromise) <span class="keyword">return</span></span><br><span class="line">        item.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">          index ++</span><br><span class="line">          results[i] = result</span><br><span class="line">          <span class="keyword">if</span> (index === promiseList.length) &#123;</span><br><span class="line">            resolve(results)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">reason</span> =&gt;</span> reject(reason))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Promise.all示例</span></span><br><span class="line">  <span class="comment">// 谁跑得快 以谁为准</span></span><br><span class="line">  <span class="keyword">static</span> race(promiseList) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MockPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      promiseList.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!item <span class="keyword">instanceof</span> MockPromise) <span class="keyword">return</span></span><br><span class="line">        item.then(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">          resolve(val)</span><br><span class="line">        &#125;, (err) =&gt; &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> <span class="variable">promise2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> </span>resolve reject 最外层的resolve reject</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环了'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> called</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.then</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`x then`</span>, then);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一个参数是将x这个promise方法作为this指向，后两个参数分别为成功失败回调</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`called`</span>, called);</span><br><span class="line">        then.call(x,</span><br><span class="line">          (</span><br><span class="line">            y =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">              called = <span class="literal">true</span></span><br><span class="line">              <span class="comment">//因为可能promise中还有promise，所以需要递归</span></span><br><span class="line">              <span class="comment">// this.resolvePromise(promise2, y, resolve, reject)</span></span><br><span class="line">              resolve(y)</span><br><span class="line">            &#125;,</span><br><span class="line">            err =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">              called = <span class="literal">true</span></span><br><span class="line">              reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">          )</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用MockPromise"><a href="#使用MockPromise" class="headerlink" title="使用MockPromise"></a>使用MockPromise</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = MockPromise.resolve(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = MockPromise.resolve(p1)</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> MockPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">'cpp MockPromise'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br><span class="line"><span class="built_in">console</span>.log(p2)</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p1) <span class="comment">// trye</span></span><br><span class="line">p3.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`p3: <span class="subst">$&#123;val&#125;</span> then1 ————`</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;val&#125;</span> then3 ————`</span>);</span><br><span class="line">  <span class="comment">// then返回的mockPromise还是有问题!!循环引用</span></span><br><span class="line">  <span class="keyword">return</span> MockPromise.reject(<span class="string">'then is reject'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;val&#125;</span> then4 ————`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="专业版-2"><a href="#专业版-2" class="headerlink" title="专业版 2"></a>专业版 2</h2><h3 id="手写-cppPromise"><a href="#手写-cppPromise" class="headerlink" title="手写 cppPromise"></a>手写 cppPromise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 专业版2</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">      <span class="keyword">this</span>.status = <span class="string">'pending'</span>;</span><br><span class="line">      <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">this</span>.onResolvedCallbacks = []</span><br><span class="line">      <span class="keyword">this</span>.onRejectedCallbacks = []</span><br><span class="line">      <span class="keyword">const</span> resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.status = <span class="string">'fulfilled'</span></span><br><span class="line">          <span class="keyword">this</span>.value = val</span><br><span class="line">          <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              cb(val)</span><br><span class="line">            &#125;, <span class="number">0</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> reject = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.status = <span class="string">'rejected'</span></span><br><span class="line">          <span class="keyword">this</span>.reason = val;</span><br><span class="line">          <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              cb(val)</span><br><span class="line">            &#125;, <span class="number">0</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 使用者传入的参数</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fn(resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造器中resolve和reject的结果传入onFufilled和onRejected中</span></span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">      onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function">(<span class="params">v</span>) =&gt;</span> v;</span><br><span class="line">      onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;<span class="keyword">throw</span> e&#125;;</span><br><span class="line">      <span class="keyword">let</span> promise2</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'fulfilled'</span>) &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> value = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                resolvePromise(promise2, value, resolve, reject)</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">              reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.onRejectedCallbacks(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> reason = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                resolvePromise(promise2, reason, resolve, reject)</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">              reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 成功回调的收集 </span></span><br><span class="line">          <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> value = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">            resolvePromise(promise2, value, resolve, reject)  </span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="comment">// 失败回调的收集</span></span><br><span class="line">          <span class="keyword">this</span>.onRejectedCallbacks(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> reason = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">            resolvePromise(promise2, reason, resolve, reject) </span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> promise2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统一处理</span></span><br><span class="line">    resolvePromise(myPromise, val, resolve, reject) &#123;</span><br><span class="line">      <span class="keyword">if</span> (myPromise === val) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>)) </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (val &amp;&amp; (<span class="keyword">typeof</span> val === <span class="string">'object'</span> || <span class="keyword">typeof</span> val === <span class="string">'function'</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (val <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">            val.then(resolve)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(val)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">let</span> thenFn = val.then</span><br><span class="line">          <span class="keyword">let</span> called</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> thenFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">            thenFn.call(val, value =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">              called = <span class="literal">true</span></span><br><span class="line">              resolvePromise(promise2, value, resolve, reject)</span><br><span class="line">            &#125;, err =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">              called = <span class="literal">true</span></span><br><span class="line">              reject(err)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 其实就相当于</span></span><br><span class="line">            <span class="comment">// if (val instanceof myPromise) &#123;</span></span><br><span class="line">            <span class="comment">//   val.then(resolve, reject)</span></span><br><span class="line">            <span class="comment">// &#125; else &#123;</span></span><br><span class="line">            <span class="comment">//   resolve(val)</span></span><br><span class="line">            <span class="comment">//   reject(val)</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(val)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">          called = <span class="literal">true</span></span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  myPromise.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(val)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  myPromise.reject = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(val)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 入参是个由Promise实例组成的数组</span></span><br><span class="line">  <span class="comment">// 返回值是个promise，因为可以使用.then</span></span><br><span class="line">  <span class="comment">// 如果全部成功，状态变为resolved, 并且返回值组成一个数组传给回调</span></span><br><span class="line">  <span class="comment">// 但凡有一个失败，状态变为rejected, 并将error返回给回调</span></span><br><span class="line">  myPromise.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = []</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> promises) &#123;</span><br><span class="line">        item.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          result[index] = res</span><br><span class="line">          index ++ </span><br><span class="line">          <span class="keyword">if</span> (index === promises.length) &#123;</span><br><span class="line">            resolve(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, (err) =&gt; &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myPromise.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">        promise.then(resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="专业版2-示例"><a href="#专业版2-示例" class="headerlink" title="专业版2 示例"></a>专业版2 示例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myPromise.all示例</span></span><br><span class="line"><span class="keyword">let</span> p1 = myPromise.resolve(<span class="number">1</span>),</span><br><span class="line">p2 = myPromise.resolve(<span class="number">2</span>),</span><br><span class="line">p3 = myPromise.resolve(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">myPromise.all([p1, p2, p3]).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="string">'res'</span>)</span><br><span class="line">&#125;, (err)=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err, <span class="string">'err'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://juejin.cn/post/6844904094079926286" target="_blank" rel="noopener">最简实现Promise，支持异步链式调用（20行）</a> </li><li><a href="https://juejin.cn/post/6844903629187448845#heading-12" target="_blank" rel="noopener">Promise之你看得懂的Promise</a></li><li><a href="https://juejin.cn/post/6844903509934997511" target="_blank" rel="noopener">Promise 必知必会（十道题）</a></li><li><a href="https://mp.weixin.qq.com/s/PhZrP1gCn_VxLub7-oh1_w" target="_blank" rel="noopener">15道ES6 Promise实战练习题，助你快速理解Promise</a></li><li><a href="https://juejin.cn/post/6844903488695042062#heading-6" target="_blank" rel="noopener">八段代码彻底掌握 Promise</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> promise </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> es6 </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: js执行机制</title>
      <link href="/2020/12/26/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/12/26/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="js执行是单线程的"><a href="#js执行是单线程的" class="headerlink" title="js执行是单线程的"></a>js执行是单线程的</h3><p>单线程是指Js引擎执行Js时只分了一个线程给他执行，也就是执行js时是单线程的。说白点就是一个时间点只能做一件事，这里只是说javascript,浏览器可不是单线程的，浏览器可是多进程的</p><h3 id="js引擎"><a href="#js引擎" class="headerlink" title="js引擎"></a>js引擎</h3><p>JS引擎是浏览器的重要组成部分，主要用于读取并执行js。js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</p><p>各大浏览器的JS引擎:</p><table><thead><tr><th>浏览器</th><th>Js引擎</th></tr></thead><tbody><tr><td>Chrome</td><td><em>V8</em></td></tr><tr><td>Firefox</td><td>SpiderMonkey</td></tr><tr><td>IE</td><td>Chakra（查克拉）</td></tr><tr><td>Safari</td><td>Nitro/JavaScript Core</td></tr></tbody></table><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>浏览器（多进程）包含了Browser进程（浏览器的主进程）、第三方插件进程和GPU进程以及浏览器渲染进程，</p><ul><li>浏览器进程<br>浏览器最核心的进程，负责管理各个标签页的创建和销毁、页面显示和功能（前进，后退，收藏等）、网络资源的管理，下载等。</li><li>插件进程<br>负责每个第三方插件的使用，每个第三方插件使用时候都会创建一个对应的进程、这可以避免第三方插件crash影响整个浏览器、也方便使用沙盒模型隔离插件进程，提高浏览器稳定性。</li><li>GPU进程<br>负责3D绘制和硬件加速</li><li>渲染进程即 浏览器内核<br>浏览器会为每个窗口分配一个渲染进程、也就是我们常说的浏览器内核，这可以避免单个 page crash 影响整个浏览器。</li></ul><p>其中浏览器渲染进程（多线程）和Web前端密切相关，包含以下线程</p><ul><li>GUI渲染线程<br> GUI 渲染线程负责渲染浏览器界面 HTML 元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。</li><li>JS引擎线程<br> Javascript引擎，也可以称为JS内核，主要负责处理 Javascript 脚本程序，例如V8引擎。Javascript 引擎线程理所当然是负责解析 Javascript 脚本，运行代码。</li><li>事件触发线程（和EventLoop密切相关）<br> 当一个事件被触发时该线程会把事件添加到事件队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。</li><li>定时器触发器线程<br> 浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。</li><li>异步HTTP请求线程<br> 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。</li></ul><blockquote><p>GUI渲染线程和JS引擎线程是互斥的，为了防止DOM渲染的不一致性，其中一个线程执行时另一个线程会被挂起。</p></blockquote><p>那么既然 JavaScript 本身被设计为单线程，为何还会有像 WebWorker 这样的多线程 API 呢？我们来看一下 WebWorker 的核心特点就明白了？</p><ul><li>创建 Worker 时， JS 引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</li><li>JS 引擎线程与 worker 线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）</li></ul><h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><p>为了实现js执行时的单线程，js引擎维护一个<strong>执行栈(先进后出)</strong> FILO,(想象下桌子上的一摞书，最上面的先被拿走，最下面的后面才能拿走)</p><h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><p>任务队列中分微任务和宏任务，且都是已经完成的<em>异步操作</em>. 这里要重点说明一下，<em>宏任务并非全是异步任务，主代码块就是属于宏任务的一种!!</em>如果当前的微任务没有执行完成时，是不会执行下一个宏任务的!</p><ul><li>宏任务是每次执行栈执行的代码（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</li><li>浏览器为了能够使得JS引擎线程与GUI渲染线程有序切换，会在当前宏任务结束之后，下一个宏任务执行开始之前，对页面进行重新渲染（宏任务 &gt; 渲染  &gt; 宏任务 &gt; …）</li><li>微任务是在当前宏任务执行结束之后立即执行的任务（在当前 宏任务执行之后，UI渲染之前执行的任务）。微任务的响应速度相比setTimeout（下一个宏任务）会更快，因为无需等待UI渲染。</li><li>当前宏任务执行后，会将在它执行期间产生的所有微任务都执行一遍。</li></ul><p>理解：</p><ul><li>宏任务中的事件是由<strong>事件触发线程</strong>来维护的</li><li>微任务中的所有任务是由<strong>JS引擎线程</strong>维护的</li></ul><blockquote><p>宏任务必然是在微任务之后才执行的（因为微任务实际上是宏任务的其中一个步骤）</p></blockquote><table><thead><tr><th>macroTask宏任务</th><th>浏览器</th><th>node</th></tr></thead><tbody><tr><td>I/O</td><td>✅</td><td>✅</td></tr><tr><td>setTimeout</td><td>✅</td><td>✅</td></tr><tr><td>setImmediate</td><td>X</td><td>✅</td></tr><tr><td>requestAnimationFrame</td><td>✅</td><td>X</td></tr></tbody></table><table><thead><tr><th>microTask微任务</th><th>浏览器</th><th>node</th></tr></thead><tbody><tr><td>process.nextTick</td><td>X</td><td>✅</td></tr><tr><td>MutationObserver</td><td>✅</td><td>X</td></tr><tr><td>Promise.then catch finally</td><td>✅</td><td>✅</td></tr></tbody></table><h3 id="js执行机制"><a href="#js执行机制" class="headerlink" title="js执行机制"></a>js执行机制</h3><p><img src= "/img/loading.gif" data-src="/images/eventLoop.png" alt="事件循环"></p><h4 id="大概过程"><a href="#大概过程" class="headerlink" title="大概过程:"></a>大概过程:</h4><ul><li><p>任务进入执行栈</p></li><li><p>js代码分同步任务和异步任务，所有同步任务都在<em>主线程</em>执行。所有异步任务进入 <em>EventTable(事件表)</em>，执行异步任务，当事件表中的异步任务执行完成之后，会在<em>事件队列(event queue)</em>中注册回调函数(函数移入event Queue)</p></li><li><p>主线程里的同步任务全部完成之后，会读取事件队列(event Queue)中的异步任务,进入主线程执行</p></li><li><p>js解析器会不断重复检查主线程执行栈是否为空，然后重复第三步，即<em>Event Loop(事件循环)</em></p><blockquote><p>js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空</p></blockquote></li></ul><h4 id="JS引擎线程和事件触发线程"><a href="#JS引擎线程和事件触发线程" class="headerlink" title="JS引擎线程和事件触发线程"></a>JS引擎线程和事件触发线程</h4><p>浏览器页面初次渲染完毕后，JS引擎线程结合事件触发线程的工作流程如下：<br>（1）同步任务在JS引擎线程（主线程）上执行，形成执行栈（Execution Context Stack）。<br>（2）主线程之外，事件触发线程管理着一个任务队列（Task Queue）。只要异步任务有了运行结果，就在任务队列之中放置一个事件。<br>（3）执行栈中的同步任务执行完毕，系统就会读取任务队列，如果有异步任务需要执行，将其加到主线程的执行栈并执行相应的异步任务。</p><p><img src= "/img/loading.gif" data-src="/images/macroTask.png" alt="执行过程"></p><h4 id="根据事件循环机制以及宏任务和微任务，重新梳理一下流程"><a href="#根据事件循环机制以及宏任务和微任务，重新梳理一下流程" class="headerlink" title="根据事件循环机制以及宏任务和微任务，重新梳理一下流程"></a>根据事件循环机制以及宏任务和微任务，重新梳理一下流程</h4><ul><li>执行一个宏任务（首次执行的主代码块 script 或者任务队列中的回调函数）</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有任务（依次执行）</li><li>JS引擎线程挂起，GUI线程执行渲染</li><li>GUI线程渲染完毕后挂起，JS引擎线程执行任务队列中的下一个宏任务</li></ul><h3 id="结合Promise实例看看执行机制"><a href="#结合Promise实例看看执行机制" class="headerlink" title="结合Promise实例看看执行机制"></a>结合Promise实例看看执行机制</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = <span class="function"><span class="params">()</span> =&gt;</span> <span class="function">(<span class="params"><span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">            resolve(<span class="number">6</span>);</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">        resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">    p.then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arg);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">first().then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>第一轮 事件循环，先执行宏任务，即主script,即new Promise立即执行，打印3 ，然后执行p这个new Promise,输出7，发现setTimeout,将回调函数放入下一轮任务队列中，p的then,放入微任务队列，first的then放入微任务队列，执行打印4，宏任务执行结束<br>在执行微任务，先执行p.then打印1,在执行first.then打印2<br>第一轮 事件循环结束，开始第二轮事件循环，先执行宏任务里面，打印5， resolve(6)不会生效，因为Promise状态一旦改变就不会发生变化</p><h3 id="面试题之-了解v8引擎吗，一段js代码如何执行的"><a href="#面试题之-了解v8引擎吗，一段js代码如何执行的" class="headerlink" title="面试题之 了解v8引擎吗，一段js代码如何执行的"></a>面试题之 了解v8引擎吗，一段js代码如何执行的</h3><ul><li>在执行一段代码时，JS 引擎会首先创建一个执行栈，JS引擎会创建一个全局执行上下文，并push到执行栈中, 这个过程JS引擎会为这段代码中所有变量分配内存并赋一个初始值（undefined），在创建完成后，JS引擎会进入执行阶段，这个过程JS引擎会逐行的执行代码，即为之前分配好内存的变量逐个赋值(真实值)。</li><li>如果这段代码中存在function的声明和调用，那么JS引擎会创建一个函数执行上下文，并push到执行栈中，其创建和执行过程跟全局执行上下文一样。但有特殊情况，即当函数中存在对其它函数的调用时，JS引擎会在父函数执行的过程中，将子函数的全局执行上下文push到执行栈，这也是为什么子函数能够访问到父函数内所声明的变量。<br>还有一种特殊情况是，在子函数执行的过程中，父函数已经return了，这种情况下，JS引擎会将父函数的上下文从执行栈中移除，与此同时，JS引擎会为还在执行的子函数上下文创建一个闭包，这个闭包里保存了父函数内声明的变量及其赋值，子函数仍然能够在其上下文中访问并使用这边变量/常量。当子函数执行完毕，JS引擎才会将子函数的上下文及闭包一并从执行栈中移除。</li><li>last JS引擎是单线程的，那么它是如何处理高并发的呢？即当代码中存在异步调用时JS是如何执行的。比如setTimeout或fetch请求都是non-blocking的，当异步调用代码触发时，JS引擎会将需要异步执行的代码移出调用栈，直到等待到返回结果，JS引擎会立即将与之对应的回调函数push进任务队列中等待被调用，当调用(执行)栈中已经没有需要被执行的代码时，JS引擎会立刻将任务队列中的回调函数逐个push进调用栈并执行。这个过程我们也称之为事件循环。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>浏览器（多进程）包含了GPU进程（浏览器渲染进程），其中GPU进程（多线程）包含一下几个线程1.GUI渲染线程2.JS引擎线程3.事件触发线程（和EventLoop密切相关）4.定时触发器线程5.异步HTTP请求线程</li><li>javascript是一门单线程语言</li><li>Event Loop是javascript的执行机制</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.cn/post/6844903561164242952" target="_blank" rel="noopener">深入理解JavaScript执行（单线程的JS）</a></li><li><a href="https://juejin.cn/post/6844903667301089288" target="_blank" rel="noopener">图解JS执行机制</a></li><li><a href="https://juejin.cn/post/6844903512845860872" target="_blank" rel="noopener">这一次，彻底弄懂 JavaScript 执行机制</a></li><li><a href="https://juejin.cn/post/6844903843197616136" target="_blank" rel="noopener">你真的理解$nextTick么</a></li><li><a href="https://mp.weixin.qq.com/s/bkSmKYGHk0V5eZIfuSTNyQ" target="_blank" rel="noopener">浏览器是如何调度进程和线程的？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> 单线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> es6 </tag>
            
            <tag> 执行机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: promise-2</title>
      <link href="/2020/12/26/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-promise-2/"/>
      <url>/2020/12/26/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-promise-2/</url>
      
        <content type="html"><![CDATA[<p>先通过刷题熟悉下Promise的基本用法</p><h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="function"><span class="params">()</span> =&gt;</span> <span class="function">(<span class="params"><span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">            resolve(<span class="number">6</span>);</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">        resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">    p.then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arg);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;));</span><br><span class="line">first().then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  3 7 4 1 2 5</span></span><br></pre></td></tr></table></figure><h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'once'</span>)</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="built_in">Date</span>.now() - start)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="built_in">Date</span>.now() - start)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// once</span></span><br><span class="line"><span class="comment">// success 1001</span></span><br><span class="line"><span class="comment">// success 1001</span></span><br></pre></td></tr></table></figure><h3 id="03"><a href="#03" class="headerlink" title="03"></a>03</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then: '</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'catch: '</span>, err)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// then Error: error!!!</span></span><br><span class="line">  <span class="comment">// at &lt;anonymous&gt;</span></span><br></pre></td></tr></table></figure><p>.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获，需要改成其中一种：</p><ul><li>return Promise.reject(new Error(‘error!!!’))</li><li>throw new Error(‘error!!!’)</li></ul><p>因为返回任意一个<em>非 promise</em> 的值都会被包裹成 promise 对象，即 return new Error(‘error!!!’) 等价于 <strong>return Promise.resolve(new Error(‘error!!!’))</strong>。</p><h3 id="04"><a href="#04" class="headerlink" title="04"></a>04</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> <span class="title">success</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> <span class="title">fail1</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'fail1: '</span>, e)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> <span class="title">fail2</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'fail2: '</span>, e)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//  fail2:  Error: error</span></span><br><span class="line">  <span class="comment">//  at success (&lt;anonymous&gt;:3:11)</span></span><br></pre></td></tr></table></figure><h3 id="05"><a href="#05" class="headerlink" title="05"></a>05</h3><p>请实现一个mergePromise函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组data中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timeout = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;, ms);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax1 = <span class="function"><span class="params">()</span> =&gt;</span> timeout(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax2 = <span class="function"><span class="params">()</span> =&gt;</span> timeout(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax3 = <span class="function"><span class="params">()</span> =&gt;</span> timeout(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mergePromise = <span class="function"><span class="params">ajaxArray</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里实现你的代码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mergePromise([ajax1, ajax2, ajax3]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// data 为 [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> promise </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> es6 </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的2020年度总结</title>
      <link href="/2020/12/20/%E6%88%91%E7%9A%842020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2020/12/20/%E6%88%91%E7%9A%842020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[  <h4 style='color: green;font-style:italic'> 人生最曼妙的风景，是内心的淡定和从容</h4><pre><code>2020年一眨眼的功夫就没了，越来越觉得时间的重要性。人都是被逼出来的，我发现自己做事越来越专注，这是一种很好的趋势，希望自己能保持出。刚过去的2020年，是值得永远铭记的一年，两位至亲突然离世让我一时难以接受现实，总以为时间还很长很长。病魔说来就来，人在这方面太过于渺小，毫无还手之力，难以改变命运。每个人都有走到终点的那一天，我只希望自己在行将就木的时候，能坦然面对。2021年给自己提出的小目标就是身体健康永远是摆在第一位的，活一天就要健健康康一天。</code></pre><h2 id="工作和学习"><a href="#工作和学习" class="headerlink" title="工作和学习"></a>工作和学习</h2><p>  有一种感觉，到了2020年才感觉自己真正走进前端。以前总觉得很难理解的名词术语，现在慢慢开始理解了，刚开始第一遍不理解，过俩月，第二遍就理解加深一点，第三遍再去看的时候，是不是更加融会贯通一点，所以2021年给自己的目标是重学前端，从最基础的js/es6/css学起，到前端框架vue源码学习，前端工程化，如果有精力，nodejs这块，部署一个网站也是要学会和理解的。<br>  不能再像以前一样，埋头苦干业务，干五年和干一年都一个样，很没有意义。要着眼于未来，所以，哪怕是在忙，也要抽时间学习。学什么呢，什么不会就学什么，直到深刻领悟的地步。<br>  之前看过一篇文章，说程序员如何阅读源码，我觉得说得很有道理，原文是这么说的<br>    - 领悟思想：只需体会作者设计框架的初衷和目的<br>    - 把握设计：只需体会代码的接口和抽象类以及宏观的设计<br>    - 体会细节：是基于顶层的抽象接口设计，逐渐展开代码的画卷<br>  很有指导意义，希望能按照这几点，好好品读 vue/webpack/axios等生态相关库框架源码，并通过文字记录下来。内心其实是很想进大厂看看，不想老了后悔，但无奈不是科班出身，加上这两年的岁月蹉跎，结果就是(苦笑)！最近这几个月，好好苦读和学习吧。每天学习一点点，哪怕是一点点，坚持几个月也是不错的收获，真希望自己能厚积薄发一次</p><p>  今年开始学习前端基础知识，写了几篇入门的文章，但总感觉有些东西还是不能立马说出来</p><ul><li>Class 和 继承</li><li>手写代码系列(这部分现在让我说我感觉自己又忘了，不能深刻理解这很头疼啊)</li><li>Webpack初始化项目</li><li>Vscode插件学习</li><li>自己的脚手架搭建cpp-cli-test</li><li>设计模式之装饰器学习</li></ul><p>我发现自己还是比较喜欢前端<em>工程化</em>，所以有时间就好好研究一下吧.前几天看了一篇文章，说的是大龄海龟硕士求职前端故事，<a href="https://mp.weixin.qq.com/s/G0c3gGAvM8YQXCD4EiwLlg" target="_blank" rel="noopener">面试一位硕士海龟前端小姐姐有感</a>,其中的辛酸感觉就像发生在自己身上，况且我还没有人家这么高的学历，更应该提升技术深度。但什么技术深度呢？看源码吗？有点找不到答案，说不上什么感觉</p><h2 id="生活和书法"><a href="#生活和书法" class="headerlink" title="生活和书法"></a>生活和书法</h2><p>  生活不止有代码还有书法和健身，希望自己能够在坚持住自己的爱好，好好领悟生活的真谛</p><h2 id="理财和基金"><a href="#理财和基金" class="headerlink" title="理财和基金"></a>理财和基金</h2><p>  现在的职业不可能一直干下去，顶多也就还有五年的光阴，考虑后续的工作很有必要，除了现在的程序员，自己还能做什么？又是苦笑不得，确实目前还找不到答案。2021年，希望自己能学习一下理财方面的知识，虽然也没多少财阔以理的，技多不压身，学习到了总比没有强。</p><h2 id="后续安排"><a href="#后续安排" class="headerlink" title="后续安排"></a>后续安排</h2><p>  js基础永远不会过时，犹如内功，不管学什么招数都是手到擒来</p><ul><li><p>事件循环</p></li><li><p>promise/generator/async await(promise最难实现的是哪个点)</p></li><li><p>ts 泛型 装饰器</p></li><li><p>webpack plugin loader</p></li><li><p>nodejs </p></li><li><p>vue</p></li><li><p>算法</p></li><li><p>渲染器原理</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2></li><li><p><a href="http://www.ruanyifeng.com/blog/2015/04/generator.html" target="_blank" rel="noopener">Generator 函数的含义与用法</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 前端 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 总结 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端之装饰者模式以及装饰器</title>
      <link href="/2020/12/13/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2020/12/13/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-src="/images/Decorator2.jpeg" alt="Decorator"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>给对象动态增加职责的方式称为装饰者模式。该模式能够在不改变对象自身的基础上，在程序运行期间给对象动态增加指责</p><h3 id="装饰函数"><a href="#装饰函数" class="headerlink" title="装饰函数"></a>装饰函数</h3><p>想要为函数增加额外功能，最简单粗暴的方式直接改写函数，但这很不友好，违反封闭-开放原则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="number">1</span>)&#125;</span><br><span class="line"><span class="comment">// 改成</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  alert(<span class="number">1</span>);</span><br><span class="line">  alert(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br></pre></td></tr></table></figure><p>在不改变函数源代码的方式能给函数增加功能，这正是开放-封闭原则。通过保存原引用的方式改写函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="number">1</span>)&#125;</span><br><span class="line"><span class="keyword">var</span> _a = a</span><br><span class="line">a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  _a()</span><br><span class="line">  alert(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br></pre></td></tr></table></figure><h3 id="编写装饰器"><a href="#编写装饰器" class="headerlink" title="编写装饰器"></a>编写装饰器</h3><p>class decorator 类装饰器<br>method decorator 方法装饰器<br>property decorator 属性装饰器<br>parameter decorator 参数装饰器</p><p>装饰器是一种特殊类型的声明，它能够被附加到<em>类声明，方法， 访问符，属性或参数</em>上。 装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。</p><h4 id="装饰器工厂"><a href="#装饰器工厂" class="headerlink" title="装饰器工厂"></a>装饰器工厂</h4><p>如果我们要定制一个修饰器如何应用到一个声明上，我们得写一个装饰器工厂函数。 装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thinFace</span>(<span class="params">name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, <span class="string">'开启瘦脸'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"thinFace(): called"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increaseEye</span>(<span class="params">name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, <span class="string">'增大眼睛'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target: <span class="built_in">string</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"increaseEye(): called"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@thinFace</span>(<span class="string">'cpp'</span>)</span><br><span class="line"><span class="meta">@increaseEye</span>(<span class="string">'niaogege'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Girl &#123;&#125;</span><br><span class="line"><span class="comment">// 打印参数</span></span><br><span class="line"></span><br><span class="line">cpp 开启瘦脸</span><br><span class="line">niaogege 增大眼睛</span><br><span class="line">increaseEye(): called</span><br><span class="line">thinFace(): called</span><br></pre></td></tr></table></figure><p>在TypeScript里，当多个装饰器应用在一个声明上时会进行如下步骤的操作：</p><ul><li>由上至下依次对装饰器表达式求值。</li><li>求值的结果会被当作函数，由下至上依次调用(装饰器函数)。</li></ul><h4 id="类装饰器-class-decorator-类装饰器"><a href="#类装饰器-class-decorator-类装饰器" class="headerlink" title="类装饰器 class decorator 类装饰器"></a>类装饰器 class decorator 类装饰器</h4><p>类装饰器在类声明之前被声明（紧靠着类声明）。 类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。即在执行装饰器函数时，会把类构造函数传递给装饰器函数。<br>如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thinFace</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  onsole.log(<span class="string">'thinFace Before'</span>, <span class="keyword">constructor</span>); <span class="comment">// 把Girl类构造函数传递给装饰器函数</span></span><br><span class="line">  <span class="keyword">constructor</span>.prototype.thinFaceF = function (<span class="params">params: <span class="built_in">any</span></span>) &#123; <span class="comment">// 给构造函数原型上增加新的方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'become thinFace'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classDecorator</span>(<span class="params">value: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'类的装饰器 Before'</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'接受一个构造函数'</span>, value); <span class="comment">// 如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@thinFace</span></span><br><span class="line"><span class="meta">@classDecorator</span>(<span class="string">'cpp'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Girl &#123;</span><br><span class="line">  <span class="keyword">private</span> greeting: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">msg: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = msg</span><br><span class="line">  &#125;</span><br><span class="line">  greetName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello!, <span class="subst">$&#123;<span class="keyword">this</span>.greeting&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  thinFaceF() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Grid 类里的函数'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> Girl(<span class="string">'wmh'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Girl类的实例'</span>, g);</span><br><span class="line">g.thinFaceF();</span><br><span class="line"><span class="comment">// 类的装饰器 Before</span></span><br><span class="line"><span class="comment">// 接受一个构造函数 cpp</span></span><br><span class="line"><span class="comment">// thinFace Before class Girl</span></span><br><span class="line"><span class="comment">// become thinFace</span></span><br></pre></td></tr></table></figure><h3 id="ts项目的运用"><a href="#ts项目的运用" class="headerlink" title="ts项目的运用"></a>ts项目的运用</h3><ul><li><a href="https://www.tslang.cn/docs/handbook/decorators.html" target="_blank" rel="noopener">装饰器</a></li></ul><h3 id="Ts项目中的’vue-property-decorator’拆解"><a href="#Ts项目中的’vue-property-decorator’拆解" class="headerlink" title="Ts项目中的’vue-property-decorator’拆解"></a>Ts项目中的’vue-property-decorator’拆解</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h3 id="ts报错信息"><a href="#ts报错信息" class="headerlink" title="ts报错信息"></a>ts报错信息</h3><ul><li><p>Unable to resolve signature of class decorator when called as an expression.<br>This expression is not callable.<br>  Type ‘void’ has no call signatures.</p></li><li><p>signature 签名</p></li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.tslang.cn/docs/handbook/decorators.html" target="_blank" rel="noopener">ts中的装饰器</a></li><li><a href="https://zhuanlan.zhihu.com/p/271226380" target="_blank" rel="noopener">设计模式大冒险第二关：装饰者模式，煎饼果子的主场</a></li><li><a href="https://segmentfault.com/a/1190000022415199" target="_blank" rel="noopener">装饰者模式和TypeScript装饰器</a></li><li><a href="https://juejin.cn/post/6895350355219972109" target="_blank" rel="noopener">从Typescript装饰器浅谈装饰者模式</a></li><li><a href="https://www.softwhy.com/article-9203-1.html" target="_blank" rel="noopener">Object.seal &amp; Object.freeze</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Decorator </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> Decorator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node包里的package.json文件</title>
      <link href="/2020/12/13/node%E5%8C%85%E9%87%8C%E7%9A%84package-json%E6%96%87%E4%BB%B6/"/>
      <url>/2020/12/13/node%E5%8C%85%E9%87%8C%E7%9A%84package-json%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>敲了两年业务代码，从来不会去留意node包里的配置，一般业务用到哪个包就去直接<em>npm i XX -D</em>, 也不会去想这包里都有啥，这样浑浑噩噩过了好长时间。其实这样很不好，就是一个单纯的切图仔，我可不想一直这样，所以最近就开始捣鼓node包，开始看的时候 对 <em>package.json</em> 里的配置项不是很熟悉，现阶段就是看一点理解了就记录一点。<br>先看下目前node包里的<em>package.json</em>文件配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"webpack-learn"</span>, <span class="comment">// 包名 一般采用中划线或者下划线，不建议采用小驼峰的形式命名</span></span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>, <span class="comment">// 版本</span></span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"vue webpack"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"dist/main.js"</span>,</span><br><span class="line">  <span class="attr">"module"</span>: <span class="string">"dist/main.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"webpack-dev-server --progress --config build/webpack.config.dev.js --inline --hot"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --progress --config build/webpack.config.prod.js"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [</span><br><span class="line">    <span class="string">"webpack init project"</span>,</span><br><span class="line">    <span class="string">"webpack"</span>,</span><br><span class="line">    <span class="string">"init Project"</span>,</span><br><span class="line">    <span class="string">"vue"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"engines"</span>: &#123;</span><br><span class="line">    <span class="attr">"node"</span>: <span class="string">"&gt;= 6"</span> <span class="comment">// node环境要求</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"cpp"</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"homepage"</span>: <span class="string">"https://github.com/niaogege/webpack-learn"</span>, <span class="comment">// 项目介绍主页</span></span><br><span class="line">  <span class="attr">"repository"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"git"</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"https://github.com/niaogege/webpack-learn.git"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"files"</span>: [</span><br><span class="line">    <span class="string">"dist"</span>,</span><br><span class="line">    <span class="string">"src"</span>,</span><br><span class="line">    <span class="string">"public"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"vue"</span>: <span class="string">"^2.6.12"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"babel-core"</span>: <span class="string">"^6.26.3"</span>,</span><br><span class="line">    <span class="attr">"babel-loader"</span>: <span class="string">"^8.2.2"</span>,</span><br><span class="line">    <span class="attr">"clean-webpack-plugin"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main-module"><a href="#main-module" class="headerlink" title="main / module"></a>main / module</h3><p><em>Main property in package.json defines package entry point 定义包的出口</em><br>简单说: 供项目用import导入的入口，主要作用是暴露此依赖包的出口，比如vue源码里的package.json中这么定义的</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">"main": "dist/vue.runtime.common.js", // 运行时用的common版本</span><br><span class="line">"module": "dist/vue.runtime.esm.js", // 运行用的es版本</span><br></pre></td></tr></table></figure><p>如果不定义main，项目中运用依赖包需要这样引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin.js'</span>);</span><br></pre></td></tr></table></figure><p>看了下vue-loader中该文件的出口定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">let</span> VueLoaderPlugin = <span class="literal">null</span></span><br><span class="line"><span class="keyword">if</span> (webpack.version &amp;&amp; webpack.version[<span class="number">0</span>] &gt; <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="comment">// webpack5 and upper</span></span><br><span class="line">  VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'./plugin-webpack5'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// webpack4 and lower</span></span><br><span class="line">  VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'./plugin-webpack4'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = VueLoaderPlugin</span><br></pre></td></tr></table></figure><h3 id="devDependencies-dependencies"><a href="#devDependencies-dependencies" class="headerlink" title="devDependencies / dependencies"></a>devDependencies / dependencies</h3><p>运行 <em>–save-dev</em> 或者 -D 安装的 插件，被写入到 <em>devDependencies</em> 域里面去，而使用 <em>–save</em> 或者 -S 安装的插件，则是被写入到 <em>dependencies</em> 区块里面去.<br>npm install 【插件名】或 npm install 【插件名】–save 归属dependencies，表示代码运行时所需要的包。</p><p>npm install 【插件名】–save-dev 归属 devDependencies，表示开发时依赖的插件（即不会打包至线上）。</p><p>dependencies, 生产环境依赖，也就是依赖会被打包到web就用中<br>devDependencies, 开发环境依赖，不会被打包，是保证web就用能运行起来的根本。</p><p>区别: </p><p>假设我是一名npm包的开发者，那么我发布的包的package.json就需要认真分好所依赖的包到底是dependencies还是devDependencies。因为我发布的包是给别人使用的，别人不会去管你是用什么环境开发的，别人要的是最终开发出来的源码。所以，当别人npm命令去安装时：</p><p><code>npm install xxx -D</code></p><p>只会把xxx里的dependencies的包下载下来，而不会去下载devDependencies里面的包。所以在发布npm包的时候，dependencies和devDependencies一定要严格区分开来!!</p><h3 id="files"><a href="#files" class="headerlink" title="files"></a>files</h3><p>这个就好理解，下载的依赖包里包含的文件名数组，像我在cpp-cli-test这个npm包里的files就是<br><code>files: [    &quot;dist&quot;,    &quot;src&quot;,    &quot;public&quot;]</code><br>因为我不想把npm包里的node_modules文件也上传，所以这里就只包含了三个文件夹</p><h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p>本人开发的脚手架会用到bin字段, 包的命令，比如<em>cpp -V</em>,</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"main": "./bin/index.js",</span><br><span class="line">"bin": &#123;</span><br><span class="line">  "cpp": "./bin/index.js" // 全局注册cpp命令</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><ul><li>废弃版本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm deprecate &lt;pkg-name&gt;[@&lt;version&gt;] &lt;message&gt;</span><br><span class="line">示例</span><br><span class="line">npm deprecate cpp-cli-test@&quot; &lt;1.0.1&quot; &quot;sorry 这个包已经被废弃了&quot;</span><br></pre></td></tr></table></figure></li><li>包的维护者和添加维护者<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm owner ls cpp-cli-test</span><br><span class="line"></span><br><span class="line">npm owner add 用户名字 包名</span><br></pre></td></tr></table></figure></li><li>打开一个模块的主页<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm home 包名</span><br></pre></td></tr></table></figure></li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><p><a href="https://bytearcher.com/articles/main-property-in-package.json-defines-entry-point/" target="_blank" rel="noopener">Main property in package.json defines package entry point</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/59601665" target="_blank" rel="noopener">package.json中的dependencies和devDependencies区别</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/z9hyaOf85DFMweBmtm1YRA" target="_blank" rel="noopener">发布NPM包</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
          <category> package.json </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> es6 </tag>
            
            <tag> package.json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>辅助开发工具和调试</title>
      <link href="/2020/12/12/%E8%BE%85%E5%8A%A9%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%92%8C%E8%B0%83%E8%AF%95/"/>
      <url>/2020/12/12/%E8%BE%85%E5%8A%A9%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%92%8C%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="安装-sourceTree"><a href="#安装-sourceTree" class="headerlink" title="安装 sourceTree"></a>安装 sourceTree</h3><ul><li><p>打开企业版<a href="https://www.sourcetreeapp.com/enterprise" target="_blank" rel="noopener">链接</a>,先下载，然后找到<em>C:\Program Files (x86)\Atlassian\Sourcetree</em>目录安装</p></li><li><p>在查询文件里输入 <em>%LocalAppData%\Atlassian\SourceTree\accounts.json</em>，编辑成以下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"$id"</span>: <span class="string">"1"</span>,</span><br><span class="line">    <span class="attr">"$type"</span>: <span class="string">"SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity"</span>,</span><br><span class="line">    <span class="attr">"Authenticate"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"HostInstance"</span>: &#123;</span><br><span class="line">      <span class="attr">"$id"</span>: <span class="string">"2"</span>,</span><br><span class="line">      <span class="attr">"$type"</span>: <span class="string">"SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount"</span>,</span><br><span class="line">      <span class="attr">"Host"</span>: &#123;</span><br><span class="line">        <span class="attr">"$id"</span>: <span class="string">"3"</span>,</span><br><span class="line">        <span class="attr">"$type"</span>: <span class="string">"SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount"</span>,</span><br><span class="line">        <span class="attr">"Id"</span>: <span class="string">"atlassian account"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"BaseUrl"</span>: <span class="string">"https://id.atlassian.com/"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"Credentials"</span>: &#123;</span><br><span class="line">      <span class="attr">"$id"</span>: <span class="string">"4"</span>,</span><br><span class="line">      <span class="attr">"$type"</span>: <span class="string">"SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account"</span>,</span><br><span class="line">      <span class="attr">"Username"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"Email"</span>: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"IsDefault"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>工具 -&gt; 选项 -&gt; 选择 <em>Dark</em> 主题</p></li></ul><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>如若遇到ssh-key已经生效 但每次git push的时候还需要登录github弹框，这时候受到删除 <strong>C:\Users%USERNAME%\AppData\Local\Atlassian\SourceTree 目录下的passwd文件</strong>,然后再通过命令行推送，第一次的时候还是需要手动push</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/qq_36735629/article/details/86422488" target="_blank" rel="noopener">企业版sourcetree</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> sourceTree </category>
          
          <category> git </category>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
            <tag> sourceTree </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶-vue-2</title>
      <link href="/2020/12/12/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-vue-2/"/>
      <url>/2020/12/12/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-vue-2/</url>
      
        <content type="html"><![CDATA[<ul><li>封装自己的vue组件</li><li></li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.cn/post/6844903636938522638" target="_blank" rel="noopener">vue中extend，mixins，extends，components,install的几个操作</a></li><li><a href="https://juejin.cn/post/6844904181443067912" target="_blank" rel="noopener">学习vue源码（5） 手写Vue.use、Vue.minxin、Vue.compile</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> vue </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶-大杂烩-1</title>
      <link href="/2020/12/05/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E5%A4%A7%E6%9D%82%E7%83%A9-1/"/>
      <url>/2020/12/05/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E5%A4%A7%E6%9D%82%E7%83%A9-1/</url>
      
        <content type="html"><![CDATA[<p>本周涉及内容</p><ul><li>vue 插槽</li><li>函数柯里化</li><li>装饰者模式 &amp;&amp; 装饰器</li><li>函数式编程 &amp;&amp; 命令式编程</li><li>proxy</li><li>css加速</li><li>cdn缓存</li></ul><h3 id="vue插槽slot"><a href="#vue插槽slot" class="headerlink" title="vue插槽slot"></a>vue插槽slot</h3><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><ul><li>函数参数固定<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry2 = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">judge</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length === fn.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn(...args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> judge(...args, ...arg)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> add2 = <span class="function">(<span class="params">a,b,c</span>) =&gt;</span> a + b + c;</span><br><span class="line"><span class="keyword">const</span> curryAdd2 = curry2(add2)</span><br><span class="line"><span class="built_in">console</span>.log(curryAdd2(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(curryAdd2(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(curryAdd2(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)) <span class="comment">// curryAdd2(...)(...) is not a function</span></span><br></pre></td></tr></table></figure></li><li>参数不固定<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> addFn = <span class="function">(<span class="params">...arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr, <span class="string">'arr'</span>, <span class="built_in">Object</span>.prototype.toString.call(arr));</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a +b )</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = []</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">temp</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length) &#123;</span><br><span class="line">      arr = [...arr, ...args]</span><br><span class="line">      <span class="keyword">return</span> temp</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`arr`</span>, arr);</span><br><span class="line">      <span class="keyword">const</span> val = fn.apply(<span class="keyword">this</span>, arr)</span><br><span class="line">      arr = []</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> curryAdd = curry(addFn)</span><br><span class="line"><span class="keyword">const</span> test1 = curryAdd(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)()</span><br><span class="line"><span class="keyword">const</span> test2 = curryAdd(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)()</span><br><span class="line"><span class="keyword">const</span> test3 = curryAdd(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)(<span class="number">5</span>, <span class="number">6</span>)()</span><br><span class="line"><span class="built_in">console</span>.log(test1) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(test2) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(test3); <span class="comment">// 21</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="装饰者模式-amp-amp-装饰器-Decorator"><a href="#装饰者模式-amp-amp-装饰器-Decorator" class="headerlink" title="装饰者模式 &amp;&amp; 装饰器(Decorator)"></a>装饰者模式 &amp;&amp; 装饰器(Decorator)</h3>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> vue </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> vue </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 在学es6之class</title>
      <link href="/2020/11/15/%E5%9F%BA%E7%A1%80-%E5%9C%A8%E5%AD%A6es6%E4%B9%8Bclass/"/>
      <url>/2020/11/15/%E5%9F%BA%E7%A1%80-%E5%9C%A8%E5%AD%A6es6%E4%B9%8Bclass/</url>
      
        <content type="html"><![CDATA[<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>class是一个语法糖，其底层还是通过 构造函数 去创建的。新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><h4 id="es5实现"><a href="#es5实现" class="headerlink" title="es5实现"></a>es5实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h4 id="es6实现"><a href="#es6实现" class="headerlink" title="es6实现"></a>es6实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125; </span><br><span class="line">  toString () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>上面代码定义了一个“类”，可以看到里面有一个<strong>constructor</strong>方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5 的构造函数Point，对应 ES6 的Point类的构造方法。</p><h4 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h4><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> A()) <span class="keyword">instanceof</span> A);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h4><ul><li>生成类的实例的写法，与 ES5 完全一样，也是使用 new 命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。</li><li>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在<em>this</em>对象上），否则都是定义在原型上(即定义在<em>class</em>类上)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CppPerson</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(&#123;name, age, fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.showFn = fn</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="keyword">this</span>.name</span><br><span class="line">    <span class="keyword">return</span> name.charAt(<span class="number">0</span>).toUpperCase() + name.slice(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> CppPerson(&#123;</span><br><span class="line">  name: <span class="string">'cpp'</span>,</span><br><span class="line">  age: <span class="string">'30'</span>,</span><br><span class="line">  fn: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is fn'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">person.getName() </span><br><span class="line">person.showFn()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'person'</span>, person);</span><br><span class="line">person.hasOwnProperty(<span class="string">'name'</span>) <span class="comment">// true</span></span><br><span class="line">person.hasOwnProperty(<span class="string">'age'</span>) <span class="comment">// true</span></span><br><span class="line">person.hasOwnProperty(<span class="string">'getName'</span>) <span class="comment">// false</span></span><br><span class="line">person.__proto__.hasOwnProperty(<span class="string">'getName'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>与 ES5 一样，类的所有实例共享一个原型对象。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo.classMethod() <span class="comment">// 'hello'</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()<span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure><h3 id="实例属性的新写法"><a href="#实例属性的新写法" class="headerlink" title="实例属性的新写法"></a>实例属性的新写法</h3><p>实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncreasingCounter</span> </span>&#123;</span><br><span class="line">  _count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> value() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Getting the current value!'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    <span class="keyword">this</span>._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>突然联想到目前的业务项目，做了2年才发现也是这样的写法，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> item: <span class="built_in">number</span> = <span class="number">0</span> <span class="comment">// 快捷导航选中index</span></span><br><span class="line"><span class="keyword">private</span> url: <span class="built_in">any</span> = &#123;&#125;; <span class="comment">// 默认url赋值</span></span><br></pre></td></tr></table></figure><p>上面代码中，实例属性item与原型上的方法，处于同一个层级。这时，不需要在实例属性前面加上this。<br>这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。<br>原本应该是这样写的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">class</span> VueGrid <span class="keyword">extends</span> Vue &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.item = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.url = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line">Foo.prop <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面的写法为Foo类定义了一个静态属性prop。</p><p>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个提案提供了类的静态属性，写法是在实例属性的前面，加上static关键字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> myStaticProp = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(MyClass.myStaticProp); <span class="comment">// 42</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个新写法大大方便了静态属性的表达。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> prop = <span class="number">1</span>; <span class="comment">// 新写法是显式声明（declarative），而不是赋值处理，语义更好。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="extends继承"><a href="#extends继承" class="headerlink" title="extends继承"></a>extends继承</h3><p>Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。<br>这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。</p><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>在 super() 执行时，它指向的是 子类 B 的构造函数，而不是父类 A 的构造函数。也就是说，super() 内部的 this 指向的是 B<br><em>super()<em>相当于</em>Parent.prototype.constructor.call(this. props)</em><br>super本身是指向父类的构造函数但做函数调用后返回的是子类的实例，实际上做了<em>parent.prototype.constructor.call(this)</em>，做对象调用时指向父类 parent.prototype,从而实现继承</p><p>super这个关键字，既可以当作函数 Function 使用，也可以当作对象 Object 使用。在这两种情况下，它的用法完全不同。</p><h4 id="作函数-Function-使用"><a href="#作函数-Function-使用" class="headerlink" title="作函数 Function 使用"></a>作函数 Function 使用</h4><p>代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> A() <span class="comment">// A</span></span><br><span class="line"><span class="keyword">new</span> B() <span class="comment">// B</span></span><br></pre></td></tr></table></figure><p>虽然代表父类的构造函数，但是返回的是子类的实例，即super内部的this指的是B的实例，因此super()在这里相当于A.prototype.constructor.call(this)。</p><blockquote><p>有点绕！！！</p></blockquote><h4 id="当作对象-Object-使用"><a href="#当作对象-Object-使用" class="headerlink" title="当作对象 Object 使用"></a>当作对象 Object 使用</h4><p>super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  p() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.p()); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure><p>子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。注意是A类原型对象上的方法。<br>这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    name() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'cpp'</span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果属性定义在父类的原型对象上，super就可以取到。</span></span><br><span class="line">Test.prototype.age = <span class="number">29</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">super</span>.name())</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">super</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Test1()) <span class="comment">// 'cpp' 29</span></span><br></pre></td></tr></table></figure><p>实例属性和方法: constructor里的，就是绑定的this，比如this.name<br>原型属性和方法: class里除了构造函数以内，其他的方法就是原型方法，原型属性需要用到Test.prototype来定义<br>静态属性和方法: static关键字标识，只能类本身调用，类的实例不能调用<br>私有属性和方法: ts里的private关键字</p><h4 id="ES6-规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例"><a href="#ES6-规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例" class="headerlink" title="ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例"></a>ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  m() &#123;</span><br><span class="line">    <span class="keyword">super</span>.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.m() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。"><a href="#如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。" class="headerlink" title="如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。"></a>如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> myMethod(msg) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'static'</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'instance'</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> myMethod(msg) &#123;</span><br><span class="line">    <span class="keyword">super</span>.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    <span class="keyword">super</span>.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.myMethod(<span class="number">1</span>); <span class="comment">// static 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child();</span><br><span class="line">child.myMethod(<span class="number">2</span>); <span class="comment">// instance 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p><h3 id="ES5-和-ES6继承区别"><a href="#ES5-和-ES6继承区别" class="headerlink" title="ES5 和 ES6继承区别"></a><a href="https://es6.ruanyifeng.com/#docs/class-extends" target="_blank" rel="noopener">ES5 和 ES6继承区别</a></h3><p>ES5 的继承，通过prototype或构造函数机制来实现, 实质是先创造子类的实例对象this，再将父类的方法添加到this上面（Parent.apply(this)）。<br>ES6 的继承机制完全不同，实质是先创建父类的实例对象this(所以必须先调用父类的super()方法)，然后再用子类的构造函数修改this。</p><p>另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y, color) &#123;</span><br><span class="line">    <span class="keyword">this</span>.color = color; <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="keyword">super</span>(x, y);</span><br><span class="line">    <span class="keyword">this</span>.color = color; <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">Class 的基本语法</a></li><li><a href="https://juejin.im/post/6844904086089760775" target="_blank" rel="noopener">详解ES6中的class</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> class </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础-基于webpack搭建vue项目</title>
      <link href="/2020/11/14/%E5%9F%BA%E7%A1%80-webpack%E6%90%AD%E5%BB%BAvue%E9%A1%B9%E7%9B%AE/"/>
      <url>/2020/11/14/%E5%9F%BA%E7%A1%80-webpack%E6%90%AD%E5%BB%BAvue%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>学习如何用webpack搭建项目，成为模板，为后面的脚手架做准备，需要学习的有</p><ul><li>webpack</li><li>node</li><li>学会手写自己的loader</li><li>手写plugin</li><li>webpack的异步加载如何实现</li><li>webpack的分包策略</li></ul><h3 id="什么是webpack？"><a href="#什么是webpack？" class="headerlink" title="什么是webpack？"></a>什么是webpack？</h3><p>官网是这么描述的: </p><blockquote><p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p></blockquote><p>先理解四个核心概念：</p><ul><li>入口(entry)</li><li>输出(output)</li><li>加载器(loader)</li><li>插件(plugins)</li></ul><h3 id="webpack搭建vue项目"><a href="#webpack搭建vue项目" class="headerlink" title="webpack搭建vue项目"></a>webpack搭建vue项目</h3><p>即<a href="https://github.com/niaogege/webpack-learn" target="_blank" rel="noopener">webpack搭建vue</a></p><h4 id="本地项目涉及的webpack版本"><a href="#本地项目涉及的webpack版本" class="headerlink" title="本地项目涉及的webpack版本"></a>本地项目涉及的webpack版本</h4><p>webpack版本众多，有时会被这些琐粹的玩意搞得头晕</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"webpack"</span>: <span class="string">"^4.41.2"</span>,</span><br><span class="line">  <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.9"</span>,</span><br><span class="line">  <span class="attr">"webpack-dev-server"</span>: <span class="string">"^3.9.0"</span>,</span><br><span class="line">  <span class="attr">"webpack-merge"</span>: <span class="string">"^5.4.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="本项目文件结构"><a href="#本项目文件结构" class="headerlink" title="本项目文件结构"></a>本项目文件结构</h4><h4 id="引入babel"><a href="#引入babel" class="headerlink" title="引入babel"></a>引入babel</h4><p><em>npm i -D babel-core babel-loader</em><br>复制代码由于在使用vue时会用到很多es6的语法，但是现在很多浏览器对es6的支持不是很好，所以在编译时需要将这些语法转换es5的语法，此时我们使用babel来进行编译。<br>babel的使用请阅读官网文档<a href="http://babeljs.cn/" target="_blank" rel="noopener">http://babeljs.cn/</a></p><h4 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h4><p>这个插件可以自动为我们生成HTML并插入对应的js和css文件。这样子是很方便的，尤其是当文件名中包含了hash值，而这个hash值在webpack每次编译的时候都会发生改变的。下面我们就逐一来介绍HtmlWebpackPlugin的用法。<br>配置参数:</p><ul><li><p>filename<br>filename表示生成html文件的名字，如果没有设置的话默认为index.html。</p></li><li><p>template<br>　当webpack自动生成html文件的时候，会基于某个模板来进行。当然你也可以自定义自己的模板，如果没有定义webpack会使用默认的模板。但是需要指出的是，当你使用了其他模板类型（比如jade），那么你需要安装对应的loader。默认情况下webpack使用ejs模板。</p></li><li><p>inject<br>inject主要是设置将js和css文件插入在html的哪个位置，由于js的加载时同步进行的，所以它的位置对网页的加载速度是有影响的。inject共有四个可选项：true、body、head和false。</p></li><li><p>true：默认值，将js文件插入body的底部。注意这里是bool类型的true，并不是字符串。设置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">　　inject: <span class="literal">true</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure></li><li><p>body：和true的功能是一样的。需要设置为字符串body。设置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  inject: <span class="string">'body'</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure></li><li><p>head：表示将js文件插入在head标签内，这里是字符串head。</p></li><li><p>false：表示不插入生成的js文件，也不插入css文件。因为其他三个可选项css文件都是插入在head标签内的。</p></li><li><p><a href="https://www.npmjs.com/package/html-webpack-plugin" target="_blank" rel="noopener">htmlWebpackPlugin</a></p></li></ul><h4 id="区分生产环境和本地开发环境"><a href="#区分生产环境和本地开发环境" class="headerlink" title="区分生产环境和本地开发环境"></a>区分生产环境和本地开发环境</h4><p>采用<em><a href="https://www.npmjs.com/package/webpack-merge" target="_blank" rel="noopener">webpck-merge</a></em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;merge&#125; = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: <span class="number">3000</span>,</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    contentBase: path.join(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">    overlay: &#123;</span><br><span class="line">      errors: <span class="literal">true</span>,</span><br><span class="line">      warnings: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>此处栽了一个大坑，打印common就是一个包含dev环境的配置对象，因为之前写法有误 导致vue-loader一直报错</p></blockquote><h4 id="本地项目运行"><a href="#本地项目运行" class="headerlink" title="本地项目运行"></a>本地项目运行</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  hot: <span class="literal">true</span>,</span><br><span class="line">  contentBase: path.join(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">  overlay: &#123;</span><br><span class="line">    errors: <span class="literal">true</span>,</span><br><span class="line">    warnings: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>output的 <em>publicPath</em> 是用来给生成的静态资源路径添加前缀的；</li><li>devServer中的 <em>publicPath</em> 是用来本地服务拦截带publicPath开头的请求的；</li><li><em>contentBase</em> 是用来指定被访问html页面所在目录的；</li></ul><h3 id="针对已有项目git初始化"><a href="#针对已有项目git初始化" class="headerlink" title="针对已有项目git初始化"></a>针对已有项目git初始化</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m "first commit"</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/niaogege/XXX.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://ddrv.cn/a/314373" target="_blank" rel="noopener">配置vue+webpack踩过的坑</a></li><li><a href="https://www.webpackjs.com/concepts/" target="_blank" rel="noopener">weboack官网</a></li><li><a href="https://juejin.cn/post/6844903541962702855" target="_blank" rel="noopener">webpack 搭建 vue 项目</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode插件开发和学习</title>
      <link href="/2020/11/08/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%92%8C%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/11/08/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%92%8C%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>vsCode插件实现</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://mp.weixin.qq.com/s/rXL1qU4h7Ugy6o9YjM6PaQ" target="_blank" rel="noopener">手摸手带你从零实现VS Code基金插件</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vscode </category>
          
          <category> node </category>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> tool </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔: 秋天来了</title>
      <link href="/2020/10/18/%E9%9A%8F%E7%AC%94-%E7%A7%8B%E5%A4%A9%E6%9D%A5%E4%BA%86/"/>
      <url>/2020/10/18/%E9%9A%8F%E7%AC%94-%E7%A7%8B%E5%A4%A9%E6%9D%A5%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h3 id="湖人夺冠"><a href="#湖人夺冠" class="headerlink" title="湖人夺冠"></a>湖人夺冠</h3><p><img src= "/img/loading.gif" data-src="/images/lakes/101202.jpg" alt="lakes champions"></p><!-- ![lakes champions](/images/lakes/101205.jpg) --><p>看到上次更博是0718，一晃，三个月，从盛夏到深秋，难得周末清闲，好久没有静下心来写点东西了(虽然也不知道自己在写啥， hhhh)。<br>最近因为练字发了几条抖音有点着迷这玩意，果断卸载，还是得聚焦现实主要任务，有些东西，随着时间的流逝就很难追回来。最主要的任务是啥呢，说实话，我自己也有点蒙，最近都在忙啥呢，我自己也不知道忙啥。</p><ul><li>看看自己手机里收藏的微信好文，是否自己都仔细阅读过了？是否读完都明白了？明白了是否自己都能在现在的项目中熟练运用？</li><li>今年再不做打算的话，程序员这一站就到头了，还得想想自己的后路。30岁的中年烦恼，提前准备，提前应对，35岁之后，我能做啥？</li><li>自己得学习起来，1.搭建脚手架 2.vscode插件 3.webpack(从0开始配置项目) 4.<a href="https://juejin.im/post/6856410900577026061" target="_blank" rel="noopener">ts使用</a> 5.算法,上面这几块得干起来，少看手机，多思考思考</li><li>基础知识还得继续夯实，主要是继承/Promise</li><li>拉勾教育上也得看起来</li><li>现在所处的项目改造，减少代码的重复</li></ul><p><img src= "/img/loading.gif" data-src="/images/lakes/101204.jpg" alt="lakes champions"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 健康 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue: 常用技巧2</title>
      <link href="/2020/07/18/vue-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A72/"/>
      <url>/2020/07/18/vue-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A72/</url>
      
        <content type="html"><![CDATA[<p><strong>hook</strong>用法<br>源码涉及hook的较多，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function callHook (vm, hook) &#123;</span><br><span class="line">  &#x2F;&#x2F; #7573 disable dep collection when invoking lifecycle hooks</span><br><span class="line">  pushTarget();</span><br><span class="line">  var handlers &#x3D; vm.$options[hook];</span><br><span class="line">  var info &#x3D; hook + &quot; hook&quot;;</span><br><span class="line">  if (handlers) &#123;</span><br><span class="line">    for (var i &#x3D; 0, j &#x3D; handlers.length; i &lt; j; i++) &#123;</span><br><span class="line">      invokeWithErrorHandling(handlers[i], vm, null, vm, info);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (vm._hasHookEvent) &#123;</span><br><span class="line">    vm.$emit(&#39;hook:&#39; + hook);</span><br><span class="line">  &#125;</span><br><span class="line">  popTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="监听组件的生命周期"><a href="#监听组件的生命周期" class="headerlink" title="监听组件的生命周期"></a>监听组件的生命周期</h3><p>Before</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; child.vue</span><br><span class="line">privte mounted() &#123;</span><br><span class="line">  this.$emit(&#39;parentClick&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; parent.vue</span><br><span class="line">&lt;Child @mounted&#x3D;&#39;parentClick&#39;&gt;</span><br></pre></td></tr></table></figure><p>After</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;child.vue</span><br><span class="line">子组件不需要任何处理</span><br><span class="line">&#x2F;&#x2F;parent.vue</span><br><span class="line">&lt;Child @hook:mounted&#x3D;&#39;parentClick&#39;&gt;</span><br><span class="line">or</span><br><span class="line">&lt;Child @hook:created&#x3D;&#39;parentClick&#39;&gt;</span><br></pre></td></tr></table></figure><h3 id="事件侦听器"><a href="#事件侦听器" class="headerlink" title="事件侦听器"></a>事件侦听器</h3><p>问: 页面中定义一个定时器，在哪个阶段清除<br>答: 在beforeDestory中销毁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Before</span><br><span class="line">mounted() &#123;</span><br><span class="line">  this.timer &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">  &#125;, 3000)</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestory() &#123;</span><br><span class="line">  clearInterval(this.timer)</span><br><span class="line">&#125;</span><br><span class="line">After</span><br><span class="line">mounted() &#123;</span><br><span class="line">  const timer &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">  &#125;, 3000)</span><br><span class="line">  this.$once(&#39;hook:beforeDestory&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    clearInterval(timer)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件销毁"><a href="#事件销毁" class="headerlink" title="事件销毁"></a>事件销毁</h3><p>通过$mounted绑定的第三方实例组件销毁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">  var picker &#x3D; new Picker(&#123;</span><br><span class="line">    field: this.$refs.input,</span><br><span class="line">    format: &#39;YYYY-MM-DD&#39;</span><br><span class="line">  &#125;)</span><br><span class="line">  this.$once(&#39;hook: beforeDestory&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    picker.destory()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue: 常用技巧1</title>
      <link href="/2020/07/18/vue-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A71/"/>
      <url>/2020/07/18/vue-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A71/</url>
      
        <content type="html"><![CDATA[<p>如果存在组件之间层级大于2层，中间需要一个过渡层的时候，属性和事件的上传下达越简洁越好，重点就是采用vue里的<strong>$atts</strong> 和事件 <strong>$listeners</strong>,先打印看看这两者是什么玩意，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$attrs: object,</span><br><span class="line">$listeners: object</span><br></pre></td></tr></table></figure><p>两者都是绑定在组件里的，且是对象类型，所以在组件阔以之间用<code>this.$attrs.info</code>去获取祖父组件传来的info信息。</p><a id="more"></a><p>以下有三个组件，三者之间都是相关有联系的，阔以称之为 祖父组件、父组件以及子组件。<br>伪代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; grandParent.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;home&quot;&gt;</span><br><span class="line">    &lt;Parent </span><br><span class="line">     :childMsg&#x3D;&#39;childMsg&#39;</span><br><span class="line">     @triggerClickChild&#x3D;&#39;triggerClickChild&#39;</span><br><span class="line">     info&#x3D;&#39;父组件&#39;</span><br><span class="line">    &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import &#123; Component, Vue &#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line">import Parent from &#39;..&#x2F;components&#x2F;parent.vue&#39;; &#x2F;&#x2F; @ is an alias to &#x2F;src</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Parent,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; parent.vue</span><br><span class="line">&lt;Child</span><br><span class="line">      label&#x3D;&#39;子组件信息&#39;</span><br><span class="line">      class&#x3D;&#39;child&#39;</span><br><span class="line">      v-bind&#x3D;&#39;$attrs&#39;</span><br><span class="line">      v-on&#x3D;&#39;$listeners&#39;</span><br><span class="line">      @triggerClickChild&#x3D;&#39;parentC&#39;</span><br><span class="line">    &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">import Child from &#39;.&#x2F;child.vue&#39;</span><br><span class="line">@Component(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">export default class Parent extends Vue &#123;</span><br><span class="line">  @Prop() private childMsg!: any; &#x2F;&#x2F; 此时childMsg信息已用所以不会传递到子组件</span><br><span class="line">  private parentC(key: string) &#123;</span><br><span class="line">    console.log(key, &#39;中间层截胡&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  private mounted() &#123;</span><br><span class="line">    console.log(this.childMsg, &#39;props&#39;)</span><br><span class="line">    console.log(this, &#39;中间组件&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; child本身的组件</span><br><span class="line">  &lt;div class&#x3D;&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h1 @click&#x3D;&#39;triggerClickChild&#39;&gt;&#123;&#123;$attrs&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  inheritAttrs: false</span><br><span class="line">&#125;)</span><br><span class="line">export default class HelloWorld extends Vue &#123;</span><br><span class="line">  private triggerClickChild() &#123;</span><br><span class="line">    this.$emit(&#39;triggerClickChild&#39;, &#39;triggerClickChild子孙组件&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">  private mounted() &#123;</span><br><span class="line">    console.log(this, &#39;attrs&#39;) &#x2F;&#x2F; &#123;info: &#39;&#39;,label: &#39;&#39;,  &#125;</span><br><span class="line">    console.log(this.$listeners) &#x2F;&#x2F; fn triggerClickChild</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>梳理以上几个组件发现这几点：<br>1.v-bind=’$atts’ 和 v-on=’$listeners’只能用于中间组件的传递，也就是起到承上启下的作用<br>2.中间组件接受的props，一旦被采用，也就无法传递到下一层。but事件，中间层阔以截胡，因为事件是由下往上，父组件和祖父组件都能接收到<br>3.有个弊端，如果中间层需要对数据进行二次加工，$attrs也就无用武之地，所以最好就是在顶层组件进行处理，如果处理不了就只能Props一层层传<br>4.当然最大的优势还是免除一层层传递，事件和属性这样简写一下高效了许多。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: 搭建脚手架</title>
      <link href="/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E6%90%AD%E5%BB%BA%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
      <url>/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E6%90%AD%E5%BB%BA%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>全局安装，<em>cpp-cli-test</em>脚手架，shell执行<em>npm i -g cpp-cli-test</em>即可，<em>cpp</em>即被注册到全局bin里,<br>本脚手架已发布到npm上，npm包地址 <a href="https://www.npmjs.com/package/cpp-cli-test" target="_blank" rel="noopener">cpp-cli-test</a></p><h3 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h3><p><code>cpp rm &lt;dir&gt;</code> 删除文件夹命令</p><h3 id="升级模板"><a href="#升级模板" class="headerlink" title="升级模板"></a>升级模板</h3><p><em>cpp upgrade</em></p><h3 id="设置自己镜像"><a href="#设置自己镜像" class="headerlink" title="设置自己镜像"></a>设置自己镜像</h3><p><em>cpp mirror <template_mirror></em></p><p>这里的镜像地址，也就是模板的下载地址，比如: <code>https://github.com/mengdu/vue-element-admin-tpl/archive/master.zip</code>以zip为结尾的文件，执行命令行 <code>cpp mirror https://github.com/mengdu/vue-element-admin-tpl/archive/master.zip</code>就是把该模板下载下来.</p><p>需要先将自己的镜像写入本地的<em>config.json</em>文件中，代码逻辑就是根据输入的镜像写入到<em>config.json</em>。写入的时候判断有没有<em>config.json</em>，如果没有则初始化生成<em>config.json</em>，有的话，则先读取，然后设置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取 config.json 文件</span></span><br><span class="line"><span class="keyword">const</span> jsonConfig = <span class="keyword">await</span> fse.readJson(cfgPath);</span><br><span class="line">jsonConfig.mirror = link</span><br><span class="line"><span class="comment">// 再写入 config.json 文件</span></span><br><span class="line"><span class="keyword">await</span> fse.writeJson(cfgPath, jsonConfig)</span><br></pre></td></tr></table></figure><h3 id="下载模板"><a href="#下载模板" class="headerlink" title="下载模板"></a>下载模板</h3><p><em>cpp template</em></p><p>下载模板的时候，先判断当前根目录下是否存在<em>config.json</em>文件，如果不存在则去生成，存在的话，先删除模板文件夹，然后读取<em>config.json</em>文件中的<code>jsonConfig.mirror</code>,然后再根据设置好的路径去远程下载，放到<em>templateTemp</em>里，下载完还需要解压<br>核心代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> download(</span><br><span class="line">  jsonConfig.mirror, <span class="comment">// 远程连接,就是前一步设置的镜像地址</span></span><br><span class="line">  path.resolve(__dirname, <span class="string">'../templateTemp/'</span>), <span class="comment">// 模板存放位置</span></span><br><span class="line">  &#123;</span><br><span class="line">    extract: <span class="literal">true</span>, <span class="comment">// 解压模板</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>先下载到<em>templateTemp</em>到文件夹，然后开始一系列文件剪切操作，找到<em>templateTemp</em>里的文件夹，即从远程下载的文件夹，然后剪切到<em>template</em>里去。</p><h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><p><em>cpp init <project_name></em><br>最重要的部分, 通过<a href="https://www.npmjs.com/package/inquirer" target="_blank" rel="noopener">inquirer</a>来与控制台交互,获取用户所输的文件夹名和设置包名来初始化，主要还是文件夹的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> multiFiles = <span class="string">`<span class="subst">$&#123;targetPath&#125;</span>/package.json`</span></span><br><span class="line"><span class="comment">// 用条件循环把模板字符替换到文件去</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 等待读取文件</span></span><br><span class="line">  <span class="keyword">const</span> multiFilesContent = fse.readFileSync(multiFiles, <span class="string">'utf8'</span>).toString()</span><br><span class="line">  <span class="comment">// 等待替换文件，handlebars.compile(原文件内容)(模板字符)</span></span><br><span class="line">  <span class="keyword">const</span> multiFilesResult = handlebars.compile(multiFilesContent)(multiMeta)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'multiFilesResult'</span>, multiFilesResult);</span><br><span class="line">  <span class="comment">// 等待输出文件</span></span><br><span class="line">  <span class="keyword">await</span> fse.outputFile(multiFiles, multiFilesResult)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="comment">// 如果出错，Spinner 就改变文字信息</span></span><br><span class="line">  initSpinner.text = chalk.red(<span class="string">`Initialize project failed. <span class="subst">$&#123;err&#125;</span>`</span>)</span><br><span class="line">  <span class="comment">// 终止等待动画并显示 X 标志</span></span><br><span class="line">  initSpinner.fail()</span><br><span class="line">  <span class="comment">// 退出进程</span></span><br><span class="line">  process.exit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中有一个坑的地方就是<em>handlebars</em>库，用于替换模板字符的，这个比较坑的就是源文件夹里的属性，必须写成这种样式才能替换模板<br>比如</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"&#123;&#123;name&#125;&#125;"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"8.8.8"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"&#123;&#123;description&#125;&#125;"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"./index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"&#123;&#123;author&#125;&#125;"</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前我以为会直接替代<em>package.json</em>里的包名和描述等等。<br>最高级的应该是用户按照所输入的名称、包名以及依赖名等汇总到<em>package.json</em>里</p><h3 id="本地调试模块，不是项目哦"><a href="#本地调试模块，不是项目哦" class="headerlink" title="本地调试模块，不是项目哦"></a>本地调试模块，不是项目哦</h3><p>添加了bin命令之后，需要执行<em>npm link</em>将 npm 模块链接到对应的运行项目中去，方便地对模块进行调试和测试</p><h3 id="接下来需要做的事"><a href="#接下来需要做的事" class="headerlink" title="接下来需要做的事"></a>接下来需要做的事</h3><ul><li>动态修改模板里的<em>package.json</em>里的name和作者<br>已经解决，</li><li>运用webpack搭建自己的需要的模板</li><li>完善<em>cpp-cli-test</em>脚手架里的命令行和帮助文档</li><li>涉及到的几个包，学习下基本的api<br>已经解决，还需要继续学习</li></ul><h3 id="npm其他操作"><a href="#npm其他操作" class="headerlink" title="npm其他操作"></a>npm其他操作</h3><p>全局删除当前的模块</p><ul><li><p>使用命令<br><code>npm uninstall -g 包名</code></p></li><li><p>直接找到对应包删除<br><code>C:\Users\自己用户的文件夹\AppData\Roaming\npm</code><br>将对应的包删除即可</p></li></ul><h3 id="node里的一些常用的api"><a href="#node里的一些常用的api" class="headerlink" title="node里的一些常用的api"></a>node里的一些常用的api</h3><h4 id="路径拼接"><a href="#路径拼接" class="headerlink" title="路径拼接"></a>路径拼接</h4><ul><li><em>__dirname</em> // 返回当前文件所在的文件夹绝对路径，比如<em>D:\code\cpp-cli\lib</em></li><li><em>path.resolve</em> // 拼接当前文件路径</li><li><em>__filename</em>: 指当前执行文件的带有完整绝对路径的文件名</li><li><em>process.cwd()</em>: 指当前执行node命令时候的文件夹目录名<br>./: 指文件所在目录<br>比如:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> configPath = path.resolve(__dirname, <span class="string">'../config.json'</span>) <span class="comment">// 返回路径</span></span><br><span class="line"><span class="built_in">console</span>.log(configPath) <span class="comment">// configPath D:\code\cpp-cli\config.json</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = path.resolve(<span class="string">'/foo/bar'</span>, <span class="string">'/tmp/file/'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// /foo/bar/tmp/file</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="相关解析"><a href="#相关解析" class="headerlink" title="相关解析"></a>相关解析</h3><p><code>#!/usr/bin/env node</code><br>使用过Linux或者Unix的开发者，对于Shebang应该不陌生，它是一个符号的名称，#！。这个符号通常在Unix系统的基本中第一行开头中出现，用于指明这个脚本文件的解释程序。了解了Shebang之后就可以理解，增加这一行是为了指定用node执行脚本文件。<br>当你输入一个命令的时候，npm是如何识别并执行对应的文件的呢？<br>具体的原理阮一峰大神已经在npm scripts 使用指南中介绍过。简单的理解:<br>就是输入命令后，会有在一个新建的shell中执行指定的脚本，在执行这个脚本的时候，我们需要来指定这个脚本的解释程序是node。<br>在一些情况下，即使你增加了这一行，但还是可能会碰到一下错误，这是为什么呢？<br><code>No such file or directory</code><br>为了解决这个问题，首先需要了解一下/usr/bin/env。我们已经知道，Shebang是为了指定脚本的解释程序，可是不同用户或者不同的脚本解释器有可能安装在不同的目录下，系统如何知道要去哪里找你的解释程序呢？<br>/usr/bin/env就是告诉系统可以在PATH目录中查找。<br>所以配置<code>#!/usr/bin/env node</code>, 就是解决了不同的用户node路径不同的问题，可以让系统动态的去查找node来执行你的脚本文件。<br>看到这里你应该理解，为什么会出现No such file or directory的错误？因为你的node安装路径没有添加到系统的PATH中。所以去进行node环境变量配置就可以了。</p><h3 id="NPM-执行脚本的原理"><a href="#NPM-执行脚本的原理" class="headerlink" title="NPM 执行脚本的原理"></a>NPM 执行脚本的原理</h3><p>npm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。<br>比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/6874815221174075405" target="_blank" rel="noopener">【工具流脚手架cli】用脚手架整合模板和配置</a></li><li><a href="https://juejin.im/post/6844903912080670734#heading-8" target="_blank" rel="noopener">一步一步搭建脚手架</a></li><li><a href="https://mp.weixin.qq.com/s/z9hyaOf85DFMweBmtm1YRA" target="_blank" rel="noopener">发布NPM包</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> cli </category>
          
          <category> node </category>
          
          <category> cpp </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
            <tag> node </tag>
            
            <tag> cli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: webpack 配置项output</title>
      <link href="/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-webpack%20%E9%85%8D%E7%BD%AE%E9%A1%B9output/"/>
      <url>/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-webpack%20%E9%85%8D%E7%BD%AE%E9%A1%B9output/</url>
      
        <content type="html"><![CDATA[<h3 id="output配置项"><a href="#output配置项" class="headerlink" title="output配置项"></a>output配置项</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: path.resolve(__dirname, <span class="string">'../src/component/index.js'</span>),</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>), <span class="comment">// 输出的文件位置</span></span><br><span class="line">    filename: <span class="string">'main.js'</span>, <span class="comment">// 输出的文件名</span></span><br><span class="line">    libraryTarget: <span class="string">'umd'</span>, <span class="comment">// 输出格式</span></span><br><span class="line">    library: <span class="string">'cppVue'</span> <span class="comment">// 模块名称</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按不同的模块方式生成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commonjs&#x2F;commonjs2: 将你的library暴露为CommonJS模块</span><br><span class="line">amd: 将你的library暴露为amd模块</span><br><span class="line">umd: 将你的library暴露为所有的模块定义下都可运行的方式</span><br></pre></td></tr></table></figure><blockquote><p>注意：commonjs和commonjs2几乎相同，只不过commonjs只包含exports，而commonjs2还包含module.exports，所以直接使用commonjs2即可。</p></blockquote><h3 id="在实践项目中的运用"><a href="#在实践项目中的运用" class="headerlink" title="在实践项目中的运用"></a>在实践项目中的运用</h3><p>首先得在<em>src</em>中定义想要导出的文件，一般是采用es6里的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://segmentfault.com/a/1190000017960583" target="_blank" rel="noopener">为什么自己写的组件库被引用总是报错——详解webpack的library和libraryTarget</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> umd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> umd </tag>
            
            <tag> output </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: vue</title>
      <link href="/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-vue/"/>
      <url>/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-vue/</url>
      
        <content type="html"><![CDATA[<h2 id="六月第三周-6-22-6-27-的安排"><a href="#六月第三周-6-22-6-27-的安排" class="headerlink" title="六月第三周(6.22-6.27)的安排"></a>六月第三周(6.22-6.27)的安排</h2><ul><li>vue源码学习</li><li>vue初始化流程</li><li>vue响应式原理</li><li>vue中的mvvm</li><li>vue虚拟Dom</li><li>vue生命周期的理解</li><li>vue如何检测数组变化</li><li>vue中如何实现异步渲染？</li></ul><a id="more"></a><p>vue运行机制</p><h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><ul><li>创建Vue实例对象</li><li>init过程会初始化生命周期/初始化事件中心/初始化渲染，执行beforeCreate周期函数</li><li>初始化调用 <em>$mount</em> 方法对Vue实例进行挂载(核心 模板编译 =&gt; 渲染函数 =&gt; 更新)</li><li>如果没有定义render方法，而是定义了template,需要经历编译阶段，需要将模板字符串编译成 <em>render function</em>,步骤如下 <ul><li>parse正则解析成AST</li><li>optimize标记静态节点</li></ul></li><li>编译成render function之后，调用$mount的<em>mountComponent</em>方法，先执行beforeMount钩子函数，然后实例化一个watcher</li><li>调用render方法将render function渲染成虚拟的VNode</li><li>生成虚拟DOM树后，需要将虚拟DOM树转化成真实的DOM节点，此时需要调用update方法，update方法又会调用<em>pacth</em>方法把虚拟DOM转换成真正的DOM节点</li></ul><h3 id="vue生命周期的理解"><a href="#vue生命周期的理解" class="headerlink" title="vue生命周期的理解"></a>vue生命周期的理解</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> LIFECYCLE_HOOKS = [</span><br><span class="line">  <span class="string">'beforeCreate'</span>,</span><br><span class="line">  <span class="string">'created'</span>,</span><br><span class="line">  <span class="string">'beforeMount'</span>,</span><br><span class="line">  <span class="string">'mounted'</span>,</span><br><span class="line">  <span class="string">'beforeUpdate'</span>,</span><br><span class="line">  <span class="string">'updated'</span>,</span><br><span class="line">  <span class="string">'beforeDestroy'</span>,</span><br><span class="line">  <span class="string">'destroyed'</span>,</span><br><span class="line">  <span class="string">'activated'</span>,</span><br><span class="line">  <span class="string">'deactivated'</span>,</span><br><span class="line">  <span class="string">'errorCaptured'</span>,</span><br><span class="line">  <span class="string">'serverPrefetch'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>常规来说 created -&gt; mounted -&gt; updated -&gt; destroyed 创建 挂载 更新 销毁<br>还有keep-alive组件的activated/deactivated 激活和停用还有最新的serverPrefetch,<br>允许我们在渲染过程中“等待”异步数据。可在任何组件中使用，而不仅仅是路由组件</p><h4 id="生命周期的钩子函数合并策略"><a href="#生命周期的钩子函数合并策略" class="headerlink" title="生命周期的钩子函数合并策略"></a>生命周期的钩子函数合并策略</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hooks and props are merged as arrays.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeHook</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = childVal</span><br><span class="line">    ? parentVal</span><br><span class="line">      ? parentVal.concat(childVal)</span><br><span class="line">      : <span class="built_in">Array</span>.isArray(childVal)</span><br><span class="line">        ? childVal</span><br><span class="line">        : [childVal]</span><br><span class="line">    : parentVal;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`res`</span>, dedupeHooks(res));</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">    ? dedupeHooks(res)</span><br><span class="line">    : res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断子组件是否含有对应名字的生命周期钩子，然后再合并父组件的生命周期钩子，还做了去重g，生命周期钩子其实阔以写成数组</p><h4 id="created-amp-amp-mounted-创建和挂载顺序"><a href="#created-amp-amp-mounted-创建和挂载顺序" class="headerlink" title="created &amp;&amp; mounted(创建和挂载顺序)"></a>created &amp;&amp; mounted(创建和挂载顺序)</h4><p>根组件created -&gt; 子组件created<br>子组件mounted -&gt; 父组件mounted </p><h3 id="vue响应式原理-vue双向绑定原理的理解"><a href="#vue响应式原理-vue双向绑定原理的理解" class="headerlink" title="vue响应式原理(vue双向绑定原理的理解)"></a>vue响应式原理(vue双向绑定原理的理解)</h3><p>answer:</p><h4 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h4><p>vue 采用数据劫持+发布者-订阅者模式的方式，通过Object.defineproperty()的方式劫持各个属性的setter/getter,在数据改变时发布消息给订阅者，触发响应的监听回调</p><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><ul><li><strong>监听器Observer</strong> 对需要监听的数据对象进行递归遍历，包括子属性对象的属性，利用Object.defineProperty()对属性都加上setter/getter,一旦某个值赋值，就会触发setter,就能监听到数据变化</li><li><strong>解析器Compiler</strong> 解析Vue模板指令，将模板中的变量都替换成数据，然后初始化页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新</li><li><strong>订阅者Watcher</strong> 订阅者是Observer和Compile之间的通信桥梁，主要任务是订阅Observer中的属性值变化的消息，当收到属性值变化的消息，触发解析器对应的更新函数 1.自身实例化的时候往属性订阅器dep添加自己 2，自身必须有update方法 3.待属性变动dep.notice通知时，调用自身的update方法，并触发Compile中绑定的回调函数</li></ul><p><strong>Last</strong> MVVM作为数据绑定的入口，整合Observe/Compile/Watcher三者，通过Observe来监听自己的model数据变化，通过Compile解析模板编译指令，最终利用Watcher搭起通信桥梁，达到数据变化-&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果</p><p>在init的时候会利用Object.defineProperty方法（不兼容IE8）监听Vue实例的响应式数据的变化从而实现数据劫持能力（利用了JavaScript对象的访问器属性get和set，在未来的Vue3中会使用ES6的Proxy来优化响应式原理）。在初始化流程中的编译阶段，当render function被渲染的时候，会读取Vue实例中和视图相关的响应式数据，此时会触发getter函数进行依赖收集（将观察者Watcher对象存放到当前闭包的订阅者Dep的subs中），此时的数据劫持功能和观察者模式就实现了一个MVVM模式中的Binder，之后就是正常的渲染和更新流程。<br>当数据发生变化或者视图导致的数据发生了变化时，会触发数据劫持的setter函数，setter会通知初始化<em>依赖收集中的Dep</em>中的和视图相应的Watcher，告知需要重新渲染视图，Wather就会再次通过update方法来更新视图。</p><h3 id="vue如何检测数组变化"><a href="#vue如何检测数组变化" class="headerlink" title="vue如何检测数组变化"></a>vue如何检测数组变化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; def &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"><span class="comment">// 原始Array未重写之前的API原型方法</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="comment">// 拷贝原型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"><span class="comment">// 重写原型的方法</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果插入的数据，将再次监听</span></span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">//  触发订阅，像页面更新响应就在这里触发</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>重写之后的数组会在每次在执行数组的原始方法之后手动触发响应页面的效果。<br>Vue2.x中并没有实现将已存在的数组元素做监听，而是去监听造成数组变化的方法，触发这个方法的同时去调用挂载好的响应页面方法，达到页面响应式的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="comment">// 监听数组元素</span></span><br><span class="line">    observe(items[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this.observeArray函数了，它的内部实现非常简单，它对数组元素进行了监听，什么意思呢，就是改变数组里的元素不能监听到，但是数组内的值是对象类型的，修改它依旧能得到监听响应，如改变list[0].val可以得到监听，但是改变list[0]不能，但是依旧没有对数组本身的变化进行监听。</p><h3 id="Vue中如何实现异步渲染？"><a href="#Vue中如何实现异步渲染？" class="headerlink" title="Vue中如何实现异步渲染？"></a>Vue中如何实现异步渲染？</h3><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/5e8b163ff265da47ee3f54a6" target="_blank" rel="noopener">2020年前端面试复习必读文章</a></li><li><a href="https://mp.weixin.qq.com/s/oAlVmZ4Hbt2VhOwFEkNEhw" target="_blank" rel="noopener">虚拟 DOM 到底是什么？(长文建议收藏)</a></li><li><a href="https://juejin.im/post/5cd8a7c1f265da037a3d0992#heading-15" target="_blank" rel="noopener">基于Vue实现一个简易MVVM</a></li><li><a href="https://juejin.im/post/5e778c71518825491d3240fd" target="_blank" rel="noopener">高级前端开发者必会的34道Vue面试题系列（二）</a></li><li><a href="https://juejin.im/post/5e8064c551882573a13777e2" target="_blank" rel="noopener">高级前端开发者必会的34道Vue面试题系列（三）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> 前端框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: promise-1</title>
      <link href="/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-promise-1/"/>
      <url>/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-promise-1/</url>
      
        <content type="html"><![CDATA[<h2 id="六月第三周-6-22-6-27-的安排"><a href="#六月第三周-6-22-6-27-的安排" class="headerlink" title="六月第三周(6.22-6.27)的安排"></a>六月第三周(6.22-6.27)的安排</h2><ul><li>promise用法1</li><li>promise用法2</li><li>promise手写</li></ul><a id="more"></a><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="promise状态不可逆性"><a href="#promise状态不可逆性" class="headerlink" title="promise状态不可逆性"></a>promise状态不可逆性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="string">"success1"</span>);</span><br><span class="line">  resolve(<span class="string">"success2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="string">"success"</span>);</span><br><span class="line">  reject(<span class="string">"reject"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">success1</span><br><span class="line">success</span><br></pre></td></tr></table></figure><h4 id="promise中的异常处理"><a href="#promise中的异常处理" class="headerlink" title="promise中的异常处理"></a>promise中的异常处理</h4><ul><li>first scene<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  foo.bar();</span><br><span class="line">  resolve( <span class="number">1</span> );  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then value: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then value: '</span>+value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 控制台输出</span></span><br><span class="line">p1 then err: <span class="built_in">ReferenceError</span> foo is not defined</span><br><span class="line">p1 then then err:  <span class="literal">undefined</span></span><br></pre></td></tr></table></figure></li><li>second scene<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  resolve( <span class="number">2</span> );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then value: '</span> + value);</span><br><span class="line">    foo.bar();</span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then value: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then err: '</span> + err);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then then value: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">p2 then value: <span class="number">2</span></span><br><span class="line">p2 then then err: <span class="built_in">ReferenceError</span> foo is not defined</span><br><span class="line">p2 then then then value: resolve</span><br></pre></td></tr></table></figure>知识点</li><li>Promise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。</li><li>then方法接受两个参数，第一个是promise成功的回调，一个是失败的回调，<em>两个函数只能一个被调用</em></li></ul><h4 id="promise-resolve"><a href="#promise-resolve" class="headerlink" title="promise.resolve()"></a>promise.resolve()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve( <span class="number">1</span> );</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve( p1 );</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2); </span><br><span class="line"><span class="built_in">console</span>.log(p1 === p3);</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p4);</span><br><span class="line"><span class="built_in">console</span>.log(p3 === p4);</span><br><span class="line"></span><br><span class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p4='</span> + value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p2='</span> + value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1='</span> + value);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 控制台输出</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">p2=<span class="number">1</span></span><br><span class="line">p1=<span class="number">1</span></span><br><span class="line">p4=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>Promise.resolve()阔以接受一个普通值或者一个Promise对象作为参数<br>当参数是普通值的时候，返回一个resolved状态的promise对象<br>当参数是Promise对象时，直接返回这个promise对象，所以p1 === p2</p><h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;               <span class="comment">//第一个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> value*<span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第二个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第三个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>); </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第四个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第五个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve: '</span>+ value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reject: '</span> + err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">resolve</span><br><span class="line">reject: reject</span><br></pre></td></tr></table></figure><p>then两个参数的返回值是以下三种情况的一种</p><ul><li>return 一个同步值或者undefined(没有返回一个值时默认是undefined),then 方法会返回一个resolved状态的promise对象，Promise对象的值就是这个返回值</li><li>return 另一个Promise，then会根据这个Promise的状态和值创建一个新的Promise对象返回</li><li>throw 一个同步异常 then方法返回一个rejected状态的promise,值是该异常</li></ul><h4 id="resolve-vs-reject"><a href="#resolve-vs-reject" class="headerlink" title="resolve vs reject"></a>resolve vs reject</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  reject(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">p2.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">p3.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 控制台输出</span></span><br><span class="line">rejected: [object <span class="built_in">Promise</span>]</span><br><span class="line">fulfilled: resolve</span><br><span class="line">rejected: resolve</span><br></pre></td></tr></table></figure><ul><li>Promise回调函数中的第一个参数resolve，会对Promise执行”拆箱”动作。即当resolve的参数是一个Promise对象时，resolve会”拆箱”获取这个Promise对象的状态和值，但这个过程是异步的。p1”拆箱”后，获取到Promise对象的状态是resolved，因此fulfilled回调被执行；</li><li>p2”拆箱”后，获取到Promise对象的状态是rejected，因此rejected回调被执行。</li><li>但Promise回调函数中的第二个参数reject不具备”拆箱“的能力，reject的参数会直接传递给then方法中的rejected回调。因此，即使p3 reject接收了一个resolved状态的Promise，then方法中被调用的依然是rejected，并且参数就是reject接收到的Promise对象。</li></ul><blockquote><p>拆箱是异步操作，所以不具备拆箱的3执行的是同步操作</p></blockquote><h4 id="扩展——-try-catch"><a href="#扩展——-try-catch" class="headerlink" title="扩展—— try catch"></a>扩展—— try catch</h4><p>问: 用一句话描述js异常是否能被try catch到<br>答: 能捕捉到的异常必须是线程执行已经进入try catch但try catch未执行完成的时候抛出来的</p><h3 id="红绿灯问题"><a href="#红绿灯问题" class="headerlink" title="红绿灯问题"></a>红绿灯问题</h3><p>Qs: 题目：红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次；如何让三个灯不断交替重复亮灯？（用 Promise 实现）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'red'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'green'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'yellow'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用then和递归实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'red'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'green'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'yellow'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> light = <span class="function"><span class="keyword">function</span>(<span class="params">timmer, cb</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            cb();</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, timmer);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> step = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> light(<span class="number">3000</span>, red);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> light(<span class="number">2000</span>, green);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> light(<span class="number">1000</span>, yellow);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        step();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 或者换种写法</span></span><br><span class="line">    <span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        resolve(<span class="string">'i am cpp'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(val) <span class="comment">// i am cpp</span></span><br><span class="line">        <span class="keyword">return</span> light(<span class="number">3000</span>, red);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> light(<span class="number">2000</span>, green);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> light(<span class="number">1000</span>, yellow);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">step();</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/597724c26fb9a06bb75260e8" target="_blank" rel="noopener">八段代码彻底掌握 Promise</a></li><li><a href="https://juejin.im/post/5e6f4579f265da576429a907" target="_blank" rel="noopener">最简实现Promise，支持异步链式调用（20行）</a></li><li><a href="https://juejin.im/post/5a04066351882517c416715d" target="_blank" rel="noopener">Promise 必知必会（十道题）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> promise </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> es6 </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 前端重学(6)</title>
      <link href="/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-6/"/>
      <url>/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-6/</url>
      
        <content type="html"><![CDATA[<h2 id="六月第二周-6-8-6-14-的安排"><a href="#六月第二周-6-8-6-14-的安排" class="headerlink" title="六月第二周(6.8-6.14)的安排"></a>六月第二周(6.8-6.14)的安排</h2><ul><li>观察者模式 vs 发布订阅模式</li><li>函数柯里化</li><li>prefetch 和 preload区别</li><li>实现一个正则表达式(匹配url连接)</li><li>内存溢出</li></ul><a id="more"></a><h2 id="观察者模式-vs-发布订阅模式"><a href="#观察者模式-vs-发布订阅模式" class="headerlink" title="观察者模式 vs 发布订阅模式"></a>观察者模式 vs 发布订阅模式</h2><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式指的是一个对象（Subject）维持一系列依赖于它的对象（Observer），当有关状态发生变更时 Subject 对象则通知一系列 Observer 对象进行更新。<br>在观察者模式中，Subject 对象拥有添加、删除和通知一系列 Observer 的方法等等，而 Observer 对象拥有更新方法(update)等等。<br>简单说，就是数据发生改变，对应的处理函数自动执行。<br>通过一个实例就能很好的明白观察者模式了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义综述主题</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Subject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.observers = []</span><br><span class="line">&#125;</span><br><span class="line">Subject.prototype = &#123;</span><br><span class="line">  <span class="comment">// 添加observe</span></span><br><span class="line">  add(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.push(observer)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 移除observe</span></span><br><span class="line">  remove(observer) &#123;</span><br><span class="line">    <span class="keyword">var</span> observers = <span class="keyword">this</span>.observers</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; observers.length; i ++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (observers[i] === observer) &#123;</span><br><span class="line">        observers.splice(i, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 通知 告诉observe 执行自己的方法</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">var</span> observers = <span class="keyword">this</span>.observers;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; observers.length;i++)&#123;</span><br><span class="line">      observers[i].update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 观察者定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义观察者里的更新方法</span></span><br><span class="line">Observer.prototype = &#123;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`观察者模式下 name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Subject</span></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Subject()</span><br><span class="line"><span class="keyword">var</span> obs1 = <span class="keyword">new</span> Observer(<span class="string">'cpp'</span>)</span><br><span class="line"><span class="keyword">var</span> obs2 = <span class="keyword">new</span> Observer(<span class="string">'chendapeng'</span>)</span><br><span class="line">sub.add(obs1)</span><br><span class="line">sub.add(obs2)</span><br><span class="line">sub.notify()</span><br></pre></td></tr></table></figure><p>应用:<br>Vue 通过观察者模式触发视图更新。Vue2.x通过Object.defineProperty劫持data数据，当数据变化后触发setter,setter内部通过订阅器notify消息，notify会调用watcher更新视图</p><h3 id="发布订阅模式-Publisher-amp-amp-Subscriber"><a href="#发布订阅模式-Publisher-amp-amp-Subscriber" class="headerlink" title="发布订阅模式(Publisher &amp;&amp; Subscriber)"></a>发布订阅模式(Publisher &amp;&amp; Subscriber)</h3><p>希望接受通知的对象基于一个主题通过自定义事件订阅主题<br>发布者通过调度中心基于一个主题向订阅者发布消息<br>代码示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调度中心</span></span><br><span class="line"><span class="keyword">let</span> pubsub = &#123;</span><br><span class="line">  list: &#123;&#125;, <span class="comment">// 订阅的数组</span></span><br><span class="line">  subscribe(key, fn) &#123; <span class="comment">// 订阅</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.list[key]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.list[key] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.list[key].push(fn)</span><br><span class="line">  &#125;,</span><br><span class="line">  publish(...args) &#123; <span class="comment">// 发布</span></span><br><span class="line">    <span class="built_in">console</span>.log(args);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(args).slice(<span class="number">8</span>, <span class="number">-1</span>))</span><br><span class="line">    <span class="keyword">const</span> key = args[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> fns = <span class="keyword">this</span>.list[key]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fns.length; i ++) &#123;</span><br><span class="line">      fns[i].apply(<span class="keyword">this</span>, [args[<span class="number">1</span>]])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 取消订阅</span></span><br><span class="line">  unSubscribe(key) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.list[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">pubsub.subscribe(<span class="string">'name'</span>, (name) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'订阅在发布模式下 name is'</span>, name);</span><br><span class="line">&#125;)</span><br><span class="line">pubsub.publish(<span class="string">'name'</span>, <span class="string">'cpp'</span>)</span><br><span class="line">pubsub.subscribe(<span class="string">'age'</span>, (age) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'订阅在发布模式下 age is'</span>, age);</span><br><span class="line">&#125;)</span><br><span class="line">pubsub.publish(<span class="string">'age'</span>, <span class="string">'18'</span>)</span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>观察者模式与发布订阅模式都是定义了<em>一个一对多的依赖关系</em>，当有关状态发生变更时则执行相应的更新。<br>不同的是，观察者模式依赖于主题(Subject)对象的一系列Observer对象被通知之后只能执行一个特定的更新方法(比如update等),而发布订阅模式阔以通过调度中心，<strong>基于不同的主题去执行不同的自定义事件</strong>，相对而言，发布订阅模式比观察者模式灵活一些。</p><h3 id="原生实现观察者模式"><a href="#原生实现观察者模式" class="headerlink" title="原生实现观察者模式"></a>原生实现观察者模式</h3><ul><li>es5实现<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> observer(mode: <span class="built_in">any</span>, old: <span class="built_in">any</span>, val: <span class="built_in">any</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;mode&#125;</span> name属性值从<span class="subst">$&#123;old&#125;</span> -&gt; <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> es5Implement() &#123;</span><br><span class="line">  <span class="keyword">const</span> targetObj = &#123;</span><br><span class="line">    age: <span class="number">28</span>,</span><br><span class="line">    name: <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">'cpp'</span></span><br><span class="line">  <span class="comment">// 定义name属性以及其设置方法</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(targetObj, <span class="string">'name'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> name</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(val) &#123;</span><br><span class="line">      <span class="keyword">this</span>.observer(<span class="string">'es5'</span>, name, val)</span><br><span class="line">      name = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  targetObj.name = <span class="string">'Martin'</span>;</span><br><span class="line">  targetObj.name = <span class="string">'Lucas'</span>;</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">'targetObj:'</span>, targetObj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>es6实现<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TargetObj</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(age, name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> name(val) &#123;</span><br><span class="line">    observer(name, val);</span><br><span class="line">    name = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> targetObj = <span class="keyword">new</span> TargetObj(<span class="number">1</span>, <span class="string">'Martin'</span>);</span><br><span class="line"><span class="comment">// 定义值改变时的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">oldVal, newVal</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 其他处理逻辑...</span></span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">'name属性的值从 '</span>+ oldVal +<span class="string">' 改变为 '</span> + newVal);</span><br><span class="line">&#125;</span><br><span class="line">targetObj.name = <span class="string">'Lucas'</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/5bb1bb616fb9a05d2b6dccfa" target="_blank" rel="noopener">谈谈观察者模式和发布订阅模式</a></li><li><a href="https://blog.csdn.net/lm278858445/article/details/78287492" target="_blank" rel="noopener">原生JavaScript实现观察者模式</a></li></ul><h2 id="函数柯里化-Curry"><a href="#函数柯里化-Curry" class="headerlink" title="函数柯里化(Curry)"></a>函数柯里化(Curry)</h2><h3 id="什么是curry"><a href="#什么是curry" class="headerlink" title="什么是curry"></a>什么是curry</h3><p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>柯里化实际是把简答的问题复杂化了，但是复杂化的同时，我们在使用函数时拥有了更加多的自由度。 而这里对于函数参数的自由处理，正是柯里化的核心所在。 柯里化本质上是降低通用性，提高适用性。</p><h2 id="prefetch-和-preload区别"><a href="#prefetch-和-preload区别" class="headerlink" title="prefetch 和 preload区别"></a>prefetch 和 preload区别</h2><p>通过插入一个页面元素来声明一个资源（比如img、script、link）。这种方式会将资源的加载和执行耦合。</p><p>用AJAX来加载资源。这种方式只有在时机成熟时才会加载资源，解决了执行时机问题。但是浏览器无法预解析，也就无法提前加载。另外如果页面有大量的阻塞脚本，就会造成延迟。<br>有没有办法既提前加载资源，又能解耦加载和执行呢?</p><h3 id="preload"><a href="#preload" class="headerlink" title="preload"></a>preload</h3><p>preload 提供了一种声明式的命令，让浏览器<em>提前加载</em>指定资源(加载后并不执行,加载和执行分离)，在需要执行的时候再执行。提供的好处主要是</p><ul><li>将加载和执行分离开，可不阻塞渲染和 document 的 onload 事件</li><li>提前加载指定资源，不再出现依赖的font字体隔了一段时间才刷出</li></ul><h3 id="如何区分-preload-和-prefetch"><a href="#如何区分-preload-和-prefetch" class="headerlink" title="如何区分 preload 和 prefetch"></a>如何区分 preload 和 prefetch</h3><ul><li>preload 告诉浏览器页面必定需要的资源，browser一定会加载这些资源</li><li>prefetch 告诉浏览器可能需要的资源，browser不一定会加载这些资源</li></ul><h3 id="用link标签创建preload"><a href="#用link标签创建preload" class="headerlink" title="用link标签创建preload"></a>用<code>link</code>标签创建preload</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'preload'</span> <span class="attr">href</span>=<span class="string">'/public/static/theme.css'</span> <span class="attr">as</span>=<span class="string">'style'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'preload'</span> <span class="attr">href</span>=<span class="string">'/public/static/vue.js'</span> <span class="attr">as</span>=<span class="string">'script'</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或者用script创建 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"> <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">'link'</span>)</span></span><br><span class="line"><span class="actionscript"> link.href=<span class="string">'/public/static/vue.js'</span></span></span><br><span class="line"><span class="actionscript"> link.rel = <span class="string">'preload'</span></span></span><br><span class="line"><span class="actionscript"> link.as = <span class="string">'script'</span></span></span><br><span class="line"><span class="javascript"> <span class="built_in">document</span>.head.appendChild(link)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="preload特点"><a href="#preload特点" class="headerlink" title="preload特点"></a>preload特点</h3><ul><li>提前加载资源</li><li>资源的加载和执行分离</li><li>不延迟网页的load事件（除非Preload资源刚好是阻塞 window 加载的资源）</li></ul><h3 id="Preload跟其他提前加载资源以及加载和执行分离的方案有什么区别？"><a href="#Preload跟其他提前加载资源以及加载和执行分离的方案有什么区别？" class="headerlink" title="Preload跟其他提前加载资源以及加载和执行分离的方案有什么区别？"></a>Preload跟其他提前加载资源以及加载和执行分离的方案有什么区别？</h3><h4 id="vs-aysnc"><a href="#vs-aysnc" class="headerlink" title="vs aysnc"></a>vs aysnc</h4><p>async 脚本是一加载完就立即执行，因此会阻塞window的onload事件。而且目前async仅限于脚本资源。<br>Preload可以实现async一样的异步加载功能。且不局限于脚本。比如以下代码实现了加载完CSS文件立即作用到网页的功能：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">as</span>=<span class="string">"style"</span> <span class="attr">onload</span>=<span class="string">"this.rel='stylesheet'"</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：如果页面存在同步阻塞脚本，等脚本执行完后，样式才会作用到网页。这样是因为Preload的资源不会阻塞window的onload事件。</p></blockquote><h4 id="vs-defer"><a href="#vs-defer" class="headerlink" title="vs defer"></a>vs defer</h4><p>defer实现了资源的加载和执行分离，并且它能保证defer的资源按照在HTML里的出现顺序执行。跟async一样，目前也只能作用于脚本资源。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>典型用例：</p><ul><li><p>在单页应用中，提前加载路由文件，提高切换路由时的渲染速度。现在大型的单页应用通常会异步加载路由文件。当用户切换路由时再异步加载相应的模块存在性能问题。可以用Preload提前加载，提升性能。</p></li><li><p>提前加载字体文件。由于字体文件必须等到CSSOM构建完成并且作用到页面元素了才会开始加载，会导致页面字体样式闪动（FOUT，Flash of Unstyled Text）。所以要用Preload显式告诉浏览器提前加载。假如字体文件在CSS生效之前下载完成，则可以完全消灭FOUT。</p></li></ul><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/5a7fb09bf265da4e8e785c38#heading-12" target="_blank" rel="noopener">用 preload 预加载页面资源</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMTcwOTM4Mg==&mid=2247484163&idx=1&sn=16b9c907971683dd61cee251adcde79b&chksm=f96edaaace1953bcaf65a1adcf30b6d3dd66cf7b648ae59c4bf807d3f8bf460d5cd638e54ca1&token=946370022&lang=zh_CN#rd" target="_blank" rel="noopener">有一种优化，叫Preload</a></li></ul><h2 id="实现一个正则表达式-匹配url连接"><a href="#实现一个正则表达式-匹配url连接" class="headerlink" title="实现一个正则表达式(匹配url连接)"></a>实现一个正则表达式(匹配url连接)</h2><p>url: <a href="http://niaogege.cn:80/index?title=1#more">http://niaogege.cn:80/index?title=1#more</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> patter = <span class="regexp">/^(http?:\/\/)([0-9a-zA-Z.]+)([:0-9]+)?([/0-9a-zA-Z.]+)?(\?[0-9a-zA-Z&amp;=]+)?(#[0-9a-zA-Z])?/</span></span><br><span class="line"><span class="comment">// 不区分大小写</span></span><br><span class="line"><span class="keyword">const</span> pattern = <span class="regexp">/^(http?:\/\/)([0-9a-z.]+)([:0-9]+)?([/0-9a-z.]+)?(\?[0-9a-z&amp;=]+)?(#[0-9a-z])?/i</span></span><br></pre></td></tr></table></figure><h3 id="匹配协议"><a href="#匹配协议" class="headerlink" title="匹配协议"></a>匹配协议</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(http?:\/\/)</span><br></pre></td></tr></table></figure><h3 id="匹配主域"><a href="#匹配主域" class="headerlink" title="匹配主域"></a>匹配主域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([<span class="number">0</span><span class="number">-9</span>a-z.]+)</span><br></pre></td></tr></table></figure><h3 id="匹配端口"><a href="#匹配端口" class="headerlink" title="匹配端口"></a>匹配端口</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([:<span class="number">0</span><span class="number">-9</span>]+)? <span class="comment">// :8080 可有可无 ？</span></span><br></pre></td></tr></table></figure><h3 id="匹配路径"><a href="#匹配路径" class="headerlink" title="匹配路径"></a>匹配路径</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([<span class="regexp">/0-9a-z.]+)? /</span><span class="regexp">/ /i</span>ndex.html 可有可无 ？</span><br></pre></td></tr></table></figure><h3 id="匹配查询"><a href="#匹配查询" class="headerlink" title="匹配查询"></a>匹配查询</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\?[<span class="number">0</span><span class="number">-9</span>a-z&amp;=]+)? <span class="comment">// ?query=1&amp;title=1&amp;keyword=2 可有可无 ？</span></span><br></pre></td></tr></table></figure><h3 id="匹配锚点"><a href="#匹配锚点" class="headerlink" title="匹配锚点"></a>匹配锚点</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(#[0-9a-z])? // #more 可有可无 ？</span><br></pre></td></tr></table></figure><h3 id="常用正则表达"><a href="#常用正则表达" class="headerlink" title="常用正则表达"></a>常用正则表达</h3><ul><li>匹配手机号码 <em>/(+86)1\d{10}/</em> </li><li>匹配身份证号码 <em>/^(\d{17}(\d|x))$/</em></li><li>匹配邮箱 <em>/^(\w)+(.\w+)</em>@(\w)+((.\w+)+)$/*</li></ul><h3 id="参考链接-2"><a href="#参考链接-2" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://louiszhai.github.io/2016/06/13/regexp/#%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">正则表达式前端使用手册</a></li><li><a href="https://blog.csdn.net/wulex/article/details/97050209" target="_blank" rel="noopener">正则匹配地址</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> http </tag>
            
            <tag> RegExp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 前端重学(5)</title>
      <link href="/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-5/"/>
      <url>/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-5/</url>
      
        <content type="html"><![CDATA[<h2 id="6-1-6-7-的安排"><a href="#6-1-6-7-的安排" class="headerlink" title="(6.1-6.7)的安排"></a>(6.1-6.7)的安排</h2><ul><li>vuex手写以及原理</li><li>mvvm理解(拖延症)</li><li>css问题(1px以及清楚浮动原理)</li><li>js基础(es5继承和es6继承的区别)</li></ul><a id="more"></a><h3 id="第二版vuex手写"><a href="#第二版vuex手写" class="headerlink" title="第二版vuex手写"></a>第二版vuex手写</h3><h3 id="mvvm理解"><a href="#mvvm理解" class="headerlink" title="mvvm理解"></a>mvvm理解</h3><h3 id="css之移动端-1px-问题"><a href="#css之移动端-1px-问题" class="headerlink" title="css之移动端 1px 问题"></a>css之移动端 1px 问题</h3><p>两个概念，一个是像素（pixel）可以简写为px，另外一个是设备像素比（DPR）devicePixelRadio</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">像素 ：指在由一个数字序列表示的图像中的一个最小单元，单位是 px，不可再次分割了。</span><br><span class="line">设备像素比（DPR）: 设备像素比 &#x3D; 设备像素 &#x2F; 设备独立像素。</span><br></pre></td></tr></table></figure><p>造成边框变粗的原因<br>其实这个原因很简单，因为css中的1px并不等于移动设备的1px，这些由于不同的手机有不同的像素密度。在window对象中有一个devicePixelRatio属性，他可以反应css中的像素与设备的像素比。</p><p>设计稿上的是<code>物理像素</code>,css中的像素是<code>逻辑像素</code><br>如果window.devicePixelRadio是2.0，即设计稿上的1px等于css中的0.5px<br>目前主流屏幕的DPR是2（8P+），拿2倍屏来说，设备的物理像素要实现1像素，而DPR=2，所以css 像素只能是 0.5。一般设计稿是按照750来设计的，它上面的1px是以750来参照的，而我们写css样式是以设备375为参照的，所以我们应该写0.5px</p><h3 id="主流方案一：利用伪元素（-after-transform）进行缩放"><a href="#主流方案一：利用伪元素（-after-transform）进行缩放" class="headerlink" title="主流方案一：利用伪元素（::after + transform）进行缩放"></a>主流方案一：利用伪元素（<code>::after + transform</code>）进行缩放</h3><p>为什么用伪元素？ 因为伪元素<code>::after或::before</code>是独立于当前元素，可以单独对其缩放而不影响元素本身的缩放<br>实现:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border-1px</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  &amp;::before&#123;</span><br><span class="line">    <span class="selector-tag">content</span>: "";</span><br><span class="line">    <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line">    <span class="selector-tag">left</span>: 0;</span><br><span class="line">    <span class="selector-tag">top</span>: 0;</span><br><span class="line">    <span class="selector-tag">width</span>: 200%;</span><br><span class="line">    <span class="selector-tag">border</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-tag">red</span>;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-tag">red</span>;</span><br><span class="line">    <span class="selector-tag">height</span>: 200%;</span><br><span class="line">    <span class="selector-tag">-webkit-transform-origin</span>: <span class="selector-tag">left</span> <span class="selector-tag">top</span>;</span><br><span class="line">    <span class="selector-tag">transform-origin</span>: <span class="selector-tag">left</span> <span class="selector-tag">top</span>;</span><br><span class="line">    <span class="selector-tag">-webkit-transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.5</span>);</span><br><span class="line">    <span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.5</span>);</span><br><span class="line">    <span class="selector-tag">pointer-events</span>: <span class="selector-tag">none</span>; <span class="comment">/* 防止点击触发 */</span></span><br><span class="line">    <span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>; <span class="comment">/*IE 盒模型 元素内容宽高 == 内容+ 内边距 + 边框*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主流方案二：针对不同的DPR设备增加媒体查询，进行对应的缩放"><a href="#主流方案二：针对不同的DPR设备增加媒体查询，进行对应的缩放" class="headerlink" title="主流方案二：针对不同的DPR设备增加媒体查询，进行对应的缩放"></a>主流方案二：针对不同的DPR设备增加媒体查询，进行对应的缩放</h3><p>实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border-1px</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  &amp;::before&#123;</span><br><span class="line">    <span class="selector-tag">content</span>: "";</span><br><span class="line">    <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line">    <span class="selector-tag">left</span>: 0;</span><br><span class="line">    <span class="selector-tag">top</span>: 0;</span><br><span class="line">    <span class="selector-tag">width</span>: 200%;</span><br><span class="line">    <span class="selector-tag">border</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-tag">red</span>;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-tag">red</span>;</span><br><span class="line">    <span class="selector-tag">height</span>: 200%;</span><br><span class="line">    <span class="selector-tag">-webkit-transform-origin</span>: <span class="selector-tag">left</span> <span class="selector-tag">top</span>;</span><br><span class="line">    <span class="selector-tag">transform-origin</span>: <span class="selector-tag">left</span> <span class="selector-tag">top</span>; <span class="comment">/* 允许改变转换元素的位置 */</span></span><br><span class="line">    <span class="selector-tag">-webkit-transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.5</span>);</span><br><span class="line">    <span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.5</span>);</span><br><span class="line">    <span class="selector-tag">pointer-events</span>: <span class="selector-tag">none</span>; <span class="comment">/* 防止点击触发 */</span></span><br><span class="line">    <span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>; <span class="comment">/* IE 盒模型 元素内容宽高 == 内容+ 内边距 + 边框 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-device-pixel-ratio:</span><span class="number">3</span>),(<span class="attribute">-webkit-min-device-pixel-ratio:</span><span class="number">3</span>) &#123;</span><br><span class="line">      <span class="selector-tag">width</span>: 300%;</span><br><span class="line">      <span class="selector-tag">height</span>: 300%;</span><br><span class="line">      <span class="selector-tag">-webkit-transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.33</span>);</span><br><span class="line">      <span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.33</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-device-pixel-ratio:</span><span class="number">2.75</span>),(<span class="attribute">-webkit-min-device-pixel-ratio:</span><span class="number">2.75</span>) &#123;</span><br><span class="line">      <span class="selector-tag">width</span>: 300%;</span><br><span class="line">      <span class="selector-tag">height</span>: 300%;</span><br><span class="line">      -webkit-transform: scale(1/2.75);</span><br><span class="line">      transform: scale(1/2.75);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-device-pixel-ratio:</span><span class="number">2</span>),(<span class="attribute">-webkit-min-device-pixel-ratio:</span><span class="number">2</span>)&#123;</span><br><span class="line">      <span class="selector-tag">width</span>: 300%;</span><br><span class="line">      <span class="selector-tag">height</span>: 300%;</span><br><span class="line">      <span class="selector-tag">-webkit-transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.5</span>);</span><br><span class="line">      <span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="css之清除浮动原理"><a href="#css之清除浮动原理" class="headerlink" title="css之清除浮动原理"></a>css之清除浮动原理</h2><p>清除浮动主要有两种方式，分别是clear清除浮动和BFC清除浮动</p><h3 id="浮动的三个特点很重要。"><a href="#浮动的三个特点很重要。" class="headerlink" title="浮动的三个特点很重要。"></a>浮动的三个特点很重要。</h3><ol><li>脱离文档流。</li><li>向左/向右浮动直到遇到父元素或者别的浮动元素。</li><li>浮动会导致父元素高度坍塌。</li></ol><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>clear属性不允许被清除浮动的元素的左边/右边挨着浮动元素，底层原理是<em>在被清除浮动的元素上边或者下边添加足够的清除空间</em></p><blockquote><p>要注意了，我们是通过在别的元素上清除浮动来实现撑开高度的，而不是在浮动元素上。</p></blockquote><p>clear浮动元素最佳实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 同时加入:before以解决现代浏览器上边距折叠的问题</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">    *zoom: 1; // 引入了zoom以支持IE6/7</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFC清除浮动"><a href="#BFC清除浮动" class="headerlink" title="BFC清除浮动"></a>BFC清除浮动</h3><p>原理就是 <em>浮动盒区域不会叠加到BFC上，(BFC区域不会与float的元素区域叠加)</em>,BFC的五条约束规则之一<br>实现就是触发BFC即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 根元素或其它包含它的元素；</span><br><span class="line">- 浮动 (元素的float不为none)；</span><br><span class="line">- 绝对定位元素 (元素的position为absolute或fixed)；</span><br><span class="line">- 行内块inline-blocks(元素的 display: inline-block)；</span><br><span class="line">- 表格单元格(元素的display: table-cell，HTML表格单元格默认属性)；</span><br><span class="line">- overflow的值不为visible的元素；</span><br><span class="line">- 弹性盒 flex boxes (元素的display: flex或inline-flex)；</span><br></pre></td></tr></table></figure><p>平常中，设置<code>overflow: hidden/scroll, float: right/left,position: absolute,display: flex/inline-flex;</code>即当前元素创建了一个BFC</p><h2 id="原型和es5继承和es6继承的区别"><a href="#原型和es5继承和es6继承的区别" class="headerlink" title="原型和es5继承和es6继承的区别"></a>原型和es5继承和es6继承的区别</h2><h3 id="原型-prototype-和-实例属性的-proto"><a href="#原型-prototype-和-实例属性的-proto" class="headerlink" title="原型(prototype) 和 实例属性的(proto)"></a>原型(prototype) 和 实例属性的(<strong>proto</strong>)</h3><ul><li>原型: 给其他对象提供共享属性的对象</li><li>隐式引用(<strong>proto</strong>): 所有实例对象都存在一个隐式引用，指向他的原型</li></ul><p>构造函数(constructor): 它的原型指向实例的原型(Person.prototype === person.<strong>proto</strong>)<br>构造函数和普通函数的区别</p><ul><li>使用new操作符生成实例的函数就是构造函数</li><li>直接调用的就是普通函数</li><li>Symbol是基础类型不是构造函数</li></ul><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p>之前已经详细阐述过es5中的继承，主要是经典继承(构造函数继承)/原型链继承/组合继承以及常用的寄生式组合继承，<a href="http://niaogege.cn/2020/05/05/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6/#more">前文链接</a>,(通过原型链实现原型属性的继承，通过构造函数实现实例属性的继承)</p><p>ES5 的继承，通过prototype或构造函数机制来实现, 实质是先创造子类的实例对象this，再将父类的方法添加到this上面（Parent.apply(this)）。<br>ES6 的继承机制完全不同，实质是先创建父类的实例对象this(所以必须先调用父类的super()方法)，然后再用子类的构造函数修改this。</p><p>ES6中新增了class关键字来定义类，通过保留的关键字<em>extends</em>实现了继承。实际上这些关键字只是一些语法糖，底层实现还是通过原型链之间的委托关联关系实现继承</p><p>如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</p><h3 id="super"><a href="#super" class="headerlink" title="super()"></a>super()</h3><p>在 super() 执行时，它指向的是 子类 B 的构造函数，而不是父类 A 的构造函数。也就是说，super() 内部的 this 指向的是 B<br><em>super()<em>相当于</em>Parent.prototype.constructor.call(this. props)</em><br>super本身是指向父类的构造函数但做函数调用后返回的是子类的实例，实际上做了<em>parent.prototype.constructor.call(this)</em>，做对象调用时指向父类.prototype,从而实现继承</p><h3 id="static-静态属性"><a href="#static-静态属性" class="headerlink" title="static 静态属性"></a>static 静态属性</h3><p>顾名思义是静态方法的意思，类相当于实例的原型，所有在类中定义的方法， 都会被实例继承。<br>如果在一个方法前， 加上static关键字， 就表示该方法不会被实例继承， 而是直接通过类来调用， 这就称为“ 静态方法”。静态方法调用直接在类上进行，而在类的实例上不可被调用。静态方法通常用于创建 实用/工具 函数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">  <span class="keyword">public</span> x!: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">public</span> y!: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">public</span> z!: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">x: <span class="built_in">any</span>, y: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">this</span>.y = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> print() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类的print方法'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.z = <span class="number">3</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> ColorPoint <span class="keyword">extends</span> Point &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">x: <span class="built_in">any</span>, y: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(x, y)</span><br><span class="line">    <span class="comment">// Point.prototype.constructor.call(this, x, y)</span></span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> m() &#123;</span><br><span class="line">    <span class="comment">// super.print() 难以调用，父类的print是静态属性，只能在类上直接调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，父类的静态方法，也会被子类继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> hello() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.hello()  <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>上面代码中，hello()是A类的静态方法，B继承A，也继承了A的静态方法。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://es6.ruanyifeng.com/#docs/class-extends" target="_blank" rel="noopener">es6之class</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> mvvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> http </tag>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 前端重学(4)</title>
      <link href="/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-4/"/>
      <url>/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-4/</url>
      
        <content type="html"><![CDATA[<p>重点js基础/Vue框架/typescript/Css/node/工具/网络基础</p><ul><li>Mvvm原理的解读以及模拟实现</li><li>Vuex源码以及模拟实现(a week)</li><li>Vue计算属性(原理及相关特性)</li><li>express完整应用(two week)</li></ul><p>前期还是需要在好好学学vue相关的源码知识，特别是mvvm以及vuex的源码阅读，大概领会其思想，目的很简单，就是面试的时候，不能被面试官问倒。<br>后面会尽量往node/webpack/ast靠拢，如果可能有时间的话，算法还是要了解。<br>源码调试不方便，不知道是自己的问题还是没有找到规律，vuex的源码是放在<code>vuex.esm.js</code>中，在2.0版本的时候，源码中还含有<code>src</code>文件夹，里面含有未压缩的各模块代码，现在vuex不是这个样子</p><a id="more"></a><h3 id="Mvvm的模拟实现"><a href="#Mvvm的模拟实现" class="headerlink" title="Mvvm的模拟实现"></a>Mvvm的模拟实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observer 数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现。</span><br><span class="line"></span><br><span class="line">Compile 指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。</span><br><span class="line"></span><br><span class="line">Watcher 订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。</span><br><span class="line"></span><br><span class="line">Dep 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。</span><br></pre></td></tr></table></figure><h2 id="Vuex源码以及模拟实现"><a href="#Vuex源码以及模拟实现" class="headerlink" title="Vuex源码以及模拟实现"></a>Vuex源码以及模拟实现</h2><p>源码这么多，不知道如何下手?不知道主线是什么，谁能告诉我如何把源码理清，其实，有好几篇文章里的思路还是比较明晰的，无奈自己太次，有点理解不了尤大大的用意，老是被一些api打断思路。<br>还有就是对数据结构没啥概念，比如说在deom里定义了两个模块，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    Test,</span><br><span class="line">    Fuck,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>modules</code>所包含的对象即使传入Store中的对象，即源码中的<code>options</code></p><h3 id="手写基础版的vuex"><a href="#手写基础版的vuex" class="headerlink" title="手写基础版的vuex"></a>手写基础版的vuex</h3><ul><li>install</li></ul><p>vuex对外暴露一个是install方法，传入vue，并把$cppStore绑定到组件上，到时候直接调用<code>this.$cppStore.state</code>即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue: any</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">initVue: any</span>) </span>&#123;</span><br><span class="line">  Vue = initVue</span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">      <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'this'</span>, options);</span><br><span class="line">      <span class="keyword">if</span> (options &amp;&amp; options.cppStore) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$cppStore = <span class="keyword">typeof</span> options.cppStore === <span class="string">'function'</span></span><br><span class="line">        ? options.cppStore()</span><br><span class="line">        : options.cppStore;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.$cppStore = options.parent &amp;&amp; options.parent.$cppStore;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CppStore</li></ul><p>第二个是对外暴露一个 <code>CppStore</code> class,这个class需要传入一个对象，一般是这种样子的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  state: &#123;&#125;,</span><br><span class="line">  actions: &#123;&#125;,</span><br><span class="line">  mutations: &#123;&#125;,</span><br><span class="line">  getters: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>安装引入以及使用<!-- main.ts --><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cppStore <span class="keyword">from</span> <span class="string">'./store/cppStore'</span>;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  cppStore: (cppStore <span class="keyword">as</span> <span class="built_in">any</span>),</span><br><span class="line">  render: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure>store/cppStore<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import vue from &#39;vue&#39;</span><br><span class="line">import CppVuex from &#39;.&#x2F;..&#x2F;..&#x2F;utils&#x2F;vuex&#39;</span><br><span class="line">vue.use(CppVuex)</span><br><span class="line">export default new CppVuex.CppStore(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 10000,</span><br><span class="line">    data: &#123;</span><br><span class="line">      age: 20,</span><br><span class="line">      name: &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    addCount(context: any, val: number) &#123;</span><br><span class="line">      const obj &#x3D; &#123;</span><br><span class="line">        age: val,</span><br><span class="line">        name: &#39;cpp&#39;</span><br><span class="line">      &#125;</span><br><span class="line">      context.commit(&#39;CHANGE_COUNT&#39;, obj)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    CHANGE_COUNT(state: any, val: any) &#123;</span><br><span class="line">      state.count +&#x3D; val.age</span><br><span class="line">      state.data &#x3D; val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    GetCount: (state: any) &#x3D;&gt; &#123;</span><br><span class="line">      return state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="Vuex-乞丐版如下"><a href="#Vuex-乞丐版如下" class="headerlink" title="Vuex 乞丐版如下"></a>Vuex 乞丐版如下</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一版的vuex</span></span><br><span class="line"><span class="keyword">let</span> Vue: <span class="built_in">any</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">initVue: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  Vue = initVue</span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">      <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'this'</span>, options);</span><br><span class="line">      <span class="keyword">if</span> (options &amp;&amp; options.cppStore) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$cppStore = <span class="keyword">typeof</span> options.cppStore === <span class="string">'function'</span></span><br><span class="line">        ? options.cppStore()</span><br><span class="line">        : options.cppStore;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.$cppStore = options.parent &amp;&amp; options.parent.$cppStore;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> CppStore &#123;</span><br><span class="line">  <span class="keyword">protected</span> $options: <span class="built_in">any</span> = &#123;&#125; </span><br><span class="line">  <span class="keyword">protected</span> state: <span class="built_in">any</span> = &#123;&#125;</span><br><span class="line">  <span class="keyword">protected</span> mutations: <span class="built_in">any</span> = &#123;&#125;</span><br><span class="line">  <span class="keyword">protected</span> actions: <span class="built_in">any</span> = &#123;&#125;</span><br><span class="line">  <span class="keyword">protected</span> getters: <span class="built_in">any</span> = &#123;&#125;</span><br><span class="line">  <span class="comment">// dispatch: any = &#123;&#125;</span></span><br><span class="line">  <span class="comment">// commit: any = &#123;&#125;</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">options: <span class="built_in">any</span> = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// 普通传来的对象</span></span><br><span class="line">    <span class="keyword">this</span>.$options = options</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      data: <span class="keyword">this</span>.$options.state</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.$options.getters &amp;&amp; <span class="keyword">this</span>.handleGetters(<span class="keyword">this</span>.$options.getters)</span><br><span class="line">    <span class="keyword">this</span>.actions = <span class="keyword">this</span>.$options.actions</span><br><span class="line">    <span class="keyword">this</span>.mutations = <span class="keyword">this</span>.$options.mutations</span><br><span class="line">    <span class="comment">// this.commit = (type: any, arg: any) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   this.mutations[type](this.state, arg)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">const</span> store = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> &#123; dispatch, commit &#125; = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// this.commit = function boundCommit (type: any, payload: any, options: any) &#123;</span></span><br><span class="line">    <span class="comment">//   return commit.call(store, type, payload, options)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// getters</span></span><br><span class="line">  <span class="keyword">protected</span> handleGetters(getters: <span class="built_in">any</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.getters = &#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(getters).forEach(<span class="function">(<span class="params">key: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>.getters, key, &#123;</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">          <span class="comment">// 执行getters中的方法</span></span><br><span class="line">          <span class="keyword">return</span> getters[key](<span class="keyword">this</span>.state)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发dispatch</span></span><br><span class="line">  <span class="keyword">protected</span> dispatch(<span class="keyword">type</span>: <span class="built_in">any</span>, arg: <span class="built_in">any</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.actions[<span class="keyword">type</span>](&#123; </span><br><span class="line">      commit: <span class="keyword">this</span>.commit, </span><br><span class="line">      state: <span class="keyword">this</span>.state, </span><br><span class="line">      getters: <span class="keyword">this</span>.getters, </span><br><span class="line">      dispatch: <span class="keyword">this</span>.dispatch </span><br><span class="line">    &#125;, arg)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// // 触发commit</span></span><br><span class="line">  <span class="keyword">protected</span> commit = <span class="function">(<span class="params"><span class="keyword">type</span>: <span class="built_in">any</span>, arg: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.mutations[<span class="keyword">type</span>](<span class="keyword">this</span>.state, arg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  CppStore,</span><br><span class="line">  install</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="intstall-vuex安装"><a href="#intstall-vuex安装" class="headerlink" title="intstall vuex安装"></a>intstall vuex安装</h3><p>安装部分，核心就是给Vue注入一个store属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Vuex init hook, injected into each instances init hooks list.</span><br><span class="line"> *&#x2F;</span><br><span class="line">function vuexInit () &#123;</span><br><span class="line">  const options &#x3D; this.$options</span><br><span class="line">  &#x2F;&#x2F; store injection</span><br><span class="line">  if (options.store) &#123;</span><br><span class="line">    this.$store &#x3D; options.store</span><br><span class="line">  &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">    this.$store &#x3D; options.parent.$store</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟action"><a href="#模拟action" class="headerlink" title="模拟action"></a>模拟action</h3><p>vuex中通过dispatch触发action</p><ul><li>知识点<br>如何判断函数是否是async函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;是否是async函数&#39;, this.action[type].constructor);</span><br><span class="line">console.log(&#39;是否是async函数&#39;, this.action[type].constructor.name &#x3D;&#x3D;&#x3D; &#39;AsyncFunction&#39;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/29982815" target="_blank" rel="noopener">Vuex2.0源码解析</a></li></ul><h2 id="手写简单的mvvm"><a href="#手写简单的mvvm" class="headerlink" title="手写简单的mvvm"></a>手写简单的mvvm</h2><p>使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"c"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./MVVM.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> mvvm = <span class="keyword">new</span> Mvvm(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      a: &#123;</span><br><span class="line">        b: 1</span><br><span class="line">      &#125;,</span><br><span class="line">      c: 2,</span><br><span class="line"><span class="actionscript">      message: <span class="string">'this is Message'</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'mvvm'</span>, mvvm);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>具体的实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创造一个实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mvvm</span>(<span class="params">options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$options = options</span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">this</span>._data = <span class="keyword">this</span>.$options.data</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 数据劫持</span></span><br><span class="line">  observe(data)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//this 代理了 this._data</span></span><br><span class="line">  <span class="comment">// mvvm._data.a.b 相等于 mvvm.a.b</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._data[key] <span class="comment">// 访问this.a.b</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">        <span class="keyword">this</span>._data[key] = newValue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initComputed.call(this);     </span></span><br><span class="line">  <span class="comment">// 数据编译</span></span><br><span class="line">  <span class="keyword">new</span> Compile(options.el, <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据劫持 给所有对象增加set get方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observe</span>(<span class="params">data = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="comment">// 给对象添加set get</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">    <span class="comment">// 把data属性通过defineProperty的方式定义属性</span></span><br><span class="line">    <span class="keyword">let</span> val = data[key];</span><br><span class="line">     <span class="comment">// 递归继续向下找，实现深度的数据劫持</span></span><br><span class="line">    observe(val);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="comment">// 将watcher添加到订阅事件中 [watcher]</span></span><br><span class="line">        Dep.target &amp;&amp; dep.addSub(Dep.target)</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val === newVal) <span class="keyword">return</span>;</span><br><span class="line">        val = newVal;</span><br><span class="line">        observe(newVal)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方便递归调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!val || <span class="keyword">typeof</span> val !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observe(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据编译</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compile</span>(<span class="params">el, vm</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将el挂载到实例上</span></span><br><span class="line">  vm.$el = <span class="built_in">document</span>.querySelector(el);</span><br><span class="line">  <span class="comment">// ?</span></span><br><span class="line">  <span class="keyword">let</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">  <span class="keyword">let</span> child</span><br><span class="line">  <span class="keyword">while</span>(child = vm.$el.firstChild) &#123;</span><br><span class="line">    fragment.appendChild(child)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child'</span>, child);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fragment'</span>, fragment);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对 el内容进行替换</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">frag</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Array</span>.from(frag.childNodes).forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> txt = node.textContent;</span><br><span class="line">      <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>;   <span class="comment">// 正则匹配&#123;&#123;&#125;&#125;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'node'</span>, node);</span><br><span class="line">      <span class="keyword">if</span> (node.nodeType === <span class="number">3</span> &amp;&amp; reg.test(txt)) &#123;</span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">replaceTxt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            node.textContent = txt.replace(reg, (matched, placeholder) =&gt; &#123;   </span><br><span class="line">              <span class="built_in">console</span>.log(placeholder);   <span class="comment">// 匹配到的分组 如：song, album.name, singer...</span></span><br><span class="line">              <span class="keyword">new</span> Watcher(vm, placeholder, replaceTxt);   <span class="comment">// 监听变化，进行匹配替换内容</span></span><br><span class="line">              <span class="keyword">return</span> placeholder.split(<span class="string">'.'</span>).reduce(<span class="function">(<span class="params">val, key</span>) =&gt;</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> val[key]; </span><br><span class="line">              &#125;, vm);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;;</span><br><span class="line">        <span class="comment">// 替换</span></span><br><span class="line">        replaceTxt();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.nodeType === <span class="number">1</span>) &#123;  <span class="comment">// 元素节点</span></span><br><span class="line">        <span class="keyword">let</span> nodeAttr = node.attributes; <span class="comment">// 获取dom上的所有属性,是个类数组</span></span><br><span class="line">        <span class="built_in">Array</span>.from(nodeAttr).forEach(<span class="function"><span class="params">attr</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> name = attr.name;   <span class="comment">// v-model  type</span></span><br><span class="line">            <span class="keyword">let</span> exp = attr.value;   <span class="comment">// c        text</span></span><br><span class="line">            <span class="keyword">if</span> (name.includes(<span class="string">'v-'</span>))&#123;</span><br><span class="line">                node.value = vm[exp];   <span class="comment">// this.c 为 2</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 监听变化</span></span><br><span class="line">            <span class="keyword">new</span> Watcher(vm, exp, <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">              node.value = newVal;   <span class="comment">// 当watcher触发时会自动将内容放进输入框中</span></span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            node.addEventListener(<span class="string">'input'</span>, e =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> newVal = e.target.value;</span><br><span class="line">                <span class="comment">// 相当于给this.c赋了一个新值</span></span><br><span class="line">                <span class="comment">// 而值的改变会调用set，set中又会调用notify，notify中调用watcher的update方法实现了更新</span></span><br><span class="line">                vm[exp] = newVal;   </span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果还有子节点，继续递归replace</span></span><br><span class="line">      <span class="keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">        replace(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 替换内容</span></span><br><span class="line">  replace(fragment);</span><br><span class="line">  vm.$el.appendChild(fragment); <span class="comment">// 文档碎片放到el元素中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发布订阅</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subs = []</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="comment">// 订阅就是放入subs</span></span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// this.subs数组里的每一项，都有一个update方法</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this.subs'</span>, <span class="keyword">this</span>.subs);</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听者</span></span><br><span class="line"><span class="comment">// 通过Watcher这个类创建的实例，都拥有update方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm, exp, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!vm &amp;&amp; !exp) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">this</span>.vm = vm;</span><br><span class="line">  <span class="keyword">this</span>.exp = exp;</span><br><span class="line">  <span class="keyword">this</span>.fn = fn;</span><br><span class="line">  Dep.target = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> arr = exp.split(<span class="string">'.'</span>);</span><br><span class="line">  <span class="keyword">let</span> val = vm;</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;    <span class="comment">// 取值</span></span><br><span class="line">     val = val[key];     <span class="comment">// 获取到this.a.b，默认就会调用get方法</span></span><br><span class="line">  &#125;);</span><br><span class="line">  Dep.target = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype.update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// notify的时候值已经更改了</span></span><br><span class="line">  <span class="comment">// 再通过vm, exp来获取新的值</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="keyword">this</span>.exp.split(<span class="string">'.'</span>);</span><br><span class="line">  <span class="keyword">let</span> val = <span class="keyword">this</span>.vm;</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;    </span><br><span class="line">      val = val[key];   <span class="comment">// 通过get获取到新的值</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.fn(val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let watcher = new Watcher(() =&gt; console.log(111));  // </span></span><br><span class="line"><span class="comment">// let dep = new Dep();</span></span><br><span class="line"><span class="comment">// dep.addSub(watcher);    // 将watcher放到数组中,watcher自带update方法， =&gt; [watcher]</span></span><br><span class="line"><span class="comment">// dep.addSub(watcher);</span></span><br><span class="line"><span class="comment">// dep.notify();   //  111, 111</span></span><br></pre></td></tr></table></figure><p>yun….一头雾水，我太难了!!!</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> mvvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> http </tag>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 前端重学(3)</title>
      <link href="/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-3/"/>
      <url>/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-3/</url>
      
        <content type="html"><![CDATA[<h2 id="五一之后第二周-5-11-5-17-的安排"><a href="#五一之后第二周-5-11-5-17-的安排" class="headerlink" title="五一之后第二周(5.11-5.17)的安排"></a>五一之后第二周(5.11-5.17)的安排</h2><p>重点js基础/Vue框架/Css/node</p><ul><li>Vuex模拟实现</li><li>手写一个简单的mvvm</li><li>BFC 以及 清除浮动以及原理</li><li>闭包</li><li>观察者模式</li><li>http1.x和http2.x</li></ul><a id="more"></a><h2 id="Vuex源码以及模拟实现"><a href="#Vuex源码以及模拟实现" class="headerlink" title="Vuex源码以及模拟实现"></a>Vuex源码以及模拟实现</h2><h3 id="vuex的模拟实现"><a href="#vuex的模拟实现" class="headerlink" title="vuex的模拟实现"></a>vuex的模拟实现</h3><h2 id="手写简单的mvvm"><a href="#手写简单的mvvm" class="headerlink" title="手写简单的mvvm"></a>手写简单的mvvm</h2><p>使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"c"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./MVVM.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> mvvm = <span class="keyword">new</span> Mvvm(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      a: &#123;</span><br><span class="line">        b: 1</span><br><span class="line">      &#125;,</span><br><span class="line">      c: 2,</span><br><span class="line"><span class="actionscript">      message: <span class="string">'this is Message'</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'mvvm'</span>, mvvm);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>具体的实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创造一个实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mvvm</span>(<span class="params">options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$options = options</span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">this</span>._data = <span class="keyword">this</span>.$options.data</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 数据劫持</span></span><br><span class="line">  observe(data)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//this 代理了 this._data</span></span><br><span class="line">  <span class="comment">// mvvm._data.a.b 相等于 mvvm.a.b</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._data[key] <span class="comment">// 访问this.a.b</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">        <span class="keyword">this</span>._data[key] = newValue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initComputed.call(this);     </span></span><br><span class="line">  <span class="comment">// 数据编译</span></span><br><span class="line">  <span class="keyword">new</span> Compile(options.el, <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据劫持 给所有对象增加set get方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observe</span>(<span class="params">data = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="comment">// 给对象添加set get</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">    <span class="comment">// 把data属性通过defineProperty的方式定义属性</span></span><br><span class="line">    <span class="keyword">let</span> val = data[key];</span><br><span class="line">     <span class="comment">// 递归继续向下找，实现深度的数据劫持</span></span><br><span class="line">    observe(val);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="comment">// 将watcher添加到订阅事件中 [watcher]</span></span><br><span class="line">        Dep.target &amp;&amp; dep.addSub(Dep.target)</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val === newVal) <span class="keyword">return</span>;</span><br><span class="line">        val = newVal;</span><br><span class="line">        observe(newVal)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方便递归调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!val || <span class="keyword">typeof</span> val !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observe(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据编译</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compile</span>(<span class="params">el, vm</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将el挂载到实例上</span></span><br><span class="line">  vm.$el = <span class="built_in">document</span>.querySelector(el);</span><br><span class="line">  <span class="comment">// ?</span></span><br><span class="line">  <span class="keyword">let</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">  <span class="keyword">let</span> child</span><br><span class="line">  <span class="keyword">while</span>(child = vm.$el.firstChild) &#123;</span><br><span class="line">    fragment.appendChild(child)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child'</span>, child);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fragment'</span>, fragment);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对 el内容进行替换</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">frag</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Array</span>.from(frag.childNodes).forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> txt = node.textContent;</span><br><span class="line">      <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>;   <span class="comment">// 正则匹配&#123;&#123;&#125;&#125;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'node'</span>, node);</span><br><span class="line">      <span class="keyword">if</span> (node.nodeType === <span class="number">3</span> &amp;&amp; reg.test(txt)) &#123;</span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">replaceTxt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            node.textContent = txt.replace(reg, (matched, placeholder) =&gt; &#123;   </span><br><span class="line">              <span class="built_in">console</span>.log(placeholder);   <span class="comment">// 匹配到的分组 如：song, album.name, singer...</span></span><br><span class="line">              <span class="keyword">new</span> Watcher(vm, placeholder, replaceTxt);   <span class="comment">// 监听变化，进行匹配替换内容</span></span><br><span class="line">              <span class="keyword">return</span> placeholder.split(<span class="string">'.'</span>).reduce(<span class="function">(<span class="params">val, key</span>) =&gt;</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> val[key]; </span><br><span class="line">              &#125;, vm);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;;</span><br><span class="line">        <span class="comment">// 替换</span></span><br><span class="line">        replaceTxt();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.nodeType === <span class="number">1</span>) &#123;  <span class="comment">// 元素节点</span></span><br><span class="line">        <span class="keyword">let</span> nodeAttr = node.attributes; <span class="comment">// 获取dom上的所有属性,是个类数组</span></span><br><span class="line">        <span class="built_in">Array</span>.from(nodeAttr).forEach(<span class="function"><span class="params">attr</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> name = attr.name;   <span class="comment">// v-model  type</span></span><br><span class="line">            <span class="keyword">let</span> exp = attr.value;   <span class="comment">// c        text</span></span><br><span class="line">            <span class="keyword">if</span> (name.includes(<span class="string">'v-'</span>))&#123;</span><br><span class="line">                node.value = vm[exp];   <span class="comment">// this.c 为 2</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 监听变化</span></span><br><span class="line">            <span class="keyword">new</span> Watcher(vm, exp, <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">              node.value = newVal;   <span class="comment">// 当watcher触发时会自动将内容放进输入框中</span></span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            node.addEventListener(<span class="string">'input'</span>, e =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> newVal = e.target.value;</span><br><span class="line">                <span class="comment">// 相当于给this.c赋了一个新值</span></span><br><span class="line">                <span class="comment">// 而值的改变会调用set，set中又会调用notify，notify中调用watcher的update方法实现了更新</span></span><br><span class="line">                vm[exp] = newVal;   </span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果还有子节点，继续递归replace</span></span><br><span class="line">      <span class="keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">        replace(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 替换内容</span></span><br><span class="line">  replace(fragment);</span><br><span class="line">  vm.$el.appendChild(fragment); <span class="comment">// 文档碎片放到el元素中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发布订阅</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subs = []</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="comment">// 订阅就是放入subs</span></span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// this.subs数组里的每一项，都有一个update方法</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this.subs'</span>, <span class="keyword">this</span>.subs);</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听者</span></span><br><span class="line"><span class="comment">// 通过Watcher这个类创建的实例，都拥有update方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm, exp, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!vm &amp;&amp; !exp) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">this</span>.vm = vm;</span><br><span class="line">  <span class="keyword">this</span>.exp = exp;</span><br><span class="line">  <span class="keyword">this</span>.fn = fn;</span><br><span class="line">  Dep.target = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> arr = exp.split(<span class="string">'.'</span>);</span><br><span class="line">  <span class="keyword">let</span> val = vm;</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;    <span class="comment">// 取值</span></span><br><span class="line">     val = val[key];     <span class="comment">// 获取到this.a.b，默认就会调用get方法</span></span><br><span class="line">  &#125;);</span><br><span class="line">  Dep.target = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype.update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// notify的时候值已经更改了</span></span><br><span class="line">  <span class="comment">// 再通过vm, exp来获取新的值</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="keyword">this</span>.exp.split(<span class="string">'.'</span>);</span><br><span class="line">  <span class="keyword">let</span> val = <span class="keyword">this</span>.vm;</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;    </span><br><span class="line">      val = val[key];   <span class="comment">// 通过get获取到新的值</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.fn(val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let watcher = new Watcher(() =&gt; console.log(111));  // </span></span><br><span class="line"><span class="comment">// let dep = new Dep();</span></span><br><span class="line"><span class="comment">// dep.addSub(watcher);    // 将watcher放到数组中,watcher自带update方法， =&gt; [watcher]</span></span><br><span class="line"><span class="comment">// dep.addSub(watcher);</span></span><br><span class="line"><span class="comment">// dep.notify();   //  111, 111</span></span><br></pre></td></tr></table></figure><p>yun….一头雾水，我太难了!!!</p><h2 id="BFC-以及-清除浮动以及原理"><a href="#BFC-以及-清除浮动以及原理" class="headerlink" title="BFC 以及 清除浮动以及原理"></a>BFC 以及 清除浮动以及原理</h2><p>BFC(block formatting context) 块级格式化上下文，用于决定块盒子(block box)的<em>布局及浮动</em>相互影响范围的一个区域，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p><h3 id="BFC创建触发条件"><a href="#BFC创建触发条件" class="headerlink" title="BFC创建触发条件"></a>BFC创建触发条件</h3><ul><li>根元素或其它包含它的元素；</li><li>浮动 (元素的float不为none)；</li><li>绝对定位元素 (元素的position为absolute或fixed)；</li><li>行内块inline-blocks(元素的 display: inline-block)；</li><li>表格单元格(元素的display: table-cell，HTML表格单元格默认属性)；</li><li>overflow的值不为visible的元素；</li><li>弹性盒 flex boxes (元素的display: flex或inline-flex)；<br>平常中，设置<code>overflow: hidden/scroll, float: right/left,position: absolute,display: flex/inline-flex;</code>即当前元素创建了一个BFC</li></ul><h3 id="BFC约束规则"><a href="#BFC约束规则" class="headerlink" title="BFC约束规则"></a>BFC约束规则</h3><ul><li>内部的盒会在垂直方向一个接一个排列（可以看作BFC中有一个的常规流）</li><li>处于同一个BFC中的元素相互影响，可能会发生外边距重叠(（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生重叠（塌陷），与方向无关。）)</li><li>每个元素的margin box的左边，与容器块border box的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</li><li>计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算</li><li>浮动盒区域不叠加到BFC上，(BFC区域不会与float的元素区域叠加)</li></ul><h3 id="BFC阔以解决的问题"><a href="#BFC阔以解决的问题" class="headerlink" title="BFC阔以解决的问题"></a>BFC阔以解决的问题</h3><ul><li>垂直外边距重叠问题</li><li>去除浮动 (BFC区域不会与float的元素区域叠加)</li><li>自适用两列布局（float + overflow）</li></ul><h3 id="实例中理解BFC的约束规则"><a href="#实例中理解BFC的约束规则" class="headerlink" title="实例中理解BFC的约束规则"></a>实例中理解BFC的约束规则</h3><ul><li><p>如何实现左侧宽度固定，右侧宽度自适应</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'box'</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'left'</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'right'</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>float + margin</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">10px</span> solid red;</span><br><span class="line">  <span class="attribute">background</span>: green;   </span><br><span class="line">  <span class="attribute">border</span>: <span class="number">3px</span> solid yellow;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;                    </span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">3px</span> solid black;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>:<span class="number">#888</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>float + calc</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left1</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: green;    <span class="comment">/* 绿色 */</span></span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right1</span>&#123;                        <span class="comment">/* 粉色 */</span></span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">200px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>float + overflow(BFC应用场景)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">background</span>: green; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right2</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>利用BFC约束规则第六点:浮动盒区域不叠加到BFC上，(BFC区域不会与float的元素区域叠加)</p></blockquote></li><li><p>最佳选择 flex</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  display: flex; // 触发BFC</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left3</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: green; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right3</span> &#123;</span><br><span class="line">  flex: 1; // flex-grow: 1;flex-shrink: 1;flex-basis: 0%;</span><br><span class="line">  <span class="selector-tag">background</span>: <span class="selector-tag">pink</span>;</span><br><span class="line">  <span class="selector-tag">outline</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">black</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>清除浮动主要有两种方式，分别是clear清除浮动和BFC清除浮动</p></li><li><p>clear清除浮动<br>底层原理是在被清除浮动的元素上边或者下边添加足够的清除空间;</p></li><li><p>浮动的三个特点很重要。</p></li></ul><ol><li>脱离文档流。</li><li>向左/向右浮动直到遇到父元素或者别的浮动元素。</li><li>浮动会导致父元素高度坍塌。</li></ol><ul><li>解决父元素高度坍塌的方式就是清除浮动，常规的方法是clear清除浮动和BFC清除浮动，推荐clearfix的方式</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 全浏览器通用的clearfix方案</span><br><span class="line">// 引入了zoom以支持IE6/7</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">" "</span>;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">  *zoom: 1; // 支持IE6/7</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/59b73d5bf265da064618731d" target="_blank" rel="noopener">学习 BFC (Block Formatting Context)</a></li><li><a href="https://www.jianshu.com/p/09bd5873bed4" target="_blank" rel="noopener">CSS中的浮动和清除浮动，梳理一下！</a></li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h2 id="http1-x和http2-x"><a href="#http1-x和http2-x" class="headerlink" title="http1.x和http2.x"></a>http1.x和http2.x</h2><h3 id="http1-x几大缺陷"><a href="#http1-x几大缺陷" class="headerlink" title="http1.x几大缺陷"></a>http1.x几大缺陷</h3><ul><li>规定客户端对同一域的并发连接最多只能2个(一般是2-8个)</li><li>线头阻塞(head of line block) 同一个连接中的请求，需要一个接一个串行发送和接收</li><li>基于文本协议，请求和响应头信息大，无法压缩</li><li>不能控制响应优先级，必须按照请求顺序响应</li><li>只能单向请求，客户端请求什么，服务器返回什么</li></ul><h3 id="Http2"><a href="#Http2" class="headerlink" title="Http2"></a>Http2</h3><p>HTTP2 的前身是 SPDY协议（一个 Google 主导推行的应用层协议，作为对 HTTP1 的增强）。HTTP2必须在维持原来 HTTP 的范式（不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段等等）前提下，实现突破性能限制，改进传输性能，实现<em>低延迟</em>和<em>高吞吐量</em>。</p><h3 id="Http2-特性"><a href="#Http2-特性" class="headerlink" title="Http2 特性"></a>Http2 特性</h3><ul><li>传输内容使用二进制协议</li><li>使用帧作为最小传输单位</li><li>多路复用</li><li>头压缩</li><li>服务器推送</li><li>优先级与依赖性</li><li>可重置</li><li>流量控制</li><li>HTTPS rfc 规范并没有要求 HTTP2 强制使用 TLS，但是目前世界所有浏览器和服务器实现都基于 HTTPS 来实现 HTTP2</li></ul><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>HTTP1.x 时代，无论是传输内容还是头信息，都是文本/ASCII编码的，虽然这有利于直接从请求从观察出内容，但是却使得想要实现并发传输异常困难（存在空格或其他字符，很难判断消息的起始和结束）。使用二进制传输可以避免这个问题，因为传输内容只有1和0，通过下面第二点的“帧”规范规定格式，即可轻易识别出不同类型内容。同时使用二进制有一个显而易见的好处是：更小的传输体积</p><h3 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h3><p> HTTP2 在维持原有 HTTP 范式的前提下，实现突破性能限制，改进传输性能，实现低延迟和高吞吐量的其中一个关键是：在应用层（HTTP2）和传输层（TCP or UDP）之间增加了二进制分帧层</p><h3 id="多路复用（Multiplexing）和流"><a href="#多路复用（Multiplexing）和流" class="headerlink" title="多路复用（Multiplexing）和流"></a>多路复用（Multiplexing）和流</h3><p>多路复用是解决 HTTP1.x 缺陷第一点（并发问题）和第二点（HOLB线头问题）的核心技术点</p><h3 id="头压缩"><a href="#头压缩" class="headerlink" title="头压缩"></a>头压缩</h3><p><em>HPACK</em>专门为头部压缩设计的算法，还被指定成单独的草案中。<br>HTTP2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送；通信期间几乎不会改变的通用键-值对（用户代理、可接受的媒体类型，等等）只需发送一次</p><h2 id="Http2-0优势"><a href="#Http2-0优势" class="headerlink" title="Http2.0优势"></a>Http2.0优势</h2><ul><li>更小的传输体积，更小或者省略重复的头消息</li><li>突破原有的 TCP 连接并发限制，使用一个 TCP 连接即可实现多请求并发，单链接也能减轻服务端的压力（更少的内存和 CPU 使用）</li><li>解决 HOLB 线头问题，慢的请求或者先发送的请求不会阻塞其他请求的返回</li><li>结合 CDN 提供实时性更高，延迟更低的内容分发代理服务，大大减少白屏时间</li><li>数据传输优先级可控，使网站可以实现更灵活和强大的页面控制</li><li>能在不中断 TCP 连接的情况下停止（重置）数据的发送</li></ul><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/5acccf966fb9a028d043c6ec" target="_blank" rel="noopener">HTTP2基本概念学习笔记</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> http </tag>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 前端重学(2)</title>
      <link href="/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-2/"/>
      <url>/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-2/</url>
      
        <content type="html"><![CDATA[<h2 id="五一之后第一周-5-6-5-9-的安排"><a href="#五一之后第一周-5-6-5-9-的安排" class="headerlink" title="五一之后第一周(5.6-5.9)的安排"></a>五一之后第一周(5.6-5.9)的安排</h2><ul><li>type 和 interface 区别</li><li>webpack中的externals配置使用</li><li>https和http协议的区别</li></ul><a id="more"></a><blockquote><p>ts语法强烈建议浏览<a href="https://www.tslang.cn/docs/handbook/interfaces.html" target="_blank" rel="noopener">官网</a>,英语理解力强的，阔推荐<a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">英文官网</a></p></blockquote><p>ts运行，本地tslint提示的各种报错有时真让人抓狂!!!(持续完善当中)</p><table><thead><tr><th>序列</th><th>提示</th><th align="center">描述</th></tr></thead><tbody><tr><td>1</td><td>Exceeds maximum line length of 150</td><td align="center">单行超150字符</td></tr><tr><td>2</td><td>expected an assignment or function call</td><td align="center">expected an assignment or function call</td></tr><tr><td>3</td><td>comment must start with a space</td><td align="center">// 注释应以空格开头</td></tr><tr><td>4</td><td>for (… in …) statements must be filtered with an if statement</td><td align="center">for in 循环体内应有if判断属性是否存在</td></tr><tr><td>5</td><td>Declaration of instance field not allowed after declaration of instance method. Instead, this should come at the beginning of the class/interface.</td><td align="center">class/interface的属性定义应放在方法前</td></tr><tr><td>6</td><td>Declaration of static method not allowed after declaration of instance method. Instead, this should come after instance fields.</td><td align="center">class/interface的静态方法定义应放在非静态方法前</td></tr><tr><td>7</td><td>Shadowed variable</td><td align="center">变量名重名</td></tr><tr><td>8</td><td>Missing radix parameter</td><td align="center">parseInt缺少转换基数，直接第二个参数为0即可</td></tr><tr><td>9</td><td>Class name must be in pascal case</td><td align="center">class类命名必须首字母大写</td></tr><tr><td>10</td><td>file should end with a newline</td><td align="center">文件末尾少个空行</td></tr><tr><td>11</td><td>Type ‘string’ is not assignable to type ‘number’</td><td align="center">接口规定的是number类型不是字符串类型</td></tr></tbody></table><blockquote><p>参考链接<a href="http://blog.dongsj.cn/20170715-team-review.html" target="_blank" rel="noopener">目前 Angular2 项目内的 TSLint 设置</a></p></blockquote><h2 id="ts中的type和interface区别"><a href="#ts中的type和interface区别" class="headerlink" title="ts中的type和interface区别"></a>ts中的type和interface区别</h2><p>interface 和 type interface 和 type 都可以用来定义一些复杂的类型结构，最很多情况下是通用的，最初我一直没能理解它们二者之间区别在哪里，后来发现，二者的区别在于：</p><ul><li>type 不能像 interface 那样合并，其在作用域内唯一</li><li>interface创建了一种新的类型，而 type 仅仅是别名，是一种引用；</li><li>如果 type 使用了 union operator （|） 操作符，则不能将 type implements 到 class 上；</li><li>如果 type 使用了 union（|） 操作符 ，则不能被用以 extends interface</li></ul><h2 id="interface阔以，type不行"><a href="#interface阔以，type不行" class="headerlink" title="interface阔以，type不行"></a>interface阔以，type不行</h2><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。</p><ul><li>优点一是可以对可能存在的属性进行预定义</li><li>优点二是可以捕获引用了不存在的属性时的错误<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Chart &#123;</span><br><span class="line">  Num: <span class="built_in">number</span>;</span><br><span class="line">  Type?: <span class="built_in">string</span>[];</span><br></pre></td></tr></table></figure><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3>初次创建的时候赋值，其他时候不允许再次赋值，在属性前用<code>readonly</code>指定<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  readonly x: <span class="built_in">number</span>;</span><br><span class="line">  readonly y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="额外属性检查"><a href="#额外属性检查" class="headerlink" title="额外属性检查"></a>额外属性检查</h3>当你不确定接口会有哪些其他的属性的时候，阔以用一个<code>字符串</code>索引签名<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  readonly x: <span class="built_in">number</span>;</span><br><span class="line">  readonly y: <span class="built_in">number</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Declaration-merging-type-不能像-interface-那样合并"><a href="#Declaration-merging-type-不能像-interface-那样合并" class="headerlink" title="Declaration merging, type 不能像 interface 那样合并"></a>Declaration merging, type 不能像 interface 那样合并</h3>接口阔以定义多次，而类型别名则不行<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> data &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> data &#123;</span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> serF: SearchFunc</span><br><span class="line">serF = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = source.search(subString);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配,这样也想<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> serF: SearchFunc</span><br><span class="line">serF = <span class="function"><span class="keyword">function</span>(<span class="params">sou: <span class="built_in">string</span>, sub: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = sou.search(sub);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可索引类型"><a href="#可索引类型" class="headerlink" title="可索引类型"></a>可索引类型</h3>索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> dataArray &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr:dataArray = [</span><br><span class="line">  <span class="string">'chen'</span>,</span><br><span class="line">  <span class="string">'peng'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>上面例子里，我们定义了dataArray接口，它具有索引签名。 这个索引签名表示了当用 <code>number</code> 去索引dataArray时会得到string类型的返回值。<blockquote><p>TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberDictionary &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  length: <span class="built_in">number</span>;    <span class="comment">// 可以，length是number类型</span></span><br><span class="line">  name: <span class="built_in">string</span>       <span class="comment">// 错误，`name`的类型与索引类型返回值的类型不匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><ul><li>实现接口<br>TypeScript也能够用它来明确的强制一个类去符合某种契约,用<code>implements</code>实现接口<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">    setTime(d: <span class="built_in">Date</span>); <span class="comment">// 在接口中描述一个方法，在类里实现它，如同下面的setTime方法一样：</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">    setTime(d: <span class="built_in">Date</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.currentTime = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>类静态部分与实例部分的区别<br>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名(new )去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</li></ul><p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只对其实例部分进行类型检查</span></span><br><span class="line"><span class="keyword">interface</span> ClockConstructor &#123;</span><br><span class="line">    <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockConstructor &#123;</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">    <span class="comment">// constructor存在于类的静态部分，所以不在检查的范围内</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口， ClockConstructor为构造函数所用和ClockInterface为实例方法所用。 为了方便我们定义一个构造函数 createClock，它用传入的类型创建实例。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数所用，这里用interface会报错？类的静态部分</span></span><br><span class="line"><span class="keyword">type</span> PerConstructor = <span class="keyword">new</span> (name: <span class="built_in">string</span>, age: <span class="built_in">number</span>) =&gt; PerInterface;</span><br><span class="line"><span class="comment">// 实例部分</span></span><br><span class="line"><span class="keyword">interface</span> PerInterface &#123;</span><br><span class="line">  sayName(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">ctor: PerConstructor, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>): <span class="title">PerInterface</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ctor(name, age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> P1Type <span class="keyword">implements</span> PerInterface &#123;</span><br><span class="line">  <span class="keyword">public</span> name!: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">public</span> age!: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`call sayName: <span class="subst">$&#123;(<span class="keyword">this</span> <span class="keyword">as</span> <span class="built_in">any</span>).name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为createPerson的第一个参数是PerConstructo类型，在createPerson(P1Type, 7, 32)里，会检查P1Type是否符合构造函数签名。</p><h4 id="访问修饰符：private、public、protected"><a href="#访问修饰符：private、public、protected" class="headerlink" title="访问修饰符：private、public、protected"></a>访问修饰符：private、public、protected</h4><ul><li>默认为public，public规定的属性必须在类的顶层</li><li>当成员被标记为private时，它就不能在声明它的类的外部访问</li><li>protected和private类似，但是，protected成员在派生类(子类)中可以访问。这是protected和privat最大的区别</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ClockInter &#123;</span><br><span class="line">  setTime(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ClockParent <span class="keyword">implements</span> ClockInter &#123;</span><br><span class="line">  <span class="keyword">public</span> currentTime!: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">protected</span> habit = <span class="string">'shufa'</span>; <span class="comment">// 受保护的属性</span></span><br><span class="line">  <span class="comment">// 限定于属性 在定义方法</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentTime = h</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> setTime() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'d'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出一个Clock 类 继承父类 并通过ClockInter实现接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Clock <span class="keyword">extends</span> ClockParent <span class="keyword">implements</span> ClockInter &#123;</span><br><span class="line">  <span class="keyword">public</span> currentTime!: <span class="built_in">any</span>;</span><br><span class="line">  <span class="comment">// 限定于属性 在定义方法</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>((<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime());</span><br><span class="line">    <span class="keyword">this</span>.currentTime = h</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> setTime() &#123;</span><br><span class="line">    <span class="comment">// 能访问受保护的属性 habit</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'d'</span>, <span class="keyword">this</span>.habit);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，Clock是一个 派生类，它派生自 ClockParent 基类，通过 extends关键字。 派生类通常被称作<em>子类</em>，基类通常被称作<em>超类</em>。<br>派生类包含了一个构造函数，它 必须调用 <em>super()</em>，它会执行基类的构造函数。 而且，在构造函数里访问 this的属性之前，我们 一定要调用 super()。 这个是TypeScript强制执行的一条重要规则。</p><blockquote><p>一个ts文件不能同时定义2个及以上的类？添加tslint.json中的规则即可</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"rules": &#123;</span><br><span class="line">  "max-classes-per-file": [</span><br><span class="line">    true,</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。主要<strong>type</strong>类型别名，也阔以继承，语法稍有不同</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape &#123;</span><br><span class="line">  sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> square = &#123;&#125; <span class="keyword">as</span> Square;</span><br><span class="line">square.color = <span class="string">'red'</span>;</span><br><span class="line">square.sideLength1 = <span class="number">10</span>;</span><br><span class="line">square.name = <span class="string">'cpp'</span></span><br></pre></td></tr></table></figure><p>也阔以继承多个接口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Shape2 &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, Shape2 &#123;</span><br><span class="line">  sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> square = &#123;&#125; <span class="keyword">as</span> Square;</span><br><span class="line">  square.color = <span class="string">'red'</span>;</span><br><span class="line">  square.name = <span class="string">'cpp'</span>;</span><br><span class="line">  square.sideLength = <span class="number">22</span></span><br></pre></td></tr></table></figure><h3 id="关键字implements有什么作用？"><a href="#关键字implements有什么作用？" class="headerlink" title="关键字implements有什么作用？"></a>关键字<code>implements</code>有什么作用？</h3><p>一句话即: 约束接口按照某种契约，举例说明</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implements的实现</span></span><br><span class="line"><span class="keyword">interface</span> ClockInter &#123;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  setTime(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInter &#123;</span><br><span class="line">  <span class="comment">// 如果age = '1111' Type 'string' is not assignable to type 'number'.</span></span><br><span class="line">  <span class="keyword">public</span> age = <span class="number">1111</span>;</span><br><span class="line">  <span class="comment">// !非空断言操作符 能确定变量一定不为空时使用</span></span><br><span class="line">  <span class="comment">// 非空断言操作符不会防止出现 null 或 undefined</span></span><br><span class="line">  <span class="keyword">public</span> currentTime!: <span class="built_in">any</span>;</span><br><span class="line">  <span class="comment">// 限定于属性 在定义方法</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentTime = h</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> setTime() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'d'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中ClockInter约束了age必须是数字类型，所以在通过ClockInter实现Clock这个类的时候，age必须按照接口定义的来约束。<br>如何引用这个<code>Clock</code>这个类呢，在<em>vue</em>文件直接import导入，然后new调用即可，如</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Clock &#125; <span class="keyword">from</span> <span class="string">'../../utils/implementsd2'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> HomeDem <span class="keyword">extends</span> Vue &#123;</span><br><span class="line">  <span class="keyword">private</span> person1: <span class="built_in">any</span> = <span class="string">''</span></span><br><span class="line">  <span class="keyword">private</span> mounted() &#123;</span><br><span class="line">    <span class="keyword">const</span> num =  (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line">    <span class="comment">// 创造一个实例并传入当前的时间戳</span></span><br><span class="line">    <span class="keyword">this</span>.person1 = <span class="keyword">new</span> Clock(num)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1'</span>, <span class="keyword">this</span>.person1);</span><br><span class="line">    <span class="keyword">this</span>.person1.setTime(num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Type类型别名"><a href="#Type类型别名" class="headerlink" title="Type类型别名"></a>Type类型别名</h3><p>type 会给一个类型起个新名字。 type 有时和 interface 很像，但是可以作用于原始值（基本类型），联合类型，元组以及其它任何你需要手写的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数所用，这里用interface会报错？</span></span><br><span class="line"><span class="keyword">type</span> PerConstructor = <span class="keyword">new</span> (name: <span class="built_in">string</span>, age: <span class="built_in">number</span>) =&gt; PerInterface;</span><br><span class="line"><span class="comment">// 实例所用</span></span><br><span class="line"><span class="keyword">interface</span> PerInterface &#123;</span><br><span class="line">  sayName(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>起别名不会新建一个类型 - 它创建了一个<code>新名字</code>来引用那个类型。给基本类型起别名通常没什么用，尽管可以做为文档的一种形式使用。</p><h3 id="interface-vs-type"><a href="#interface-vs-type" class="headerlink" title="interface vs type"></a>interface vs type</h3><ul><li><p>两者都可以用来描述对象或函数的类型，但是语法不同</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SetPoint = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">interface</span> SetPoint &#123;</span><br><span class="line">   (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tuple</span></span><br><span class="line"><span class="keyword">type</span> Data = [<span class="built_in">number</span>, <span class="built_in">string</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// dom</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">type</span> B = <span class="keyword">typeof</span> div;</span><br></pre></td></tr></table></figure></li><li><p>继承Extend<br>语法有所不同，interface继承用extends,type用 <em>&amp;</em> 继承</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PartialPointX = &#123; x: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="keyword">type</span> Point = PartialPointX &amp; &#123; y: <span class="built_in">number</span>; &#125;;</span><br></pre></td></tr></table></figure></li><li><p>class implements实现接口<br>类可以以相同的方式实现接口或类型别名。但是请注意，类和接口被认为是静态的。因此，它们不能实现/扩展命名联合类型的类型别名。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PartialPoint = &#123; x: <span class="built_in">number</span>; &#125; | &#123; y: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">FIXME:</span> can not implement a union type</span></span><br><span class="line"><span class="keyword">class</span> SomePartialPoint <span class="keyword">implements</span> PartialPoint &#123;</span><br><span class="line">  x: <span class="number">1</span>;</span><br><span class="line">  y: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>declaration mergeing</p></li></ul><p>与类型别名不同，接口可以定义多次，并将被视为单个接口(合并所有声明的成员)</p><ul><li>计算属性，生成映射类型<br>type 能使用 in 关键字生成映射类型，但 interface 不行。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Keys = <span class="string">"firstname"</span> | <span class="string">"surname"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DudeType = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> Keys]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test: DudeType = &#123;</span><br><span class="line">  firstname: <span class="string">"Pawel"</span>,</span><br><span class="line">  surname: <span class="string">"Grzybek"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="comment">//interface DudeType2 &#123;</span></span><br><span class="line"><span class="comment">//  [key in keys]: string</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>参考链接</p><ul><li><a href="https://www.tslang.cn/docs/handbook/interfaces.html" target="_blank" rel="noopener">tsHandBook</a></li><li><a href="https://juejin.im/post/5e889626f265da480c0315d8" target="_blank" rel="noopener">TypeScript 中 interface 和 type 使用区别介绍</a></li></ul><h2 id="webpack中的externals配置使用"><a href="#webpack中的externals配置使用" class="headerlink" title="webpack中的externals配置使用"></a>webpack中的externals配置使用</h2><h3 id="官网解释"><a href="#官网解释" class="headerlink" title="官网解释"></a>官网解释</h3><p>webpack 中的 externals 配置提供了不从 bundle 中引用依赖的方式。解决的是，所创建的 bundle 依赖于那些存在于用户环境(consumer environment)中的依赖。</p><p>意思是如果需要引用一个库，但是又不想让webpack打包（减少打包的时间），并且又不影响我们在程序中以CMD、AMD或者window/global全局等方式进行使用（一般都以import方式引用使用），那就可以通过配置externals;</p><h3 id="Vue项目中如何实践"><a href="#Vue项目中如何实践" class="headerlink" title="Vue项目中如何实践"></a>Vue项目中如何实践</h3><ul><li>在vue.config.js中更改<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">      config.externals = &#123;</span><br><span class="line">        echarts: <span class="string">'echarts'</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在<em>index.html</em>中引入vue.js,通过cdn方式或者本地资源引入都行</li></ul><h3 id="externals和libraryTarget的关系"><a href="#externals和libraryTarget的关系" class="headerlink" title="externals和libraryTarget的关系"></a>externals和libraryTarget的关系</h3><ul><li>libraryTarget配置如何暴露 library。如果不设置library,那这个library就不暴露。就相当于一个自执行函数</li><li>externals是决定的是以哪种模式去加载所引入的额外的包</li><li>libraryTarget决定了你的library运行在哪个环境，哪个环境也就决定了你哪种模式去加载所引入的额外的包。也就是说，externals应该和libraryTarget保持一致。library运行在浏览器中的，你设置externals的模式为commonjs，那代码肯定就运行不了了。</li><li>如果是应用程序开发，一般是运行在浏览器环境libraryTarget可以不设置，externals默认的模式是global，也就是以全局变量的模式加载所引入外部的库。</li></ul><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://www.jianshu.com/p/283b17d17b3c" target="_blank" rel="noopener">webpack 的externals配置</a></li></ul><h2 id="https和http协议的区别"><a href="#https和http协议的区别" class="headerlink" title="https和http协议的区别"></a>https和http协议的区别</h2><h3 id="HTTP和HTTPS的基本概念"><a href="#HTTP和HTTPS的基本概念" class="headerlink" title="HTTP和HTTPS的基本概念"></a>HTTP和HTTPS的基本概念</h3><p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，是http协议身披一层SSL(Secure Socket Layer，安全套阶 层)协议，SSL这层协议存在于应用层（http层）到TCP层之间:</p><p><strong>应用层(http) =&gt; ssl =&gt; TCP =&gt; IP</strong></p><p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><h3 id="HTTP缺点"><a href="#HTTP缺点" class="headerlink" title="HTTP缺点"></a>HTTP缺点</h3><ul><li>明文传输，私密信息已被窃取</li><li>无法验证通信者身份，可能存储伪装者(客户端和服务器)</li><li>http协议无法判断通信报文的完整性，通信报文在TCP/IP协议通信中可能会被篡改<br>http协议的缺点，只能是ssl协议来完成</li></ul><h3 id="HTTPS使用SSL（Secure-Scocket-Layer-，安全套阶层）和TLS-Transport-Layer-Secure，安全层传输协议-这两种协议。"><a href="#HTTPS使用SSL（Secure-Scocket-Layer-，安全套阶层）和TLS-Transport-Layer-Secure，安全层传输协议-这两种协议。" class="headerlink" title="HTTPS使用SSL（Secure Scocket Layer ，安全套阶层）和TLS(Transport Layer Secure，安全层传输协议)这两种协议。"></a>HTTPS使用SSL（Secure Scocket Layer ，安全套阶层）和TLS(Transport Layer Secure，安全层传输协议)这两种协议。</h3><p>IETF 以 SSL3.0 为基准，后又制定了 TLS1.0、TLS1.1 和TLS1.2。TSL 是以 SSL 为原型开发的协议，有时会统一称该协议 为 SSL。当前主流的版本是 SSL3.0 和 TLS1.0。由于 SSL1.0 协议在设计之初被发现出了问题，就没有实际投入 使用。SSL2.0 也被发现存在问题，所以很多浏览器直接废除了 该协议版本。</p><p><strong>HTTP + 认证 + 加密 + 完整性保护 = HTTPS</strong></p><h3 id="HTTPS和HTTP的区别主要如下："><a href="#HTTPS和HTTP的区别主要如下：" class="headerlink" title="HTTPS和HTTP的区别主要如下："></a>HTTPS和HTTP的区别主要如下：</h3><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl(Secure Scocket Layer 安全套阶层)加密传输协议。</p><p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者默认是80，后者默认是443。</p><p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h3 id="HTTPS优点"><a href="#HTTPS优点" class="headerlink" title="HTTPS优点"></a>HTTPS优点</h3><ul><li>seo方面<br>采用https的网站在搜索结果的排名中较高</li><li>安全性</li></ul><p>1.使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；<br>2.TTPS协议是由<em>SSL+HTTP</em>协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。<br>3.HTTPS是现行架构下最安全的解决方案，虽然不是<em>绝对安全</em>，但它大幅增加了中间人攻击的成本。</p><h3 id="HTTPS缺点"><a href="#HTTPS缺点" class="headerlink" title="HTTPS缺点"></a>HTTPS缺点</h3><ul><li><p>seo方面<br>使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电，此外，HTTPS协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响</p></li><li><p>经济方面</p></li></ul><p>1.ca证书需要费用<br>2.ssl证书需要绑定ip，不能在同一个IP上绑定多个域名<br>3.https连接缓存不如http高效，大流量网站不一定非要https<br>4.HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本</p><ul><li>使用ssl协议，处理速度会变得很慢<br>一种是指通信慢。另一种是指由于大量消耗CPU 及内存等资源，导致处理速度变慢。<br>由于https还需要做服务器/客户端加密以及解密处理，因此肯定会消耗CPU和内存等硬件资源。</li></ul><p>参考链接</p><ul><li><a href="http://www.mahaixiang.cn/internet/1233.html" target="_blank" rel="noopener">HTTP与HTTPS的区别</a></li><li><a href="https://juejin.im/post/5c1c9b50f265da616e4c695e" target="_blank" rel="noopener">前端面试http和https的区别</a></li><li><a href="https://juejin.im/post/5af3e002f265da0b7c074ada" target="_blank" rel="noopener">http与https的区别我真的知道吗</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> vue </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> vue </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 前端重学(1)</title>
      <link href="/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-1/"/>
      <url>/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-1/</url>
      
        <content type="html"><![CDATA[<p>五一假期安排</p><ul><li>防抖和节流函数</li><li>new 构造函数实例</li><li>手写apply</li><li>单例模式以及vue单组件</li><li>vue3的demo实现</li><li>继承</li></ul><a id="more"></a><h2 id="函数防抖和节流"><a href="#函数防抖和节流" class="headerlink" title="函数防抖和节流"></a>函数防抖和节流</h2><p>都阔以用于持续触发函数的优化中，防抖是，触发事件后n秒内，函数只能执行一次。如果在N秒内又重新触发，则需要重新计时开始。或者简洁点：连续触发的时候，只会执行一次。在停止N秒之后才能继续执行，典型的案例就是防止多次提交的按钮</p><p>而节流呢，是每间隔N秒，只执行一次。就像水龙头里的水，节流只能减缓水流，但事件依然会执行。频率变少了。典型案例是滚动scroll/resize事件</p><p>两者最大的区别就是节流是依然执行，可用于滚动事件。而防抖，如果一直在触发中，只有停下来的时候才会执行一次。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 防抖</span></span><br><span class="line"><span class="comment"> * @param fn </span></span><br><span class="line"><span class="comment"> * @param wait </span></span><br><span class="line"><span class="comment"> * @param immedate 是否立即执行 true 立即执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> debounce = <span class="function">(<span class="params">fn: <span class="built_in">any</span>, wait: <span class="built_in">number</span> = 1000, immedate: <span class="built_in">boolean</span> = <span class="literal">true</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self: <span class="built_in">any</span> = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">      clearTimeout(timeout)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (immedate) &#123;</span><br><span class="line">      <span class="keyword">const</span> callNow = !timeout</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        timeout = <span class="literal">null</span></span><br><span class="line">      &#125;, wait)</span><br><span class="line">      <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">        fn.apply(self, args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        fn.apply(self, args)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>防抖函数，主要是采用异步线程setTimeout进行延时执行,立即执行，是在触发事件的开始的时候就立即执行。而非立即执行版的防抖，就是执行完N秒之后，不触发事件才会执行<br>箭头函数没有自己的arguments,但是阔以通过命名参数的形式或者rest参数的形式传参</p></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖 非立即执行</span></span><br><span class="line">    <span class="keyword">const</span> DivD: <span class="built_in">any</span> = <span class="built_in">document</span>.getElementById(<span class="string">'Test'</span>)</span><br><span class="line">    DivD.addEventListener(<span class="string">'mousemove'</span>, debounce(<span class="keyword">this</span>.dataSetting, <span class="number">1000</span>, <span class="literal">false</span>), <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><blockquote><p>addEventListener的第二个参数实际上是debounce函数里return回的方法，let timeout = null 这行代码只在addEventListener的时候执行了一次 触发事件的时候不会执行，那么每次触发scroll事件的时候都会清除上次的延时器同时记录一个新的延时器，当scroll事件停止触发后最后一次记录的延时器不会被清除可以延时执行，这是debounce函数的原理</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 函数节流</span></span><br><span class="line"><span class="comment"> * @param fn 执行函数</span></span><br><span class="line"><span class="comment"> * @param wait 等待的时间</span></span><br><span class="line"><span class="comment"> * @param type 默认是1 时间戳版 2定时器版</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn: <span class="built_in">any</span>, wait: <span class="built_in">number</span> = 1000, <span class="keyword">type</span>: <span class="built_in">number</span> = 1</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> timeout: <span class="built_in">any</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 时间戳版</span></span><br><span class="line">      <span class="keyword">const</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">      <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">        fn.apply(context, args);</span><br><span class="line">        previous = now</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">type</span> ===<span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">// 定时器版</span></span><br><span class="line">      <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">        timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          timeout = <span class="literal">null</span></span><br><span class="line">          fn.apply(context, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>节流最大的特点就是减少事件的频率，可能由1毫秒到1000毫秒才能触发事件。事件依然会执行，频率变少。时间戳版和定时器版各有特色，都是满足一个假设条件才能执行事件，执行事件都是用apply绑定</p></blockquote><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节流 定时器版</span></span><br><span class="line"><span class="keyword">const</span> iframe4: <span class="built_in">any</span> = <span class="built_in">document</span>.getElementById(<span class="string">'Test4'</span>)</span><br><span class="line">iframe4.addEventListener(<span class="string">'mousemove'</span>, throttle(<span class="keyword">this</span>.dataSetting, <span class="number">1000</span>, <span class="number">2</span>), <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h2 id="new-构造函数和模拟实现"><a href="#new-构造函数和模拟实现" class="headerlink" title="new 构造函数和模拟实现"></a>new 构造函数和模拟实现</h2><h3 id="如何理解执行上下文"><a href="#如何理解执行上下文" class="headerlink" title="如何理解执行上下文"></a>如何理解执行上下文</h3><p>context主要指代码执行环境，分为</p><ul><li>全局执行环境</li><li>函数执行环境</li><li>eval执行环境</li></ul><p>每一段js代码执行，都会先创建一个上下文环境</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域其实可理解为该上下文中声明的 <em>变量和声明的作用范围</em>。可分为 块级作用域 和 函数作用域</p><h3 id="如何理解作用域链"><a href="#如何理解作用域链" class="headerlink" title="如何理解作用域链"></a>如何理解作用域链</h3><p>我们知道，我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含 父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。</p><p>由两部分组成:</p><ul><li>[[scope]]属性: 指向父级变量对象和作用域链，也就是包含了父级的[[scope]]和AO</li><li>AO: 自身活动对象<br>如此 [[scope]]包含[[scope]]，便自上而下形成一条 链式作用域。</li></ul><p>从当前环境向父级一层一层查找<em>变量</em>的过程</p><ul><li><a href="https://juejin.cn/post/6844903776512393224#heading-18" target="_blank" rel="noopener">参考链接</a></li></ul><h3 id="如何理解原型链"><a href="#如何理解原型链" class="headerlink" title="如何理解原型链"></a>如何理解原型链</h3><p>前期: 每个函数都有prototype属性，每个函数实例对象都有一个<strong>proto</strong>对象，而这个对象指向函数的protoType属性。<br>当我们访问实例对象的属性或者方法时，首先从自身构造函数中查找，如果没有就通过<em><strong>proto</strong></em>去原型上查找，这个查找的过程我们称之为原型链。</p><h3 id="new-做了哪些操作"><a href="#new-做了哪些操作" class="headerlink" title="new 做了哪些操作"></a>new 做了哪些操作</h3><p>1.创建了一个新对象<br>2.这个对象也就是构造函数中的this,阔以访问挂载在this上的任意属性<br>3.这个对象还能访问构造函数原型上的属性，需要将对象与构造函数链接起来<br>4.默认返回this，如果手动定义返回原始值不影响，返回对象需要正常处理</p><p>手动实现一个new 操作符</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 手动实现一个new操作符</span></span><br><span class="line"><span class="comment"> * @param &#123;Funtion&#125; Con 构造函数</span></span><br><span class="line"><span class="comment"> * @param &#123;Array&#125; args 参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Create = <span class="function">(<span class="params">Con: <span class="built_in">any</span>, ...args: <span class="built_in">any</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 验证构造函数是否是函数类型</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> Con !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'Create Function this first param must be a function'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 继承原型上的prototype属性,又称原型上继承</span></span><br><span class="line">  <span class="keyword">const</span> obj: <span class="built_in">any</span> = <span class="built_in">Object</span>.create(Con.prototype);</span><br><span class="line">  <span class="comment">// or obj.__proto__ = Con.prototype</span></span><br><span class="line">  <span class="comment">// or Object.setPrototypeOf(obj, Con.prototype)</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'constructor'</span>, Con);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'obj'</span>, obj);</span><br><span class="line">  <span class="comment">// 除去构造函数的其他参数</span></span><br><span class="line">  <span class="comment">// 生成新的对象会绑定到构造函数上this对象上，并且传入剩余的参数</span></span><br><span class="line">  <span class="keyword">const</span> res = Con.apply(obj, args)</span><br><span class="line">  <span class="comment">// 如果返回是对象就是对象,否则返回obj</span></span><br><span class="line">  <span class="comment">// 默认构造函数返回的是undefined</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">'object'</span> ? res : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="create说明"><a href="#create说明" class="headerlink" title="create说明"></a>create说明</h4><p>1.接受构造函数和其他参数<br>2.创建obj对象，同时继承构造函数的原型链上的属性和方法，所以我们通过 setPrototypeOf 将两者联系起来。这段代码等同于 <strong>obj.<strong>proto</strong> = Con.prototype</strong><br>3.生成新的对象会绑定到构造函数上this对象上，并且传入剩余的参数<br>4.返回值处理</p><p>用法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private mounted() &#123;</span><br><span class="line">  <span class="comment">// 箭头函数不能通过new关键字调用</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">this: any, name: any</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.habits = <span class="string">'Games'</span></span><br><span class="line">  &#125;</span><br><span class="line">  Person.prototype.age = <span class="number">30</span>;</span><br><span class="line">  Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sayName: i am'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建person1实例</span></span><br><span class="line">  <span class="keyword">this</span>.person1 = <span class="keyword">new</span> (Person <span class="keyword">as</span> any)(<span class="string">'cpp'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'typeof'</span>, <span class="keyword">typeof</span> Person);</span><br><span class="line">  <span class="comment">// 实例对象上的__proto__</span></span><br><span class="line">  <span class="comment">// console.log('__proto__', this.person1.__proto__);</span></span><br><span class="line">  <span class="comment">// console.log('prototype', Person.prototype);</span></span><br><span class="line">  <span class="comment">// 实例对象上的__proto__ 全等于 构造函数的原型</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'==='</span>,  <span class="keyword">this</span>.person1.__proto__ === Person.prototype);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'constructor'</span>, Person.prototype.constructor === Person);</span><br><span class="line">  <span class="keyword">this</span>.person1.sayName();</span><br><span class="line">  <span class="comment">// 模拟new的实现</span></span><br><span class="line">  <span class="keyword">const</span> person2 = Create(Person, <span class="string">'cpp222'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p2'</span>, person2.name);</span><br><span class="line">  person2.sayName()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟new简洁版</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Create</span>(<span class="params">Con, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个对象，继承构造函数上的原型属性</span></span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(Con.prototype);</span><br><span class="line">  <span class="comment">// 绑定到this上</span></span><br><span class="line">  <span class="keyword">const</span> res = Con.apply(obj, agrs)</span><br><span class="line">  <span class="keyword">return</span> res instanceOf <span class="string">'Object'</span> ? res : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="apply-amp-amp-call-amp-amp-bind-手动实现"><a href="#apply-amp-amp-call-amp-amp-bind-手动实现" class="headerlink" title="apply &amp;&amp; call &amp;&amp; bind()手动实现"></a>apply &amp;&amp; call &amp;&amp; bind()手动实现</h2><h3 id="call-用法"><a href="#call-用法" class="headerlink" title="call 用法"></a>call 用法</h3><blockquote><p>call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p></blockquote><p>说起来有点拗口，就是指定this值，调用某个函数<br>举例子:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar函数--this'</span>, <span class="keyword">this</span>); <span class="comment">// &#123;value: 'chendapepeng'&#125; 指向foo</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar函数--this.value'</span>, <span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  value: <span class="string">'cpp'</span>,</span><br><span class="line">&#125;</span><br><span class="line">bar.call(foo, <span class="string">'chendapeng'</span>, <span class="number">30</span>); <span class="comment">// 执行bar函数，且传参</span></span><br></pre></td></tr></table></figure><p>注意两点：</p><ul><li>call 改变了<strong>this</strong>的指向，指向到 foo</li><li>bar 函数执行了</li></ul><h3 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h3><p>假设这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  value: <span class="string">'cpp'</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo.bar(); <span class="comment">// 'cpp'</span></span><br></pre></td></tr></table></figure><p>但是这样多了一个属性，但是阔以删除,大体分为这几步,简单版的myCall</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCall</span>(<span class="params">con</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> context = con || <span class="built_in">window</span>; <span class="comment">// 相当于foo</span></span><br><span class="line">  context.fn = <span class="keyword">this</span> <span class="comment">// foo.bar</span></span><br><span class="line">  context.fn()</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar函数--this'</span>, <span class="keyword">this</span>); <span class="comment">// &#123;value: 'chendapepeng'&#125; 指向foo</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar函数--this.value'</span>, <span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  value: <span class="string">'cpp'</span>,</span><br><span class="line">&#125;</span><br><span class="line">Funtion.prototype.myCall = myCall</span><br><span class="line">bar.myCall(foo)</span><br></pre></td></tr></table></figure><h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><p>call 函数还能给定参数执行函数,直接上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mockCall: <span class="function"><span class="keyword">function</span> (<span class="params">con, ...args</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> context = con || <span class="built_in">window</span>;</span><br><span class="line">   <span class="comment">// 首先获取调用call的函数，比如bar.call(foo),就是bar函数</span></span><br><span class="line">   context.fn = <span class="keyword">this</span>;</span><br><span class="line">   context.fn(...args)</span><br><span class="line">   <span class="comment">// 用完记得删除调用对象里的方法</span></span><br><span class="line">   <span class="keyword">delete</span> context.fn</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><p>bar函数阔以有返回值的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'bar函数--this'</span>, <span class="keyword">this</span>); <span class="comment">// &#123;value: 'chendapepeng'&#125; 指向foo</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'bar函数--this.value'</span>, <span class="keyword">this</span>.value);</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        value: <span class="keyword">this</span>.value,</span><br><span class="line">        name,</span><br><span class="line">        age</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> foo = &#123;</span><br><span class="line">      value: <span class="string">'cpp'</span>,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以最终版的就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mockCall: <span class="function"><span class="keyword">function</span> (<span class="params">con, ...args</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> context = con || <span class="built_in">window</span>;</span><br><span class="line">   <span class="comment">// 首先获取调用call的函数，比如bar.call(foo),就是bar函数</span></span><br><span class="line">   context.fn = <span class="keyword">this</span>;</span><br><span class="line">   <span class="keyword">const</span> res = context.fn(...args)</span><br><span class="line">   <span class="comment">// 用完记得删除调用对象里的方法</span></span><br><span class="line">   <span class="keyword">delete</span> context.fn</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><h3 id="bind实现"><a href="#bind实现" class="headerlink" title="bind实现"></a>bind实现</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 模拟bind</span></span><br><span class="line"><span class="comment"> * @param this 调用的方法</span></span><br><span class="line"><span class="comment"> * @param con 当前调用者，对象</span></span><br><span class="line"><span class="comment"> * @param args </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mockBind = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, con: <span class="built_in">any</span>, ...args: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log('mock__this', this);</span></span><br><span class="line">  <span class="comment">// console.log('mock__con', con);</span></span><br><span class="line">  <span class="keyword">const</span> context = con || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> fbound = <span class="function">(<span class="params">...bindArgs: <span class="built_in">any</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log('context', context);</span></span><br><span class="line">    self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> self ? <span class="keyword">this</span> : context, [...args, ...bindArgs])</span><br><span class="line">  &#125;</span><br><span class="line">  fbound.prototype = <span class="keyword">this</span>.prototype</span><br><span class="line">  <span class="keyword">return</span> fbound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue手动挂载组件"><a href="#Vue手动挂载组件" class="headerlink" title="Vue手动挂载组件"></a>Vue手动挂载组件</h2><p>本文主要有以下内容</p><ul><li><em>Vue.extend()</em></li><li><em>单例模式</em></li><li><em>Vue.use() 和 Vue.prototype.myFunction</em></li></ul><h3 id="挂载组件步骤"><a href="#挂载组件步骤" class="headerlink" title="挂载组件步骤"></a>挂载组件步骤</h3><p>在一些需求中，手动挂载组件能够让我们实现起来更加优雅。比如一个弹窗组件，最理想的用法是通过命令式调用，就像 elementUI 的 this.$message</p><h4 id="vue-extend"><a href="#vue-extend" class="headerlink" title="vue.extend()"></a>vue.extend()</h4><p>使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。预设了部分选项的vue实例构造器，返回一个组件构造器，用来生成组件，可以在实例上扩展方法，从而使用更灵活</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 创建构造器</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> Profile = Vue.extend(&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">  template: '<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123;firstName&#125;&#125;</span><span class="xml"> </span><span class="template-variable">&#123;&#123;lastName&#125;&#125;</span><span class="xml"> aka </span><span class="template-variable">&#123;&#123;alias&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span>',</span></span></span><br><span class="line"><span class="actionscript">  data: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      firstName: <span class="string">'Walter'</span>,</span></span><br><span class="line"><span class="actionscript">      lastName: <span class="string">'White'</span>,</span></span><br><span class="line"><span class="actionscript">      alias: <span class="string">'Heisenberg'</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="actionscript"><span class="comment">// 创建 Profile 实例，并挂载到一个app元素上。</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">new</span> Profile().$mount(<span class="string">'#app'</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Walter White aka Heisenberg<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Vue.extend创建的是一个Vue组件构造器，而不是一个具体的组件实例；里面预设了很多vue实例选项</p></blockquote><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>先看一个简单的例子<code>getSingle</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Anima: any = <span class="function"><span class="keyword">function</span>(<span class="params">this: any, name: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> AnimalSingle: any = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> instance: any = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">name: string</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">      <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">return</span> instance = <span class="keyword">new</span> Anima(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> AnimalSingle(<span class="string">'cat'</span>)</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="keyword">new</span> AnimalSingle(<span class="string">'dog'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'==='</span>, a1, a2, a1 === a2); <span class="comment">// Anima&#123;name: 'cat'&#125; Anima&#123;name: 'cat'&#125; true</span></span><br></pre></td></tr></table></figure><ul><li>使用闭包封装了instance私有变量并返回一个函数</li><li>利用 || 语法判断如果instance不存在则执行后者的实例化Anima方法，存在则直接返回instance，确保了只存在一个弹框实例<br>实现方式：使用一个变量存储类实例对象（值初始为 null/undefined ）。进行类实例化时，判断类实例对象是否存在，存在则返回该实例，不存在则创建类实例后返回。多次调用类生成实例方法，返回同一个实例对象。</li></ul><h3 id="构建属于自己的封装组件"><a href="#构建属于自己的封装组件" class="headerlink" title="构建属于自己的封装组件"></a>构建属于自己的封装组件</h3><p>用法，首先<em>main.ts</em>中全局引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Toast <span class="keyword">from</span> <span class="string">'./components/Toast/index'</span>;</span><br><span class="line"><span class="comment">// vue.use注册</span></span><br><span class="line"><span class="comment">// Vue.use(Toast);</span></span><br><span class="line">Vue.prototype.$toast = Toast;</span><br></pre></td></tr></table></figure><p>具体的组件用法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private showSuccess() &#123;</span><br><span class="line">  (<span class="keyword">this</span> <span class="keyword">as</span> any).$toast.success(&#123;</span><br><span class="line">    type: <span class="string">'success'</span>,</span><br><span class="line">    content: <span class="string">'这是测试tosat11'</span>,</span><br><span class="line">    duration: <span class="number">2000</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看看如何实现的，主要思路是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> toast <span class="keyword">from</span> <span class="string">'./toast.vue'</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="comment">// Vue.extend()生成一个Vue组件构造器函数，需要new一个实例才行</span></span><br><span class="line"><span class="keyword">const</span> ToastConstructor = Vue.extend(toast);</span><br><span class="line"><span class="keyword">let</span> instance: any = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> Toast: any = <span class="function">(<span class="params">options: any</span>) =&gt;</span> &#123;</span><br><span class="line">  instance = <span class="keyword">new</span> ToastConstructor(&#123;</span><br><span class="line">    data: options</span><br><span class="line">  &#125;).$mount();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'instance'</span>, instance); <span class="comment">// vueCopmponent vue组件实例</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(instance.$el)</span><br><span class="line">&#125;</span><br><span class="line">[<span class="string">'success'</span>, <span class="string">'error'</span>, <span class="string">'info'</span>].forEach(<span class="function">(<span class="params">type: any</span>) =&gt;</span> &#123;</span><br><span class="line">  Toast[type] = <span class="function">(<span class="params">options: any</span>) =&gt;</span> &#123;</span><br><span class="line">    options.type = type;</span><br><span class="line">    <span class="keyword">return</span> Toast(options);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Toast</span><br></pre></td></tr></table></figure><p>如果想在main.ts中Vue.use()引入的话，导出一个传递参数的<code>install</code>方法即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'success'</span>, <span class="string">'error'</span>, <span class="string">'info'</span>].forEach(<span class="function">(<span class="params">type: any</span>) =&gt;</span> &#123;</span><br><span class="line">  Toast[type] = <span class="function">(<span class="params">options: any</span>) =&gt;</span> &#123;</span><br><span class="line">    options.type = type;</span><br><span class="line">    <span class="keyword">return</span> Toast(options);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">...(上面的都一样，只需暴露一个install方法)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install: <span class="function">(<span class="params">vue</span>) =&gt;</span> &#123;</span><br><span class="line">    vue.prototype.$toast = Toast</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在main.ts中直接引入即可</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Toast <span class="keyword">from</span> <span class="string">'./components/Toast'</span></span><br><span class="line">Vue.use(Toast)</span><br></pre></td></tr></table></figure><p>为啥需要用use才能用，源码看了下，在GlobalAPI下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initUse</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// toast导出的是funtion类型</span></span><br><span class="line">  Vue.use = <span class="function"><span class="keyword">function</span> (<span class="params">plugin: <span class="built_in">Function</span> | <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> installedPlugins = (<span class="keyword">this</span>._installedPlugins || (<span class="keyword">this</span>._installedPlugins = []))</span><br><span class="line">    <span class="comment">// 判断当前的插件是否在installedPlugins集合里，如果有立马返回</span></span><br><span class="line">    <span class="comment">// 解释了多次使用Vue.use()只会运行一次</span></span><br><span class="line">    <span class="keyword">if</span> (installedPlugins.indexOf(plugin) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// additional parameters 额外的参数，像options</span></span><br><span class="line">    <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    args.unshift(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 如果插件有install，则绑定到plugin,并全传参</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin.install === <span class="string">'function'</span>) &#123;</span><br><span class="line">      plugin.install.apply(plugin, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">'function'</span>) &#123;</span><br><span class="line">      plugin.apply(<span class="literal">null</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    installedPlugins.push(plugin)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert an Array-like object to a real Array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toArray</span> (<span class="params">list, start</span>) </span>&#123;</span><br><span class="line">  start = start || <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> i = list.length - start;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="keyword">new</span> <span class="built_in">Array</span>(i);</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    ret[i] = list[i + start];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Vue.use(plugin)和Vue.prototype.$plugin = Plugin的区别<br>Vue.use(): 插件必须是一个对象，拥有install方法的对象，初始化插件必须有Vue.use()引入。同一个插件多次使用Vue.use()也只会运行一次。且vue.use()必须在new Vue()之前使用。<br>Vue.prototype.$plugin = Plugin: 在Vue组件构造器函数的原型上增加一个方法，运用的是函数原型的特性，即函数原型上的属性和方法，实例都能共享</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p> 与变量解构结合，并隐式返回<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Test1 = <span class="function">(<span class="params">&#123;value, num&#125;: any</span>) =&gt;</span> (&#123;<span class="attr">total</span>: value * num&#125;)</span><br><span class="line"><span class="keyword">const</span> res = Test1(&#123;</span><br><span class="line">  value: <span class="number">100</span>,</span><br><span class="line">  num: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'res'</span>, res);</span><br></pre></td></tr></table></figure><br> 与普通函数的区别</p><h3 id="没有this"><a href="#没有this" class="headerlink" title="没有this"></a>没有this</h3><p>箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值。因为箭头函数没有 this，所以也不能用 call()、apply()、bind() 这些方法改变 this 的指向</p><h3 id="没有arguments"><a href="#没有arguments" class="headerlink" title="没有arguments"></a>没有arguments</h3><p>但命名参数或者 rest 参数的形式访问参数:</p><h3 id="不能通过-new-关键字调用"><a href="#不能通过-new-关键字调用" class="headerlink" title="不能通过 new 关键字调用"></a>不能通过 new 关键字调用</h3><p>当通过 new 调用函数时，执行 <code>[[Construct]]</code> 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上。<br>箭头函数并没有 <code>[[Construct]]</code>方法，不能被用作构造函数，如果通过 new 的方式调用，会报错。<br>于是箭头函数也不存在 prototype 这个属性。</p><h3 id="无new-target"><a href="#无new-target" class="headerlink" title="无new.target"></a>无new.target</h3><p>因为不能使用 new 调用，所以也没有 new.target 值</p><h3 id="哪些场景下不能使用箭头函数"><a href="#哪些场景下不能使用箭头函数" class="headerlink" title="哪些场景下不能使用箭头函数"></a>哪些场景下不能使用箭头函数</h3><p>借鉴知乎大佬王仕军的文章，原文请移步<a href="https://zhuanlan.zhihu.com/p/26540168" target="_blank" rel="noopener">什么时候你不能使用箭头函数？</a></p><h4 id="定义对象里的方法"><a href="#定义对象里的方法" class="headerlink" title="定义对象里的方法"></a>定义对象里的方法</h4><p>在一个对象上，定义一个指向函数的属性，当方法被调用时，方法内的this指向方法所属的对象</p><ul><li><p>定义字面量方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calculator = &#123;</span><br><span class="line">  array: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  sum: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// =&gt; true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.array.reduce(<span class="function">(<span class="params">result, item</span>) =&gt;</span> result + item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="comment">// Throws "TypeError: Cannot read property 'reduce' of undefined"</span></span><br><span class="line">calculator.sum();</span><br></pre></td></tr></table></figure><p>calculator.sum 使用箭头函数来定义，但是调用的时候会抛出 TypeError，因为运行时 this.array 是未定义的，调用 calculator.sum 的时候，执行上下文里面的 this 仍然指向的是 window，原因是箭头函数把函数上下文绑定到了 window 上，this.array 等价于 window.array，显然后者是未定义的。<br>改造普通函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calculator = &#123;</span><br><span class="line">    array: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    sum() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === calculator); <span class="comment">// =&gt; true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.array.reduce(<span class="function">(<span class="params">result, item</span>) =&gt;</span> result + item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">calculator.sum(); <span class="comment">// =&gt; 6</span></span><br></pre></td></tr></table></figure></li><li><p>定义原型方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">any</span>, game: <span class="built_in">string</span> = 'cf'</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.habits = game</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.age = <span class="number">30</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'sayName: i am'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.person1 = <span class="keyword">new</span> (Person <span class="keyword">as</span> <span class="built_in">any</span>)(<span class="string">'cpp'</span>)</span><br></pre></td></tr></table></figure><p>使用传统的函数表达式就能解决问题</p></li></ul><h4 id="定义事件回调函数"><a href="#定义事件回调函数" class="headerlink" title="定义事件回调函数"></a>定义事件回调函数</h4><p>this 是 JS 中很强大的特性，可以通过多种方式改变函数执行上下文，JS 内部也有几种不同的默认上下文指向，但普适的规则是在谁上面调用函数 this 就指向谁，这样代码理解起来也很自然，读起来就像在说，某个对象上正在发生某件事情。</p><p>但是，箭头函数在声明的时候就绑定了执行上下文，要动态改变上下文是不可能的，在需要动态上下文的时候它的弊端就凸显出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'myButton'</span>);</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// =&gt; true</span></span><br><span class="line">    <span class="keyword">this</span>.innerHTML = <span class="string">'Clicked button'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>修正后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'myButton'</span>);</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === button); <span class="comment">// =&gt; true</span></span><br><span class="line">    <span class="keyword">this</span>.innerHTML = <span class="string">'Clicked button'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="定义构造函数"><a href="#定义构造函数" class="headerlink" title="定义构造函数"></a>定义构造函数</h4><p>构造新的 Person 实例时，JS 引擎抛了错误,tslint也直接给出了提示<code>An arrow function cannot have a &#39;this&#39; parameter</code>,还有<code>Property &#39;name&#39; does not exist on type &#39;Home&#39;</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person =  <span class="function">(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">any</span>, game: <span class="built_in">string</span> = 'cf'</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.habits = game</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.age = <span class="number">30</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'sayName: i am'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.person1 = <span class="keyword">new</span> (Person <span class="keyword">as</span> <span class="built_in">any</span>)(<span class="string">'cpp'</span>)</span><br></pre></td></tr></table></figure><p>改成普通函数即可</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="借助构造函数继承-经典继承"><a href="#借助构造函数继承-经典继承" class="headerlink" title="借助构造函数继承(经典继承)"></a>借助构造函数继承(经典继承)</h3><p>先看代码，Parent 是父类，Child 是子类。通过 Parent1.call(this, name)  改变了 this 指向，使子类继承了父类的属性，即 Child 也有了 name 属性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> extendConstructor() &#123;</span><br><span class="line">  <span class="keyword">const</span> Parent: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="string">'——this.name——'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> Child: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="comment">// 这里是重点</span></span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> p1 = <span class="keyword">new</span> Parent(<span class="string">'wmh'</span>);</span><br><span class="line">  <span class="keyword">const</span> c1 = <span class="keyword">new</span> Child(<span class="string">'cpp'</span>, <span class="number">30</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1,'</span>, p1);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'c1,'</span>, c1);</span><br><span class="line">  p1.sayName() <span class="comment">// wmh ——this.name——</span></span><br><span class="line">  c1.sayName() <span class="comment">// c1.sayName is not a function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点</p><ul><li>这种方式不能继承父类原型链上的属性，只能继承在父类显式声明的属性</li><li>方法都在构造函数中定义，每次创建实例都会创建一遍方法。</li></ul><h3 id="借助原型链实现继承"><a href="#借助原型链实现继承" class="headerlink" title="借助原型链实现继承"></a>借助原型链实现继承</h3><p>子类Child的原型属性等价于父类的一个实例，并且传参</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> extendPrototype() &#123;</span><br><span class="line">  <span class="keyword">const</span> Parent: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> Child: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//重点在这句</span></span><br><span class="line">  Child.prototype = <span class="keyword">new</span> Parent(<span class="string">'chendapeng'</span>)</span><br><span class="line">  <span class="keyword">const</span> p1 = <span class="keyword">new</span> Parent(<span class="string">'wmh'</span>);</span><br><span class="line">  <span class="keyword">const</span> c1 = <span class="keyword">new</span> Child(<span class="string">'cpp'</span>, <span class="number">30</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1,'</span>, p1);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'c1,'</span>, c1);</span><br><span class="line">  p1.sayName() <span class="comment">// wmh ——this.name——</span></span><br><span class="line">  c1.sayName() <span class="comment">// chendapeng ——this.name——</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类能继承父类的属性和方法<br>缺点:</p><ul><li>创建child类的时候，不能像Parent传参</li><li>子类创建的实例所在的原型链上的属性共享<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private extendPrototype() &#123;</span><br><span class="line">  <span class="keyword">const</span> Parent: any = <span class="function"><span class="keyword">function</span>(<span class="params">this: any, name: string, arr: any</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.arr = arr</span><br><span class="line">  &#125;</span><br><span class="line">  Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="string">'——this.name——'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> Child: any = <span class="function"><span class="keyword">function</span> (<span class="params">this: any, name: string, age: number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  Child.prototype = <span class="keyword">new</span> Parent(<span class="string">'chendapeng'</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">  <span class="keyword">const</span> p1 = <span class="keyword">new</span> Parent(<span class="string">'wmh'</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">  <span class="keyword">const</span> c1 = <span class="keyword">new</span> Child(<span class="string">'cpp'</span>, <span class="number">30</span>);</span><br><span class="line">  c1.arr.push(<span class="number">4</span>)</span><br><span class="line">  <span class="keyword">const</span> c2 = <span class="keyword">new</span> Child(<span class="string">'pp'</span>, <span class="number">99</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1,'</span>, p1.arr); [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'c1,'</span>, c1.arr); <span class="comment">// [1,2,3,4]</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'c2,'</span>, c2.arr); <span class="comment">// [1,2,3,4]</span></span><br><span class="line">  <span class="comment">// p1.sayName() // wmh ——this.name——</span></span><br><span class="line">  <span class="comment">// c1.sayName() // c1.sayName is not a function</span></span><br><span class="line">&#125;</span><br><span class="line">子类实例c1和c2上的arr属性都是从父类继承过来的，改了c1.arr属性,c2.arr也发生了变化</span><br></pre></td></tr></table></figure><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> extendTwo() &#123;</span><br><span class="line">   <span class="keyword">const</span> Parent: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.name = name</span><br><span class="line">     <span class="keyword">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   &#125;</span><br><span class="line">   Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="string">'——this.name——'</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">const</span> Child: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">     Parent.call(<span class="keyword">this</span>, name)</span><br><span class="line">     <span class="keyword">this</span>.age = age</span><br><span class="line">   &#125;</span><br><span class="line">   Child.prototype = <span class="keyword">new</span> Parent(<span class="string">'cpp'</span>)</span><br><span class="line">   <span class="keyword">const</span> c1 = <span class="keyword">new</span> Child(<span class="string">'wmh'</span>, <span class="number">22</span>);</span><br><span class="line">   c1.arr.push(<span class="number">5</span>)  </span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'c1'</span>, c1); <span class="comment">// [1,2,3, 5]</span></span><br><span class="line">   <span class="keyword">const</span> c2 = <span class="keyword">new</span> Child(<span class="string">'cpp'</span>, <span class="number">30</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'c2'</span>, c2); <span class="comment">// [1,2,3,</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3>ES5 <code>Object.create</code> 的模拟实现，将传入的对象作为创建的对象的原型。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">funtion createObj(o) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> vue </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> vue </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My First blog</title>
      <link href="/2020/07/05/My-First-blog/"/>
      <url>/2020/07/05/My-First-blog/</url>
      
        <content type="html"><![CDATA[<p>  感谢<a href="https://jerryc.me/posts/21cfbf15/" target="_blank" rel="noopener">Butterfly</a>提供的技术支持,希望自己也能参与到其，<br>  Jerryc个人博客有各种关于主题色彩的设置，<a href="https://demo.jerryc.me/posts/ceeb73f/#CDN" target="_blank" rel="noopener">请移步</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 主题 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/07/05/hello-world/"/>
      <url>/2020/07/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
