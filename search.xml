<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试基础:0514</title>
      <link href="/2021/05/14/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-0514/"/>
      <url>/2021/05/14/%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80-0514/</url>
      
        <content type="html"><![CDATA[<ul><li><p>对自己做过的事要有足够的了解和思考，特别是简历上提到的技术关键词，务必做到了然于心，做到熟悉源码的程度</p></li><li><p>对于常用的api不能仅限于使用层面上，分析源码是必须的</p></li><li><p>算法目标还是刷到100道，手写代码这块每天逼自己多写多练</p></li><li><p>心态方面吧，及时调整和沟通，多跟大佬们交流、学习</p></li><li><p>vue-router跟vuex怎么混入到vue实例中的</p></li><li><p>vue-directive指令的声明周期</p></li><li><p>requestAnimationFrame是怎么保证在宏任务里的执行顺序</p></li><li><p>304跟200的区别(304从缓存系统中返回数据，速度更快，如果没有名字协商缓存，需要从源服务器返回，响应慢)</p></li><li><p>ts中的高级用法源码是如何实现的，比如Picker</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Picker&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要刻意练习，加深理解</p></blockquote></li></ul><p>四场面试做个总结以及需要补充的点</p><ul><li><p>axios封装和分析源码(精简)</p></li><li><p>内存管理GC,新生代和老生代</p></li><li><p>异步编程方案，横向比较Promise/async/Generator</p></li><li><p>常用的loader和plugin源码分析</p></li><li><p>vue-router和vuex源码实现(精简)</p></li><li><p>项目部署相关</p></li></ul><h3 id="vue-router跟vuex怎么混入到vue实例中的"><a href="#vue-router跟vuex怎么混入到vue实例中的" class="headerlink" title="vue-router跟vuex怎么混入到vue实例中的"></a>vue-router跟vuex怎么混入到vue实例中的</h3><p>Vuex的双向绑定通过调用 new Vue实现，然后通过 Vue.mixin 注入到Vue组件的生命周期中，再通过劫持state.get将数据放入组件中</p><p>Vuex仅仅是Vue的一个插件。Vuex只能使用在vue上，因为其高度依赖于Vue的双向绑定和插件系统。<br>Vuex的注入代码比较简单，调用了一下applyMixin方法，现在的版本其实就是调用了Vue.mixin，在所有组件的 beforeCreate生命周期注入了设置 this.$store这样一个对象</p><h4 id="划重点：1行代码-Vue-mixin"><a href="#划重点：1行代码-Vue-mixin" class="headerlink" title="划重点：1行代码 Vue.mixin"></a>划重点：1行代码 Vue.mixin</h4><h4 id="划重点：重点就是一行代码resetStoreVM-this-state"><a href="#划重点：重点就是一行代码resetStoreVM-this-state" class="headerlink" title="划重点：重点就是一行代码resetStoreVM(this, state)"></a>划重点：重点就是一行代码resetStoreVM(this, state)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/store.js</span></span><br><span class="line"><span class="keyword">constructor</span> (options = &#123;&#125;) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    plugins = [],</span><br><span class="line">    strict = <span class="literal">false</span></span><br><span class="line">  &#125; = options</span><br><span class="line">  <span class="comment">// store internal state</span></span><br><span class="line">  <span class="keyword">this</span>._committing = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">this</span>._actions = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">this</span>._actionSubscribers = []</span><br><span class="line">  <span class="keyword">this</span>._mutations = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">this</span>._wrappedGetters = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">this</span>._modules = <span class="keyword">new</span> ModuleCollection(options)</span><br><span class="line">  <span class="keyword">this</span>._modulesNamespaceMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">this</span>._subscribers = []</span><br><span class="line">  <span class="keyword">this</span>._watcherVM = <span class="keyword">new</span> Vue()</span><br><span class="line">  <span class="keyword">const</span> store = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> &#123; dispatch, commit &#125; = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> state = <span class="keyword">this</span>._modules.root.state</span><br><span class="line">  <span class="comment">// init root module.</span></span><br><span class="line">  <span class="comment">// this also recursively registers all sub-modules</span></span><br><span class="line">  <span class="comment">// and collects all module getters inside this._wrappedGetters</span></span><br><span class="line">  installModule(<span class="keyword">this</span>, state, [], <span class="keyword">this</span>._modules.root)</span><br><span class="line">  resetStoreVM(<span class="keyword">this</span>, state)</span><br><span class="line">  <span class="comment">// apply plugins</span></span><br><span class="line">  plugins.forEach(<span class="function"><span class="params">plugin</span> =&gt;</span> plugin(<span class="keyword">this</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="new-Vue。通过-Vue自己的响应式系统注入"><a href="#new-Vue。通过-Vue自己的响应式系统注入" class="headerlink" title="new Vue。通过 Vue自己的响应式系统注入"></a>new Vue。通过 Vue自己的响应式系统注入</h4><p>resetStoreVM是什么呢</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetStoreVM</span> (<span class="params">store, state, hot</span>) </span>&#123;</span><br><span class="line">  store._vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      $$state: state</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: computed</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="当你再Vue中通过-this-如果调用-store的数据呢？"><a href="#当你再Vue中通过-this-如果调用-store的数据呢？" class="headerlink" title="当你再Vue中通过 this 如果调用 store的数据呢？"></a>当你再Vue中通过 this 如果调用 store的数据呢？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当获取state时，返回以双向绑定的$$sate</span></span><br><span class="line"><span class="keyword">var</span> prototypeAccessors$<span class="number">1</span> = &#123; <span class="attr">state</span>: &#123; <span class="attr">configurable</span>: <span class="literal">true</span> &#125; &#125;;</span><br><span class="line">prototypeAccessors$<span class="number">1.</span>state.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._vm._data.$$state</span><br><span class="line">&#125;;</span><br><span class="line">prototypeAccessors$<span class="number">1.</span>state.set = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((process.env.NODE_ENV !== <span class="string">'production'</span>)) &#123;</span><br><span class="line">    assert(<span class="literal">false</span>, <span class="string">"use store.replaceState() to explicit replace store state."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将state定义在原型中</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperties( Store.prototype, prototypeAccessors$<span class="number">1</span> );</span><br></pre></td></tr></table></figure><p>最终是通过<strong>this._vm._data.$$state</strong>来获取的</p><ul><li>vuex<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMixin</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> version = <span class="built_in">Number</span>(Vue.version.split(<span class="string">'.'</span>)[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">if</span> (version &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    Vue.mixin(&#123; <span class="attr">beforeCreate</span>: vuexInit &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// override init and inject vuex init procedure</span></span><br><span class="line">    <span class="comment">// for 1.x backwards compatibility.</span></span><br><span class="line">    <span class="keyword">var</span> _init = Vue.prototype._init;</span><br><span class="line">    Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ( options === <span class="keyword">void</span> <span class="number">0</span> ) options = &#123;&#125;;</span><br><span class="line">      options.init = options.init</span><br><span class="line">        ? [vuexInit].concat(options.init)</span><br><span class="line">        : vuexInit;</span><br><span class="line">      _init.call(<span class="keyword">this</span>, options);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Vuex init hook, injected into each instances init hooks list.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">vuexInit</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> options = <span class="keyword">this</span>.$options;</span><br><span class="line">    <span class="comment">// store injection</span></span><br><span class="line">    <span class="keyword">if</span> (options.store) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store = <span class="keyword">typeof</span> options.store === <span class="string">'function'</span></span><br><span class="line">        ? options.store()</span><br><span class="line">        : options.store;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">      <span class="comment">// Vue 实例才会具有 $store 属性，组件是没有的</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'mixin'</span>, options)</span><br><span class="line">      <span class="keyword">this</span>.$store = options.parent.$store;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>vue-router<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _Vue = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> install(Vue) &#123;</span><br><span class="line">    <span class="comment">// 1. 判断当前插件是否已安装</span></span><br><span class="line">    <span class="keyword">if</span> (VueRouter.install.installed) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    VueRouter.install.installed = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 2. 把 Vue 构造函数存储到全局变量中</span></span><br><span class="line">    _Vue = Vue;</span><br><span class="line">    <span class="comment">// 3. 把创建 Vue 实例时传入的 router 对象注入到所有 Vue 实例上</span></span><br><span class="line">    <span class="comment">// 混入</span></span><br><span class="line">    _Vue.mixin(&#123;</span><br><span class="line">      beforeCreate() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.$options.router) &#123;</span><br><span class="line">          _Vue.prototype.$router = <span class="keyword">this</span>.$options.router;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://juejin.cn/post/6844904062240948231#heading-1" target="_blank" rel="noopener">字节跳动面试官：请说一下vuex工作原理（重点就几行代码而已啦）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试积累: 0513</title>
      <link href="/2021/05/13/%E9%9D%A2%E8%AF%95%E7%A7%AF%E7%B4%AF-0513/"/>
      <url>/2021/05/13/%E9%9D%A2%E8%AF%95%E7%A7%AF%E7%B4%AF-0513/</url>
      
        <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>作用域</span><br><span class="line"><span class="number">2.</span>样式优先级</span><br><span class="line"><span class="number">3.</span>es5继承es6继承</span><br><span class="line"><span class="number">4.</span>http2<span class="number">.0</span>二进制分帧是怎么实现的，跟<span class="number">1.0</span>有什么区别</span><br><span class="line"><span class="number">5.</span>css动画</span><br><span class="line"><span class="number">6.</span>微任务和宏任务</span><br><span class="line"><span class="number">7.</span>plugin和loader区别</span><br><span class="line"><span class="number">8.</span>前序遍历/中序遍历/后序遍历以及应用场景</span><br><span class="line"><span class="number">9.</span>watcher跟computed属性区别</span><br><span class="line"><span class="number">10.</span>keep-alive</span><br><span class="line"><span class="number">11.</span>getBridge</span><br><span class="line"><span class="number">12.</span><span class="keyword">async</span>函数实现原理</span><br><span class="line"><span class="number">13.</span>异步方案都有哪些</span><br></pre></td></tr></table></figure><p>node层面的，<br>vite</p><!-- proxy --><p>简历吃透，</p><p>额外补充的有：</p><ul><li><p>hasOwnProperty和in操作符的区别<br>hasOwnProperty检测一个属性是否存在实例中还是存在原型中，返回值是true的时候存在实例对象中<br>in 无论该属性存在实例中还是原型对象中，只要存在对象中，都会返回true</p></li><li><p>repaint和reflow<br>重绘：<br>在改变DOM元素的视觉效果时触发，在不涉及任何排版布局的时候触发<br>触发场景： opactity/text-align/color/:hover/background-color<br>回流：<br>在某一个DOM元素位置发生变化时触发，而且会重新计算所有元素的位置和页面中的占有的面积，会影响所有的children/ancestiors/siblings<br>触发场景: 1.添加或者删除可见元素 2.元素位置改变 3.页面渲染器初始化 4.浏览器窗口尺寸改变</p></li><li><p>实现Array.from</p></li><li><p>es6/ts是怎么编译成es5的</p></li><li><p>dom树是怎么构建的</p></li><li><p>let/var/function</p><ul><li>let 的创建过程被提升了，初始化的时候没有提升</li><li>var的创建和初始化都被提升</li><li>function的创建、初始化、赋值都被提升</li></ul></li></ul><ul><li><p>this 几种绑定的优先级<br>new &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认<br>this是运行期间绑定，和它声明的环境无关，跟它调用的对象有关</p></li><li><p>xss攻击原理、分类、具体案例。前端如何防御</p></li><li><p>csrf攻击原理、具体案例，前端如何防御</p></li><li><p>Http劫持，页面劫持原理，防御措施</p></li><li><p>weakset跟set区别</p></li><li><p>es6 async函数的实现原理，就是Generator函数和自动执行器，包装在一个函数里</p></li><li><p>es6里的协程<br>Generator函数是协程在ES6的实现，最大特点就是交出函数的执行权（yield暂停执行）<br>协程是一种用户态的轻量级线程，协程的调度完全由用户控制，协程有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，所以上下文的切换非常快</p></li><li><p>前端工程化</p><ul><li>本地搭建</li><li>私服搭建</li><li>项目部署</li><li>lerna多包管理</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试积累: 0512</title>
      <link href="/2021/05/12/%E9%9D%A2%E8%AF%95%E7%A7%AF%E7%B4%AF-0512/"/>
      <url>/2021/05/12/%E9%9D%A2%E8%AF%95%E7%A7%AF%E7%B4%AF-0512/</url>
      
        <content type="html"><![CDATA[<p>0512面试积累</p><ul><li><p>新生代跟老生代区别</p></li><li><p>arr.some()//arr.find()模拟</p></li><li><p>事件委托(按钮点击之后，事件顺序)</p></li><li><p>treeShaking原理</p></li><li><p>ssr原理</p></li><li><p>前端工程化应用</p></li><li><p>node cluster集群</p></li><li><p>hmr原理</p></li><li><p>@import跟link区别</p></li><li><p>强缓存跟协商缓存，cache-control中的private跟public区别</p></li><li><p>jsBridge原理</p></li><li><p>esModule跟commonjs区别，互相引用的问题</p></li><li><p>keep-alive原理以及activated和deactivated专属</p></li><li><p>手写发布订阅模式</p></li><li><p><a href="https://juejin.cn/post/6844904153437700103#heading-2" target="_blank" rel="noopener">EventEmitter(发布订阅模式–简单版)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试积累: 0510</title>
      <link href="/2021/05/10/%E9%9D%A2%E8%AF%95%E7%A7%AF%E7%B4%AF-0510/"/>
      <url>/2021/05/10/%E9%9D%A2%E8%AF%95%E7%A7%AF%E7%B4%AF-0510/</url>
      
        <content type="html"><![CDATA[<blockquote><p>面试官问： 你知道axios是怎么取消请求的嘛？里面的源码是怎么设计的<br>面试官问: 你常用的loader是什么？了解过里面的源码吗</p></blockquote><p>要对自己用过的东西有足够的了解，这样才能在面试者应对自如。比如说项目是用vue-cli3搭建的，那你就要知道vue-cli3是如何搭建脚手架的，大体流程是什么？源码说说看，而我又一次倒在了源码层面，上面俩个面试题，我答的出来怎么用，但是源码是怎么实现的，我却不知道，很沮丧，接下来，给自己的任务就是</p><p><img src= "/img/loading.gif" data-src="/images/axios/3.jpg" alt="axios"></p><ul><li>熟知axios基本使用，了解其设计思想，挖掘核心</li><li>vue-loader/VueLoaderPlugin源码和设计</li><li>vue-cli3源码</li></ul><p>遇到的面试题主要还是常见的</p><ul><li>tcp三次握手和细节</li><li>前端性能优化，说出不一样的点</li><li>ts在你们项目是如何落地的</li><li>前端性能优化，说出亮点</li><li>Node Js，项目是如何部署的</li><li>如何优化目前的架构</li><li>单例模式设计</li><li>发布订阅模式应用</li><li>vuex源码</li><li>二分查找</li><li>元素距离中间css</li><li>Git rebase 和 Git pull区别</li><li>vue-router路由模式</li></ul><blockquote><p>最近好浮躁，上班干活没劲，特别无聊，应该是从年后到现在一直是这种状态，不过，在自己的严格要求下，本着不浪费生命的一分一秒原则，我都在做着有意义的事，明后天有两场重要的面试，希望自己能有好的发挥</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsBridge相关</title>
      <link href="/2021/05/09/jsBridge%E7%9B%B8%E5%85%B3/"/>
      <url>/2021/05/09/jsBridge%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>面试官问 js bridge 通信原理？不懂<br>JS Bridge 原理？有没有安全漏洞？</p></blockquote><p> <img src= "/img/loading.gif" data-src="/images/jsBridge/1.png" alt="js跟native"></p><h2 id="双向通信交互"><a href="#双向通信交互" class="headerlink" title="双向通信交互"></a>双向通信交互</h2><p>基本原理<br>WebViewJavaScriptBridge的基本原理简单来说就是，建立一个桥梁，然后注册自己，他人调用。</p><p><strong>把 OC 的方法注册到桥梁中，让 JS 去调用</strong><br><strong>把 JS 的方法注册在桥梁中，让 OC 去调用</strong></p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li><p>JS初始化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupWebViewJavascriptBridge</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">window</span>.WebViewJavascriptBridge) &#123; <span class="keyword">return</span> callback(WebViewJavascriptBridge); &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">window</span>.WVJBCallbacks) &#123; <span class="keyword">return</span> <span class="built_in">window</span>.WVJBCallbacks.push(callback); &#125;</span><br><span class="line">   <span class="built_in">window</span>.WVJBCallbacks = [callback]; <span class="comment">// 创建一个 WVJBCallbacks 全局属性数组，并将 callback 插入到数组中。</span></span><br><span class="line">   <span class="keyword">var</span> WVJBIframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>); <span class="comment">// 创建一个 iframe 元素</span></span><br><span class="line">   WVJBIframe.style.display = <span class="string">'none'</span>; <span class="comment">// 不显示</span></span><br><span class="line">   WVJBIframe.src = <span class="string">'wvjbscheme://__BRIDGE_LOADED__'</span>; <span class="comment">// 设置 iframe 的 src 属性</span></span><br><span class="line">   <span class="built_in">document</span>.documentElement.appendChild(WVJBIframe); <span class="comment">// 把 iframe 添加到当前文导航上。</span></span><br><span class="line">   setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">document</span>.documentElement.removeChild(WVJBIframe) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里主要是注册 OC 将要调用的 JS 方法。下面具体的交互操作会提到</span></span><br><span class="line">setupWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span>(<span class="params">bridge</span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="原生调用H5"><a href="#原生调用H5" class="headerlink" title="原生调用H5"></a>原生调用H5</h3><p>原生调用H5有2个步骤，首先是js要注入一个方法 testA 到桥梁中，其次是原生调用桥梁中的方法 testA</p></li><li><p>js要注入一个方法 testA 到桥梁中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 往桥梁中注入js方法a</span></span><br><span class="line">setupWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span>(<span class="params">bridge</span>)</span>&#123;</span><br><span class="line">   <span class="comment">// 声明 OC 需要调用的 JS 方法。</span></span><br><span class="line">   bridge.registerHanlder(<span class="string">'testA'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data,responseCallback</span>)</span>&#123;</span><br><span class="line">       <span class="comment">// data 是 OC 传递过来的数据.</span></span><br><span class="line">       <span class="comment">// responseCallback 是调用完毕之后传递给 OC 的数据</span></span><br><span class="line">       alert(<span class="string">"JS 被 OC 调用了."</span>);</span><br><span class="line">       responseCallback(&#123;<span class="attr">jsdata</span>: <span class="string">"js 的数据"</span>,<span class="attr">from</span> : <span class="string">"JS"</span>&#125;);</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>原生调用桥梁中的方法 testA</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[_jsBridge callHandler:@<span class="string">"testA"</span> data:@<span class="string">"传递给 JS 的参数"</span> responseCallback:^(id responseData) &#123;</span><br><span class="line">   NSLog(@<span class="string">"JS 的返回值: %@"</span>, responseData);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li></ul><h3 id="H5调用原生"><a href="#H5调用原生" class="headerlink" title="H5调用原生"></a>H5调用原生</h3><p>H5调用原生同样是两个步骤。注册自己，他人调用</p><ul><li>往桥梁中注入Oc的testB方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[_jsBridge registerHandler:@<span class="string">"testB"</span> handler:^(id data, WVJBResponseCallback responseCallback) &#123;</span><br><span class="line">   <span class="comment">// data 是 JS 传递过来的数据.</span></span><br><span class="line">   <span class="comment">// responseCallback 是调用完毕之后传递给 js 的数据</span></span><br><span class="line">   responseCallback(@<span class="string">"传给js的值"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li><li>JS调用桥梁中的testB方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WebViewJavascriptBridge.callHandler(<span class="string">'testB'</span>,&#123;<span class="attr">data</span> : <span class="string">"传给 OC 的入参"</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">dataFromOC</span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"JS 调用了 OC 的方法"</span>);</span><br><span class="line">  alert(<span class="string">'调用结束后OC返回给JS的数据：'</span>, dataFromOC);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3></li><li>ObjectC调js三种方式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单纯的调用 JSFunction，不往 JS 传递参数，也不需要 JSFunction 的返回值。</span></span><br><span class="line">[_jsBridge callHandler:@<span class="string">"a"</span>];</span><br><span class="line"><span class="comment">// 调用 JSFunction，并向 JS 传递参数，但不需要 JSFunciton 的返回值。</span></span><br><span class="line">[_jsBridge callHandler:@<span class="string">"a"</span> data:@<span class="string">"传给js的入参"</span>];</span><br><span class="line"><span class="comment">// 调用 JSFunction ，并向 JS 传递参数，也需要 JSFunction 的返回值。</span></span><br><span class="line">[_jsBridge callHandler:@<span class="string">"a"</span> data:@<span class="string">"传递给 JS 的参数"</span> responseCallback:^(id responseData) &#123;</span><br><span class="line">    NSLog(@<span class="string">"JS 的返回值: %@"</span>,responseData);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li><li>Js调用原生的三种方式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// JS 单纯的调用 OC 的 block</span></span><br><span class="line">WebViewJavascriptBridge.callHandler(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// JS 调用 OC 的 block，并传递 JS 参数</span></span><br><span class="line">WebViewJavascriptBridge.callHandler(<span class="string">'b'</span>,<span class="string">"JS 参数"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// JS 调用 OC 的 block，传递 JS 参数，并接受 OC 的返回值。</span></span><br><span class="line">WebViewJavascriptBridge.callHandler(<span class="string">'b'</span>,&#123;<span class="attr">data</span> : <span class="string">"这是 JS 传递到 OC 的数据"</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">dataFromOC</span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"JS 调用了 OC 的方法!"</span>);</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"returnValue"</span>).value = dataFromOC;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="Android端-跟-JS交互"><a href="#Android端-跟-JS交互" class="headerlink" title="Android端 跟 JS交互"></a>Android端 跟 JS交互</h2><h3 id="Native端调用JS"><a href="#Native端调用JS" class="headerlink" title="Native端调用JS"></a>Native端调用JS</h3><p>native调用js比较简单，只要遵循：”javascript: 方法名(‘参数,需要转为字符串’)”的规则即可。</p><p>使用以下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mWebView.evaluateJavascript(<span class="string">"javascript: 方法名('参数,需要转为字符串')"</span>, <span class="keyword">new</span> ValueCallback() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceiveValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//这里的value即为对应JS方法的返回值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>不适合传输大量数据(大量数据建议用接口方式获取)</li><li>mWebView.loadUrl(“javascript: 方法名(‘参数,需要转为字符串’)”);函数需在UI线程运行，因为mWebView为UI控件</li></ul><h3 id="Js调用Native端方法"><a href="#Js调用Native端方法" class="headerlink" title="Js调用Native端方法"></a>Js调用Native端方法</h3><p>要想js能够Native，需要对WebView设置以下属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WebSettings webSettings = mWebView.getSettings();  </span><br><span class="line"><span class="comment">// Android容器允许JS脚本</span></span><br><span class="line">webSettings.setJavaScriptEnabled(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// Android容器设置侨连对象</span></span><br><span class="line">mWebView.addJavascriptInterface(getJSBridge(), <span class="string">"JSBridge"</span>);</span><br></pre></td></tr></table></figure><p>这里我们看到了getJSBridge()，Native中通过addJavascriptInterface添加暴露出来的JS桥对象,然后再该对象内部声明对应的API方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getJSBridge</span><span class="params">()</span></span>&#123;  </span><br><span class="line">  Object insertObj = <span class="keyword">new</span> Object()&#123;  </span><br><span class="line">    <span class="meta">@JavascriptInterface</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">H5foo</span><span class="params">()</span></span>&#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="string">"H5foo"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@JavascriptInterface</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">H5foo2</span><span class="params">(<span class="keyword">final</span> String param)</span></span>&#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="string">"H5foo2:"</span> + param;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;;  </span><br><span class="line">  <span class="keyword">return</span> insertObj;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那Html端怎么调用Native端方法呢</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> JSBridge = <span class="built_in">window</span>.JSBridge</span><br><span class="line">JSBridge.call(<span class="string">'H5foo'</span>, &#123;&#125;, (value: string) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 原生回传给h5端信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="IOS端-跟-JS交互"><a href="#IOS端-跟-JS交互" class="headerlink" title="IOS端 跟 JS交互"></a>IOS端 跟 JS交互</h2><h3 id="Native端调JS"><a href="#Native端调JS" class="headerlink" title="Native端调JS"></a>Native端调JS</h3><p>Native调用js的方法比较简单，Native通过stringByEvaluatingJavaScriptFromString调用H5端绑定在window上的函数。不过应注意Oc和Swift的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Swift</span></span><br><span class="line">webview.stringByEvaluatingJavaScriptFromString(<span class="string">"H5方法名(参数)"</span>)</span><br><span class="line"><span class="comment">//OC</span></span><br><span class="line">[webView stringByEvaluatingJavaScriptFromString:@<span class="string">"H5方法名(参数);"</span>];</span><br></pre></td></tr></table></figure><p>优缺点</p><ul><li>Native调用JS方法时,能拿到JS方法的返回值</li><li>不适合传输大量数据(大量数据建议用接口方式获取)</li></ul><h3 id="JS调用Native端"><a href="#JS调用Native端" class="headerlink" title="JS调用Native端"></a>JS调用Native端</h3><p>Native中通过引入官方提供的<em>JavaScriptCore<em>库(iOS7以上),然后可以将api绑定到</em>JSContext上</em>(然后Html中JS默认通过* window.top.*可调用)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入官方的库文件</span></span><br><span class="line">#import &lt;JavaScriptCore/JavaScriptCore.h&gt;</span><br><span class="line"><span class="comment">// Native注册api函数(OC)</span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)webViewDidFinishLoad:(UIWebView *)webView&#123;</span><br><span class="line">    [self hideProgress];</span><br><span class="line">    [self setJSInterface];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)setJSInterface&#123;</span><br><span class="line">    JSContext *context =[_wv valueForKeyPath:@<span class="string">"documentView.webView.mainFrame.javaScriptContext"</span>];</span><br><span class="line">    <span class="comment">// 注册名为foo的api方法</span></span><br><span class="line">    context[@<span class="string">"H5foo"</span>] = ^() &#123;</span><br><span class="line">        <span class="comment">//获取参数</span></span><br><span class="line">        NSArray *args = [JSContext currentArguments];</span><br><span class="line">        NSString *title = [NSString stringWithFormat:@<span class="string">"%@"</span>,[args objectAtIndex:<span class="number">0</span>]];</span><br><span class="line">        <span class="comment">//返回一个值  'foo:'+title</span></span><br><span class="line">        <span class="keyword">return</span> [NSString stringWithFormat:@<span class="string">"H5foo:%@"</span>, title];</span><br><span class="line">    &#125;;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>H5端 中JS调用Native方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.top.H5foo(<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure><ul><li>说明</li><li>JS能调用到已经暴露的api,并且能得到相应返回值</li><li>iOS原生本身是无法被JS调用的,但是通过引入官方提供的第三方”JavaScriptCore”,即可开放api给JS调用</li></ul><h2 id="原生和h5-的另一种通讯方式：最广为流行的方法-JSBridge-桥协议"><a href="#原生和h5-的另一种通讯方式：最广为流行的方法-JSBridge-桥协议" class="headerlink" title="原生和h5 的另一种通讯方式：最广为流行的方法 JSBridge-桥协议"></a>原生和h5 的另一种通讯方式：最广为流行的方法 JSBridge-桥协议</h2><p> <img src= "/img/loading.gif" data-src="/images/jsBridge/2.png" alt="js跟native"></p><p>JSBridge 是广为流行的Hybrid 开发中JS和Native一种通信方式，简单的说，JSBridge就是定义Native和JS的通信，Native只通过一个固定的桥对象调用JS，JS也只通过固定的桥对象调用native，<br>基本原理是：</p><p>h5 –&gt; 通过某种方式触发一个url –&gt; native捕获到url，进行分析 –&gt;原生做处理 –&gt; native 调用h5的JSBridge对象传递回调</p><p>上面我们看到native已经和js实现通信，为什么还要通过url scheme 的这种jsBridge方法呢</p><ul><li>Android4.2 一下，addJavaScriptInterface方式有安全漏洞</li><li>ios7以下，js无法调用native</li><li>url scheme交互方式是一套现有的成熟方案，可以兼容各种版本</li></ul><h3 id="url-scheme-介绍"><a href="#url-scheme-介绍" class="headerlink" title="url scheme 介绍"></a>url scheme 介绍</h3><p>url scheme是一种类似于url的链接，是为了方便app直接互相调用设计的：具体为：可以用系统的 OpenURI 打开类似与url的链接（可拼入参数），然后系统会进行判断，如果是系统的 url scheme，则打开系统应用，否则找看是否有app注册中scheme，打开对应app，需要注意的是，这种scheme必须原生app注册后才会生效，如微信的scheme为 <strong>weixin://</strong></p><p>本文JSBridge中的url scheme则是仿照上述的形式的一种，具体位置app不会注册对应的scheme，而是由前端页面通过某种方式触发scheme（如用 iframe.src），然后native用某种方法捕获对应的url触发事件，然后拿到当前触发url，根据定好的协议(scheme://method…)，分析当前触发了哪种方法，然后根据定义来实现</p><h2 id="js调native三种方式"><a href="#js调native三种方式" class="headerlink" title="js调native三种方式"></a>js调native三种方式</h2><p>在H5中JavaScript调用Native的方式主要有一下几种</p><ul><li>注入API，注入Native对象或方法到JavaScript的window对象中（可以类比于RPC调用）。</li><li>拦截URL Scheme，客户端拦截WebView的请求并做相应的操作（可以类比于JSONP）</li><li>JSBridge</li></ul><h3 id="注入API"><a href="#注入API" class="headerlink" title="注入API"></a>注入API</h3><p>通过WebView提供的接口，向JavaScript的window中注入对象或方法(Android使用<strong>addJavascriptInterface(</strong>)方法)，让JavaScript调用时相当于执行相应的Native端的逻辑，达到JavaScript调用Native的效果。</p><ul><li><p>安卓核心代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">webView.addJavascriptInterface(<span class="keyword">new</span> InjectNativeObject(<span class="keyword">this</span>), <span class="string">"NativeBridge"</span>);</span><br><span class="line"><span class="comment">// 主要代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WebView webView;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectNativeObject</span> </span>&#123; <span class="comment">// 注入到JavaScript的对象</span></span><br><span class="line">        <span class="keyword">private</span> Context context;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InjectNativeObject</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.context = context;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@JavascriptInterface</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openNewPage</span><span class="params">(String msg)</span> </span>&#123; <span class="comment">// 打开新页面，接受前端传来的参数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@JavascriptInterface</span> <span class="comment">// 存在兼容性问题</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123; <span class="comment">// 退出app</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// JS注入</span></span><br><span class="line">       webView.addJavascriptInterface(<span class="keyword">new</span> InjectNativeObject(<span class="keyword">this</span>), <span class="string">"NativeBridge"</span>);</span><br><span class="line">       webView.loadUrl(String.format(<span class="string">"http://%s:3000/login_webview"</span>, host)); <span class="comment">// 加载Webview</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>H5端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.NativeBridge = <span class="built_in">window</span>.NativeBridge || &#123;&#125;; <span class="comment">// 注入的对象</span></span><br><span class="line"><span class="comment">// 登录按钮点击，调用注入的openNewPage方法，并传入相应的值</span></span><br><span class="line">loginButton.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.NativeBridge.openNewPage(accountInput.value + passwordInput.value);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 退出按钮点击，调用quit方法</span></span><br><span class="line">quitButton.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.NativeBridge.quit();</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="拦截URL-Scheme"><a href="#拦截URL-Scheme" class="headerlink" title="拦截URL Scheme"></a>拦截URL Scheme</h3><p>H5端通过iframe.src或localtion.href发送<strong>Url Schema</strong>请求，之后Native（Android端通过shouldOverrideUrlLoading()方法）拦截到请求的Url Scheme（包括参数等）进行相应的操作。<br>通俗点讲就是，H5发一个普通的http请求可能是: <em>daydream.com/?a=1&amp;b=1</em>， 而与客户端约定的JSBridge Url Schema可能是: <em>Daydream://jsBridgeTest/?data={a:1,b:2}</em>，客户端可以通过schema来区分是JSBridge调用还是普通的https请求从而做不同的处理。</p><p>其实现过程原理类似于JSONP</p><p>首先在H5中注入一个全局callback方法，放在window对象中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback_1</span>(<span class="params">data</span>) </span>&#123; </span><br><span class="line"><span class="built_in">console</span>.log(data); </span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">window</span>.callback_1 </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.callback_1 = callback_1;</span><br></pre></td></tr></table></figure><p>Native通过<strong>shouldOverrideUrlLoading(</strong>)，拦截到WebView的请求，并通过与前端约定好的Url Schema判断是否是JSBridge调用。<br>Native解析出前端带上的callback，并使用下面方式调用callback</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webView.loadUrl(<span class="built_in">String</span>.format(<span class="string">"javascript:callback_1(%s)"</span>, isChecked)); <span class="comment">// 可以带上相应的参数</span></span><br></pre></td></tr></table></figure><p>缺陷：使用URL Schema有一定的长度问题，url过长可能会导致丢失; 一次JSBridge调用耗时可能比较长，创建请求需要一定的时间。</p><h3 id="第三方框架使用getJsBridge"><a href="#第三方框架使用getJsBridge" class="headerlink" title="第三方框架使用getJsBridge"></a>第三方框架使用getJsBridge</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bridge = (<span class="built_in">window</span> <span class="keyword">as</span> any).getJsBridge()</span><br><span class="line">bridge.call(<span class="string">'原生上定义'</span>, (params: <span class="string">'H5传给原生的参数'</span>)， <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 拿到原生给的信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上通信都是单向通信交互</p><h2 id="native调js"><a href="#native调js" class="headerlink" title="native调js"></a>native调js</h2><p>Native 调用 JS 一般就是直接 JS 代码字符串，有些类似我们调用 JS 中的 eval 去执行一串代码比如<code>eval(&quot;alert(&#39;cpp&#39;)&quot;)</code>。一般有 <strong>loadUrl/evaluateJavascript</strong> 等几种方法，这里逐一介绍。<br>但是不管哪种方式，客户端都只能拿到挂载到 <strong>window 对象上面的属性和方法</strong>。</p><h2 id="其他相关问题"><a href="#其他相关问题" class="headerlink" title="其他相关问题"></a>其他相关问题</h2><h3 id="明明不是同一个语言，为什么-js-和-native-可以通信？"><a href="#明明不是同一个语言，为什么-js-和-native-可以通信？" class="headerlink" title="明明不是同一个语言，为什么 js 和 native 可以通信？"></a>明明不是同一个语言，为什么 js 和 native 可以通信？</h3><p>这就好像问，为什么JS能调用C++实现的原生方法。关键词，宿主环境。JS在Webview的宿主环境，而Webview在Android的宿主环境。所以通过Webview这个中间方就能通信。</p><h3 id="怎么判断-webview-是否加载完成？"><a href="#怎么判断-webview-是否加载完成？" class="headerlink" title="怎么判断 webview 是否加载完成？"></a>怎么判断 webview 是否加载完成？</h3><h3 id="怎么实现-h5-页面秒开"><a href="#怎么实现-h5-页面秒开" class="headerlink" title="怎么实现 h5 页面秒开"></a>怎么实现 h5 页面秒开</h3><p>webview预加载</p><h3 id="捕获url参数"><a href="#捕获url参数" class="headerlink" title="捕获url参数"></a>捕获url参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jso</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.keys(params).reduce(</span><br><span class="line">    (acc, curKey, arr) =&gt; acc + <span class="string">`<span class="subst">$&#123; curKey &#125;</span>=<span class="subst">$&#123; params[curKey] &#125;</span>&amp;`</span>, <span class="string">''</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">jso(&#123;</span><br><span class="line">name: <span class="string">'cpp'</span>,</span><br><span class="line">age: <span class="number">23</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// name=cpp&amp;age=23&amp;</span></span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://juejin.cn/post/6916316666208976904" target="_blank" rel="noopener">JS Bridge 通信原理与实践</a></li><li><a href="https://juejin.cn/post/6844904025511444493" target="_blank" rel="noopener">JSBridge原理浅析与实践</a></li><li><a href="https://cloud.tencent.com/developer/article/1038398" target="_blank" rel="noopener">JSBridge深度剖析</a></li><li><a href="https://juejin.cn/post/6847902218763534349" target="_blank" rel="noopener">写给前端工程师的JSBridge原理</a></li><li><a href="https://juejin.cn/post/6844904048236167176#heading-1" target="_blank" rel="noopener">H5与原生APP交互</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> jsBridge </category>
          
          <category> webview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jsBridge </tag>
            
            <tag> webview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue进阶10-keep-alive</title>
      <link href="/2021/05/04/vue%E8%BF%9B%E9%98%B610-keep-alive/"/>
      <url>/2021/05/04/vue%E8%BF%9B%E9%98%B610-keep-alive/</url>
      
        <content type="html"><![CDATA[<h2 id="lru-amp-浏览器缓存策略"><a href="#lru-amp-浏览器缓存策略" class="headerlink" title="lru &amp; 浏览器缓存策略"></a>lru &amp; 浏览器缓存策略</h2><p>浏览器中的缓存是一种在本地保存资源副本，它的大小是有限的，当我们请求数过多时，缓存空间会被用满，此时，继续进行网络请求就需要确定缓存中哪些数据被保留，哪些数据被移除，这就是浏览器缓存淘汰策略，最常见的淘汰策略有 FIFO（先进先出）、LFU（最少使用）、LRU（最近最少使用）。<br>LRU （ Least Recently Used ：最近最少使用 ）缓存淘汰策略，故名思义，就是根据数据的历史访问记录来进行淘汰数据，其核心思想是 如果数据最近被访问过，那么将来被访问的几率也更高 ，优先淘汰最近没有被访问到的数据。</p><h2 id="vue中的keep-alive"><a href="#vue中的keep-alive" class="headerlink" title="vue中的keep-alive"></a>vue中的keep-alive</h2><p><em>keep-alive</em> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <code>&lt;transition&gt;</code> 相似，<code>&lt;keep-alive&gt;</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。</p><p>当组件在 <code>&lt;keep-alive&gt;</code> 内被切换，它的 <strong>activated 和 deactivated</strong> 这两个生命周期钩子函数将会被对应执行。</p><p>vue内置组件，主要用于<strong>保留组件状态或避免重新渲染</strong>，主要使用如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 基本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 多个条件判断的子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">comp-a</span> <span class="attr">v-if</span>=<span class="string">"a &gt; 1"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp-a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">comp-b</span> <span class="attr">v-else</span>&gt;</span><span class="tag">&lt;/<span class="name">comp-b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 和 `&lt;transition&gt;` 一起使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果有上述的多个条件性的子元素，<keep-alive> 要求同时只有一个子元素被渲染</p></blockquote><p>最常用的两个属性：include 、 exculde ，用于组件进行有条件的缓存，可以用逗号分隔字符串、正则表达式或一个数组来表示。<br>在 2.5.0 版本中，keep-alive 新增了 max 属性，用于最多可以缓存多少组件实例，一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉，看，这里就应用了 LRU 算法。即在 keep-alive 中缓存达到 max，新增缓存实例会优先淘汰最近没有被访问到的实例，看下源码实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponentName</span> (<span class="params">opts: ?VNodeComponentOptions</span>): ?<span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> opts &amp;&amp; (opts.Ctor.options.name || opts.tag)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matches</span>(<span class="params">pattern, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(pattern)) &#123;</span><br><span class="line">    <span class="keyword">return</span> pattern.indexOf(name) &gt; <span class="number">-1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> pattern === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> pattern.split(<span class="string">','</span>).indexOf(name) &gt; <span class="number">-1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRegExp(pattern)) &#123;</span><br><span class="line">    <span class="keyword">return</span> pattern.test(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pruneCache</span>(<span class="params">keepAliveInstance, filter</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache = keepAliveInstance.cache;</span><br><span class="line">  <span class="keyword">var</span> keys = keepAliveInstance.keys;</span><br><span class="line">  <span class="keyword">var</span> _vnode = keepAliveInstance._vnode;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> cache) &#123;</span><br><span class="line">    <span class="keyword">var</span> cachedNode = cache[key];</span><br><span class="line">    <span class="keyword">if</span> (cachedNode) &#123;</span><br><span class="line">      <span class="keyword">var</span> name = getComponentName(cachedNode.componentOptions);</span><br><span class="line">      <span class="keyword">if</span> (name &amp;&amp; !filter(name)) &#123;</span><br><span class="line">        pruneCacheEntry(cache, key, keys, _vnode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缩减缓存入口 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pruneCacheEntry</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  cache,</span></span></span><br><span class="line"><span class="function"><span class="params">  key,</span></span></span><br><span class="line"><span class="function"><span class="params">  keys,</span></span></span><br><span class="line"><span class="function"><span class="params">  current</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cached$$<span class="number">1</span> = cache[key];</span><br><span class="line">  <span class="keyword">if</span> (cached$$<span class="number">1</span> &amp;&amp; (!current || cached$$<span class="number">1.</span>tag !== current.tag)) &#123;</span><br><span class="line">    cached$$<span class="number">1.</span>componentInstance.$destroy();</span><br><span class="line">  &#125;</span><br><span class="line">  cache[key] = <span class="literal">null</span>;</span><br><span class="line">  remove(keys, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除指定那个数组项，会改变原始数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length) &#123;</span><br><span class="line">    <span class="keyword">var</span> index = arr.indexOf(item);</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr.splice(index, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> patternTypes = [<span class="built_in">String</span>, <span class="built_in">RegExp</span>, <span class="built_in">Array</span>];</span><br><span class="line"><span class="keyword">var</span> KeepAlive = &#123;</span><br><span class="line">  name: <span class="string">'keep-alive'</span>,</span><br><span class="line">  abstract: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 三个props </span></span><br><span class="line">  props: &#123;</span><br><span class="line">    include: patternTypes,</span><br><span class="line">    exclude: patternTypes,</span><br><span class="line">    max: [<span class="built_in">String</span>, <span class="built_in">Number</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 组件生命周期</span></span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> <span class="title">created</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.keys = [];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  destroyed: <span class="function"><span class="keyword">function</span> <span class="title">destroyed</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> <span class="keyword">this</span>.cache) &#123;</span><br><span class="line">      <span class="comment">// 删除所有缓存</span></span><br><span class="line">      pruneCacheEntry(<span class="keyword">this</span>.cache, key, <span class="keyword">this</span>.keys);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  mounted: <span class="function"><span class="keyword">function</span> <span class="title">mounted</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">this</span>$<span class="number">1</span> = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 遍历 cache，如果缓存的节点名称与传入的规则没有匹配上的话，就把这个节点从缓存中移除</span></span><br><span class="line">    <span class="keyword">this</span>.$watch(<span class="string">'include'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      pruneCache(<span class="keyword">this</span>$<span class="number">1</span>, <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123; <span class="keyword">return</span> matches(val, name); &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.$watch(<span class="string">'exclude'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      pruneCache(<span class="keyword">this</span>$<span class="number">1</span>, <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123; <span class="keyword">return</span> !matches(val, name); &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> slot = <span class="keyword">this</span>.$slots.default;</span><br><span class="line">    <span class="keyword">var</span> vnode = getFirstComponentChild(slot);</span><br><span class="line">    <span class="keyword">var</span> componentOptions = vnode &amp;&amp; vnode.componentOptions;</span><br><span class="line">    <span class="keyword">if</span> (componentOptions) &#123;</span><br><span class="line">      <span class="keyword">var</span> name = getComponentName(componentOptions);</span><br><span class="line">      <span class="keyword">var</span> ref = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">var</span> include = ref.include;</span><br><span class="line">      <span class="keyword">var</span> exclude = ref.exclude;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// not included</span></span><br><span class="line">        (include &amp;&amp; (!name || !matches(include, name))) ||</span><br><span class="line">        <span class="comment">// excluded</span></span><br><span class="line">        (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span> vnode</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> ref$<span class="number">1</span> = <span class="keyword">this</span>; <span class="comment">// 当前组件实例 VueComponent</span></span><br><span class="line">      <span class="keyword">var</span> cache = ref$<span class="number">1.</span>cache;</span><br><span class="line">      <span class="keyword">var</span> keys = ref$<span class="number">1.</span>keys;</span><br><span class="line">      <span class="keyword">var</span> key = vnode.key == <span class="literal">null</span></span><br><span class="line">        <span class="comment">// same constructor may get registered as different local components</span></span><br><span class="line">        <span class="comment">// so cid alone is not enough (#3269)</span></span><br><span class="line">        ? componentOptions.Ctor.cid + (componentOptions.tag ? (<span class="string">"::"</span> + (componentOptions.tag)) : <span class="string">''</span>)</span><br><span class="line">        : vnode.key;</span><br><span class="line">      <span class="comment">// LRU核心</span></span><br><span class="line">      <span class="comment">// 如果命中缓存，则从缓存中获取 vnode 的组件实例，并且调整 key 的顺序放入 keys 数组的末尾</span></span><br><span class="line">      <span class="keyword">if</span> (cache[key]) &#123;</span><br><span class="line">        vnode.componentInstance = cache[key].componentInstance;</span><br><span class="line">        <span class="comment">// make current key freshest</span></span><br><span class="line">        remove(keys, key);</span><br><span class="line">        keys.push(key);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有命中缓存就把vnode放进缓存里</span></span><br><span class="line">        cache[key] = vnode;</span><br><span class="line">        keys.push(key);</span><br><span class="line">        <span class="comment">// prune oldest entry</span></span><br><span class="line">        <span class="comment">// 如果配置了max,且有key有值大于max,则移除第一个缓存</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.max &amp;&amp; keys.length &gt; <span class="built_in">parseInt</span>(<span class="keyword">this</span>.max)) &#123;</span><br><span class="line">          pruneCacheEntry(cache, keys[<span class="number">0</span>], keys, <span class="keyword">this</span>._vnode);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      vnode.data.keepAlive = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="number">0</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 keep-alive 缓存超过 max 时，使用的缓存淘汰算法就是 LRU 算法，它在实现的过程中用到了 cache 对象用于保存缓存的组件实例及 key 值，keys 数组用于保存缓存组件的 key ，当 keep-alive 中渲染一个需要缓存的实例时：</p><ul><li>判断缓存中是否已缓存了该实例，缓存了则直接获取，并调整 key 在 keys 中的位置（移除 keys 中 key ，并放入 keys 数组的最后一位）</li><li>如果没有缓存，则缓存该实例，若 keys 的长度大于 max （缓存长度超过上限），则移除 keys[0] 缓存</li></ul><h2 id="leetcode中的lru"><a href="#leetcode中的lru" class="headerlink" title="leetcode中的lru"></a>leetcode中的lru</h2><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p><p>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lru-cache" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lru-cache</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    private cache: <span class="built_in">Map</span>&lt;number, number&gt;</span><br><span class="line">    <span class="keyword">constructor</span>(private capacity: number = 0) &#123;</span><br><span class="line">        <span class="keyword">this</span>.cache = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span>(key: number): number &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.cache.has(key)) &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="keyword">this</span>.cache.get(key)</span><br><span class="line">          <span class="keyword">this</span>.cache.delete(key)</span><br><span class="line">          <span class="keyword">this</span>.cache.set(key, val)</span><br><span class="line">          <span class="keyword">return</span> val</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span> </span><br><span class="line">    &#125;</span><br><span class="line">    put(key: number, <span class="attr">value</span>: number): <span class="keyword">void</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.capacity === <span class="number">0</span>) <span class="keyword">return</span> </span><br><span class="line">        <span class="comment">// 存在, 移到最底下的位置，同时移除顶部的项</span></span><br><span class="line">        <span class="comment">// 不存在，则需要看是否超出capacity，如果没有超出，则塞到最底下 如果超出，仍然需要移除顶部的项</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.cache.has(key)) &#123;</span><br><span class="line">          <span class="keyword">this</span>.cache.delete(key)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.capacity  &lt;= <span class="keyword">this</span>.cache.size ) &#123;</span><br><span class="line">              <span class="keyword">let</span> oldKey = <span class="keyword">this</span>.cache.keys().next().value</span><br><span class="line">              <span class="keyword">this</span>.cache.delete(oldKey)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.cache.set(key, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new LRUCache(capacity)</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"> * obj.put(key,value)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>-<a href="https://juejin.cn/post/6844904116620099591" target="_blank" rel="noopener">前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法</a></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> keepAlive </category>
          
          <category> lru </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> keepAlive </tag>
            
            <tag> lru </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios封装与源码</title>
      <link href="/2021/05/03/axios%E5%B0%81%E8%A3%85%E4%B8%8E%E6%BA%90%E7%A0%81/"/>
      <url>/2021/05/03/axios%E5%B0%81%E8%A3%85%E4%B8%8E%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>明明之中，上天都有安排，我要是提前把这篇文章搞完，也不至于面试面得这么狼狈！！</p><h2 id="封装使用"><a href="#封装使用" class="headerlink" title="封装使用"></a>封装使用</h2><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.cn/post/6844903824583294984" target="_blank" rel="noopener">Axios 源码解析</a></li><li><a href="https://vue3js.cn/interview/vue/axios.html#%E4%B8%80%E3%80%81axios%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noopener">面试官：Vue项目中有封装过axios吗？主要是封装哪方面的</a></li><li><a href="https://vue3js.cn/interview/vue/axiosCode.html" target="_blank" rel="noopener">面试官：你了解axios的原理吗？有看过它的源码吗</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue3调试: 源码调试</title>
      <link href="/2021/05/03/vue3%E8%B0%83%E8%AF%95-%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95/"/>
      <url>/2021/05/03/vue3%E8%B0%83%E8%AF%95-%E6%BA%90%E7%A0%81%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-src="/images/vue/vue3.png" alt="vue3.0源码调试"></p><h2 id="vue2调试"><a href="#vue2调试" class="headerlink" title="vue2调试"></a>vue2调试</h2><p>在vue2.0版本调试的时候，本人是直接通过console里的提示，即在<em>node_modules\vue\dist\vue.runtime.esm.js</em>直接调试，由于是运行时版本，vue-loader转换之后的东西还得单独去找，像是css module里的<em>scoped</em>属性也是比较不太好定位，vue3.0感觉比2.0调试要方便点</p><h2 id="vue3-0调试"><a href="#vue3-0调试" class="headerlink" title="vue3.0调试"></a>vue3.0调试</h2><h3 id="One-Step-准备好俩个本地仓库"><a href="#One-Step-准备好俩个本地仓库" class="headerlink" title="One Step: 准备好俩个本地仓库"></a>One Step: 准备好俩个本地仓库</h3><p>一个文件夹下，放俩个文件，文件目录这样既可</p><ul><li>learnVue3<ul><li>vue-next</li><li>vue-study</li></ul></li></ul><h3 id="Two-Step-对刚新建的俩个项目初始化"><a href="#Two-Step-对刚新建的俩个项目初始化" class="headerlink" title="Two Step: 对刚新建的俩个项目初始化"></a>Two Step: 对刚新建的俩个项目初始化</h3><p><strong>vue-next</strong> git clone <a href="https://github.com/vuejs/vue-next.git" target="_blank" rel="noopener">https://github.com/vuejs/vue-next.git</a><br><strong>vue-study</strong> 是利用vue-cli生成的一个标准项目</p><h3 id="Three-Step-分别对俩个项目进行改造"><a href="#Three-Step-分别对俩个项目进行改造" class="headerlink" title="Three Step: 分别对俩个项目进行改造"></a>Three Step: 分别对俩个项目进行改造</h3><h4 id="vue-next"><a href="#vue-next" class="headerlink" title="vue-next"></a>vue-next</h4><ul><li><p>改造<em>package.json</em>，在script命令列表那dev后面加上<strong>–sourcemap</strong> 即： dev”: “node scripts/dev.js –sourcemap”,</p><blockquote><p>sourcemap 维护了前后代码映射关系的json描述文件</p></blockquote></li><li><p>本地执行yarn run dev 生成一个<em><a href="http://localhost:5000/packages/vue/dist/vue.global.js" target="_blank" rel="noopener">http://localhost:5000/packages/vue/dist/vue.global.js</a></em>文件，注意看文件位置和文件名，这个文件就是生成的vue文件，vue3.0由ts编写，最终跑的肯定还是js文件，这个文件会执行vue3中的几个核心代码库</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vue.global.js：Vue 完整代码（包含了runtime 跟 compiler ）。</span><br><span class="line">vue.global.js.map：vue.global.js 源码映射文件，提供给浏览器调试用。</span><br></pre></td></tr></table></figure></li><li><p>本地继续执行 <em>yarn run serve</em> 这个命令也很重要，一开始我以为，如果我改动yue源码，也就是<em>vue-next\packages</em>中的ts文件时，总不可能每次都要<em>yarn run dev</em>吧，这样太low了，后来看到还有一个server命令，rollup 会监听文件的改变自动编译打包，顿时就明白了，改动到源码位置，<em>yarn run dev</em>会重新执行tsc命令，生成全新的vue.global.js文件</p></li></ul><p>以上三步配置好，vue-next文件基本就改完了，记住<strong>vue.global.js文件</strong>位置</p><h4 id="vue-study"><a href="#vue-study" class="headerlink" title="vue-study"></a>vue-study</h4><p>只要俩步就好，本地跑起来，默认vue文件加载的是 node_modules 目录底下的 vue3.0 源码，不是我们在vue-next中生成的vue文件地址</p><ul><li>修改public/index.html文件，head里加上vue3源码的文件位置<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"http://localhost:5000/packages/vue/dist/vue.global.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li><li>修改vue.config.js文件，添加externals配置，执行本地的vue全局变量<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.externals = &#123;</span><br><span class="line">      vue: <span class="string">'Vue'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Four-Step-vue-study启动"><a href="#Four-Step-vue-study启动" class="headerlink" title="Four Step: vue-study启动"></a>Four Step: vue-study启动</h3>在<em>vue-study</em>启动npm run serve即可，即查看vue3.0源码</li></ul><h2 id="参考文件"><a href="#参考文件" class="headerlink" title="参考文件"></a>参考文件</h2><ul><li><a href="https://blog.csdn.net/vv_bug/article/details/111568951" target="_blank" rel="noopener">闲聊Vue3.0及2020年终总结</a></li><li><a href="https://vue3js.cn/start/" target="_blank" rel="noopener">Vue3 One Piece</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue3 </category>
          
          <category> vue3源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> vue3源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue进阶9-vuex</title>
      <link href="/2021/05/02/vue%E8%BF%9B%E9%98%B69-vuex/"/>
      <url>/2021/05/02/vue%E8%BF%9B%E9%98%B69-vuex/</url>
      
        <content type="html"><![CDATA[<h2 id="vue-router跟vuex-怎么混入到vue实例中的"><a href="#vue-router跟vuex-怎么混入到vue实例中的" class="headerlink" title="vue-router跟vuex 怎么混入到vue实例中的"></a>vue-router跟vuex 怎么混入到vue实例中的</h2><h2 id="面试官问：请说出vuex原理，实现一个mini版本的vuex"><a href="#面试官问：请说出vuex原理，实现一个mini版本的vuex" class="headerlink" title="面试官问：请说出vuex原理，实现一个mini版本的vuex"></a>面试官问：请说出vuex原理，实现一个mini版本的vuex</h2><h2 id="vuex是啥"><a href="#vuex是啥" class="headerlink" title="vuex是啥"></a>vuex是啥</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化<br>核心思想：通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    name: <span class="string">'cpp'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      state.name=<span class="string">'cpp + wmh'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终引用的时候</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'../store'</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function">(<span class="params">h</span>) =&gt;</span> h(app)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><h3 id="五个核心"><a href="#五个核心" class="headerlink" title="五个核心"></a>五个核心</h3><p>Vuex的5个核心属性是什么？<br>分别是 state、getters、mutations、actions、modules</p><h4 id="Vuex中要从state派生一些状态出来，且多个组件使用它，该怎么做"><a href="#Vuex中要从state派生一些状态出来，且多个组件使用它，该怎么做" class="headerlink" title="Vuex中要从state派生一些状态出来，且多个组件使用它，该怎么做?"></a>Vuex中要从state派生一些状态出来，且多个组件使用它，该怎么做?</h4><p>使用getter属性，相当Vue中的计算属性computed，只有原状态改变派生状态才会改变。<br>getter接收两个参数，第一个是state，第二个是getters(可以用来访问其他getter)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        price: <span class="number">10</span>,</span><br><span class="line">        number: <span class="number">10</span>,</span><br><span class="line">        discount: <span class="number">0.7</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        total: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> state.price * state.number</span><br><span class="line">        &#125;,</span><br><span class="line">        discountTotal: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> state.discount * getters.total</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后在组件中可以用计算属性computed通过this.$store.getters.total这样来访问这些派生转态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    total() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.total</span><br><span class="line">    &#125;,</span><br><span class="line">    discountTotal() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.discountTotal</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Getter-怎么通过getter来实现在组件内可以通过特定条件来获取state的状态？"><a href="#Getter-怎么通过getter来实现在组件内可以通过特定条件来获取state的状态？" class="headerlink" title="Getter 怎么通过getter来实现在组件内可以通过特定条件来获取state的状态？"></a>Getter 怎么通过getter来实现在组件内可以通过特定条件来获取state的状态？</h4><p>通过让getter返回一个函数，来实现给getter传参。然后通过参数来进行判断从而获取state中满足要求的状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">    getTodoById: <span class="function">(<span class="params">state</span>) =&gt;</span> <span class="function">(<span class="params">id</span>) =&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.find(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id === id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后在组件中可以用计算属性computed通过this.$store.getters.getTodoById(2)这样来访问这些派生转态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    getTodoById() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.getTodoById</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">mounted()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.getTodoById(<span class="number">2</span>))<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模块的命名空间"><a href="#模块的命名空间" class="headerlink" title="模块的命名空间"></a>模块的命名空间</h3><p>默认情况下，模块内部的action、mutation和getter是注册在全局命名空间，如果多个模块中action、mutation的命名是一样的，那么提交mutation、action时，将会触发所有模块中命名相同的mutation、action。<br>这样有太多的耦合，如果要使你的模块具有更高的封装度和复用性，你可以通过添加 <em>namespaced: true</em> 的方式使其成为带命名空间的模块。</p><blockquote><p>namespaced: true</p></blockquote><p>如果么有注册命名空间，dispatch 模块内的action怎么整？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state=&#123;</span><br><span class="line">  name: <span class="string">'a.js'</span>,</span><br><span class="line">  path: <span class="string">'./a.js'</span>,</span><br><span class="line">  moduleName: <span class="string">'AA'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations=&#123;</span><br><span class="line">  CHANGE_NAME: <span class="function">(<span class="params">state, name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a.js中的mutation'</span>)</span><br><span class="line">    state.name = <span class="string">'muatation: cpp-'</span> + name</span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'mutationA'</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> actions=&#123;</span><br><span class="line">  actionA: &#123;</span><br><span class="line">    root: <span class="literal">true</span>,</span><br><span class="line">    handler(context, data) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'context'</span>, context, data)</span><br><span class="line">      context.dispatch(<span class="string">'AllAction'</span>, <span class="string">'from a.js'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  AllAction(context, data) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'context a.js'</span>, context, data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  <span class="comment">// namespaced: true,</span></span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件中是这样触发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">changeAction() &#123;</span><br><span class="line">  <span class="keyword">this</span>.$store.dispatch(<span class="string">'AModule/AllAction'</span>, &#123;</span><br><span class="line">    data: <span class="string">'from Sort'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面会显示报错，<code>unknown action type: AModule/AllAction</code>,如果启用命名空间才不会报错，当然如果使用<em>createNamespacedHelpers</em>创建基于某个命名空间辅助函数，则更加高效</p><p>组件注册</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createNamespacedHelpers&#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">const</span> &#123;mapState, mapActions&#125; = createNamespacedHelpers(<span class="string">'AModule'</span>) <span class="comment">// 绑定AModule模块</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// vue组件</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  ...mapActions([</span><br><span class="line">    <span class="string">'AllAction'</span>,</span><br><span class="line">    <span class="string">'actionA'</span></span><br><span class="line">  ]),</span><br><span class="line">  changeAction() &#123;</span><br><span class="line">    <span class="keyword">this</span>.AllAction(&#123;</span><br><span class="line">      data: <span class="string">'from Soort 222'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="plugin插件"><a href="#plugin插件" class="headerlink" title="plugin插件"></a>plugin插件</h3><p>Vuex插件就是一个函数，它接收 store 作为唯一参数。在Vuex.Store构造器选项plugins引入。 在store/plugin.js文件中写入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createPlugin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">store</span> =&gt;</span> &#123;</span><br><span class="line">    store.subscribe(<span class="function">(<span class="params">mutation, state</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'subscribe'</span>, mutation)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'state'</span>, state)</span><br><span class="line">    &#125;),</span><br><span class="line">    store.subscribeAction(&#123;</span><br><span class="line">      before: <span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`before action <span class="subst">$&#123;action.type&#125;</span>`</span>, state)</span><br><span class="line">      &#125;,</span><br><span class="line">      after: <span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;<span class="comment">//提交action之后</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`after action <span class="subst">$&#123;action.type&#125;</span>`</span>, state)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在store/index.js文件中写入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> createPlugin <span class="keyword">from</span> <span class="string">'./plugin'</span></span><br><span class="line"><span class="keyword">const</span> myPlugin = <span class="keyword">new</span> createPlugin(&#123;<span class="attr">name</span>: <span class="string">'myPlugin'</span>&#125;) <span class="comment">// 支持传参</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [myPlugin],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.cn/post/6844903839015895047#heading-30" target="_blank" rel="noopener">前端工程师面试必备（持续更新中）</a></li><li><a href="https://juejin.cn/post/6844903993374670855#heading-12" target="_blank" rel="noopener">Vuex面试题汇总</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vuex </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue进阶8-vue3.0 Vs 2.0横向对比</title>
      <link href="/2021/05/02/vue%E8%BF%9B%E9%98%B68-vue3-0-Vs-2-0%E6%A8%AA%E5%90%91%E5%AF%B9%E6%AF%94/"/>
      <url>/2021/05/02/vue%E8%BF%9B%E9%98%B68-vue3-0-Vs-2-0%E6%A8%AA%E5%90%91%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同"><a href="#Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同" class="headerlink" title="Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同"></a>Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同</h2><h3 id="Options-Api"><a href="#Options-Api" class="headerlink" title="Options Api"></a>Options Api</h3><p>一、Options Api<br>Options API，即大家常说的选项API，即以vue为后缀的文件，通过定义methods，computed，watch，data等属性与方法，共同处理页面逻辑</p><h3 id="Composition-Api"><a href="#Composition-Api" class="headerlink" title="Composition Api"></a>Composition Api</h3><p>组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）</p><p>即使项目很大，功能很多，我们都能快速的定位到这个功能所用到的所有 API</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>下面对Composition Api与Options Api进行两大方面的比较<br>逻辑组织<br>逻辑复用</p><blockquote><p>组合优于继承</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>在逻辑组织和逻辑复用方面，Composition API是优于Options API</li><li>因为Composition API几乎是函数，会有更好的类型推断。</li><li>Composition API对 tree-shaking 友好，代码也更容易压缩</li><li>Composition API中见不到this的使用，减少了this指向不明的情况</li><li>如果是小型组件，可以继续使用Options API，也是十分友好的</li></ul><h2 id="Vue2-x和Vue3-x-diff算法分别说一下"><a href="#Vue2-x和Vue3-x-diff算法分别说一下" class="headerlink" title="Vue2.x和Vue3.x diff算法分别说一下"></a>Vue2.x和Vue3.x diff算法分别说一下</h2><h3 id="vue2-双端比较"><a href="#vue2-双端比较" class="headerlink" title="vue2 双端比较"></a>vue2 双端比较</h3><p>所谓双端比较就是新列表和旧列表两个列表的头与尾互相对比，，在对比的过程中指针会逐渐向内靠拢，直到某一个列表的开始节点大于结束节点的索引，对比停止。</p><h3 id="vue3-最长递增子序列"><a href="#vue3-最长递增子序列" class="headerlink" title="vue3 最长递增子序列"></a>vue3 最长递增子序列</h3><p>vue3.0diff核心算法</p><h2 id="Vue3-0性能提升"><a href="#Vue3-0性能提升" class="headerlink" title="Vue3.0性能提升"></a>Vue3.0性能提升</h2><h3 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h3><p>因此，Vue3在编译阶段，做了进一步优化。主要有如下：</p><h4 id="diff算法优化-PatchFlag-静态标记"><a href="#diff算法优化-PatchFlag-静态标记" class="headerlink" title="diff算法优化-PatchFlag(静态标记)"></a>diff算法优化-PatchFlag(静态标记)</h4><p>vue3在diff算法中相比vue2增加了静态标记flag,<br>在 Vue 3.0 中，对 diff 算法进行了优化，在创建虚拟 DOM 时，根据 DOM 内容是否会发生变化，而给予相对应类型的静态标记（PatchFlag）,下次发生变化的时候直接找该地方进行比较,其他静态写死的内容根本不用去比较</p><p><a href="https://vue-next-template-explorer.netlify.app/" target="_blank" rel="noopener">vue3模板编译网站</a></p><p>标记枚举类型如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="keyword">enum</span> PatchFlags &#123;</span><br><span class="line">  TEXT = <span class="number">1</span>,<span class="comment">// 动态的文本节点</span></span><br><span class="line">  CLASS = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,  <span class="comment">// 2 动态的 class</span></span><br><span class="line">  STYLE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,  <span class="comment">// 4 动态的 style</span></span><br><span class="line">  PROPS = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,  <span class="comment">// 8 动态属性，不包括类名和样式</span></span><br><span class="line">  FULL_PROPS = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,  <span class="comment">// 16 动态 key，当 key 变化时需要完整的 diff 算法做比较</span></span><br><span class="line">  HYDRATE_EVENTS = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,  <span class="comment">// 32 表示带有事件监听器的节点</span></span><br><span class="line">  STABLE_FRAGMENT = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,   <span class="comment">// 64 一个不会改变子节点顺序的 Fragment</span></span><br><span class="line">  KEYED_FRAGMENT = <span class="number">1</span> &lt;&lt; <span class="number">7</span>, <span class="comment">// 128 带有 key 属性的 Fragment</span></span><br><span class="line">  UNKEYED_FRAGMENT = <span class="number">1</span> &lt;&lt; <span class="number">8</span>, <span class="comment">// 256 子节点没有 key 的 Fragment</span></span><br><span class="line">  NEED_PATCH = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,   <span class="comment">// 512</span></span><br><span class="line">  DYNAMIC_SLOTS = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,  <span class="comment">// 动态 solt</span></span><br><span class="line">  HOISTED = <span class="number">-1</span>,  <span class="comment">// 特殊标志是负整数表示永远不会用作 diff</span></span><br><span class="line">  BAIL = <span class="number">-2</span> <span class="comment">// 一个特殊的标志，指代差异算法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HoistStatic-静态提升"><a href="#HoistStatic-静态提升" class="headerlink" title="HoistStatic 静态提升"></a>HoistStatic 静态提升</h4><p>Vue3中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用</p><p>这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用</p><h4 id="事件监听缓存"><a href="#事件监听缓存" class="headerlink" title="事件监听缓存"></a>事件监听缓存</h4><p>默认情况下 @click 事件被认为是动态变量，所以每次更新视图的时候都会追踪它的变化。但是正常情况下，我们的 @click 事件在视图渲染前和渲染后，都是同一个事件，基本上不需要去追踪它的变化，所以 Vue 3.0 对此作出了相应的优化叫事件监听缓存<br>Before</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; openBlock <span class="keyword">as</span> _openBlock, createBlock <span class="keyword">as</span> _createBlock &#125; <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (_openBlock(), _createBlock(<span class="string">"h1"</span>, &#123; <span class="attr">onClick</span>: _ctx.clickMsg &#125;, <span class="string">"111"</span>, <span class="number">8</span> <span class="comment">/* PROPS */</span>, [<span class="string">"onClick"</span>]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在未开启事件监听缓存的情况下，我们看到这串代码编译后被静态标记为 8，之前讲解过被静态标记的标签就会被拉去做比较，而静态标记 8 对应的是“动态属性，不包括类名和样式”。 @click 被认为是动态属性，所以我们需要开启 Options 下的 cacheHandler 属性<br>After</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; openBlock <span class="keyword">as</span> _openBlock, createBlock <span class="keyword">as</span> _createBlock &#125; <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (_openBlock(), _createBlock(<span class="string">"h1"</span>, &#123;</span><br><span class="line">    onClick: _cache[<span class="number">1</span>] || <span class="function">(<span class="params">_cache[<span class="number">1</span>] = (...args</span>) =&gt;</span> (_ctx.clickMsg &amp;&amp; _ctx.clickMsg(...args)))</span><br><span class="line">  &#125;, <span class="string">"111"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SSR优化</p><h3 id="源码体积"><a href="#源码体积" class="headerlink" title="源码体积"></a>源码体积</h3><p>相比Vue2，Vue3整体体积变小了，除了移出一些不常用的API,主要是通过Tree shanking实现</p><p>任何一个函数，如ref、reavtived、computed等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小</p><h3 id="响应式系统"><a href="#响应式系统" class="headerlink" title="响应式系统"></a>响应式系统</h3><p>vue2中采用 defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式<br>vue3采用proxy重写了响应式系统，因为proxy可以对整个对象进行监听，所以不需要深度遍历<br>可以监听动态属性的添加<br>可以监听到数组的索引和数组length属性<br>可以监听删除属性</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.cn/post/6844904134303301645#heading-13" target="_blank" rel="noopener">抄笔记：尤雨溪在Vue3.0 Beta直播里聊到了这些…</a></li><li><a href="https://juejin.cn/post/6844904134647234568" target="_blank" rel="noopener">尤大Vue3.0直播虚拟Dom总结(和React对比)</a></li><li><a href="https://juejin.cn/post/6903171037211557895" target="_blank" rel="noopener">Vue3教程：Vue 3.x 快在哪里？</a></li><li><a href="https://mp.weixin.qq.com/s/6vtqipkWQN6wUxmu9bXFZQ" target="_blank" rel="noopener">React、Vue2、Vue3的三种Diff算法</a></li><li><a href="https://vue3js.cn/interview/vue3/composition.html#%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D" target="_blank" rel="noopener">Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</a></li><li><a href="https://vue-next-template-explorer.netlify.com/" target="_blank" rel="noopener">Template Explorer</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue3.0 </category>
          
          <category> vue2.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3.0 </tag>
            
            <tag> vue2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络进阶: tcp/udp/dns/http等</title>
      <link href="/2021/04/30/%E7%BD%91%E7%BB%9C%E8%BF%9B%E9%98%B6-tcp-udp-dns-http%E7%AD%89/"/>
      <url>/2021/04/30/%E7%BD%91%E7%BB%9C%E8%BF%9B%E9%98%B6-tcp-udp-dns-http%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<p>网络协议很基础，基础到平时开发中，你说用到吧也能用到，你说用不到也是，基本上只要接口能通，后端能返回数据前端基本就完事了，但作为一枚合格的前端开发工程师，了解基本的网络通信大有裨益</p><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><h3 id="什么是-HTTP-队头阻塞？"><a href="#什么是-HTTP-队头阻塞？" class="headerlink" title="什么是 HTTP 队头阻塞？"></a>什么是 HTTP 队头阻塞？</h3><p>从前面的小节可以知道，HTTP 传输是基于<strong>请求-应答</strong>的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的<strong>HTTP队头阻塞</strong>问题。</p><h3 id="HTTP1-1-如何解决-HTTP-的队头阻塞问题？"><a href="#HTTP1-1-如何解决-HTTP-的队头阻塞问题？" class="headerlink" title="HTTP1.1 如何解决 HTTP 的队头阻塞问题？"></a>HTTP1.1 如何解决 HTTP 的队头阻塞问题？</h3><ul><li>并发连接<br>对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。</li><li>域名分片<br>一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。<br>比如 content1.sanyuan.com 、content2.sanyuan.com。<br>这样一个sanyuan.com域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。</li></ul><h3 id="HTTP-1-1的缺陷"><a href="#HTTP-1-1的缺陷" class="headerlink" title="HTTP/1.1的缺陷"></a>HTTP/1.1的缺陷</h3><p>1.高延迟–带来页面加载速度的降低<br>网络延迟问题主要由于队头阻塞(Head-Of-Line Blocking),导致带宽无法被充分利用。<br>队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。针对队头阻塞,人们尝试过以下办法来解决:</p><ul><li>域名分片 将同一页面的资源分散到不同域名下，提升连接上限。 Chrome有个机制，对于同一个域名，默认允许同时建立 6 个 TCP持久连接，使用持久连接时，虽然能公用一个TCP管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。另外如果在同一个域名下同时有10个请求发生，那么其中4个请求会进入排队等待状态，直至进行中的请求完成。</li><li>雪碧图 Spriting合并多张小图为一张大图,再用JavaScript或者CSS将小图重新“切割”出来的技术。</li><li>内联(Inlining)是另外一种防止发送很多小图请求的技巧，将图片的原始数据嵌入在CSS文件里面的URL里，减少网络请求次数。</li><li>拼接(Concatenation)将多个体积较小的JavaScript使用webpack等工具打包成1个体积更大的JavaScript文件,但如果其中1个文件的改动就会导致大量数据被重新下载多个文件。</li></ul><p>2.无状态特性–带来的巨大HTTP头部<br>header里携带的内容过大，在一定程度上增加了传输的成本。更要命的是，成千上万的请求响应报文里有很多字段值都是重复的，非常浪费。</p><p>3.明文传输–带来的不安全性<br>4.不支持服务端推送</p><h3 id="HTTP-2-新特性"><a href="#HTTP-2-新特性" class="headerlink" title="HTTP/2 新特性"></a>HTTP/2 新特性</h3><h4 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a>二进制传输</h4><p>HTTP/2传输数据量的大幅减少,主要有两个原因:以二进制方式传输和Header 压缩。我们先来介绍二进制传输,HTTP/2 采用二进制格式传输数据，而非HTTP/1.x 里纯文本形式的报文 ，二进制协议解析起来更高效。HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。</p><h4 id="Header-压缩"><a href="#Header-压缩" class="headerlink" title="Header 压缩"></a>Header 压缩</h4><p>HTTP/2并没有使用传统的压缩算法，而是开发了专门的”HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。</p><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>在 HTTP/2 中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。</p><p>在 HTTP/2 中，有了二进制分帧之后，HTTP /2 不再依赖 TCP 链接去实现多流并行了，在 HTTP/2中,</p><ul><li>同域名下所有通信都在单个连接上完成。</li><li>单个连接可以承载任意数量的双向数据流。</li><li>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</li></ul><p>这一特性，使性能有了极大提升：</p><ul><li>同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应,这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个TCP连接竞争带宽所带来的问题。</li><li>并行交错地发送多个请求/响应，请求/响应之间互不影响。</li><li>在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。</li></ul><h4 id="Server-Push"><a href="#Server-Push" class="headerlink" title="Server Push"></a>Server Push</h4><p>HTTP2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为”服务器推送”（ Server Push，也叫 Cache push）</p><h4 id="提高安全性"><a href="#提高安全性" class="headerlink" title="提高安全性"></a>提高安全性</h4><p>出于兼容的考虑，HTTP/2延续了HTTP/1的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。</p><p>但由于HTTPS已经是大势所趋，而且主流的浏览器Chrome、Firefox等都公开宣布只支持加密的HTTP/2，所以“事实上”的HTTP/2是加密的。也就是说，互联网上通常所能见到的HTTP/2都是使用”https”协议名，跑在TLS上面。HTTP/2协议定义了两个字符串标识符：“h2”表示加密的HTTP/2，“h2c”表示明文的HTTP/2。</p><h3 id="http3-0新特性"><a href="#http3-0新特性" class="headerlink" title="http3.0新特性"></a>http3.0新特性</h3><h4 id="1-HTTP-2-的缺点"><a href="#1-HTTP-2-的缺点" class="headerlink" title="1.HTTP/2 的缺点"></a>1.HTTP/2 的缺点</h4><p>主要是底层支撑的 TCP 协议造成的</p><ul><li>TCP 以及 TCP+TLS建立连接的延时</li><li>TCP的队头阻塞并没有彻底解决<br>上文我们提到在HTTP/2中，多个请求是跑在一个TCP管道中的。但当出现了丢包时，HTTP/2 的表现反倒不如 HTTP/1 了。因为TCP为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，HTTP/2出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该TCP连接中的所有请求（如下图）。而对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。</li></ul><h4 id="HTTP-3简介"><a href="#HTTP-3简介" class="headerlink" title="HTTP/3简介"></a>HTTP/3简介</h4><p>Google 在推SPDY的时候就已经意识到了这些问题，于是就另起炉灶搞了一个基于 UDP 协议的“QUIC”协议，让HTTP跑在QUIC上而不是TCP上。而这个“HTTP over QUIC”就是HTTP协议的下一个大版本，HTTP/3。它在HTTP/2的基础上又实现了质的飞跃，真正“完美”地解决了“队头阻塞”问题。</p><h4 id="QUIC新功能"><a href="#QUIC新功能" class="headerlink" title="QUIC新功能"></a>QUIC新功能</h4><p>上面我们提到QUIC基于UDP，而UDP是“无连接”的，根本就不需要“握手”和“挥手”，所以就比TCP来得快。此外QUIC也实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似HTTP/2的“流”和“多路复用”，单个“流”是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。具体来说QUIC协议有以下特点：</p><ul><li><p>实现了类似TCP的流量控制、传输可靠性的功能。<br>虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。</p></li><li><p>实现了快速握手功能<br>由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。</p></li><li><p>集成了TLS加密功能。<br>目前QUIC使用的是TLS1.3，相较于早期版本TLS1.3有更多的优点，其中最重要的一点是减少了握手所花费的RTT个数。</p></li><li><p>多路复用，彻底解决TCP中队头阻塞的问题<br>和TCP不同，QUIC实现了在<strong>同一物理连接</strong>上可以有多个独立的<strong>逻辑数据流</strong>（如下图）。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。<br><img src= "/img/loading.gif" data-src="/images/network/quic.jpg" alt="逻辑数据流"></p></li></ul><h3 id="如何理解-HTTP-的请求方法？"><a href="#如何理解-HTTP-的请求方法？" class="headerlink" title="如何理解 HTTP 的请求方法？"></a>如何理解 HTTP 的请求方法？</h3><h4 id="有哪些请求方法？"><a href="#有哪些请求方法？" class="headerlink" title="有哪些请求方法？"></a>有哪些请求方法？</h4><p>http/1.1规定了以下请求方法(注意，都是大写):</p><ul><li>GET: 通常用来获取资源</li><li>HEAD: 获取资源的元信息</li><li>POST: 提交数据，即上传数据</li><li>PUT: 修改数据</li><li>DELETE: 删除资源(几乎用不到)</li><li>CONNECT: 建立连接隧道，用于代理服务器</li><li>OPTIONS: 列出可对资源实行的请求方法，用来跨域请求</li><li>TRACE: 追踪请求-响应的传输路径</li></ul><h4 id="GET-和-POST-有什么区别？"><a href="#GET-和-POST-有什么区别？" class="headerlink" title="GET 和 POST 有什么区别？"></a>GET 和 POST 有什么区别？</h4><p>  从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。<br>  从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。<br>  从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。<br>  从幂等性的角度，GET是幂等的，而POST不是。(幂等表示执行相同的操作，结果也是相同的)<br>  从TCP的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)</p><h3 id="简要概括一下-HTTP-的特点？HTTP-有哪些缺点？"><a href="#简要概括一下-HTTP-的特点？HTTP-有哪些缺点？" class="headerlink" title="简要概括一下 HTTP 的特点？HTTP 有哪些缺点？"></a>简要概括一下 HTTP 的特点？HTTP 有哪些缺点？</h3><h4 id="HTTP-的特点概括如下"><a href="#HTTP-的特点概括如下" class="headerlink" title="HTTP 的特点概括如下:"></a>HTTP 的特点概括如下:</h4><ul><li>灵活可扩展，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。</li><li>可靠传输。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性</li><li>请求-应答。也就是一发一收、有来有回， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色</li><li>无状态。这里的状态是指通信过程的上下文信息，而每次 http 请求都是独立、无关的，默认不需要保留状态信息</li></ul><h4 id="http缺点"><a href="#http缺点" class="headerlink" title="http缺点"></a>http缺点</h4><ul><li>无状态<br>所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的无状态。</li></ul><p>在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。</p><p>但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。</p><ul><li>明文传输<br>即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。</li><li>队头阻塞问题<br>当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的队头阻塞问题</li></ul><h3 id="如何理解-HTTP-代理？"><a href="#如何理解-HTTP-代理？" class="headerlink" title="如何理解 HTTP 代理？"></a>如何理解 HTTP 代理？</h3><p>我们知道在 HTTP 是基于请求-响应模型的协议，一般由客户端发请求，服务器来进行响应。<br>当然，也有特殊情况，就是代理服务器的情况。引入代理之后，作为代理的服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应；而对于源服务器，表现为客户端发起请求，具有双重身份。</p><h2 id="http3"><a href="#http3" class="headerlink" title="http3"></a>http3</h2><h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><ul><li>客户端向服务器端发送https请求，通知服务端可支持的加密算法</li><li>服务端向客户端发送公钥和电子证书以及通知要是用的算法</li><li>客户端确认电子证书，验证公钥的有效性，是否过期，是否是对方web服务器所属(证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书(操作系统内置的Root证书或者Client内置的Root证书)</li><li>客户端利用伪随机数生成对称密钥，然后用公钥加密该对称加密中的密钥，发送给服务器端</li><li>服务端用自己的私钥解密，得到密钥，至此Client和Server双方都持有了相同的对称密钥</li><li>服务端Server使用对称密钥加密“明文内容A”，发送给Client。</li><li>Client使用对称密钥解密响应的密文，得到“明文内容A”。</li><li>Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B</li></ul><h2 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h2><p>三次握手和四次挥手仿佛是所有面试者挥之不去的阴影，说归说还是得去掌握</p><h3 id="TCP协议的基本操作"><a href="#TCP协议的基本操作" class="headerlink" title="TCP协议的基本操作"></a>TCP协议的基本操作</h3><p>如果一个Host主动向另一个host发起链接，称之为 SYN: synchroniation 请求同步<br>如果一个Host主动断开请求，称之为FIN: finish 请求完成</p><p>为了保持链接和可靠性约束，TCP协议要保证每一条发出的数据必须给返回</p><h3 id="三次握手和四次挥手涉及到的属于"><a href="#三次握手和四次挥手涉及到的属于" class="headerlink" title="三次握手和四次挥手涉及到的属于"></a>三次握手和四次挥手涉及到的属于</h3><ul><li>ack 确认号</li><li>seq 通讯初识序列号</li><li>ACK 代表响应，所有的消息都必须有响应，这是tcp确保稳定性的一环</li></ul><p>这里请你思考一个问题：稳定性要求数据无损地传输，也就是说拆包获得数据，又需要恢复到原来的样子。而在复杂的网络环境当中，即便所有的段是顺序发出的，也不能保证它们顺序到达，因此，发出的每一个 TCP 段都需要有序号。这个序号，就是 Sequence Number（Seq）。</p><blockquote><p>Sequence Number 和 Acknowledge Number 的设计，就非常巧妙地利用发送字节数和接收字节数解决了顺序的问题。</p></blockquote><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>  <img src= "/img/loading.gif" data-src="/images/network/three.png" alt="三次握手细节"></p><p>  1） Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号帧），这时候Client进入syn_sent状态，表示客户端等待服务器的回复</p><p>  2） Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1(x是来自客户端的seq)，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个帧），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号帧）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。</p><p>  3） Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个帧），Client自己的序号seq= x + 1（表示这就是我的第1个帧，相对于第0个帧来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。</p><p>  总结来说就是</p><ul><li>客户端向服务端发送SYN, Seq=x</li><li>服务端返回SYN,ACK,ack=x+1,seq=y</li><li>客户端发送ACK,ack=y+1,seq=x+1</li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>  <img src= "/img/loading.gif" data-src="/images/network/four.png" alt="四次挥手细节"></p><p>第一次挥手：Client将FIN置为1，发送一个序列号seq = p给Server；进入FIN_WAIT_1状态；<br>第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号p+1；进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。<br>第三次挥手：Server将FIN置1，发送一个序列号给Client:seq=q；同时把ack=p + 1, ACK=1 一起发给客户端，服务器进入LAST_ACK状态；<br>第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=序列号q+1 以及seq=p+1给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。</p><ul><li>总结来说就是</li><li>客户端向服务端发送FIN,seq=p</li><li>服务端向客户端返回ACK,ack=p+1</li><li>服务端向客户端返回FIN,seq=q</li><li>客户端向服务端发送ACK,ack=q+1,seq=p+1</li></ul><h3 id="客户端TIME-WAIT状态的意义是什么？"><a href="#客户端TIME-WAIT状态的意义是什么？" class="headerlink" title="客户端TIME_WAIT状态的意义是什么？"></a>客户端TIME_WAIT状态的意义是什么？</h3><p>第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。 MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><h3 id="TCP为啥要拆包和粘包"><a href="#TCP为啥要拆包和粘包" class="headerlink" title="TCP为啥要拆包和粘包"></a>TCP为啥要拆包和粘包</h3><p>在传输层封包不能太大。这种限制，往往是以缓冲区大小为单位的。也就是 TCP 协议，会将数据拆分成不超过缓冲区大小的一个个部分。每个部分有一个独特的名词，叫作 TCP 段（TCP Segment）。</p><p>数据经过拆分，然后传输，然后在目的地重组，俗称拆包。所以拆包是将数据拆分成多个 TCP 段传输。那么粘包是什么呢？有时候，如果发往一个目的地的多个数据太小了，为了防止多次发送占用资源，TCP 协议有可能将它们合并成一个 TCP 段发送，在目的地再还原成多个数据，这个过程俗称粘包。所以粘包是将多个数据合并成一个 TCP 段发送</p><p>划重点：<br>拆包： 数据拆分成多个TCP段传输<br>粘包： 多个数据合并成一个TCP段</p><p>TCP 拆包的作用是将任务拆分处理，降低整体任务出错的概率，以及减小底层网络处理的压力。拆包过程需要保证数据经过网络的传输，又能恢复到原始的顺序。这中间，需要数学提供保证顺序的理论依据。TCP 利用（发送字节数、接收字节数）的唯一性来确定封包之间的顺序关系。</p><p>粘包是为了防止数据量过小，导致大量的传输，而将多个 TCP 段合并成一个发送。</p><h3 id="滑动窗口和流速控制是怎么回事？"><a href="#滑动窗口和流速控制是怎么回事？" class="headerlink" title="滑动窗口和流速控制是怎么回事？"></a>滑动窗口和流速控制是怎么回事？</h3><p>动窗口是 TCP 协议控制可靠性的核心。发送方将数据拆包，变成多个TCP 段。然后将数据放入一个拥有滑动窗口的数组，依次发出，仍然遵循先入先出（FIFO）的顺序，但是窗口中的TCP 段会一次性发送。窗口中序号最小的TCP 段如果收到 ACK，窗口就会发生滑动；如果最小序号的TCP 段 长时间没有收到 ACK，就会触发整个窗口的数据重新发送。</p><p>另一方面，在多次传输中，网络的平均延迟往往是相对固定的，这样 TCP 协议可以通过双方协商窗口大小控制流速。</p><h2 id="udp"><a href="#udp" class="headerlink" title="udp"></a>udp</h2><h2 id="开启网络线程到发出一个完整的http请求"><a href="#开启网络线程到发出一个完整的http请求" class="headerlink" title="开启网络线程到发出一个完整的http请求"></a>开启网络线程到发出一个完整的http请求</h2><p>DNS解析</p><p>如果输入的是域名，需要进行dns解析成IP，大致流程：</p><p>如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host<br>如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP<br>域名查询时有可能是经过了CDN调度器的（如果有cdn存储功能的话），而且，需要知道dns解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑dns-prefetch优化</p><p>TCP/IP请求</p><p>tcp将http长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输。</p><p>然后，待到断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）</p><p>tcp/ip的并发限制</p><p>浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）。而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求</p><p>get和post的区别</p><p>get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。</p><p>get会产生一个tcp数据包，post两个</p><p>get请求时，浏览器会把headers和data一起发送出去，服务器响应200（返回数据），<br>post请求时，浏览器先发送headers，服务器响应100 continue，浏览器再发送data，服务器响应200（返回数据）。</p><p>从服务器接收到请求到对应后台接收到请求<br>负载均衡</p><p>用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了nginx控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的HTTP响应，并将它反馈给用户</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://mp.weixin.qq.com/s/baMDhvKQXs7OAQUosfefgg" target="_blank" rel="noopener">（建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系</a></li><li><a href="https://mp.weixin.qq.com/s/Zt8ljlUa2uZ_Wvez8H4rOQ" target="_blank" rel="noopener">解读HTTP/2与HTTP/3 的新特性</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> tcp </category>
          
          <category> udp </category>
          
          <category> http </category>
          
          <category> https </category>
          
          <category> http3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> https </tag>
            
            <tag> tcp </tag>
            
            <tag> udp </tag>
            
            <tag> http3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: Ts使用</title>
      <link href="/2021/04/29/%E5%9F%BA%E7%A1%80-Ts%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/04/29/%E5%9F%BA%E7%A1%80-Ts%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>都不好意跟别人说自己写了两年的ts,就只会用any，任何数据都是用any搞定，any类型会使编译器放弃检验，等于自废武功，这是个非常不好的习惯，可惜在错误的道路上越走越远，现在难得有机会好好学习一下，总结最近学习ts心得，最重要的一点还是执行力，什么高级特性，只要你码起来，都不在话下，但就是从认知到敲代码中间差了几万八千里，我就是差了2年700多天(哇咔咔 这么惨),</p><blockquote><p>学习ts的时候，一定要记住手写，要去实践，实践出真知！！！</p></blockquote><h2 id="来点实际的吧"><a href="#来点实际的吧" class="headerlink" title="来点实际的吧"></a>来点实际的吧</h2><blockquote><p>高级类型最好还是把源码都写下，加深印象，特别是常用的高级类型</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下所有案例基于此</span></span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Partial&lt;T&gt; T类型所有子集属性变成可选</span></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> PartialUser = Partial&lt;User&gt;</span><br><span class="line"><span class="comment">// 相当于: </span></span><br><span class="line"><span class="keyword">type</span> PartialUser = &#123; id?: <span class="built_in">number</span>; age?: <span class="built_in">number</span>; name?: <span class="built_in">string</span>; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pick&lt;T, K&gt; 从T中挑选部分属性Keys构建一个新类型 Keys从属于T的子集</span></span><br><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> PickUser = Pick&lt;User, <span class="string">'age'</span> | <span class="string">'name'</span>&gt;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">type</span> PickUser = &#123; age: <span class="built_in">number</span>, name: <span class="built_in">string</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Records&lt;K, T&gt; 属性名类型为K, 属性值为T类型，用来将某个类型的属性映射到另一个类型上</span></span><br><span class="line"><span class="comment">// K中所有属性值转化为T类型，申明一个普通的Object对象</span></span><br><span class="line"><span class="keyword">type</span> Records&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> NameKeys = <span class="string">'cpp'</span> | <span class="string">'wmh'</span></span><br><span class="line"><span class="keyword">const</span> Persopn: Record&lt;NameKeys, User&gt; = &#123;</span><br><span class="line">  <span class="string">'cpp'</span>: &#123;</span><br><span class="line">    name: <span class="string">'cpp'</span>,</span><br><span class="line">    age: <span class="number">30</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'wmh'</span>: &#123;</span><br><span class="line">    name: <span class="string">'wmh'</span>,</span><br><span class="line">    age: <span class="number">23</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exclude&lt;T, U&gt; 去除T类型中跟U类型的交集部分，返回T中剩下的子集 构建一个新类型</span></span><br><span class="line"><span class="comment">// 取差值 跟Extract类型相反</span></span><br><span class="line"><span class="keyword">type</span> Exclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? never : T</span><br><span class="line"><span class="keyword">interface</span> OtherUser &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  sex: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ExcludeUser1 = Exclude&lt;<span class="string">'a'</span> | <span class="string">'b'</span> | <span class="string">'c'</span>, <span class="string">'a'</span> | <span class="string">'b'</span>&gt; <span class="comment">// 'c'</span></span><br><span class="line"><span class="keyword">type</span> ExcludeUser2 = Exclude&lt;keyof User, keyof OtherUser&gt; <span class="comment">// 'id' 和 ‘age’</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Extract&lt;T, U&gt; 去俩个类型的交集 </span></span><br><span class="line"><span class="keyword">type</span> Extract&lt;T, U&gt; =  T <span class="keyword">extends</span> U ? T : never;</span><br><span class="line"><span class="keyword">interface</span> OtherUser &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  sex: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ExtractUser1 = Extract&lt;<span class="string">'a'</span> | <span class="string">'b'</span> | <span class="string">'c'</span>, <span class="string">'a'</span> | <span class="string">'b'</span>&gt; <span class="comment">// 'a' | 'b'</span></span><br><span class="line"><span class="keyword">type</span> ExtractUser2 = Extract&lt;keyof User, keyof OtherUser&gt; <span class="comment">// 'name’</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Omit&lt;T, K&gt; 从类型T中获取所有属性，然后从中剔除Keys属性后构造一个新类型</span></span><br><span class="line"><span class="keyword">type</span> Omit&lt;T, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;</span><br><span class="line"><span class="keyword">type</span> OmitName = Omit&lt;User, <span class="string">'name'</span>&gt;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">type</span> OmitName = &#123;age: <span class="built_in">number</span>, id: <span class="built_in">number</span> &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Readonly&lt;T&gt; 所有属性设置为readonly 不能再次赋值</span></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">    readonly [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> readonlyUser: Readonly&lt;Pick&lt;User, <span class="string">'name'</span>&gt;&gt; = &#123;</span><br><span class="line">  name: <span class="string">'cpp'</span></span><br><span class="line">&#125;</span><br><span class="line">readonlyUser.name = <span class="string">'wmh'</span> <span class="comment">// error 只读属性不能分配</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Required&lt;T&gt; T类型中所有的属性变为必选项</span></span><br><span class="line"><span class="keyword">type</span> Required&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T] -? : T[p]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testUser: Partial&lt;User&gt; = &#123;</span><br><span class="line">  id: <span class="number">111</span> <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testUser2: Required&lt;User&gt; = &#123;</span><br><span class="line">  id: <span class="number">121</span> <span class="comment">// erroe 缺少 age | name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -? 可选属性前面加- 代表必选</span></span><br></pre></td></tr></table></figure><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>重点介绍使用场景和代码实例</p><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><ul><li>TypeScript支持数字的和基于字符串的枚举</li><li>反向映射: 对于 number 类型的枚举值， 会产生一个对应下标的索引， 如下： up： 1， 1： ‘up’</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">    Up = <span class="number">1</span>,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Dirction) <span class="comment">// &#123; 1: "Up", 2: "Down", 3: "Left", 4: "Right", Up: 1, Down: 2, Left: 3, Right: 4 &#125;</span></span><br></pre></td></tr></table></figure><h3 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h3><p>unknown指的是不可预先定义的类型，在很多场景下，它可以替代any的功能同时保留静态检查的能力。<br>unknown的一个使用场景是，避免使用any作为函数的参数类型而导致的静态类型检查bug</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">input: unknown</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(input)) &#123;</span><br><span class="line">    <span class="keyword">return</span> input.length;    <span class="comment">// Pass: 这个代码块中，类型守卫已经将input识别为array类型</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> input.length;      <span class="comment">// Error: 这里的input还是unknown类型，静态检查报错。如果入参是any，则会放弃检查直接成功，带来报错风险</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h3><p>可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myArr: StringArray = [<span class="string">'cpp'</span>, <span class="string">'chendap'</span>]</span><br><span class="line"><span class="keyword">let</span> myArr2: StringArray = [<span class="number">1</span>, <span class="string">'33'</span>] <span class="comment">// error 不能将类型“number”分配给类型“string”。</span></span><br></pre></td></tr></table></figure><p>TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是<strong>数字索引的返回值必须是字符串索引返回值类型的子类型</strong>。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。<br>数字索引的返回值必须是字符串索引返回值类型的子类型 这句话很拗口，我是这么理解的，字符串索引的返回值类型必须和其他属性返回值类型相匹配，比如定义的字符串索引返回值类型是string<code>[index: string]: string</code>,其他属性类型也得是string,下面的例子很好说明了这一点:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numb: StringDirctionary = &#123; </span><br><span class="line">  <span class="string">'2'</span>: <span class="string">'ccc'</span>,</span><br><span class="line">  name: <span class="string">'111'</span>, </span><br><span class="line">  length: <span class="string">'111'</span>, </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> StringDirctionary &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">string</span>, <span class="comment">// [index: number]: string 也是ok, [PropName: string]: string也是ok</span></span><br><span class="line">  length: <span class="built_in">string</span>, <span class="comment">// ok length也是string </span></span><br><span class="line">  name: <span class="built_in">number</span> <span class="comment">// error 类型“number”的属性“name”不能赋给字符串索引类型“string” 索引签名类型都是string,不能将新增的name属性number类型兼容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>在使用ts时，会遇到下面这种代码</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> language: <span class="built_in">string</span> = <span class="string">'js'</span></span><br></pre></td></tr></table></figure><p>上面的写法太啰嗦，ts有一个类型推断机制，也就是说ts会根据变量赋的值自动给该变量设置一个类型，我们用更简洁的语法改写下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> language = <span class="string">'js'</span></span><br></pre></td></tr></table></figure><p>那什么时候需要给变量设置类型呢？<br>如果声明了一个变量但没有设置其初始值，推荐设置一个类型，如</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myLove: <span class="built_in">string</span></span><br><span class="line"><span class="keyword">let</span> langs = [<span class="string">'ts'</span>, <span class="string">'js'</span>]</span><br><span class="line">myLove = langs[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="非空断言运算符"><a href="#非空断言运算符" class="headerlink" title="非空断言运算符 !"></a>非空断言运算符 !</h3><p>用在变量名和函数名之后，某些场景下 你比程序还肯定，这段代码不会有null | undefined类型，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params">cb?: () =&gt; <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">  cb!() <span class="comment">// ts不报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可选链运算符"><a href="#可选链运算符" class="headerlink" title="可选链运算符 ?."></a>可选链运算符 ?.</h3><p><strong>?.</strong> 用来判断左侧表达式是否是NUll | undefined ,如果是则停止运行程序，减少大量的 &amp;&amp; 运算</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  a &amp;&amp;</span><br><span class="line">  Reflect.has(a, <span class="string">'b'</span>) &amp;&amp;</span><br><span class="line">  a.b</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// before</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a?.b) &#123;&#125; <span class="comment">// now</span></span><br></pre></td></tr></table></figure><p>比如我们写出a?.b时，编译器会自动生成如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a === <span class="literal">null</span> || a === <span class="keyword">void</span> <span class="number">0</span> ? <span class="keyword">void</span> <span class="number">0</span> : a.b;</span><br></pre></td></tr></table></figure><h3 id="空值合并运算符"><a href="#空值合并运算符" class="headerlink" title="空值合并运算符 ??"></a>空值合并运算符 ??</h3><p>??与||的功能是相似的，区别在于 <strong>??</strong> 在左侧表达式结果为null或者undefined时，才会返回右侧表达式<br><code>const b = a ?? 10</code>相当于下列</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b =  a !== <span class="literal">null</span> &amp;&amp; a !== <span class="built_in">void</span> <span class="number">0</span> ? a : <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="键值获取-keyof"><a href="#键值获取-keyof" class="headerlink" title="键值获取 keyof"></a>键值获取 keyof</h3><p>keyof可以获取一个类型所有键值，返回一个联合类型，如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User1 =  &#123;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> Userq = keyof User1</span><br></pre></td></tr></table></figure><p>keyof的一个典型用途是限制访问对象的key合法化，因为any做索引是不被接受的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Object</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">User</span>&gt;(<span class="params">user: T, name: K</span>): <span class="title">T</span>[<span class="title">K</span>]</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> user[name]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例类型获取-typeof-与typeof类型保护"><a href="#实例类型获取-typeof-与typeof类型保护" class="headerlink" title="实例类型获取 typeof 与typeof类型保护"></a>实例类型获取 typeof 与typeof类型保护</h3><h3 id="遍历属性-in"><a href="#遍历属性-in" class="headerlink" title="遍历属性 in"></a>遍历属性 in</h3><p>in 只能用在</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    occupation: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Admin &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    role: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Person = User | Admin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> persons: Person[] = [</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">'Max Mustermann'</span>,</span><br><span class="line">        occupation: <span class="string">'Chimney sweep'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">'Jane Doe'</span>,</span><br><span class="line">        role: <span class="string">'Administrator'</span></span><br><span class="line">    &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">logPerson</span>(<span class="params">person: Person</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> additionalInformation: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="string">'role'</span> <span class="keyword">in</span> person) &#123;</span><br><span class="line">        additionalInformation = person.role;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        additionalInformation = person.occupation;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">` - <span class="subst">$&#123;person.name&#125;</span>, <span class="subst">$&#123;person.age&#125;</span>, <span class="subst">$&#123;additionalInformation&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">persons.forEach(logPerson);</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型推断-infer"><a href="#泛型推断-infer" class="headerlink" title="泛型推断 infer"></a>泛型推断 infer</h3><p>infer的中文是“推断”的意思，一般是搭配上面的泛型条件语句使用的，所谓推断，就是你不用预先指定在泛型列表中，在运行时会自动判断，不过你得先预定义好整体的结构。举个例子</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo&lt;T&gt; = T <span class="keyword">extends</span> &#123;t: infer Test&#125; ? Test: <span class="built_in">string</span></span><br></pre></td></tr></table></figure><p>首选看extends后面的内容，{t: infer Test}可以看成是一个包含t属性的类型定义，这个t属性的value类型通过infer进行推断后会赋值给Test类型，如果泛型实际参数符合{t: infer Test}的定义那么返回的就是Test类型，否则默认给缺省的string类型。<br>举个例子</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> One = Foo&lt;<span class="built_in">number</span>&gt;  <span class="comment">// string，因为number不是一个包含t的对象类型</span></span><br><span class="line"><span class="keyword">type</span> Two = Foo&lt;&#123;t: <span class="built_in">boolean</span>&#125;&gt;  <span class="comment">// boolean，因为泛型参数匹配上了，使用了infer对应的type</span></span><br><span class="line"><span class="keyword">type</span> Three = Foo&lt;&#123;a: <span class="built_in">number</span>, t: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>&#125;&gt; <span class="comment">// () =&gt; void，泛型定义是参数的子集，同样适配</span></span><br></pre></td></tr></table></figure><h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b2: <span class="built_in">Boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> body: HTMLElement = <span class="built_in">document</span>.body;</span><br><span class="line"><span class="keyword">const</span> divList: NodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function">(<span class="params">e: MouseEvent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib" target="_blank" rel="noopener">TS核心库</a></p><h2 id="装饰器支持"><a href="#装饰器支持" class="headerlink" title="装饰器支持"></a>装饰器支持</h2><p>开启对装饰器的支持，命令行 编译文件时：<br><code>** tsc --target ES5 --experimentalDecorators test.ts**</code></p><p>配置文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"target"</span>: <span class="string">"ES5"</span>,</span><br><span class="line">    <span class="string">"experimentalDecorators"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TS对js文件编译时检查"><a href="#TS对js文件编译时检查" class="headerlink" title="TS对js文件编译时检查"></a>TS对js文件编译时检查</h2><p>在js中使用类型和错误检测也是很不错的<br>ts提供了一个特殊功能，允许我们在编译时对代码进行错误检测和类型检测，前提是需要在本地全局安装Typescript,使用时，只需要在js文件第一行加上<br><strong>// @ts-check</strong> 即可，如</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @ts-check</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;any[]&#125; arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre.concat(<span class="built_in">Array</span>.isArray(cur) ? flat(cur) : cur), [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://segmentfault.com/a/1190000039868550?utm_source=sf-homepage" target="_blank" rel="noopener">TS实用工具类型</a></li><li><a href="https://mp.weixin.qq.com/s/6Mmy4_d11P1iPFSgX7GOBw" target="_blank" rel="noopener">TypeScript 原来可以这么香？！</a></li><li><a href="https://mp.weixin.qq.com/s/cXafSOOZ9eD5GZN0tTGQ-Q" target="_blank" rel="noopener">TypeScript 高级用法</a></li><li><a href="https://typescript-exercises.github.io/#exercise=3&file=%2Findex.ts" target="_blank" rel="noopener">ts练习题</a></li><li><a href="https://www.tslang.cn/docs/handbook/advanced-types.html" target="_blank" rel="noopener">Ts官网文档中文版</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Typescript </category>
          
          <category> ts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typescript </tag>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础-面试当中的正则表达式</title>
      <link href="/2021/04/20/%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E5%BD%93%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2021/04/20/%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E5%BD%93%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="RegExp表达式的方法"><a href="#RegExp表达式的方法" class="headerlink" title="RegExp表达式的方法"></a>RegExp表达式的方法</h2><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">template, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span></span><br><span class="line">  <span class="keyword">if</span> (reg.test(template)) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="built_in">RegExp</span>.$<span class="number">1.</span>trim() <span class="comment">// name = reg.exec(template)[1]</span></span><br><span class="line">    template = template.replace(reg, data[name])</span><br><span class="line">    <span class="keyword">return</span> render(template, data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> template</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">render(<span class="string">`&#123;&#123;msg&#125;&#125;-&#123;&#123;name&#125;&#125;`</span>, &#123;<span class="attr">msg</span>: <span class="string">'chendap'</span>, <span class="attr">name</span>: <span class="string">'wmh'</span>&#125;) <span class="comment">// chendap-wmh</span></span><br></pre></td></tr></table></figure><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><ul><li>回文字符串<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> s != <span class="string">'string'</span>) <span class="keyword">return</span> s = s.toString()</span><br><span class="line">    <span class="keyword">if</span>(s.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> r = <span class="regexp">/[^a-zA-Z0-9]/ig</span>;</span><br><span class="line">    s = s.replace(r, <span class="string">''</span>).toLowerCase()</span><br><span class="line">    <span class="keyword">return</span> s == s.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line">isPalindrome(<span class="string">'cppc'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="描述字符"><a href="#描述字符" class="headerlink" title="描述字符"></a>描述字符</h2><p>元字符<br>元字符    描述<br>.    查找单个字符，除了换行和行结束符<br>\w    查找单词字符<br>\W    查找非单词字符<br>\d    查找数字<br>\D    查找非数字字符<br>\s    查找空白字符<br>\S    查找非空白字符<br>\b    匹配单词边界<br>\B    匹配非单词边界</p><h2 id="描述字符范围"><a href="#描述字符范围" class="headerlink" title="描述字符范围"></a>描述字符范围</h2><p>在正则表达式语法中，放括号表示字符范围。在方括号中可以包含多个字符，表示匹配其中任意一个字符。如果多个字符的编码顺序是连续的，可以仅指定开头和结尾字符，省略中间字符，仅使用连字符~表示。如果在方括号内添加脱字符^前缀，还可以表示范围之外的字符。例如：<br>[abc]：查找方括号内任意一个字符。<br>[^abc]：查找不在方括号内的字符。<br>[0-9]：查找从 0 至 9 范围内的数字，即查找数字。<br>[a-z]：查找从小写 a 到小写 z 范围内的字符，即查找小写字母。<br>[A-Z]：查找从大写 A 到大写 Z 范围内的字符，即查找大写字母。<br>[A-z]：查找从大写 A 到小写 z 范围内的字符，即所有大小写的字母。</p><h2 id="选择匹配"><a href="#选择匹配" class="headerlink" title="选择匹配"></a>选择匹配</h2><p>选择匹配类似于 JavaScript 的逻辑与运算，使用竖线|描述，表示在两个子模式的匹配结果中任选一个。例如：</p><p>1) 匹配任意数字或字母<br><code>var r = /\w+|\d+/;</code><br>2) 可以定义多重选择模式。设计方法：在多个子模式之间加入选择操作符。<br><code>var r = /(abc)|(efg)|(123)|(456)/;</code></p><h2 id="重复匹配"><a href="#重复匹配" class="headerlink" title="重复匹配"></a>重复匹配</h2><p>在正则表达式语法中，定义了一组重复类量词，如表所示。它们定义了重复匹配字符的确数或约数。</p><p>重复类量词列表<br>量词      描述<br>n+        匹配任何包含至少一个 n 的字符串<br>n*        匹配任何包含零个或多个 n 的字符串<br>n?        匹配任何包含零个或一个 n 的字符串<br>n{x}      匹配包含 x 个 n 的序列的字符串<br>n{x,y}    匹配包含最少 x 个、最多 y 个 n 的序列的字符串<br>n{x,}      匹配包含至少 x 个 n 的序列的字符串</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><code>var s = &quot;ggle gogle google gooogle goooogle gooooogle goooooogle gooooooogle goooooooogle&quot;;</code></p><p>1.如果仅匹配单词 ggle 和 gogle，可以设计：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/go?gle/g</span>;</span><br><span class="line"><span class="keyword">var</span> a = s.match(r)</span><br></pre></td></tr></table></figure><p>量词?表示前面字符或子表达式为可有可无，等效于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/go&#123;0,1&#125;gle/g</span>;</span><br><span class="line"><span class="keyword">var</span> a = s.match(r);</span><br></pre></td></tr></table></figure><p>2.如果匹配第 4 个单词 gooogle，可以设计：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/go&#123;3&#125;gle/g</span>;</span><br><span class="line"><span class="keyword">var</span> a = s.match(r);</span><br></pre></td></tr></table></figure><p>等效于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/gooogle/g</span>;</span><br><span class="line"><span class="keyword">var</span> a = s.match(r);</span><br></pre></td></tr></table></figure><p>3.如果匹配第 4 个到第 6 个之间的单词，可以设计：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/go&#123;3,5&#125;gle/g</span>;</span><br><span class="line"><span class="keyword">var</span> a = s.match(r);</span><br></pre></td></tr></table></figure><p>4.如果匹配所有单词，可以设计：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/go*gle/g</span>;</span><br><span class="line"><span class="keyword">var</span> a = s.match(r);</span><br></pre></td></tr></table></figure><p>量词*表示前面字符或表达式可以不出现，或者重复出现任意多次。等效于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/go(0,)gle/g</span>;</span><br><span class="line"><span class="keyword">var</span> a = s.match(r);</span><br></pre></td></tr></table></figure><p>5.如果匹配包含字符“o”的所有词，可以设计：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/go+gle/g</span>;</span><br><span class="line"><span class="keyword">var</span> a = s.match(r);</span><br><span class="line"><span class="comment">// array(8)</span></span><br><span class="line"><span class="number">0</span>: <span class="string">"gogle"</span></span><br><span class="line"><span class="number">1</span>: <span class="string">"google"</span></span><br><span class="line"><span class="number">2</span>: <span class="string">"gooogle"</span></span><br><span class="line"><span class="number">3</span>: <span class="string">"goooogle"</span></span><br><span class="line"><span class="number">4</span>: <span class="string">"gooooogle"</span></span><br><span class="line"><span class="number">5</span>: <span class="string">"goooooogle"</span></span><br><span class="line"><span class="number">6</span>: <span class="string">"gooooooogle"</span></span><br><span class="line"><span class="number">7</span>: <span class="string">"goooooooogle"</span></span><br></pre></td></tr></table></figure><p>相当于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/go&#123;1,&#125;gle/g</span>;</span><br><span class="line"><span class="keyword">var</span> a = s.match(r);</span><br></pre></td></tr></table></figure><h2 id="惰性匹配"><a href="#惰性匹配" class="headerlink" title="惰性匹配"></a>惰性匹配</h2><p>重复类量词都具有贪婪性，在条件允许的前提下，会匹配尽可能多的字符。<br>?、{n} 和 {n,m} 重复类具有弱贪婪性，表现为贪婪的有限性。<br>*、+ 和 {n,} 重复类具有强贪婪性，表现为贪婪的无限性。</p><h2 id="边界量词"><a href="#边界量词" class="headerlink" title="边界量词"></a>边界量词</h2><p>边界就是确定匹配模式的位置，如字符串的头部或尾部，具体说明如表所示。<br>JavaScript 正则表达式支持的边界量词<br>量词    说明<br>^        匹配开头，在多行检测中，会匹配一行的开头<br>$        匹配结尾，在多行检测中，会匹配一行的结尾</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><code>var s = &quot;how are you&quot;</code></p><h3 id="匹配最后一个单词"><a href="#匹配最后一个单词" class="headerlink" title="匹配最后一个单词"></a>匹配最后一个单词</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/\w+$/</span>;</span><br><span class="line"><span class="keyword">var</span> a = s.match(r);  <span class="comment">//返回数组["you"]</span></span><br></pre></td></tr></table></figure><h3 id="匹配第一个单词"><a href="#匹配第一个单词" class="headerlink" title="匹配第一个单词"></a>匹配第一个单词</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/^\w+/</span>;</span><br><span class="line"><span class="keyword">var</span> a = s.match(r);  <span class="comment">//返回数组["how"]</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://c.biancheng.net/view/5632.html" target="_blank" rel="noopener">JS正则表达式语法大全（非常详细）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> RegExp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> RegExp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 面试当中的各种打印题(积累)</title>
      <link href="/2021/04/18/%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E5%BD%93%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%89%93%E5%8D%B0%E9%A2%98-%E7%A7%AF%E7%B4%AF/"/>
      <url>/2021/04/18/%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95%E5%BD%93%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%89%93%E5%8D%B0%E9%A2%98-%E7%A7%AF%E7%B4%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="this相关"><a href="#this相关" class="headerlink" title="this相关"></a>this相关</h2><h4 id="one"><a href="#one" class="headerlink" title="one"></a>one</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;</span><br><span class="line"> text: <span class="string">'o1'</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.text</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> o2 = &#123;</span><br><span class="line"> text: <span class="string">'o2'</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> o1.fn()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> o3 = &#123;</span><br><span class="line"> text: <span class="string">'o3'</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> fn = o1.fn</span><br><span class="line">    <span class="keyword">return</span> fn()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(o1.fn()) <span class="comment">// 01</span></span><br><span class="line"><span class="built_in">console</span>.log(o2.fn()) <span class="comment">// 01</span></span><br><span class="line"><span class="built_in">console</span>.log(o3.fn()) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h4 id="Two"><a href="#Two" class="headerlink" title="Two"></a>Two</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    name: <span class="string">'cpp'</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.trace()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'wmh'</span></span><br><span class="line">test.fn() <span class="comment">// cpp</span></span><br><span class="line">test.fn.call(<span class="keyword">this</span>) <span class="comment">// wmh</span></span><br></pre></td></tr></table></figure><h4 id="Three"><a href="#Three" class="headerlink" title="Three"></a>Three</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fullName = <span class="string">'1'</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    fullName: <span class="string">'2'</span>,</span><br><span class="line">    prop: &#123;</span><br><span class="line">        fullName: <span class="string">'3'</span>,</span><br><span class="line">        getFullName: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.fullName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.prop.getFullName())</span><br><span class="line"><span class="keyword">var</span> test = obj.prop.getFullName</span><br><span class="line"><span class="built_in">console</span>.log(test())</span><br></pre></td></tr></table></figure><h2 id="作用域相关"><a href="#作用域相关" class="headerlink" title="作用域相关"></a>作用域相关</h2><h3 id="one-1"><a href="#one-1" class="headerlink" title="one"></a>one</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    a: <span class="number">40</span>,</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="string">'new'</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">        go.prototype.a = <span class="number">50</span></span><br><span class="line">        <span class="keyword">return</span> go</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = test.init() <span class="comment">// </span></span><br><span class="line">p() <span class="comment">// </span></span><br><span class="line"><span class="keyword">new</span> p() <span class="comment">//</span></span><br></pre></td></tr></table></figure><p>init改成箭头函数呢</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    a: <span class="number">40</span>,</span><br><span class="line">    init: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="string">'new'</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">        &#125;</span><br><span class="line">        go.prototype.a = <span class="number">50</span></span><br><span class="line">        <span class="keyword">return</span> go</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = test.init() <span class="comment">// </span></span><br><span class="line">p() <span class="comment">// </span></span><br><span class="line"><span class="keyword">new</span> p() <span class="comment">//</span></span><br></pre></td></tr></table></figure><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="one-2"><a href="#one-2" class="headerlink" title="one"></a>one</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="built_in">console</span>.log(a.a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(a.b); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> A();</span><br><span class="line">b.__proto__.a = <span class="number">2</span>;</span><br><span class="line">A.prototype.b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(a.b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3: composition-api(转载)</title>
      <link href="/2021/04/11/vue3-composition-api-%E8%BD%AC%E8%BD%BD/"/>
      <url>/2021/04/11/vue3-composition-api-%E8%BD%AC%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p><code>Composition API</code> 将是 Vue 3 的核心功能，它具有许多更改和性能改进。我们可以在 <code>Vue 2</code> 中通过 npm 插件<code>@vue/composition-api</code> 使用它。<br>本人重点将带你了解：</p><ol><li><code>@vue/composition-api</code>常见 api 使用</li><li>vue3 代码逻辑提取和复用</li><li>如何使用<code>provide+inject</code>替代<code>vuex</code>方案</li></ol><h3 id="vue2-使用-composition-api"><a href="#vue2-使用-composition-api" class="headerlink" title="vue2 使用 composition-api"></a>vue2 使用 composition-api</h3><p>主文件 main.ts 或者 app.vue 添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueCompositionAPI <span class="keyword">from</span> <span class="string">'@vue/composition-api'</span></span><br><span class="line">Vue.use(VueCompositionAPI)</span><br></pre></td></tr></table></figure><p><code>Composition API</code> 不再传入 <code>data、mounted</code> 等参数，<br>通过引入的 <code>ref</code>、<code>onMounted</code>等方法实现数据的双向绑定、生命周期函数的执行。</p><h3 id="核心语法"><a href="#核心语法" class="headerlink" title="核心语法"></a>核心语法</h3><p><code>reactive</code>：接收一个普通对象然后返回该普通对象的响应式代理。</p><p><code>ref</code>：接受一个参数值并返回一个响应式且可改变的 <code>ref</code> 对象。<code>ref</code> 对象拥有一个指向内部值的单一属性 .value。</p><p><code>computed</code>：传入一个 <code>getter</code> 函数，返回一个默认不可手动修改的 <code>ref</code> 对象。</p><p><code>readonly</code>：传入一个对象（响应式或普通）或 ref，返回一个原始对象的只读代理。一个只读的代理是“深层的”，对象内部任何嵌套的属性也都是只读的。</p><p><code>watchEffect</code>：立即执行传入的一个函数，并响应式追踪其依赖，并在其依赖变更时重新运行该函数。可显式的调用返回值以停止侦听。</p><p><code>watch</code>：全等效于 2.x <code>this.\$watch</code> （以及 <code>watch</code> 中相应的选项）。</p><h4 id="setup-函数"><a href="#setup-函数" class="headerlink" title="setup 函数"></a>setup 函数</h4><p>现在要介绍的第一个 API 就是 <code>setup</code> 函数。<br><code>setup</code> 函数是一个新的组件选项。作为在组件内使用 <code>Composition API</code> 的入口点。<br>先看个简单 demo</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"increase"</span>&gt;</span>count is: &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    setup() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> count = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> increase = <span class="function"><span class="params">()</span> =&gt;</span> count++</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123; count, increase &#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>1、调用时机</p><p>创建组件实例，然后初始化 <code>props</code> ，紧接着就调用 <code>setup</code> 函数。<br>从 vue2 生命周期钩子的视角来看，它会在 <code>beforeCreate</code> 钩子之后，<code>created</code> 之前被调用。</p><p>2、模板中使用</p><p>如果 <code>setup</code> 返回一个对象，则对象的属性将会被合并到组件模板的渲染上下文。</p><p>3、渲染函数 / JSX 中使用</p><p><code>setup</code> 也可以返回一个函数，函数中也能使用当前 <code>setup</code> 函数作用域中的响应式数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h, ref, reactive &#125; <span class="keyword">from</span> <span class="string">'@vue/composition-api'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> object = reactive(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> h(<span class="string">'div'</span>, [count.value, object.foo])</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、两个参数<br><code>props</code>(注意 props 对象是响应式的),<br><code>context</code>(上下文对象，从原来 2.x 中 this 选择性地暴露了一些 <code>property</code>。)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComponent = &#123;</span><br><span class="line">  setup(props, context) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;</span><br><span class="line">      attrs,</span><br><span class="line">      emit,</span><br><span class="line">      isServer,</span><br><span class="line">      listeners,</span><br><span class="line">      parent,</span><br><span class="line">      refs,</span><br><span class="line">      root,</span><br><span class="line">      slots,</span><br><span class="line">      ssrContext,</span><br><span class="line">    &#125; = context</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ref-amp-reactive"><a href="#ref-amp-reactive" class="headerlink" title="ref &amp; reactive"></a>ref &amp; reactive</h4><p>在 <code>App.vue</code> 中，点击事件绑定了 <code>increase</code>，然后修改了 <code>count</code>，<br>但是页面并没有发生改变，这是因为 <code>setup</code> 函数返回的对象中 <code>count</code> 不是响应式数据，<br>那么如何创建响应式数据呢？此时就要掌握响应式系统 API，我们可以使用 <code>ref</code> 和 <code>reactive</code> 创建。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"increase"</span>&gt;</span></span><br><span class="line">    count is: &#123;&#123; count &#125;&#125;, state.count is &#123;&#123; state.count &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; ref, reactive &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    setup() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> count = ref(<span class="number">0</span>) <span class="comment">// &#123; value: 0 &#125;</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> state = reactive(&#123; <span class="attr">number</span>: <span class="number">0</span> &#125;)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> increase = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line">        count.value++</span><br><span class="line">        state.count++</span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123; count, state, increase &#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接受一个参数值并返回一个响应式且可改变的 <code>ref</code> 对象。<br><code>ref</code> 对象拥有一个指向内部值的单一属性 <code>.value</code>。</p><p>当 <code>ref</code> 作为渲染上下文的属性返回（即在 <code>setup()</code> 返回的对象中）并在模板中使用时，<br>它会自动解套，无需在模板内额外书写 <code>.value</code></p><p>Vue 本身已经有 “<code>ref</code>“ 的概念了。<br>但只是为了在模板中获取 DOM 元素或组件实例 (“模板引用”)。<br>新的 <code>ref</code> 系统同时用于逻辑状态和模板引用。</p><p><code>reactive</code> 接收一个普通对象然后返回该普通对象的响应式代理。</p><p>响应式转换是“深层的”：会影响对象内部所有嵌套的属性。基于 ES2015 的 Proxy 实现，返回的代理对象不等于原始对象。建议仅使用代理对象而避免依赖原始对象。</p><p>不要解构返回的代理对象，那样会使其失去响应性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"increase"</span>&gt;</span>count is: &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; ref, reactive &#125; <span class="keyword">from</span> <span class="string">'@vue/composition-api'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    setup() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> state = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> increase = <span class="function"><span class="params">()</span> =&gt;</span> state.count++</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123; ...state, increase &#125; <span class="comment">// 展开state属性将失去响应式</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="toRef-和-toRefs"><a href="#toRef-和-toRefs" class="headerlink" title="toRef 和 toRefs"></a>toRef 和 toRefs</h4><p>那如果我们真的想展开 <code>state</code> 的属性，在模板使用 count 而不是 state.count 的写法那怎么办呢？我们可以使用 <code>toRef</code> 和 <code>toRefs</code> 这两个 API，进行转换成 ref 对象，之前已经介绍了 ref 对象是可以直接在模板中使用的。</p><p><code>toRef</code> 可以用来为一个 <code>reactive</code> 对象的属性创建一个 ref。这个 ref 可以被传递并且能够保持响应性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"increase"</span>&gt;</span></span><br><span class="line">    count is: &#123;&#123; count &#125;&#125;,count2 is: &#123;&#123; count2 &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; ref, reactive, toRef, toRefs &#125; <span class="keyword">from</span> <span class="string">'@vue/composition-api'</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    setup() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> state = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> countRef = toRef(state, <span class="string">'count'</span>)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> state2 = reactive(&#123; <span class="attr">count2</span>: <span class="number">0</span> &#125;)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> increase = <span class="function"><span class="params">()</span> =&gt;</span> state.count++</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> stateAsRefs = toRefs(state2)</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123; count: countRef, increase, ...stateAsRefs &#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>把一个响应式对象转换成普通对象，该普通对象的每个 <code>property</code> 都是一个 <code>ref</code> ，和响应式对象 <code>property</code> 一一对应。</p><h4 id="computed-amp-watch"><a href="#computed-amp-watch" class="headerlink" title="computed &amp; watch"></a>computed &amp; watch</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countDouble = computed(<span class="function"><span class="params">()</span> =&gt;</span> count.value * <span class="number">2</span>)</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; state.count,</span><br><span class="line">  (count, prevCount) =&gt; &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="代码逻辑提取和复用"><a href="#代码逻辑提取和复用" class="headerlink" title="代码逻辑提取和复用"></a>代码逻辑提取和复用</h3><p><code>Composition API</code> 的第一个明显优势是很容易提取逻辑。解决了</p><h4 id="逻辑提取"><a href="#逻辑提取" class="headerlink" title="逻辑提取"></a>逻辑提取</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCount = <span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> increase = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    count.value += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> reset = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    count.value = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    count.value = number</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count,</span><br><span class="line">    increase,</span><br><span class="line">    reset,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码复用"><a href="#代码复用" class="headerlink" title="代码复用"></a>代码复用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 另外一个文件使用:</span></span><br><span class="line"><span class="keyword">const</span> &#123; count, increase &#125; = useCount(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(count) <span class="comment">//输出1</span></span><br><span class="line">increase()</span><br><span class="line"><span class="built_in">console</span>.log(count) <span class="comment">//输出2</span></span><br><span class="line">reset()</span><br><span class="line"><span class="built_in">console</span>.log(count) <span class="comment">//输出0</span></span><br></pre></td></tr></table></figure><p>有效的解决了 <code>mixins</code> 复用命名冲突，难以识别命名来自哪个 <code>mixin</code> 文件的问题。</p><h3 id="替代-vuex-状态管理"><a href="#替代-vuex-状态管理" class="headerlink" title="替代 vuex 状态管理"></a>替代 vuex 状态管理</h3><p>状态 <code>store</code> 可以放在一个单一的文件或者目录里,比如设置一个全局组件可以只用的配置 <code>config</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//context/config.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; provide, inject, ref, onMounted, readonly &#125; <span class="keyword">from</span> <span class="string">'@vue/composition-api'</span></span><br><span class="line"><span class="keyword">const</span> configSymbol: symbol = Symbol()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useProvider = &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">let</span> config = ref(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> configServer = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="comment">// await 一些异步操作，比如api等</span></span><br><span class="line">      config.value = &#123; name: <span class="string">'名字'</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    onMounted(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">await</span> configServer()</span><br><span class="line">    &#125;)</span><br><span class="line">    provide(configSymbol, &#123;</span><br><span class="line">      <span class="comment">//导出只读的config只有函数内部可以修改状态</span></span><br><span class="line">      config: readonly(config),</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useInject = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> inject(configSymbol)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最顶层的组件（例如 main.ts）上注入，config 就可以在所有的组件中使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">'@vue/composition-api'</span></span><br><span class="line"><span class="keyword">import</span> &#123; useProvider &#125; <span class="keyword">from</span> <span class="string">'./context/config'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    useProvider()</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>业务逻辑页面使用 config</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useInject &#125; <span class="keyword">from</span> <span class="string">'./context/config'</span></span><br><span class="line"><span class="keyword">const</span> Components = &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; config &#125; = useInject()</span><br><span class="line">    <span class="built_in">console</span>.log(config.value.name) <span class="comment">//输出“名字”</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      config,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue3 </category>
          
          <category> composition-api </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue3 </tag>
            
            <tag> composition-api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础: 异步加载js方式-async/defer</title>
      <link href="/2021/04/10/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BDjs%E6%96%B9%E5%BC%8F-async-defer/"/>
      <url>/2021/04/10/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BDjs%E6%96%B9%E5%BC%8F-async-defer/</url>
      
        <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-src="/images/async/async_vs_defer.jpg" alt="js异步加载"></p><h2 id="浏览器渲染页面的过程"><a href="#浏览器渲染页面的过程" class="headerlink" title="浏览器渲染页面的过程"></a>浏览器渲染页面的过程</h2><p>从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面五件事情上：</p><ul><li>DNS 查询</li><li>TCP 连接</li><li>HTTP 请求即响应</li><li>服务器响应</li><li>客户端渲染</li></ul><p>主要说说第五个部分，即浏览器对内容的渲染，这一部分（渲染树构建、布局及绘制），又可以分为下面五个步骤：</p><ul><li>处理 HTML 标记并构建 DOM 树。(dom)</li><li>处理 CSS 标记并构建 CSSOM 树。(cssom)</li><li>将 DOM 与 CSSOM 合并成一个渲染树。(render tree)</li><li>根据渲染树来布局，以计算每个节点的几何信息。(layout)</li><li>将各个节点绘制到屏幕上。(paint)</li></ul><p>需要明白，这五个步骤并不一定一次性顺序完成。如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。实际页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM，下面就来看看它们的影响方式。</p><h2 id="阻塞渲染：CSS-与-JavaScript"><a href="#阻塞渲染：CSS-与-JavaScript" class="headerlink" title="阻塞渲染：CSS 与 JavaScript"></a>阻塞渲染：CSS 与 JavaScript</h2><p>现代浏览器总是并行加载资源。例如，当 HTML 解析器（HTML Parser）被脚本阻塞时，解析器虽然会停止构建 DOM，但仍会识别该脚本后面的资源，并进行预加载。<br>同时，由于下面两点：</p><ul><li>默认情况下，CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。</li><li>JavaScript 不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性。</li></ul><p>存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 的解析。另外：</p><ul><li>当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行。</li><li>JavaScript 可以查询和修改 DOM 与 CSSOM。</li><li>CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪。</li></ul><p>所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：</p><ul><li>CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。</li><li>JavaScript 应尽量少影响 DOM 的构建。</li></ul><h2 id="异步加载js方式有哪些"><a href="#异步加载js方式有哪些" class="headerlink" title="异步加载js方式有哪些"></a>异步加载js方式有哪些</h2><p>defer和async是script标签的两个属性，用于在<strong>不阻塞页面文档解析</strong>的前提下异步加载脚本，控制脚本的下载和对应的执行时机<br><img src= "/img/loading.gif" data-src="/images/async/defer.jpg" alt="js异步加载"></p><blockquote><p>异步加载脚本是相对于html文档解析</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"../XXX.js"</span> defer or <span class="keyword">async</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="默认的script脚本"><a href="#默认的script脚本" class="headerlink" title="默认的script脚本"></a>默认的script脚本</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;code&gt;<span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"x.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span>&lt;<span class="regexp">/code&gt;</span></span><br></pre></td></tr></table></figure><p>当浏览器遇到 script 标签时，文档的解析将停止，并立即下载并执行脚本，脚本执行完毕后将继续解析文档。也就是说 脚本文件的下载和执行是与文档解析同步进行，也就是说，它会阻塞文档的解析，如果控制得不好，在用户体验上就会造成一定程度的影响</p><h2 id="defer-html4"><a href="#defer-html4" class="headerlink" title="defer (html4)"></a>defer (html4)</h2><p>异步加载脚本，加载文档的时候，文档的解析不会停止，等到文档解析完成之后，才会执行脚本</p><h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><p>1.只适用于外联脚本(含有src属性)，不会对内联脚本有效<br>2.多个defer脚本按照下载的顺序执行，按序执行<br>3.执行时机是在文档解析完成之后，也就是DOMContentLoaded之前执行(整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。这句话当中的document文档解析完毕后不一定会触发DOMContentLoaded 事件，得等到defer-script执行完成之后)</p><h3 id="相比于默认脚本"><a href="#相比于默认脚本" class="headerlink" title="相比于默认脚本"></a>相比于默认脚本</h3><p>1.载入 JavaScript 文件时不阻塞 HTML 的解析<br>2.执行阶段被放到 HTML 标签解析完成之后。</p><h2 id="async-html5"><a href="#async-html5" class="headerlink" title="async (html5)"></a>async (html5)</h2><p>异步加载脚本，加载完会立即执行，执行的时候会阻塞html文档解析，执行完异步脚本之后，html文档会继续解析<br>注意点:<br>1.也是只适用于外联脚本，和defer保持一致<br>2.多个async脚本，下载和执行也是异步的，不能保证执行顺序<br>3.执行时机，一定是在window.onload之前执行，但不能确保是与DOMContentLoaded的执行先后顺序</p><h2 id="defer和async区别"><a href="#defer和async区别" class="headerlink" title="defer和async区别"></a><em>defer和async区别</em></h2><p>一句话概括：<br>async是异步加载，加载完会立即执行，执行的时候会阻塞html文档解析。<br>defer也是异步加载脚本，等Html文档解析完成之后再去执行脚本</p><p><img src= "/img/loading.gif" data-src="/images/async/async.png" alt="js异步加载"></p><h2 id="document-createElement"><a href="#document-createElement" class="headerlink" title="document.createElement"></a>document.createElement</h2><p>使用 document.createElement 创建的 script 默认是异步的，示例如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.createElement(<span class="string">"script"</span>).async); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>所以通过动态添加 script 标签引入 JavaScript 文件默认是不会阻塞页面的。如果想同步执行，需要将 async 属性人为设置为 false。<br>如果使用 document.createElement 创建 link 标签会怎样呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">'link'</span>)</span><br><span class="line">link.rel = <span class="string">'stylesheet'</span></span><br><span class="line">link.href= <span class="string">'index.css'</span></span><br><span class="line"><span class="built_in">document</span>.head.appendChild(link) <span class="comment">// 也不会阻塞页面解析</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.cn/post/6844903875653140494#heading-0" target="_blank" rel="noopener">关于defer和async的原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/29418126" target="_blank" rel="noopener">浏览器的渲染：过程与原理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> async </category>
          
          <category> defer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> async </tag>
            
            <tag> defer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>focus-聚焦核心</title>
      <link href="/2021/04/06/focus-%E8%81%9A%E7%84%A6%E6%A0%B8%E5%BF%83/"/>
      <url>/2021/04/06/focus-%E8%81%9A%E7%84%A6%E6%A0%B8%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<p>聚集核心,never give up!!!</p><h3 id="vue源码"><a href="#vue源码" class="headerlink" title="vue源码"></a>vue源码</h3><ul><li><input checked="" disabled="" type="checkbox"> mvvm模式</li><li><input checked="" disabled="" type="checkbox"> vue双向绑定原理</li><li><input checked="" disabled="" type="checkbox"> $nextTick</li><li><input checked="" disabled="" type="checkbox"> watch和computed</li><li><input checked="" disabled="" type="checkbox"> 依赖收集</li><li><input disabled="" type="checkbox"> slot应用及原理</li><li><input disabled="" type="checkbox"> 封装Vue.extends实例</li><li><input checked="" disabled="" type="checkbox"> 手写vue-router</li><li><input disabled="" type="checkbox"> 手写vuex</li><li><input disabled="" type="checkbox"> vue3核心熟悉</li></ul><h3 id="webpack相关原理"><a href="#webpack相关原理" class="headerlink" title="webpack相关原理"></a>webpack相关原理</h3><ul><li><input checked="" disabled="" type="checkbox"> 构建过程</li><li><input checked="" disabled="" type="checkbox"> 手写webpack</li><li><input checked="" disabled="" type="checkbox"> 手写loader和plugin</li><li><input disabled="" type="checkbox"> 热更新原理</li><li><input disabled="" type="checkbox"> 分包策略(splitChunk)</li><li><input disabled="" type="checkbox"> 打包流程优化 </li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li><input checked="" disabled="" type="checkbox"> 单例模式</li><li><input checked="" disabled="" type="checkbox"> 策略模式</li><li><input checked="" disabled="" type="checkbox"> 发布订阅模式</li><li><input checked="" disabled="" type="checkbox"> 工厂模式</li><li><input checked="" disabled="" type="checkbox"> 外观模式</li><li><input checked="" disabled="" type="checkbox"> 装饰器模式</li><li><input checked="" disabled="" type="checkbox"> 代理模式</li><li><input checked="" disabled="" type="checkbox"> 迭代器模式</li></ul><h3 id="ts理解"><a href="#ts理解" class="headerlink" title="ts理解"></a>ts理解</h3><ul><li><input checked="" disabled="" type="checkbox"> interface</li><li><input checked="" disabled="" type="checkbox"> type</li><li>[] 装饰器</li><li>[] 泛型应用</li></ul><h3 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h3><ul><li><input disabled="" type="checkbox"> 栈</li><li><input disabled="" type="checkbox"> 队列</li><li><input disabled="" type="checkbox"> 二叉树</li><li><input disabled="" type="checkbox"> 链表</li><li><input disabled="" type="checkbox"> 滑动窗口</li><li><input disabled="" type="checkbox"> DFS</li><li><input disabled="" type="checkbox"> BFS</li></ul><h3 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h3><ul><li><input checked="" disabled="" type="checkbox"> handwriting series</li></ul><h3 id="其他拓展"><a href="#其他拓展" class="headerlink" title="其他拓展"></a>其他拓展</h3><ul><li><input checked="" disabled="" type="checkbox"> js和bridge</li><li><input checked="" disabled="" type="checkbox"> webview</li><li><input disabled="" type="checkbox"> cli</li></ul><h4 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一步 http:<span class="comment">//xx.cn.com/tig-cpp/report/query</span></span><br><span class="line">第二步 baseURL: <span class="string">'/cpp'</span>,</span><br><span class="line">第三步</span><br><span class="line">      <span class="string">'/cpp'</span>: &#123;</span><br><span class="line">        target: <span class="string">'http:/xx.cn.com'</span>,</span><br><span class="line">        ws: <span class="literal">true</span>,</span><br><span class="line">        changeOrigin: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure><h3 id="回溯，自问自答"><a href="#回溯，自问自答" class="headerlink" title="回溯，自问自答"></a>回溯，自问自答</h3><h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><ul><li>高度塌陷原因是什么<br>在文档流中，父元素会默认被子元素撑开，一旦子元素设置浮动，完全脱离文档流，就会导致子元素无法撑起父元素的高度，就会产生父元素高度塌陷问题</li><li>clear 属性清除浮动的原理是什么？</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue进阶7-vue-router</title>
      <link href="/2021/04/04/vue%E8%BF%9B%E9%98%B67-vue-router/"/>
      <url>/2021/04/04/vue%E8%BF%9B%E9%98%B67-vue-router/</url>
      
        <content type="html"><![CDATA[<ul><li>前后端路由差别</li><li>前端路由解决的问题</li><li>前端路由实现原理</li><li>对比react和vue路由实现原理</li><li>实现hash路由和history路由</li><li>Vue-router路由模式有几种</li><li>实现一个简单的vue-router</li><li>vue-router懒加载三种方式</li><li>路由导航守卫</li><li>其他细节问题</li></ul><h2 id="前后端路由差别"><a href="#前后端路由差别" class="headerlink" title="前后端路由差别"></a>前后端路由差别</h2><ul><li><p>后端路由，切换路由时，服务端会去匹配并查找对应<strong>资源</strong>，返回给浏览器并渲染</p></li><li><p>前端路由, (spa)纯浏览器行为，是由浏览器控制的API(hash/history)，当打开一个spa页面后，切换路由，浏览器改变<strong>地址栏url并通过js</strong>展示对应页面(组件)，即通过浏览器提供的接口hash/history来实现前端路由！</p></li></ul><h2 id="前端路由解决的问题"><a href="#前端路由解决的问题" class="headerlink" title="前端路由解决的问题"></a>前端路由解决的问题</h2><p>凡是整个项目都是 DOM 直出的页面，我们都称它为“传统页面”（SSR 属于首屏直出，这里我不认为是传统页面的范畴）<br>单页面应用都是通过JS渲染页面，比如这样</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">'text/javascript'</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> root = <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>) <span class="comment">// 获取根节点</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> divNode = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>) <span class="comment">// 创建 div 节点</span></span></span><br><span class="line"><span class="actionscript">    divNode.innerText = <span class="string">'前端路由是啥？'</span> <span class="comment">// 插入内容</span></span></span><br><span class="line"><span class="actionscript">    root.appendChild(divNode) <span class="comment">// 插入根节点</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>页面所有的组件都是通过一个app.js的脚本，通过该脚本生成dom挂在到app节点下面</p><p>为了解决单页面网站，通过切换浏览器地址路径，来匹配相对应的页面组件(需保证不刷新页面),下图</p><p><img src= "/img/loading.gif" data-src="/images/vue/router.png" alt="前端路由实现"></p><p>前端路由 会根据浏览器地址栏 <strong>pathname/hash</strong> 的变化，去匹配相应的页面组件。然后将其通过创建 DOM 节点的形式，插入到根节点 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code> 达到无刷新页面切换的效果(达到改变视图的同时不会向后端发出请求)，从侧面也能说明正因为无刷新，所以 React 、 Vue 、 Angular 等现代框架在创建页面组件的时候，每个组件都有自己的 生命周期 。</p><h2 id="前端路由实现原理"><a href="#前端路由实现原理" class="headerlink" title="前端路由实现原理"></a>前端路由实现原理</h2><h3 id="hash-哈希模式"><a href="#hash-哈希模式" class="headerlink" title="hash 哈希模式"></a>hash 哈希模式</h3><p>利用<em>a</em>标签锚点，浏览器通过<strong>hashchange</strong>事件能监听到url地址上针对 <strong>‘#’</strong>后面的变化。hashchange还能监听到如下变化</p><ul><li>点击a标签，改变浏览器地址</li><li>浏览器的前进和后退行为</li><li>通过window.location方法，改变浏览器地址</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>hashchange hash模式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'#/page1'</span>&gt;</span> page1 <span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'#/page2'</span>&gt;</span> page2 <span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 渲染组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'router-view'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">'module'</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, loaded)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, HashChange) <span class="comment">// 监听浏览器的前进后退 监听a标签改变的浏览器地址</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> routerView = <span class="literal">null</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">loaded</span><span class="params">()</span> </span>&#123; </span></span><br><span class="line"><span class="javascript">      routerView = <span class="built_in">document</span>.getElementById(<span class="string">'router-view'</span>)</span></span><br><span class="line">      HashChange()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">HashChange</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">switch</span>(location.hash) &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">case</span> <span class="string">'#/page1'</span>:</span></span><br><span class="line"><span class="actionscript">          routerView.innerHTML = <span class="string">'page1'</span></span></span><br><span class="line"><span class="actionscript">          <span class="keyword">break</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">case</span> <span class="string">'#/page2'</span>:</span></span><br><span class="line"><span class="actionscript">          routerView.innerHTML = <span class="string">'page 2'</span></span></span><br><span class="line"><span class="actionscript">          <span class="keyword">break</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="history-历史模式"><a href="#history-历史模式" class="headerlink" title="history 历史模式"></a>history 历史模式</h3><p>history依赖的原生事件是<strong>popstate</strong>,需要注意的是history.pushState()和history.replaceState()不会触发popstate事件，只有浏览器做出动作的时候,比如浏览器做出前进或者后退等(js代码中调用history.back()或者history.forward())</p><blockquote><p>pushState 和 replaceState 都是 HTML5 的新 API，他们的作用很强大，可以做到改变浏览器地址却不刷新页面。这是实现改变地址栏却不刷新页面的核心方法</p></blockquote><blockquote><p>关于 popstate 事件监听路由的局限, history对象的 back(), forward() 和 go() 三个等操作会主动触发 popstate 事件，但是 pushState 和 replaceState 不会触发 popstate 事件，这时我们需要手动触发页面跳转(渲染)。</p></blockquote><p>a标签的点击事件不会被popstate事件监听(这个popstate事件触发条件也是任性)，解决思路是遍历页面所有的a标签，监听a标签的点击事件，同时阻止a标签的默认行为preventDefault,在点击事件的回调函数里获取a标签的href属性，再通过pushState去主动改变浏览器的location.pathname值，然后手动执行popstate事件的回调函数(下文中的PopChange函数)，去匹配相应的路由，展示对应的页面组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>history 历史模式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'/page1'</span>&gt;</span> page11 <span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">'/page2'</span>&gt;</span> page22 <span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 渲染组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'router-view'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">'module'</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, loaded)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, PopChange) <span class="comment">// 监听浏览器的前进和后退 非常重要</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> routerView = <span class="literal">null</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">loaded</span><span class="params">()</span> </span>&#123; </span></span><br><span class="line"><span class="javascript">      routerView = <span class="built_in">document</span>.getElementById(<span class="string">'router-view'</span>)</span></span><br><span class="line">      PopChange()</span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> aList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'a[href]'</span>) <span class="comment">// 遍历所有a标签</span></span></span><br><span class="line"><span class="javascript">      aList.forEach(<span class="function"><span class="params">aNode</span> =&gt;</span> aNode.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        e.preventDefault() <span class="comment">// 阻止a标签的默认行为</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> href = aNode.getAttribute(<span class="string">'href'</span>)</span></span><br><span class="line"><span class="actionscript">        history.pushState(<span class="literal">null</span>, <span class="string">''</span>, href) <span class="comment">// 手动修改浏览器地址</span></span></span><br><span class="line"><span class="actionscript">        PopChange() <span class="comment">// 手动触发执行PopChange事件 匹配相应路由 不然浏览器地址都改变了页面无变化</span></span></span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">PopChange</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">switch</span>(location.pathname) &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">case</span> <span class="string">'/page1'</span>:</span></span><br><span class="line"><span class="actionscript">          routerView.innerHTML = <span class="string">'page 1'</span></span></span><br><span class="line"><span class="actionscript">          <span class="keyword">break</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">case</span> <span class="string">'/page2'</span>:</span></span><br><span class="line"><span class="actionscript">          routerView.innerHTML = <span class="string">'page 2'</span></span></span><br><span class="line"><span class="actionscript">          <span class="keyword">break</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里注意，不能在浏览器直接打开静态文件，需要通过 web 服务，启动端口去浏览网址。比如 live-server</p></blockquote><h2 id="Vue-router路由三种模式"><a href="#Vue-router路由三种模式" class="headerlink" title="Vue-router路由三种模式"></a>Vue-router路由三种模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mode = options.mode || <span class="string">'hash'</span></span><br><span class="line"><span class="keyword">this</span>.fallback = mode === <span class="string">'history'</span> &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.fallback) &#123;</span><br><span class="line">  mode = <span class="string">'hash'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!inBrowser) &#123;</span><br><span class="line">  mode = <span class="string">'abstract'</span> <span class="comment">// nodejs环境就是抽象模式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.mode = mode</span><br><span class="line"><span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'history'</span>:</span><br><span class="line">    <span class="keyword">this</span>.history = <span class="keyword">new</span> HTML5History(<span class="keyword">this</span>, options.base)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'hash'</span>:</span><br><span class="line">    <span class="keyword">this</span>.history = <span class="keyword">new</span> HashHistory(<span class="keyword">this</span>, options.base, <span class="keyword">this</span>.fallback)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'abstract'</span>:</span><br><span class="line">    <span class="keyword">this</span>.history = <span class="keyword">new</span> AbstractHistory(<span class="keyword">this</span>, options.base)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      assert(<span class="literal">false</span>, <span class="string">`invalid mode: <span class="subst">$&#123;mode&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。</li><li>history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。</li><li>abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式</li></ul><h2 id="手写vue-router"><a href="#手写vue-router" class="headerlink" title="手写vue-router"></a>手写vue-router</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">History</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.current = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.mode = options.mode || <span class="string">'hash'</span>;</span><br><span class="line">    <span class="keyword">this</span>.routes = options.routes || [];</span><br><span class="line">    <span class="keyword">this</span>.history = <span class="keyword">new</span> History;</span><br><span class="line">    <span class="keyword">this</span>.routesMap = <span class="keyword">this</span>.createMap(<span class="keyword">this</span>.routes)</span><br><span class="line">    <span class="keyword">this</span>.init()</span><br><span class="line">  &#125;</span><br><span class="line">  init() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mode === <span class="string">'hash'</span>) &#123;</span><br><span class="line">      <span class="comment">//如果为false的话，那么执行后面的语句，改成/</span></span><br><span class="line">      <span class="comment">//如果为true的话，执行''，不改变任何东西</span></span><br><span class="line">      location.hash ? <span class="string">''</span> : location.hash = <span class="string">'/'</span>;</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.history.current = location.hash.slice(<span class="number">1</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.history.current = location.hash.slice(<span class="number">1</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      location.pathname ? <span class="string">''</span> : location.pathname = <span class="string">'/'</span>;</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.history.current = location.pathname</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.history.current = location.pathname</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  createMap(routes) &#123;</span><br><span class="line">    <span class="keyword">return</span> routes.reduce(<span class="function">(<span class="params">prev, item</span>) =&gt;</span> &#123;</span><br><span class="line">      prev[item.path] = item.component</span><br><span class="line">      <span class="keyword">return</span> prev</span><br><span class="line">    &#125;, &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">VueRouter.install=<span class="function"><span class="keyword">function</span>(<span class="params">Vue</span>)</span>&#123;</span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    <span class="comment">//全局混入了router实例，并且做了响应式绑定</span></span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.$options &amp;&amp; <span class="keyword">this</span>.$options.router) &#123;</span><br><span class="line">        <span class="keyword">this</span>._root = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">this</span>._router = <span class="keyword">this</span>.$options.router</span><br><span class="line">        Vue.util.defineReactive(<span class="keyword">this</span>, <span class="string">'current'</span>, <span class="keyword">this</span>._router.history)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._root = <span class="keyword">this</span>.$parent._root</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  Vue.component(<span class="string">'router-view'</span>, &#123;</span><br><span class="line">    render(h) &#123;</span><br><span class="line">      <span class="keyword">let</span> current = <span class="keyword">this</span>._self._root._router.history.current;</span><br><span class="line">      <span class="built_in">console</span>.log(current);</span><br><span class="line">      <span class="keyword">let</span> routesMap = <span class="keyword">this</span>._self._root._router.routesMap</span><br><span class="line">      <span class="built_in">console</span>.log(routesMap);</span><br><span class="line">      <span class="keyword">return</span> h(routesMap[current])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> VueRouter</span><br></pre></td></tr></table></figure><h2 id="vue-router路由懒加载"><a href="#vue-router路由懒加载" class="headerlink" title="vue-router路由懒加载"></a>vue-router路由懒加载</h2><p>哪个组件用到就加载哪个组件，首屏渲染的时候不需要全都下载main.js,对比俩者的大小也能看出来<br>像 vue 这种单页面应用，如果没有路由懒加载，运用 webpack 打包后的文件将会很大，造成进入首页时，需要加载的内容过多，出现较长时间的白屏，运用路由懒加载则可以将页面进行划分，需要的时候才加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时。<br>懒加载三种方式:</p><ul><li>vue 异步组件</li><li>ES6 的 import()</li><li>webpack 的 require.ensure()</li></ul><ol><li><p>vue 异步组件 这种方法主要是使用了 resolve 的异步机制，用 require 代替了 import 实现按需加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Main = <span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">require</span>([<span class="string">'./main'</span>], resolve);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      component: Main</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>es6中的import函数 按需加载,可以理解也是为通过 Promise 的 resolve 机制。因为 Promise 函数返回的 Promise 为 resolve 组件本身，而我们又可以使用 import 来导入组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Main = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./main'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      component: Main</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>3.webpack 的 require.ensure() 这种模式可以通过参数中的 webpackChunkName 将 js 分开打包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      component: <span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">require</span>.ensure([], () =&gt; resolve(<span class="built_in">require</span>(<span class="string">'@/components/main'</span>)), <span class="string">'main'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="路由导航守卫"><a href="#路由导航守卫" class="headerlink" title="路由导航守卫"></a>路由导航守卫</h2><p>正如其名，vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。<br>记住参数或查询的改变并不会触发进入/离开的导航守卫。你可以通过观察 $route 对象来应对这些变化，或使用 beforeRouteUpdate 的组件内守卫</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="关于子路由刷新的解决方式"><a href="#关于子路由刷新的解决方式" class="headerlink" title="关于子路由刷新的解决方式"></a>关于子路由刷新的解决方式</h3><p>history模式子路由刷新会404，因此需要后端配合，将未匹配到的路由默认指向html文件</p><h3 id="浏览器（环境）兼容处理"><a href="#浏览器（环境）兼容处理" class="headerlink" title="浏览器（环境）兼容处理"></a>浏览器（环境）兼容处理</h3><p>history 模式中pushState、replaceState是HTML5的新特性，在 IE9 下会强行降级使用 hash 模式，非浏览器环境转换成abstract 模式。</p><h3 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h3><p>router-link点击相当于调用$router.push方法去修改url</p><p><router-link> 比起写死的 <code>&lt;a href=&quot;...&quot;&gt;</code> 会好一些，理由如下：</p><p>无论是 HTML5 history 模式还是 hash 模式，它的表现行为一致，所以，当你要切换路由模式，或者在 IE9 降级使用 hash 模式，无须作任何变动。<br>在 HTML5 history 模式下，router-link 会守卫点击事件，让浏览器不再重新加载页面。<br>当你在 HTML5 history 模式下使用 base 选项之后，所有的 to 属性都不需要写（基路径）了。</p><h3 id="route和-router的区别"><a href="#route和-router的区别" class="headerlink" title="$route和$router的区别"></a>$route和$router的区别</h3><p>$route是当前路由信息对象，包括path，params，hash，query，fullPath，matched，name等路由信息参数。<br>而$router是路由实例对象，包括了路由的跳转方法，路由守卫、钩子函数、当前路由模式等,包含子路由信息，即$router.currentRoute === $route</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB" target="_blank" rel="noopener">导航守卫</a></li><li><a href="https://juejin.cn/post/6844903806782668814#heading-2" target="_blank" rel="noopener">vue面试</a></li><li><a href="https://juejin.cn/post/6862215979745673224" target="_blank" rel="noopener">Vue-router源码</a></li><li><a href="https://mp.weixin.qq.com/s/j78ycLwTFYOVFIM9er-A7Q" target="_blank" rel="noopener">对前端路由的一些理解</a></li><li><a href="https://juejin.cn/post/6947847527253311496#heading-20" target="_blank" rel="noopener">vue高频面试题整理</a></li><li><a href="https://vue3js.cn/interview/vue/spa.html#%E4%B8%89%E3%80%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAspa" target="_blank" rel="noopener">面试官：你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢</a></li><li><a href="https://juejin.cn/post/6854573214485053453#heading-16" target="_blank" rel="noopener">【面试必备】如何实现 VueRouter？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue-router </category>
          
          <category> hashchange </category>
          
          <category> popstate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue-router </tag>
            
            <tag> hashchange </tag>
            
            <tag> popstate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue进阶6-diff算法</title>
      <link href="/2021/04/03/vue%E8%BF%9B%E9%98%B66-diff%E7%AE%97%E6%B3%95/"/>
      <url>/2021/04/03/vue%E8%BF%9B%E9%98%B66-diff%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-src="/images/diff/diff3.png" alt="diff"></p><h2 id="数据发生变化时，vue是怎么更新节点的"><a href="#数据发生变化时，vue是怎么更新节点的" class="headerlink" title="数据发生变化时，vue是怎么更新节点的"></a>数据发生变化时，vue是怎么更新节点的</h2><p>我们先根据真实DOM生成一颗virtual DOM，当virtual DOM某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使oldVnode的值为Vnode。<br>diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁。</p><h2 id="分析Vue中-diff算法与虚拟dom"><a href="#分析Vue中-diff算法与虚拟dom" class="headerlink" title="分析Vue中 diff算法与虚拟dom"></a>分析Vue中 diff算法与虚拟dom</h2><p><img src= "/img/loading.gif" data-src="/images/diff/diff%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B.png" alt="diff算法过程"></p><h2 id="vue中diff核心策略"><a href="#vue中diff核心策略" class="headerlink" title="vue中diff核心策略"></a>vue中diff核心策略</h2><p>平级比较，不考虑跨级比较节点的情况，内部采用深度优先递归 + 双指针(两端对比)策略进行比较<br>Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作，<br>展开来说</p><p>(观察主流的虚拟 DOM 库（<strong>snabbdom</strong>、virtual-dom），通常都有一个 h 函数，也就是 React 中的 React.createElement，以及 Vue 中的 render 方法中的 createElement，另外 React 是通过 babel 将 jsx 转换为 h 函数渲染的形式，而 Vue 是使用 vue-loader 将模版转为 h 函数渲染的形式（也可以通过 babel-plugin-transform-vue-jsx 插件在 vue 中使用 jsx，本质还是转换为 h 函数渲染形式）。)</p><p>可以看到，最终 HTML 代码会被转译成 h 函数的渲染形式。h 函数接受是三个参数，分别代表是 DOM 元素的标签名、属性、子节点，最终返回一个虚拟 DOM 的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">tag, props, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    tag,</span><br><span class="line">    props: props || &#123;&#125;,</span><br><span class="line">    children: children.flat()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s/oAlVmZ4Hbt2VhOwFEkNEhw" target="_blank" rel="noopener">从 h 函数说起</a></p><h3 id="vm-update"><a href="#vm-update" class="headerlink" title="vm.update"></a>vm.update</h3><p>当数据发生改变时，set方法会让调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图。</p><h3 id="patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点"><a href="#patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点" class="headerlink" title="patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点"></a>patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点</h3><ul><li>判断两节点是否值得比较(基本属性是否相同，sameVnode)，值得比较则执行patchVnode；</li><li>不值得比较则创建新节点Vnode替换oldVnode；</li></ul><h3 id="patchVnode：当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法；"><a href="#patchVnode：当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法；" class="headerlink" title="patchVnode：当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法；"></a>patchVnode：当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法；</h3><ul><li>找到对应的真实dom，称为el；</li><li>判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return；</li><li>如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点；</li><li>如果oldVnode有子节点而Vnode没有，则删除el的子节点；</li><li>如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el；</li><li>如果两者都有子节点且不相同，则执行updateChildren函数比较子节点，这一步很重要</li></ul><h3 id="updateChildren函数"><a href="#updateChildren函数" class="headerlink" title="updateChildren函数"></a>updateChildren函数</h3><p>现在分别对oldS、oldE、S、E两两做sameVnode比较，有四种比较方式，当其中两个能匹配上那么真实dom中的相应节点会移到Vnode相应的位置</p><ul><li>如果是oldS和E匹配上了，那么真实dom中的第一个节点会移到最后</li><li>如果是oldE和S匹配上了，那么真实dom中的最后一个节点会移到最前，匹配上的两个指针向中间移动</li><li>如果四种匹配没有一对是成功的，分为两种情况<ul><li>如果新旧子节点都存在key，那么会根据oldChild的key生成一张hash表，用S的key与hash表做匹配，匹配成功就判断S和匹配节点是否为sameNode，如果是，就在真实dom中将成功的节点移到最前面，否则，将S生成对应的节点插入到dom中对应的oldS位置，S指针向中间移动，被匹配old中的节点置为null。</li><li>如果没有key,则<strong>直接将S生成新的节点插入真实DOM</strong>（ps：这下可以解释为什么v-for的时候需要设置key了，如果没有key那么就只会做四种匹配，就算指针中间有可复用的节点都不能被复用了,没做到）</li></ul></li></ul><h2 id="vue中-diff算法是如何比对新旧虚拟dom树节点的"><a href="#vue中-diff算法是如何比对新旧虚拟dom树节点的" class="headerlink" title="vue中 diff算法是如何比对新旧虚拟dom树节点的"></a>vue中 diff算法是如何比对新旧虚拟dom树节点的</h2><ul><li>判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return</li><li>进行文本节点的判断，若 oldVnode.text !== vnode.text，那么就会直接进行文本节点的替换；</li><li>在vnode没有文本节点的情况下，进入子节点的 diff；</li><li>当 oldCh 和 ch 都存在且不相同的情况下，调用<strong>updateChildren</strong>对子节点进行 diff；</li><li>若 oldCh不存在，ch 存在，首先清空 oldVnode 的文本节点，同时调用 addVnodes 方法将 ch 添加到elm真实 dom 节点当中；</li><li>若 oldCh存在，ch不存在，则删除 elm 真实节点下的 oldCh 子节点；</li><li>若 oldVnode 有文本节点，而 vnode 没有，那么就清空这个文本节点。</li></ul><h2 id="Vue中的diff算法"><a href="#Vue中的diff算法" class="headerlink" title="Vue中的diff算法"></a>Vue中的diff算法</h2><p>看源码之前，先把俩个常用的工具函数贴一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUndef</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v === <span class="literal">undefined</span> || v === <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDef</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v !== <span class="literal">undefined</span> &amp;&amp; v !== <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue-js-源码的-diff-调用逻辑"><a href="#Vue-js-源码的-diff-调用逻辑" class="headerlink" title="Vue.js 源码的 diff 调用逻辑"></a>Vue.js 源码的 diff 调用逻辑</h3><p><img src= "/img/loading.gif" data-src="/images/diff/diff.jpg" alt="diff"></p><p>每个组件实例都会有相应的Watcher实,渲染组件的过程，会把属性记录为依赖，当我们操作数据的时候，依赖项的setter会被调用，从而通知Watcher重新计算，从而使得相关的组件得以更新。<br>完成视图的更新工作事实上就是调用了vm._update方法，这个方法接收的第一个参数是刚生成的Vnode，调用的vm._update方法定义在 <code>src/core/instance/lifecycle.js</code>中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> prevEl = vm.$el</span><br><span class="line">  <span class="keyword">const</span> prevVnode = vm._vnode</span><br><span class="line">  vm._vnode = vnode</span><br><span class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">    <span class="comment">// initial render 没有父节点 vm.$el真实的dom节点</span></span><br><span class="line">    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// updates 更新的时候走这里 老 新节点进行diff</span></span><br><span class="line">    vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">    prevEl.__vue__ = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">    vm.$el.__vue__ = vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">    vm.$parent.$el = vm.$el</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法当中最为关键的就是 vm.<strong>patch</strong> 方法，这也是整个 virtual-dom 当中最为核心的方法，主要完成了prevVnode 和 vnode 的 diff 过程并根据需要操作的 vdom 节点打 patch，最后生成新的真实 dom 节点并完成视图的更新工作。</p><p>接下来，让我们看下 vm.<strong>patch</strong> 的逻辑过程， vm.<strong>patch</strong> 方法定义在 <code>src/core/vdom/patch.js</code> 中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</span><br><span class="line">      <span class="comment">// 创建一个新节点 create new root element</span></span><br><span class="line">      isInitialPatch = <span class="literal">true</span></span><br><span class="line">      createElm(vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 对oldVnode和vnode进行diff，并对oldVnode打patch  </span></span><br><span class="line">      <span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType)</span><br><span class="line">      <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        <span class="comment">// patch existing root node</span></span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果新旧来个节点局部属性不一致则跳过diff 直接新建一个vNode</span></span><br><span class="line">        createElm(</span><br><span class="line">          vnode,</span><br><span class="line">          insertedVnodeQueue,</span><br><span class="line">          oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</span><br><span class="line">          nodeOps.nextSibling(oldElm)</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在 patch 方法中，我们看到会分为两种情况，<br><strong>一种是当 oldVnode 不存在时，会创建新的节点</strong><br><strong>另一种则是已经存在 oldVnode ，那么会对 oldVnode 和 vnode 进行 diff 及 patch 的过程</strong></p><p>其中 patch 过程中会调用 <strong>sameVnode</strong> 方法来对对传入的2个 vnode 进行基本属性的比较，只有当基本属性相同的情况下才认为新旧俩个vnode 只是局部发生了更新，然后才会对这新旧俩个 vnode 进行 diff<br>如果俩个vnode 的基本属性存在不一致的情况，那么就会直接跳过 diff 的过程，进而依据 vnode 新建一个真实的 dom，同时删除老的 dom 节点。</p><blockquote><p>patchVnode和patch区别<br>pacth调用patchVnode，如果存在老节点 才会执行该方法，颗粒度更细</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较基本属性如tagName data属性等</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.key === b.key &amp;&amp; (</span><br><span class="line">      (</span><br><span class="line">        a.tag === b.tag &amp;&amp; </span><br><span class="line">        a.isComment === b.isComment &amp;&amp;</span><br><span class="line">        isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class="line">        sameInputType(a, b)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>diff 过程中主要是通过调用 patchVnode 方法进行的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  oldVnode,</span></span></span><br><span class="line"><span class="function"><span class="params">  vnode</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> oldCh = oldVnode.children</span><br><span class="line">  <span class="keyword">const</span> ch = vnode.children</span><br><span class="line">  <span class="comment">// 如果vnode没有文本节点</span></span><br><span class="line">  <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">    <span class="comment">// 如果oldVnode的children属性存在且vnode的children属性也存在  </span></span><br><span class="line">    <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">      <span class="comment">// 新老  子节点不一样 整个diff的核心  </span></span><br><span class="line">      <span class="keyword">if</span> (oldCh !== ch) &#123;</span><br><span class="line">        <span class="comment">// updateChildren，对子节点进行diff  </span></span><br><span class="line">        updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        checkDuplicateKeys(ch)</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// 如果oldVnode的text存在，那么首先清空text的内容,然后将vnode的children添加进去  </span></span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">      addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">      <span class="comment">// 删除elm下的oldchildren</span></span><br><span class="line">      removeVnodes(oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">      <span class="comment">// oldVnode有子节点，而vnode没有，那么就清空这个节点  </span></span><br><span class="line">      nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">    <span class="comment">// 新老节点不一样 直接进行文本节点的替换</span></span><br><span class="line">    nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码得知<br>diff 过程中又分了好几种情况，oldCh 为 oldVnode的子节点，ch 为 Vnode 的子节点：</p><ul><li>判断oldVnode和Vnode是否相同，相同直接退出</li><li>如果他们都有文本节点并且不相等，那么将更新为Vnode的文本节点</li><li>在 vnode 没有文本节点的情况下，进入子节点的 diff；</li><li>当 oldCh 和 ch 都存在且不相同的情况下，调用 <strong>updateChildren</strong> 对子节点进行 diff；</li><li>若 oldCh 不存在，ch 存在，首先清空 oldVnode 的文本节点，同时调用 <em>addVnodes</em> 方法将 ch 添加到<em>elm</em>真实dom节点当中；</li><li>若 oldCh 存在，ch 不存在，则删除 elm 真实节点下的 oldCh 子节点；</li><li>若 oldVnode 有文本节点，而 vnode 没有，那么就清空这个文本节点</li></ul><h3 id="子节点-diff-流程分析"><a href="#子节点-diff-流程分析" class="headerlink" title="子节点 diff 流程分析"></a>子节点 diff 流程分析</h3><p>这里着重分析下 updateChildren方法，它也是整个 diff 过程中最重要的环节，以下为 Vue.js 的源码过程，为了更形象理解 diff 过程，我们给出相关的示意图来讲解。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span> (<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 为oldCh和newCh分别建立索引，为之后遍历的依据</span></span><br><span class="line">   <span class="keyword">let</span> oldStartIdx = <span class="number">0</span></span><br><span class="line">   <span class="keyword">let</span> newStartIdx = <span class="number">0</span></span><br><span class="line">   <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span></span><br><span class="line">   <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">   <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span></span><br><span class="line">   <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">   <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">   <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line">   <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">     <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">       oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">       oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">       patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">       oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">       newStartVnode = newCh[++newStartIdx]</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">       patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">       oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">       newEndVnode = newCh[--newEndIdx]</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">       patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">       canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">       oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">       newEndVnode = newCh[--newEndIdx]</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">       patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">       canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">       oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">       newStartVnode = newCh[++newStartIdx]</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">       idxInOld = isDef(newStartVnode.key)</span><br><span class="line">         ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">         : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">       <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">         <span class="comment">// 在老的节点找key 找不到就新加子节点</span></span><br><span class="line">         createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         vnodeToMove = oldCh[idxInOld]</span><br><span class="line">         <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">           patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">           oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">           canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">           createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       newStartVnode = newCh[++newStartIdx]</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">     refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">     addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">     removeVnodes(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>updateChildren函数主要做了一下工作</p><ul><li>将Vnode的子节点Vch和oldVnode的子节点oldCh 开始和结束提取出来<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>] <span class="comment">// 老的子节点 开始</span></span><br><span class="line"><span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx] <span class="comment">// 老的子节点 结束</span></span><br><span class="line"><span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>] <span class="comment">// 新的子节点 开始</span></span><br><span class="line"><span class="keyword">let</span> newEndVnode = newCh[newEndIdx] <span class="comment">// 新的子节点 开始</span></span><br></pre></td></tr></table></figure></li><li>oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx &gt; EndIdx 表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。</li></ul><h3 id="patch过程中涉及的操作DOM-api"><a href="#patch过程中涉及的操作DOM-api" class="headerlink" title="patch过程中涉及的操作DOM api"></a>patch过程中涉及的操作DOM api</h3><p>diff 我们会看到 <strong>nodeOps</strong> 相关的方法对真实 DOM 结构进行操作，nodeOps 定义在 src/platforms/web/runtime/node-ops.js 中，其为基本 DOM 操作,有一个是关于<strong>setStyleScope</strong>设置属性scoped的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span> (<span class="params">tagName: string, vnode: VNode</span>): <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> elm = <span class="built_in">document</span>.createElement(tagName)</span><br><span class="line">  <span class="keyword">if</span> (tagName !== <span class="string">'select'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> elm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vnode.data &amp;&amp; vnode.data.attrs &amp;&amp; vnode.data.attrs.multiple !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    elm.setAttribute(<span class="string">'multiple'</span>, <span class="string">'multiple'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> elm</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElementNS</span> (<span class="params">namespace: string, tagName: string</span>): <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.createElementNS(namespaceMap[namespace], tagName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createTextNode</span> (<span class="params">text: string</span>): <span class="title">Text</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.createTextNode(text)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComment</span> (<span class="params">text: string</span>): <span class="title">Comment</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.createComment(text)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">insertBefore</span> (<span class="params">parentNode: Node, newNode: Node, referenceNode: Node</span>) </span>&#123;</span><br><span class="line">  parentNode.insertBefore(newNode, referenceNode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">removeChild</span> (<span class="params">node: Node, child: Node</span>) </span>&#123;</span><br><span class="line">  node.removeChild(child)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">appendChild</span> (<span class="params">node: Node, child: Node</span>) </span>&#123;</span><br><span class="line">  node.appendChild(child)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parentNode</span> (<span class="params">node: Node</span>): ?<span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> node.parentNode</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextSibling</span> (<span class="params">node: Node</span>): ?<span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> node.nextSibling</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">tagName</span> (<span class="params">node: Element</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> node.tagName</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setTextContent</span> (<span class="params">node: Node, text: string</span>) </span>&#123;</span><br><span class="line">  node.textContent = text</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setStyleScope</span> (<span class="params">node: Element, scopeId: string</span>) </span>&#123;</span><br><span class="line">  node.setAttribute(scopeId, <span class="string">''</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图解子节点diff"><a href="#图解子节点diff" class="headerlink" title="图解子节点diff"></a>图解子节点diff</h3><p><img src= "/img/loading.gif" data-src="/images/diff/diff4.gif" alt="diff"></p><p>现在分别对oldS、oldE、S、E两两做sameVnode比较，有四种比较方式，当其中两个能匹配上那么<em>真实dom</em>中的相应节点会移到Vnode相应的位置，这句话有点绕，打个比方</p><ul><li>如果是oldS和E匹配上了，那么真实dom中的第一个节点会移到最后</li><li>如果是oldE和S匹配上了，那么真实dom中的最后一个节点会移到最前，匹配上的两个指针向中间移动</li><li>如果四种匹配没有一对是成功的，分为两种情况<ul><li>如果新旧子节点都存在key，那么会根据oldChild的key生成一张hash表，用S的key与hash表做匹配，匹配成功就判断S和匹配节点是否为sameNode，如果是，就在真实dom中将成功的节点移到最前面，否则，将S生成对应的节点插入到dom中对应的oldS位置，S指针向中间移动，被匹配old中的节点置为null。</li><li>如果没有key,则<strong>直接将S生成新的节点插入真实DOM</strong>（ps：这下可以解释为什么v-for的时候需要设置key了，如果没有key那么就只会做四种匹配，就算指针中间有可复用的节点都不能被复用了,没做到）</li></ul></li></ul><p>(假设old和new中的子节点都有key)<br><img src= "/img/loading.gif" data-src="/images/diff/diff1.png" alt="diff"></p><ul><li><p>第一步<br>oldS: a, oldE: d<br>S: a, E: b<br>oldS和S匹配，则将dom中的a节点放到第一个，已经是第一个了就不管了，此时dom的位置为：a b d</p></li><li><p>第二步<br>oldS:b oldE:d<br>S:c E:b<br>oldS和E匹配上，将真实dom节点b移到最后，因为E中的b在最后位置，印证这句话:一旦能匹配上，则真实dom对应节点将会按照newE中的位置来，此时真实dom位置是 a d b</p></li><li><p>第三步<br>oldS: d oldE: d<br>S: c E: d<br>oldS和E匹配上，位置不变 此时还是 a d b</p></li><li><p>第四步<br>oldS++;<br>oldE–;<br>oldS &gt; oldE;<br>遍历结束，说明oldCh先遍历完。就将剩余的vCh节点根据自己的的index插入到真实dom中去，此时dom位置为：a c d b</p></li></ul><p>这个匹配过程的结束有两个条件：</p><ul><li>oldS &gt; oldE表示oldCh先遍历完，新节点多余老节点，那么就将多余的vCh根据index添加到dom中去（如上图）</li><li>S &gt; E表示vCh先遍历完，新节点少于老节点，那么就在真实dom中将区间为<strong>[oldS, oldE]</strong>的多余节点删掉</li></ul><p>第二个例子模拟下diff过程<br><img src= "/img/loading.gif" data-src="/images/diff/diff2.png" alt="diff"></p><ul><li><p>第一步<br>oldS: b, oldE: e<br>S: a, E: e<br>oldE和E匹配，则将dom中的e节点放到最后一个，此时真实dom位置是 b a d f e</p></li><li><p>第二步<br>oldS:b oldE:f<br>S:a E:b<br>oldS和E匹配上，将真实dom节点b移到倒数第二位，此时真实dom位置是 a d f b e</p></li><li><p>第三步<br>oldS: a oldE: f<br>S: a E: a<br>oldS和S匹配上，位置不变 此时还是 a d f b e</p></li><li><p>第四步<br>S ++;<br>E –;<br>S &gt; E;<br>遍历结束，说明Ch先遍历完。S &gt; E表示vCh先遍历完，新节点少于老节点，那么就在真实dom中将区间为<strong>[oldS, oldE]</strong>的多余节点删掉,此时真实dom位置就是 a b e </p></li></ul><p>当这些节点sameVnode成功后就会紧接着执行patchVnode(又回到前面的patchVnode方法了，递归咯)了，可以看一下上面的代码<br>就这样层层递归下去，直到将oldVnode和Vnode中的所有子节点比对完。也将dom的所有补丁都打好啦.DomDiff的过程更像是俩棵树的比较，每找到相同的节点，都会层层往下比较子节点，这才是真正的<em>深度递归遍历比较</em>的过程</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://mp.weixin.qq.com/s/mIk9skR1wmmXNUdneec-UQ" target="_blank" rel="noopener">分析diff算法与虚拟dom（理解现代前端框架）</a></li><li><a href="https://mp.weixin.qq.com/s/-KHkunImjGPXZeZDmyctNw" target="_blank" rel="noopener">vue3.0 diff算法详解(超详细)</a></li><li><a href="https://juejin.cn/post/6844903895467032589#heading-14" target="_blank" rel="noopener">深入剖析：Vue核心之虚拟DOM</a></li><li><a href="https://juejin.cn/post/6844903607913938951" target="_blank" rel="noopener">详解vue的diff算法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> diff </category>
          
          <category> vNode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vNode </tag>
            
            <tag> diff </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue进阶5-virtual Dom</title>
      <link href="/2021/04/03/vue%E8%BF%9B%E9%98%B65-virtual-Dom/"/>
      <url>/2021/04/03/vue%E8%BF%9B%E9%98%B65-virtual-Dom/</url>
      
        <content type="html"><![CDATA[<h2 id="virtual-Dom-是什么"><a href="#virtual-Dom-是什么" class="headerlink" title="virtual Dom 是什么"></a>virtual Dom 是什么</h2><p>虚拟 DOM 其实就是js对象，通过对象的方式表示真实的 DOM 结构，将页面的状态抽象成js对象的形式</p><h2 id="为什么需要虚拟dom"><a href="#为什么需要虚拟dom" class="headerlink" title="为什么需要虚拟dom"></a>为什么需要虚拟dom</h2><p>频繁的操作 DOM 会使得网站的性能下降，为了保证性能，我们需要使得 DOM 的操作尽量精简，我们可以通过操作虚拟 DOM 的方法，去比较新旧节点的差异然后精确的获取最小的，最为必要的 DOM 集合，最终挂载到真实的 DOM 上。因为操作数据结构，远比我们直接修改 DOM 节点来的快，我们真实的 DOM 操作在最好的情况下，其实只需要在最后来那么一下，他们喊是patch补丁一下</p><ul><li>保证各框架性能下限，在不进行手动优化的情况下，提供系统过得去的性能</li><li>跨平台，例如服务端渲染(这个能力的根本，是 Javascript 代码能<strong>低代价</strong>地在各个平台运行（得利于浏览器在各个平台的普及和 NodeJS），也就是常说的 Javascript 的优势之一是跨平台)</li></ul><h2 id="虚拟dom优缺点"><a href="#虚拟dom优缺点" class="headerlink" title="虚拟dom优缺点"></a>虚拟dom优缺点</h2><ul><li>优点是其抽象能力和常驻内存的特性，让vue/react框架能更容易实现更强大的 diff 算法(由于 Virtual DOM 的存在，diff 算法可以更方便且更强大)</li><li>缺点是增加了框架复杂度，也占用了更多的内存</li></ul><p>(本想说一下几个优势，后来发现有大佬觉得这不是虚拟dom的优势)</p><p><a href="https://mp.weixin.qq.com/s/nwnnlMLdC-LvnY3-CiiT6A" target="_blank" rel="noopener">大佬总结的几个关于 Virtual DOM 优势误区：</a></p><ul><li><p>操作 DOM 太慢，操作 Virtual DOM 对象快 ❌<br>Virtual DOM 很快，但这并不是它的优势，因你本可以选择不使用 Virtual DOM 。</p></li><li><p>使用 Virtual DOM 可以避免频繁操作 DOM ，能有效减少回流和重绘次数 ❌<br>无论你在一次事件循环中调用多少次的 DOM API ，浏览器也只会触发一次回流与重绘（如果需要），并且如果多次调用并没有修改 DOM 状态，那么回流与重绘一次都不会发生。批量操作也不能减少回流与重绘。</p></li><li><p>Virtual DOM 有跨平台优势 ❌<br>跨平台是 Javascript 的优势，与 Virtual DOM 无关。</p></li></ul><h2 id="virtual-dom-实现"><a href="#virtual-dom-实现" class="headerlink" title="virtual dom 实现"></a>virtual dom 实现</h2><p>主要是这四个步骤，基本上大差不差</p><ul><li>用js对象模拟DOM树</li><li>render方法生成真实 DOM 节点</li><li>计算新老虚拟dom差异-即diff算法</li><li>将两个虚拟 DOM 对象的差异应用到真正的 DOM 树 </li></ul><h3 id="用js对象模拟DOM树"><a href="#用js对象模拟DOM树" class="headerlink" title="用js对象模拟DOM树"></a>用js对象模拟DOM树</h3><ul><li>tagName 对应真实的标签类型，比如ul标签p标签等等</li><li>attrs 表示节点上的所有属性，比如<code>arrts: {class: &#39;list&#39;, style: &quot;color:green&quot;}</code></li><li>child 表示该节点的孩子节点, 比如<code>[&#39;Vue&#39;]</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(tagName, attrs = &#123;&#125;, child = []) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tagName = tagName</span><br><span class="line">    <span class="keyword">this</span>.attrs = attrs</span><br><span class="line">    <span class="keyword">this</span>.child = child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newElement</span>(<span class="params">tag, attr, child</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Element(tag, attr, child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 newElement方法即可生成</p><h3 id="render方法生成真实-DOM-节点"><a href="#render方法生成真实-DOM-节点" class="headerlink" title="render方法生成真实 DOM 节点"></a>render方法生成真实 DOM 节点</h3><ul><li>增加设置对象属性的方法setAttr()</li><li>类的内部添加创建真实DOm节点的 render 方法</li><li>最后通过一个renderDom方法将dom 渲染到浏览器(appendChild)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对标签设置属性</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setAttr = <span class="function"><span class="keyword">function</span> (<span class="params">node, key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'style'</span>:</span><br><span class="line">      node.style.cssText = <span class="string">`<span class="subst">$&#123;value&#125;</span>`</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'value'</span>:</span><br><span class="line">      <span class="keyword">let</span> tagName = node.tagName || <span class="string">''</span></span><br><span class="line">      tagName = tagName.toLowerCase()</span><br><span class="line">      <span class="keyword">if</span> (tagName === <span class="string">'input'</span> || tagName === <span class="string">'textarea'</span>) &#123;</span><br><span class="line">        node.value = value</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.setAttribute(key, value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      node.setAttribute(key, value)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(tagName, attrs = &#123;&#125;, child = []) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tagName = tagName</span><br><span class="line">    <span class="keyword">this</span>.attrs = attrs</span><br><span class="line">    <span class="keyword">this</span>.child = child</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> ele = <span class="built_in">document</span>.createElement(<span class="keyword">this</span>.tagName)</span><br><span class="line">    <span class="keyword">let</span> attrs = <span class="keyword">this</span>.attrs</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> attrs) &#123;</span><br><span class="line">      setAttr(ele, key, attrs[key])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> childNodes = <span class="keyword">this</span>.child</span><br><span class="line">    <span class="comment">// 如果是虚拟dom就继续递归遍历</span></span><br><span class="line">    <span class="comment">// 不是就代表文本节点 直接创建</span></span><br><span class="line">    childNodes.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> childEle = child <span class="keyword">instanceof</span> Element</span><br><span class="line">        ? child.render()</span><br><span class="line">        : <span class="built_in">document</span>.createTextNode(child)</span><br><span class="line">      <span class="comment">// 挂在到真实的dom节点上</span></span><br><span class="line">      ele.appendChild(childEle)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> ele</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> RealDom = VdObj1.render()</span><br><span class="line"><span class="comment">// console.dir(RealDom)</span></span><br><span class="line"><span class="keyword">const</span> renderDom = <span class="function"><span class="keyword">function</span> (<span class="params">element, target</span>) </span>&#123;</span><br><span class="line">  target.appendChild(element)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderDom(RealDom, <span class="built_in">document</span>.body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="比较新老虚拟dom差异-即diff算法"><a href="#比较新老虚拟dom差异-即diff算法" class="headerlink" title="比较新老虚拟dom差异-即diff算法"></a>比较新老虚拟dom差异-即diff算法</h3><p>diff 算法用来比较两棵 Virtual DOM 树的差异，如果需要两棵树的完全比较，那么 diff 算法的时间复杂度为O(n^3)。但是在前端当中，你很少会跨越层级地移动 DOM 元素，所以 Virtual DOM 只会对同一个层级的元素进行对比，如下图所示， div 只会和同一层级的 div 对比，第二层级的只会跟第二层级对比，这样算法复杂度就可以达到 O(n)</p><ul><li>深度优先遍历，记录差异</li><li>根据差异更改原先真实的dom结构,即更新dom</li></ul><h4 id="深度优先遍历-记录俩棵树的差异"><a href="#深度优先遍历-记录俩棵树的差异" class="headerlink" title="深度优先遍历 记录俩棵树的差异"></a>深度优先遍历 记录俩棵树的差异</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> diff = <span class="function">(<span class="params">oldNode, newNode</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 用来存放补丁的对象</span></span><br><span class="line">  <span class="keyword">let</span> difference = &#123;&#125;</span><br><span class="line">  <span class="comment">// 递归树 然后把比较后的结果放到补丁里</span></span><br><span class="line">  walk(oldNode, newNode, <span class="number">0</span>, difference)</span><br><span class="line">  <span class="keyword">return</span> difference</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> initIndex = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> REMOVE = <span class="string">'remove'</span></span><br><span class="line"><span class="keyword">const</span> MODIFY_TEXT = <span class="string">'modify_text'</span></span><br><span class="line"><span class="keyword">const</span> CHANGE_ATTRS = <span class="string">'change_attrs'</span></span><br><span class="line"><span class="keyword">const</span> TACEREPLACE = <span class="string">'replace'</span></span><br><span class="line"><span class="comment">// 获取最小差异数组</span></span><br><span class="line"><span class="keyword">const</span> walk = <span class="function">(<span class="params">oldNode, newNode, index, difference</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 每个元素都有一个补丁</span></span><br><span class="line">  <span class="keyword">let</span> diffResult = []</span><br><span class="line">  <span class="keyword">if</span> (!newNode) &#123;</span><br><span class="line">    diffResult.push(&#123;</span><br><span class="line">      index,</span><br><span class="line">      type: REMOVE</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 文本节点直接替换</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> newNode === <span class="string">'string'</span> &amp;&amp; <span class="keyword">typeof</span> oldNode === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldNode !== newNode) &#123;</span><br><span class="line">      diffResult.push(&#123;</span><br><span class="line">        index,</span><br><span class="line">        value: newNode,</span><br><span class="line">        type: MODIFY_TEXT</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldNode.tagName === newNode.tagNam) &#123;</span><br><span class="line">    <span class="comment">// 节点类型相同 则继续比较熟悉是否相同</span></span><br><span class="line">    <span class="keyword">let</span> storeAttrs = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> oldNode.attrs) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldNode.attrs[key] !== newNode.attrs[key]) &#123;</span><br><span class="line">        storeAttrs[key] = oldNode.attrs[key]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> newNode.attrs) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!oldNode.attrs.hasOwnProperty(key)) &#123;</span><br><span class="line">        storeAttrs[key] = newNode.attrs[key]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(storeAttrs).length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      diffResult.push(&#123;</span><br><span class="line">        index,</span><br><span class="line">        value: storeAttrs,</span><br><span class="line">        type: CHANGE_ATTRS</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归遍历子节点</span></span><br><span class="line">    <span class="keyword">if</span> (oldNode.child &amp;&amp; oldNode.child.length) &#123;</span><br><span class="line">      oldNode.child.forEach(<span class="function">(<span class="params">child, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 深度递归遍历所有要保留的index</span></span><br><span class="line">        getDiff(child, newNode.child[index], ++initIndex, difference)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldNode.tagName !== newNode.tagName) &#123;</span><br><span class="line">    <span class="comment">// 节点类型不相同 直接替换</span></span><br><span class="line">    diffResult.push(&#123;</span><br><span class="line">      index,</span><br><span class="line">      type: TACEREPLACE,</span><br><span class="line">      newNode</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!oldNode) &#123;</span><br><span class="line">    diffResult.push(&#123;</span><br><span class="line">      newNode,</span><br><span class="line">      type: TACEREPLACE</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前元素补丁放到大补丁</span></span><br><span class="line">  <span class="keyword">if</span> (diffResult.length) &#123;</span><br><span class="line">    difference[index] = diffResult</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="根据差异更改原先真实的dom结构-即更新dom"><a href="#根据差异更改原先真实的dom结构-即更新dom" class="headerlink" title="根据差异更改原先真实的dom结构,即更新dom"></a>根据差异更改原先真实的dom结构,即更新dom</h4><p>现在我们已经生成了两个虚拟 DOM, 并且将两个 DOM 之间的差异用对象的方式保存了下来，接下来，我们就要通过这些来将差异更新到真实的 DOM 上面去！！下面的代码很长，但确实是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> patch = <span class="function">(<span class="params">node, difference</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> pacer = &#123; <span class="attr">index</span>: <span class="number">0</span> &#125;</span><br><span class="line">  <span class="comment">// 给元素打补丁</span></span><br><span class="line">  patchNode(node, pacer, difference)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> patchNode = <span class="function">(<span class="params">node, pacer, difference</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> currentDifference = difference[pacer.index]</span><br><span class="line">  <span class="keyword">let</span> childNodes = node.childNodes</span><br><span class="line">  <span class="comment">// 先序深度优先遍历</span></span><br><span class="line">  childNodes.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">    pacer.index++</span><br><span class="line">    patchNode(child, pacer, difference)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (currentDifference) &#123;</span><br><span class="line">    doPatch(node, currentDifference)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据传递的diff进行遍历操作node节点</span></span><br><span class="line"><span class="keyword">const</span> doPatch = <span class="function">(<span class="params">node, difference</span>) =&gt;</span> &#123;</span><br><span class="line">  difference.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (item.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'change_attrs'</span>:</span><br><span class="line">        <span class="keyword">const</span> attrs = item.value</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> attrs) &#123;</span><br><span class="line">          <span class="keyword">if</span> (node.nodeType !== <span class="number">1</span>) <span class="keyword">return</span></span><br><span class="line">          <span class="keyword">const</span> value = attrs[key]</span><br><span class="line">          <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            setAttr(node, key, value)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.removeAttribute(key)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'modify_text'</span>:</span><br><span class="line">        node.textContent = item.value</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'replace'</span>:</span><br><span class="line">        <span class="comment">// 新节点替换老节点 需要先判断新节点是不是element实例 如果是需要调用render方法渲染新节点</span></span><br><span class="line">        <span class="comment">// 如果不是则表明新节点是文本节点，直接创建一个文本节点</span></span><br><span class="line">        <span class="keyword">let</span> newNode = (item.newNode <span class="keyword">instanceof</span> Element)</span><br><span class="line">          ? item.newNode.render(item.newNode)</span><br><span class="line">          : <span class="built_in">document</span>.createTextNode(item.newNode)</span><br><span class="line">        <span class="comment">// 调用父级的replaceChild方法替换为新的节点</span></span><br><span class="line">        node.parentNode.replaceChild(newNode, node)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'remove'</span>:</span><br><span class="line">        node.parentNode.removeChild(node)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用的时候，这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  renderDom(RealDom, <span class="built_in">document</span>.body)</span><br><span class="line">  <span class="keyword">const</span> diffs = diff(VdObj1, VdObj2)</span><br><span class="line">  patch(RealDom, diffs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dom-diff过程"><a href="#dom-diff过程" class="headerlink" title="dom diff过程"></a>dom diff过程</h3><p>总结来说：</p><ul><li>用JS对象模拟DOM（虚拟DOM）</li><li>把此虚拟DOM转成真实DOM并插入页面中（render）</li><li>如果有事件发生修改了虚拟DOM，比较两棵虚拟DOM树的差异，得到差异对象（diff）</li><li>把差异对象应用到真正的DOM树上（patch）</li></ul><h2 id="vue的虚拟dom"><a href="#vue的虚拟dom" class="headerlink" title="vue的虚拟dom"></a>vue的虚拟dom</h2><p>看了这么多别人的关于虚拟dom的文章，今天的主角依然是vue中的虚拟dom和diff算法，不然面试的时候依然直接跪！</p><h3 id="模板转换成视图的过程"><a href="#模板转换成视图的过程" class="headerlink" title="模板转换成视图的过程"></a>模板转换成视图的过程</h3><p><img src= "/img/loading.gif" data-src="/images/diff/virtualDom.jpg" alt="vue 虚拟dom"></p><ul><li>Vue.js通过编译将template 模板转换成渲染函数(render function) ，执行渲染函数就可以得到一个虚拟节点树</li><li>在对数据模型进行操作的时候，会触发对应 Dep 中的 Watcher 对象。Watcher 对象会调用对应的 update 来修改视图。这个过程主要是将新旧虚拟节点进行差异对比，然后根据对比结果进行DOM操作来更新视图。</li></ul><p>针对上图有几个概念说下:</p><ul><li><p>渲染函数：渲染函数是用来生成Virtual DOM的。Vue推荐使用模板来构建我们的应用界面，在底层实现中Vue会将模板编译成渲染函数，当然我们也可以不写模板，直接写渲染函数，以获得更好的控制。</p></li><li><p>VNode 虚拟节点：它可以代表一个真实的 dom 节点。通过 <strong>createElement</strong> 方法能将 VNode 渲染成 dom 节点。简单地说，vnode可以理解成节点描述对象，它描述了应该怎样去创建真实的DOM节点。</p></li><li><p>patch(也叫做patching算法)：虚拟DOM最核心的部分，它可以将vnode渲染成真实的DOM，这个过程是对比新旧虚拟节点之间有哪些不同，然后根据对比结果找出需要更新的的节点进行更新。Vue的Virtual DOM Patching算法是基于Snabbdom的实现，并在此基础上作了很多的调整和改进</p></li></ul><h3 id="Vue模板编译原理"><a href="#Vue模板编译原理" class="headerlink" title="Vue模板编译原理"></a>Vue模板编译原理</h3><p>Vue首先会将template模板进行编译，其中包括parse/optimize/generate三个过程</p><h4 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h4><p>parse会使用正则表达式解析template模板中的指令、class/style等数据，形成AST，及上文的这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js模拟DOM结构</span></span><br><span class="line"><span class="keyword">var</span> element = &#123;</span><br><span class="line">  tagName: <span class="string">'ul'</span>, <span class="comment">// 节点标签名</span></span><br><span class="line">  attrs: &#123; <span class="comment">// DOM的属性，用一个对象存储键值对</span></span><br><span class="line">    class: 'item',</span><br><span class="line">    id: <span class="string">'list'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  children: [ <span class="comment">// 该节点的子节点</span></span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">attrs</span>: &#123;<span class="attr">class</span>: <span class="string">'item1'</span>&#125;, <span class="attr">children</span>: <span class="string">"Item 1"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">attrs</span>: &#123;<span class="attr">class</span>: <span class="string">'item2'</span>&#125;, <span class="attr">children</span>: <span class="string">"Item 2"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">attrs</span>: &#123;<span class="attr">class</span>: <span class="string">'item3'</span>, <span class="attr">style</span>: <span class="string">'font-size: 20px'</span>&#125;, <span class="attr">children</span>: <span class="string">"Item 3"</span>&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="optimize"><a href="#optimize" class="headerlink" title="optimize"></a>optimize</h4><p>optimize过程主要是为了优化后面的diff算法，vue在编译过程中会主动标记static静态节点，后续update更新视图的时候，patch过程中会直接跳过这些标记静态节点</p><h4 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h4><p>最后通过generate 将 AST 转化成 render function 字符串，得到结果是 render 的字符串以及 staticRenderFns 字符串,render函数字符串可能长这样:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">with</span> (<span class="keyword">this</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> __h__(</span><br><span class="line">      <span class="string">'ul'</span>, </span><br><span class="line">      &#123;<span class="attr">staticClass</span>: <span class="string">"list"</span>&#125;, </span><br><span class="line">      [</span><br><span class="line">        <span class="string">" "</span>,</span><br><span class="line">        __h__(<span class="string">'li'</span>, &#123;<span class="attr">class</span>: item&#125;, [<span class="built_in">String</span>((msg))]),</span><br><span class="line">        <span class="string">" "</span>,</span><br><span class="line">        __h__(<span class="string">'li'</span>, &#123;<span class="attr">class</span>: item&#125;, [<span class="built_in">String</span>((msg))]),</span><br><span class="line">        <span class="string">""</span>,</span><br><span class="line">        __h__(<span class="string">'li'</span>, &#123;<span class="attr">class</span>: item&#125;, [<span class="built_in">String</span>((msg))]),</span><br><span class="line">        <span class="string">""</span></span><br><span class="line">      ]</span><br><span class="line">    )</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="VNode模拟virtual-dom结构"><a href="#VNode模拟virtual-dom结构" class="headerlink" title="VNode模拟virtual-dom结构"></a>VNode模拟virtual-dom结构</h3><p>从虚拟dom到真实DOM要经过vNode定义，diff、patch等过程,总结一下主要的流程</p><ul><li><p>引入编译时版本vue.esm.js，执行<em>initMixin</em>方法</p></li><li><p>初始化vue，创建一个Vue实例，执行<strong>this._init</strong>方法，然后执行<strong>vm.$mount(vm.$options.el)</strong>方法准备挂载，生命周期函数<em>callHook(vm, ‘created’)</em>之后</p></li><li><p>Vue实例挂载，调用<strong>mountComponent方法</strong>，该方法核心就是先实例化一个渲染Watcher，在它的回调函数中会调用 <em>updateComponent</em> 方法，在此方法中调用 <em>vm._render</em> 方法先生成虚拟 VNode，最终调用 <em>vm._update</em> 更新 DOM</p></li><li><p>创建虚拟VNode,<em>vm._render</em>,会调用<strong>createElement</strong>方法，该方法最终会创建一个VNode实例 <em>new VNode()</em></p></li></ul><h4 id="VNode类解析"><a href="#VNode类解析" class="headerlink" title="VNode类解析"></a>VNode类解析</h4><p>在 Vue.js 中，Virtual DOM 是用 VNode 这个 Class 去描述，它定义在 <code>src/core/vdom/vnode.js</code> 中 ，从以下代码块中可以看到 Vue.js 中的 Virtual DOM 的定义较为复杂一些，因为它这里包含了很多 Vue.js 的特性。实际上 Vue.js 中 Virtual DOM 是借鉴了一个开源库  snabbdom 的实现，然后加入了一些 Vue.js 的一些特性</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> VNode &#123;</span><br><span class="line">  tag: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  data: VNodeData | <span class="built_in">void</span>;</span><br><span class="line">  children: ?<span class="built_in">Array</span>&lt;VNode&gt;;</span><br><span class="line">  text: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  elm: Node | <span class="built_in">void</span>;</span><br><span class="line">  ns: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  context: Component | <span class="built_in">void</span>; <span class="comment">// rendered in this component's scope</span></span><br><span class="line">  key: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">void</span>;</span><br><span class="line">  componentOptions: VNodeComponentOptions | <span class="built_in">void</span>;</span><br><span class="line">  componentInstance: Component | <span class="built_in">void</span>; <span class="comment">// component instance</span></span><br><span class="line">  parent: VNode | <span class="built_in">void</span>; <span class="comment">// component placeholder node</span></span><br><span class="line">  <span class="comment">// strictly internal</span></span><br><span class="line">  raw: <span class="built_in">boolean</span>; <span class="comment">// contains raw HTML? (server only)</span></span><br><span class="line">  isStatic: <span class="built_in">boolean</span>; <span class="comment">// hoisted static node</span></span><br><span class="line">  isRootInsert: <span class="built_in">boolean</span>; <span class="comment">// necessary for enter transition check</span></span><br><span class="line">  isComment: <span class="built_in">boolean</span>; <span class="comment">// empty comment placeholder?</span></span><br><span class="line">  isCloned: <span class="built_in">boolean</span>; <span class="comment">// is a cloned node?</span></span><br><span class="line">  isOnce: <span class="built_in">boolean</span>; <span class="comment">// is a v-once node?</span></span><br><span class="line">  asyncFactory: <span class="built_in">Function</span> | <span class="built_in">void</span>; <span class="comment">// async component factory function</span></span><br><span class="line">  asyncMeta: <span class="built_in">Object</span> | <span class="built_in">void</span>;</span><br><span class="line">  isAsyncPlaceholder: <span class="built_in">boolean</span>;</span><br><span class="line">  ssrContext: <span class="built_in">Object</span> | <span class="built_in">void</span>;</span><br><span class="line">  fnContext: Component | <span class="built_in">void</span>; <span class="comment">// real context vm for functional nodes</span></span><br><span class="line">  fnOptions: ?ComponentOptions; <span class="comment">// for SSR caching</span></span><br><span class="line">  devtoolsMeta: ?<span class="built_in">Object</span>; <span class="comment">// used to store functional render context for devtools</span></span><br><span class="line">  fnScopeId: ?<span class="built_in">string</span>; <span class="comment">// functional scope id support</span></span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    tag?: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    data?: VNodeData,</span></span><br><span class="line"><span class="params">    children?: ?<span class="built_in">Array</span>&lt;VNode&gt;,</span></span><br><span class="line"><span class="params">    text?: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    elm?: Node,</span></span><br><span class="line"><span class="params">    context?: Component,</span></span><br><span class="line"><span class="params">    componentOptions?: VNodeComponentOptions,</span></span><br><span class="line"><span class="params">    asyncFactory?: <span class="built_in">Function</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tag = tag</span><br><span class="line">    <span class="keyword">this</span>.data = data</span><br><span class="line">    <span class="keyword">this</span>.children = children</span><br><span class="line">    <span class="keyword">this</span>.text = text</span><br><span class="line">    <span class="keyword">this</span>.elm = elm</span><br><span class="line">    <span class="keyword">this</span>.ns = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.context = context</span><br><span class="line">    <span class="keyword">this</span>.fnContext = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.fnOptions = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.fnScopeId = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.key = data &amp;&amp; data.key</span><br><span class="line">    <span class="keyword">this</span>.componentOptions = componentOptions</span><br><span class="line">    <span class="keyword">this</span>.componentInstance = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.parent = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.raw = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.isStatic = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.isRootInsert = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.isComment = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.isCloned = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.isOnce = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.asyncFactory = asyncFactory</span><br><span class="line">    <span class="keyword">this</span>.asyncMeta = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.isAsyncPlaceholder = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抓重点，看几个关键的属性定义即可：<br>tag 属性即这个vnode的标签属性,比如h1/span<br>data 属性包含了最后渲染成真实dom节点后，节点上的class，attribute，style以及绑定的事件,比如<code>attrs: {id: &quot;app&quot;, class: &quot;rootApp&quot;}</code><br>children 属性是vnode的子节点<br>text 属性是文本属性<br>elm 属性为这个vnode对应的真实dom节点<br>key 属性是vnode的标记，在<strong>diff</strong>过程中可以提高diff的效率</p><h4 id="源码创建-VNode-过程"><a href="#源码创建-VNode-过程" class="headerlink" title="源码创建 VNode 过程"></a>源码创建 VNode 过程</h4><p>1.引入编译时版本vue.esm.js，执行<em>initMixin</em>方法<br>2.初始化vue<br>实例化一个Vue实例时，即<code>new Vue</code>时，执行的src/core/instance/index.js 中定义的 Function 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br><span class="line">initMixin(Vue)</span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br></pre></td></tr></table></figure><p>通过查看 Vue 的 function，我们知道 Vue 只能通过 new 关键字初始化，然后调用 this._init 方法，该方法在 src/core/instance/init.js 中定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span> (<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    vm._uid = uid++</span><br><span class="line">    <span class="keyword">let</span> startTag, endTag</span><br><span class="line">    vm.$options = mergeOptions(</span><br><span class="line">      resolveConstructorOptions(vm.constructor),</span><br><span class="line">      options || &#123;&#125;,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">    vm._self = vm</span><br><span class="line">    initLifecycle(vm)</span><br><span class="line">    initEvents(vm)</span><br><span class="line">    initRender(vm)</span><br><span class="line">    callHook(vm, <span class="string">'beforeCreate'</span>)</span><br><span class="line">    initInjections(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">    <span class="comment">// 初始化状态</span></span><br><span class="line">    initState(vm)</span><br><span class="line">    initProvide(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">    callHook(vm, <span class="string">'created'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.Vue实例挂载<br>Vue 中是通过 $mount 实例方法去挂载 dom 的，下面我们通过分析 compiler 版本的 mount 实现，相关源码在目录<code>src/platforms/web/runtime/entry-runtime-with-compiler.js</code> 文件中定义：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现$mount 方法实际上会去调用 mountComponent 方法，这个方法定义在 <code>src/core/instance/lifecycle.js</code> 文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  el: ?Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  <span class="comment">// created之后 也就是beforeMount之前已经能拿到$el</span></span><br><span class="line">  callHook(vm, <span class="string">'beforeMount'</span>)</span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    vm._update(vm._render(), hydrating)</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 实例化一个渲染Watcher，在它的回调函数中会调用 updateComponent 方法  </span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">        callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm._isMounted = <span class="literal">true</span></span><br><span class="line">    callHook(vm, <span class="string">'mounted'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看到，mountComponent 核心就是先实例化一个渲染Watcher，在它的回调函数中会调用 <code>updateComponent</code> 方法，在此方法中调用 vm._render 方法先生成虚拟 Node，最终调用 vm._update 更新 DOM。</p><p>4.创建虚拟dom<br>紧接上面的<em>vm._render</em>，Vue实例的一个私有方法，它用来把实例渲染成一个虚拟 Node,并返回该虚拟dom。它的定义在 <code>src/core/instance/render.js</code> 文件中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.$options</span><br><span class="line">  vm.$vnode = _parentVnode</span><br><span class="line">  <span class="comment">// render self</span></span><br><span class="line">  <span class="keyword">let</span> vnode</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    currentRenderingInstance = vm</span><br><span class="line">    <span class="comment">// 调用vm.$createElement</span></span><br><span class="line">    vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    handleError(e, vm, <span class="string">`render`</span>)</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; vm.$options.renderError) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`renderError`</span>)</span><br><span class="line">        vnode = vm._vnode</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode = vm._vnode</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentRenderingInstance = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// set parent</span></span><br><span class="line">  vnode.parent = _parentVnode</span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>vnode = render.call(vm._renderProxy, vm.$createElement)</code>生成虚拟dom,调用<em>createElement</em>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$createElement = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>接着再调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  context: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  data: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  children: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  normalizationType: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  alwaysNormalize: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _createElement(context, tag, data, children, normalizationType)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">_createElement</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  context: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag?: string | Class&lt;Component&gt; | Function | Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  data?: VNodeData,</span></span></span><br><span class="line"><span class="function"><span class="params">  children?: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  normalizationType?: number</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">// 创建虚拟 vnode</span></span><br><span class="line">  vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">    config.parsePlatformTagName(tag), data, children,</span><br><span class="line">    <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createElement 方法有 5 个参数，<br>context 表示 VNode 的上下文环境，它是 Component 类型；<br>tag表示标签，它可以是一个字符串，也可以是一个 Component；<br>data 表示 VNode 的数据，它是一个 VNodeData 类型，可以在 flow/vnode.js 中找到它的定义；<br>children 表示当前 VNode 的子节点，它是任意类型的，需要被规范为标准的 VNode 数组；</p><h2 id="vue对Dom更新做了哪些标记优化处理"><a href="#vue对Dom更新做了哪些标记优化处理" class="headerlink" title="vue对Dom更新做了哪些标记优化处理"></a>vue对Dom更新做了哪些标记优化处理</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://mp.weixin.qq.com/s/mIk9skR1wmmXNUdneec-UQ" target="_blank" rel="noopener">分析diff算法与虚拟dom（理解现代前端框架）</a></li><li><a href="https://mp.weixin.qq.com/s/oAlVmZ4Hbt2VhOwFEkNEhw" target="_blank" rel="noopener">虚拟 DOM 到底是什么？(长文建议收藏)</a></li><li><a href="https://mp.weixin.qq.com/s/nwnnlMLdC-LvnY3-CiiT6A" target="_blank" rel="noopener">Virtual DOM 认知误区</a></li><li><a href="https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/virtual-dom.html#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">Virtual DOM</a></li><li><a href="https://juejin.cn/post/6844903615652610055" target="_blank" rel="noopener">深入框架本源系列 —— Virtual Dom</a></li><li><a href="https://juejin.cn/post/6854573217462534151" target="_blank" rel="noopener">通俗易懂的vue虚拟（Virtual ）DOM和diff算法</a></li><li><a href="https://mp.weixin.qq.com/s/oAlVmZ4Hbt2VhOwFEkNEhw" target="_blank" rel="noopener">虚拟 DOM 到底是什么？(长文建议收藏)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> vNode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vNode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue进阶4-watch和computed</title>
      <link href="/2021/04/03/vue%E8%BF%9B%E9%98%B64-watch%E5%92%8Ccomputed/"/>
      <url>/2021/04/03/vue%E8%BF%9B%E9%98%B64-watch%E5%92%8Ccomputed/</url>
      
        <content type="html"><![CDATA[<h2 id="watch-user-watcher-和computed-computed-watcher-区别和运用场景"><a href="#watch-user-watcher-和computed-computed-watcher-区别和运用场景" class="headerlink" title="watch(user-watcher)和computed(computed-watcher)区别和运用场景"></a>watch(user-watcher)和computed(computed-watcher)区别和运用场景</h2><ul><li><p>computed：是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p></li><li><p>watch：没有缓存性，更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；当我们需要深度监听对象中的属性时，可以打开deep：true选项，这样便会对对象中的每一项进行监听</p></li></ul><p>运用场景：</p><ul><li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li><li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用watch选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul><p>更简洁的回答:</p><ul><li>当模板中的某个值需要通过一个或多个数据计算得到时，就可以使用计算属性，还有计算属性的函数不接受参数；</li><li>监听属性watch主要是监听某个值发生变化后，对新值去进行逻辑处理。</li></ul><h2 id="watch源码分析"><a href="#watch源码分析" class="headerlink" title="$watch源码分析"></a>$watch源码分析</h2><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词:"></a>关键词:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$watch: <span class="function"><span class="keyword">function</span>(<span class="params">key, cb, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Watcher(<span class="keyword">this</span>, key, cb);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法:"></a>用法:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  <span class="string">'test'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'foucus'</span>, newVal, oldVal)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'name'</span>: &#123;</span><br><span class="line">    handler: <span class="string">'changeName'</span>, <span class="comment">// methods中的方法名</span></span><br><span class="line">    immediate: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'test.age'</span>: <span class="string">'watchTestAge'</span>  <span class="comment">// methods中的方法名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者这样</span></span><br><span class="line">vm.$watch(<span class="string">'test.age'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;);</span><br><span class="line">created() &#123;</span><br><span class="line">  <span class="keyword">this</span>.$watch(<span class="string">'name'</span>, newName =&gt; &#123;...&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="官方描述"><a href="#官方描述" class="headerlink" title="官方描述:"></a>官方描述:</h3><p>watcher: 一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个 property。</p><p>initState =&gt; initWatch() =&gt; createWatcher =&gt; vm.$watch(expOrFn, handler, options)</p><blockquote><p>注意，不应该使用箭头函数来定义 watcher 函数 (例如 searchQuery: newValue =&gt; this.updateAutocomplete(newValue))。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.updateAutocomplete 将是 undefined。</p></blockquote><h3 id="监听属性初始化"><a href="#监听属性初始化" class="headerlink" title="监听属性初始化"></a>监听属性初始化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initState</span>(<span class="params">vm</span>) </span>&#123;  <span class="comment">// 初始化所有状态时</span></span><br><span class="line">  vm._watchers = []  <span class="comment">// 当前实例watcher集合</span></span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options  <span class="comment">// 合并后的属性</span></span><br><span class="line">  ... <span class="comment">// 其他状态初始化</span></span><br><span class="line">  <span class="keyword">if</span>(opts.watch) &#123;  <span class="comment">// 如果有定义watch属性</span></span><br><span class="line">    initWatch(vm, opts.watch)  <span class="comment">// 执行初始化方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initWatch</span> (<span class="params">vm, watch</span>) </span>&#123;  <span class="comment">// 初始化方法</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> watch) &#123;  <span class="comment">// 遍历watch内多个监听属性</span></span><br><span class="line">    <span class="keyword">const</span> handler = watch[key]  <span class="comment">// 每一个监听属性的值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(handler)) &#123;  <span class="comment">// 如果该项的值为数组</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class="line">        createWatcher(vm, key, handler[i])  <span class="comment">// 将每一项使用watcher包装</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      createWatcher(vm, key, handler) <span class="comment">// 不是数组直接使用watcher</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWatcher</span> (<span class="params">vm, expOrFn, handler, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(handler)) &#123; <span class="comment">// 如果是对象，参数移位</span></span><br><span class="line">    options = handler  </span><br><span class="line">    handler = handler.handler</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">'string'</span>) &#123;  <span class="comment">// 如果是字符串，表示为方法名</span></span><br><span class="line">    handler = vm[handler]  <span class="comment">// 获取methods内的方法</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm.$watch(expOrFn, handler, options)  <span class="comment">// 封装</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监听原理"><a href="#监听原理" class="headerlink" title="监听原理"></a>监听原理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    expOrFn,  <span class="regexp">//</span> 对应上文的test<span class="regexp">/name/</span>test.age</span></span></span><br><span class="line"><span class="function"><span class="params">    cb, <span class="regexp">//</span> 回调函数</span></span></span><br><span class="line"><span class="function"><span class="params">    options</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 如果是对象则需要走createWatcher</span></span><br><span class="line">    <span class="keyword">if</span> (isPlainObject(cb)) &#123;</span><br><span class="line">      <span class="keyword">return</span> createWatcher(vm, expOrFn, cb, options)</span><br><span class="line">    &#125;</span><br><span class="line">    options.user = <span class="literal">true</span>; <span class="comment">// 手动表示user: true</span></span><br><span class="line">    <span class="keyword">var</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options); <span class="comment">// 核心就是一句话 new 一个Watcher实例</span></span><br><span class="line">    <span class="comment">// &#123;depp: true, immediate&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">      cb.call(vm, watcher.value); <span class="comment">// 立即执行回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回函数，执行取消监听</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      watcher.teardown();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然watch内部是使用this.$watch，但是我们也是可以手动调用this.$watch来创建监听属性的，所以第二个参数cb会出现是对象的情况。接下来设置一个标记位options.user为true，表明这是一个user-watcher。再给watch设置了immediate属性后，会将实例化后得到的值传入回调，并立即执行一次回调函数，这也是immediate的实现原理。最后的返回值是一个方法，执行后可以取消对该监听属性的监听。</p><p>watch监听属性收集依赖<br>root =&gt; init() 根组件初始化<br>root =&gt; vm._update(vm._render(), hydrating) 根组件渲染 没状态 不用收集依赖<br>  =&gt; initData<br>  =&gt; observer(name) // name转为响应式<br>  =&gt; initWatch(watch) // 初始化watch<br>  =&gt; $watch(name) // 触发name的get 收集user-watcher<br>  =&gt; Sub.$mount() // 子组件挂载<br>  =&gt; new Watcher(vm, getter) // 实例化一个render-watcher<br>  =&gt; vm.render // 触发name的get 收集render-watcher<br>Watch 监听属性派发更新<br>  =&gt; name = ‘cpp’ // 触发set<br>  =&gt; dep.notify() // dep通知收集到的watcher<br>  =&gt; user-watcher // 派发新值和旧值给回调函数<br>  =&gt; render-watcher // 视图改变</p><h3 id="deep原理"><a href="#deep原理" class="headerlink" title="deep原理"></a>deep原理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.get = <span class="function"><span class="keyword">function</span> <span class="title">get</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  pushTarget(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line">  <span class="keyword">var</span> vm = <span class="keyword">this</span>.vm;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    value = <span class="keyword">this</span>.getter.call(vm, vm);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">      <span class="comment">// 用户手动的user watcher</span></span><br><span class="line">      handleError(e, vm, (<span class="string">"getter for watcher \""</span> + (<span class="keyword">this</span>.expression) + <span class="string">"\""</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">    <span class="comment">// dependencies for deep watching</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">      traverse(value);</span><br><span class="line">    &#125;</span><br><span class="line">    popTarget();</span><br><span class="line">    <span class="keyword">this</span>.cleanupDeps();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> seenObjects = <span class="keyword">new</span> _Set();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursively traverse an object to evoke all converted</span></span><br><span class="line"><span class="comment"> * getters, so that every nested property inside the object</span></span><br><span class="line"><span class="comment"> * is collected as a "deep" dependency.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverse</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">  _traverse(val, seenObjects);</span><br><span class="line">  seenObjects.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_traverse</span> (<span class="params">val, seen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i, keys;</span><br><span class="line">  <span class="keyword">var</span> isA = <span class="built_in">Array</span>.isArray(val);</span><br><span class="line">  <span class="keyword">if</span> ((!isA &amp;&amp; !isObject(val)) || <span class="built_in">Object</span>.isFrozen(val) || val <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只有数字和对象才有—__ob__属性</span></span><br><span class="line">  <span class="keyword">if</span> (val.__ob__) &#123;</span><br><span class="line">    <span class="keyword">var</span> depId = val.__ob__.dep.id; <span class="comment">// 手动依赖收集器的id</span></span><br><span class="line">    <span class="keyword">if</span> (seen.has(depId)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    seen.add(depId);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isA) &#123;</span><br><span class="line">    i = val.length;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123; _traverse(val[i], seen); &#125; <span class="comment">// 递归触发每一项的get进行依赖收集</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    keys = <span class="built_in">Object</span>.keys(val);</span><br><span class="line">    i = keys.length;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123; _traverse(val[keys[i]], seen); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="watch总结"><a href="#watch总结" class="headerlink" title="watch总结"></a>watch总结</h3><p>这里说明了为什么watch和this.$watch的实现是一致的，以及简单解释它的原理就是为需要观察的数据创建并收集user-watcher，当数据改变时通知到user-watcher将新值和旧值传递给用户自己定义的回调函数。最后分析了定义watch时会被使用到的三个参数：sync、immediate、deep它们的实现原理。简单说明它们的实现原理就是：</p><ul><li>sync是不将watcher加入到nextTick队列而同步的更新</li><li>immediate是立即以得到的值执行一次回调函数</li><li>deep是递归的对它的子值进行依赖收集。</li></ul><h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><h3 id="关键词-1"><a href="#关键词-1" class="headerlink" title="关键词"></a>关键词</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.initComputed();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span>(<span class="params">vm, computed</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> watchers = vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// 创建一个纯净对象</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">const</span> getter = computed[key]  <span class="comment">// computed每项对应的回调函数</span></span><br><span class="line">    watchers[key] = <span class="keyword">new</span> Watcher(vm, getter, noop, &#123;<span class="attr">lazy</span>: <span class="literal">true</span>&#125;)  <span class="comment">// 实例化computed-watcher</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      defineComputed(vm, key, getter)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  displayName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name.charAt(<span class="number">0</span>).toUpperCase() + <span class="keyword">this</span>.name.slice(<span class="number">1</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  mockComputed() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.focus + <span class="string">'!!!'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  aPlus: &#123;</span><br><span class="line">    <span class="keyword">get</span>: function() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'computed aplus'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(val) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'触发 set aPlus'</span>)</span><br><span class="line">      <span class="keyword">this</span>.name = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="官方描述-1"><a href="#官方描述-1" class="headerlink" title="官方描述"></a>官方描述</h3><p>计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。<br>计算属性的结果会被缓存，计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。</p><h3 id="源码分析-初始化"><a href="#源码分析-初始化" class="headerlink" title="源码分析 初始化"></a>源码分析 初始化</h3><ul><li>initState =&gt; </li><li>initComputed(vm, opts.computed) =&gt; </li><li>new Watcher(vm,getter || noop,noop,computedWatcherOptions) =&gt; </li><li>defineComputed(vm, key, userDef) =&gt; </li><li>createComputedGetter(key) =&gt; </li><li>Object.defineProperty(target, key, sharedPropertyDefinition);</li></ul><p>其中Watcher中的lazy/dirty: true,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">computedWatcherOptions = &#123;<span class="attr">lazy</span>: <span class="literal">true</span>&#125;</span><br><span class="line"><span class="keyword">this</span>.lazy = !!options.lazy; <span class="comment">//</span></span><br><span class="line"><span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy; <span class="comment">// for lazy watchers</span></span><br><span class="line"><span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</span><br><span class="line">  ? <span class="literal">undefined</span></span><br><span class="line">  : <span class="keyword">this</span>.get();</span><br></pre></td></tr></table></figure><p>开始聚焦源码 vm._computedWatchers</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initState</span>(<span class="params">vm</span>) </span>&#123;  <span class="comment">// 初始化所有状态时</span></span><br><span class="line">  vm._watchers = []  <span class="comment">// 当前实例watcher集合</span></span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options  <span class="comment">// 合并后的属性</span></span><br><span class="line">  </span><br><span class="line">  ... <span class="comment">// 其他状态初始化</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(opts.computed) &#123;  <span class="comment">// 如果有定义计算属性</span></span><br><span class="line">    initComputed(vm, opts.computed)  <span class="comment">// 进行初始化</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span>(<span class="params">vm, computed</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> watchers = vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// 创建一个纯净对象</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">const</span> getter = computed[key]  <span class="comment">// computed每项对应的回调函数</span></span><br><span class="line">    watchers[key] = <span class="keyword">new</span> Watcher(vm, getter, noop, &#123;<span class="attr">lazy</span>: <span class="literal">true</span>&#125;)  <span class="comment">// 实例化computed-watcher</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      defineComputed(vm, key, getter)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算属性实现原理"><a href="#计算属性实现原理" class="headerlink" title="计算属性实现原理"></a>计算属性实现原理</h3><p>这里还是按照惯例，将定义的computed属性的每一项使用Watcher类进行实例化，不过这里是按照computed-watcher的形式，来看下如何实例化的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(vm, expOrFn, cb, options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    <span class="keyword">this</span>._watchers.push(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span>(options) &#123;</span><br><span class="line">      <span class="keyword">this</span>.lazy = !!options.lazy  <span class="comment">// 表示是computed</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy  <span class="comment">// dirty为标记位，表示是否对computed计算</span></span><br><span class="line">    <span class="keyword">this</span>.getter = expOrFn  <span class="comment">// computed的回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="keyword">this</span>.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有执行get方法</p><p>这里的App组件在执行extend创建子组件的构造函数时，已经将key挂载到vm的原型中了，不过之前也是执行的defineComputed方法，所以不妨碍我们看它做了什么：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineComputed</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: createComputedGetter(key),</span><br><span class="line">    <span class="keyword">set</span>: noop</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个方法的作用就是让computed成为一个响应式数据，并定义它的get属性，也就是说当页面执行渲染访问到computed时，才会触发get然后执行createComputedGetter方法，所以之前的点到为止再这里会续上，看下get方法是怎么定义的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span> (<span class="params">key</span>) </span>&#123; <span class="comment">// 高阶函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">// 返回函数</span></span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">this</span>._computedWatchers &amp;&amp; <span class="keyword">this</span>._computedWatchers[key]</span><br><span class="line">    <span class="comment">// this还可以这样用，得到key对应的computed-watcher</span></span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="keyword">if</span> (watcher.dirty) &#123;  <span class="comment">// 在实例化watcher时为true，表示需要计算</span></span><br><span class="line">        watcher.evaluate()  <span class="comment">// 进行计算属性的求值,把computed-watcher放到依赖收集器deps数组里</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;  <span class="comment">// 当前的watcher，这里是页面渲染触发的这个方法，所以为render-watcher</span></span><br><span class="line">        watcher.depend()  <span class="comment">// 收集当前watcher</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> watcher.value  <span class="comment">// 返回求到的值或之前缓存的值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  evaluate () &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()  <span class="comment">//  计算属性求值 会将当前的computed-watcher作为依赖收集到自己的dep</span></span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">false</span>  <span class="comment">// 表示计算属性已经计算，不需要再计算</span></span><br><span class="line">  &#125;</span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length  <span class="comment">// deps内是计算属性内能访问到的响应式数据的dep的数组集合</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">this</span>.deps[i].depend()  <span class="comment">// 让每个dep收集当前的render-watcher</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这里的变量watcher就是之前computed对应的computed-watcher实例，接下来会执行Watcher类专门为计算属性定义的两个方法，在执行evaluate方法进行求值的过程中又会触发computed内可以访问到的响应式数据的get()方法，它们会将当前的computed-watcher作为依赖收集到自己的dep里，计算完毕之后将dirty置为false，表示已经计算过了。</p></li><li><p>如果Dep.target如果当前页面渲染用到了这个Watcher,会执行watcher.depend()让计算属性内的响应式数据订阅当前的render-watcher，所以computed内的响应式数据会收集computed-watcher和render-watcher两个watcher</p></li><li><p>当computed内的状态发生变更触发set后，首先通知computed需要进行重新计算，然后通知到视图执行渲染，执行渲染中会访问到computed计算后的值，最终渲染到页面。</p></li></ul><blockquote><p> 计算属性内的值须是响应式数据才能触发重新计算。</p></blockquote><h3 id="computed-总结"><a href="#computed-总结" class="headerlink" title="computed 总结"></a>computed 总结</h3><p>为什么计算属性有缓存功能？因为当计算属性经过计算后，内部的标志位(dirty)会表明已经计算过了，再次访问时会直接读取计算后的值；<br>为什么计算属性内的响应式数据发生变更后，计算属性会重新计算？因为内部依赖的响应式数据会收集computed-watcher，变更后通知计算属性要进行计算，也会通知页面重新渲染，渲染时会读取到重新计算后的值。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.cn/post/6844903981957791757#heading-3" target="_blank" rel="noopener">手把手带你实现一个最精简的响应式系统来学习Vue的data、computed、watch源码</a></li><li><a href="https://juejin.cn/post/6844903926819454983" target="_blank" rel="noopener">Vue原理解析（九）：搞懂computed和watch原理，减少使用场景思考时间</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue进阶3-数据绑定</title>
      <link href="/2021/04/03/vue%E8%BF%9B%E9%98%B63-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
      <url>/2021/04/03/vue%E8%BF%9B%E9%98%B63-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<ul><li>defineProperty和proxy区别</li><li>谈谈对vue响应式原理的理解(Vue双向绑定如何实现的)1.数据劫持2.发布订阅</li><li>vue中的依赖收集是怎么处理的</li><li>vue如何检测数组变化(重写数组方法)</li><li>为何采用异步渲染(Vue中的数据多次变化但只会更新一次)</li><li>nextTick实现原理</li><li>v-model实现原理</li></ul><h2 id="defineProperty和proxy区别"><a href="#defineProperty和proxy区别" class="headerlink" title="defineProperty和proxy区别"></a>defineProperty和proxy区别</h2><h3 id="Vue3-x改用Proxy替代Object-defineProperty。"><a href="#Vue3-x改用Proxy替代Object-defineProperty。" class="headerlink" title="Vue3.x改用Proxy替代Object.defineProperty。"></a>Vue3.x改用Proxy替代Object.defineProperty。</h3><p>因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。<br>Proxy只会代理对象的第一层，Vue3是怎样处理这个问题的呢？<br>判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。<br>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</p><h3 id="Proxy-与-Object-defineProperty-优劣对比"><a href="#Proxy-与-Object-defineProperty-优劣对比" class="headerlink" title="Proxy 与 Object.defineProperty 优劣对比"></a>Proxy 与 Object.defineProperty 优劣对比</h3><p>Proxy 的优势如下:<br>Proxy 可以直接监听对象而非属性；<br>Proxy 可以直接监听数组的变化；<br>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；<br>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；<br>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；<br>Object.defineProperty 的优势如下:<br>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。</p><h2 id="谈谈对vue响应式原理-双向绑定原理的理解"><a href="#谈谈对vue响应式原理-双向绑定原理的理解" class="headerlink" title="谈谈对vue响应式原理/双向绑定原理的理解"></a>谈谈对vue响应式原理/双向绑定原理的理解</h2><p>Vue 数据双向绑定主要是指：a数据变化更新视图，b视图变化更新数据。其中，View视图变化更新Data，可以通过事件监听的方式来实现，所以 Vue数据双向绑定的工作主要是如何根据Data变化更新View。</p><p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。<br>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。<br>每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p><p>监听器 Observer：<br>完成 Data 中所有数据的代理<br>对数据对象进行遍历，包括子属性对象的属性，利用Object.defineProperty这个核心API给所有属性都加上 setter 和 getter属性。当某个对象的值发生变化，会触发 setter，那么就能监听到了数据变化，达到视图更新的目的</p><p>解析器 Compile：<br>1.解析 Vue 模板指令(v-for v-if等)，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数(@click/@keydown)<br>2.跟Watcher建立关系，即添加监听数据的订阅者Watcher，一旦数据有变动，收到通知，调用更新函数进行数据更新。(通过new Watcher()添加回调来接收数据变化的通知)</p><p>订阅者(观察者) Watcher：<br>1.Watcher是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。<br>2.每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把接触过属性记录为依赖(这句话难以理解，其实就是初始化Watcher读取属性的时候，就开始记录为依赖)，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新——这是一个典型的观察者模式</p><p>订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</p><p>另外一种全面回答:</p><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p><p>1.需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化<br>2.compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图<br>3.Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是: a.在自身实例化时往属性订阅器(dep)里面添加自己 b.自身必须有一个 update()方法 c.待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退。</p><p>4.MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。</p><h3 id="1-实现一个-Observer"><a href="#1-实现一个-Observer" class="headerlink" title="1.实现一个 Observer"></a>1.实现一个 Observer</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.data = data</span><br><span class="line">  <span class="keyword">this</span>.walk(data)</span><br><span class="line">&#125;</span><br><span class="line">Observer.prototype = &#123;</span><br><span class="line">  walk(data) &#123;</span><br><span class="line">    <span class="comment">//遍历,对这个对象的所有属性都进行监听</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.defineReactive(data, key, data[key])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  defineReactive(data, key, val) &#123;</span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="keyword">let</span> childObj = observe(val)</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>: function getter() &#123;</span><br><span class="line">        <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">          <span class="comment">// 在这里添加一个订阅者</span></span><br><span class="line">          <span class="built_in">console</span>.log(Dep.target)</span><br><span class="line">          dep.addSub(Dep.target)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>: function setter() &#123;</span><br><span class="line">        <span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        val = newVal</span><br><span class="line">        childObj = observe(newVal)</span><br><span class="line">        dep.notify()</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value, vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!value || <span class="keyword">typeof</span> value !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observer(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消息订阅器Dep，订阅器Dep主要负责收集订阅者，然后在属性变化的时候执行对应订阅者的更新函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subs = []</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;,</span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function">(<span class="params">sub</span>) =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">Dep.target = <span class="literal">null</span></span><br></pre></td></tr></table></figure><h3 id="2-实现一个-Watcher"><a href="#2-实现一个-Watcher" class="headerlink" title="2.实现一个 Watcher"></a>2.实现一个 Watcher</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm, exp, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.cb = cb</span><br><span class="line">  <span class="keyword">this</span>.vm = vm</span><br><span class="line">  <span class="keyword">this</span>.exp = exp</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="keyword">this</span>.get() <span class="comment">// 将自己添加到订阅器的操作</span></span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="keyword">this</span>.run()</span><br><span class="line">  &#125;,</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.vm.data[<span class="keyword">this</span>.exp]</span><br><span class="line">    <span class="keyword">let</span> oldVal = <span class="keyword">this</span>.value</span><br><span class="line">    <span class="keyword">if</span> (value !== oldVal) &#123;</span><br><span class="line">      <span class="keyword">this</span>.value = value</span><br><span class="line">      <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    Dep.target = <span class="keyword">this</span> <span class="comment">// 缓存自己</span></span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.vm.data[<span class="keyword">this</span>.exp] <span class="comment">// 强制执行监听器里的get函数</span></span><br><span class="line">    Dep.target = <span class="literal">null</span> <span class="comment">// 释放自己</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h2><p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p><p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。</p><p>每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p><h3 id="最让人疑问的就是组件渲染过程中是如何把接触过的数据property记录为依赖的，简单就是说vue是如何收集依赖的？？？"><a href="#最让人疑问的就是组件渲染过程中是如何把接触过的数据property记录为依赖的，简单就是说vue是如何收集依赖的？？？" class="headerlink" title="最让人疑问的就是组件渲染过程中是如何把接触过的数据property记录为依赖的，简单就是说vue是如何收集依赖的？？？"></a>最让人疑问的就是组件渲染过程中是如何把接触过的数据property记录为依赖的，简单就是说vue是如何收集依赖的？？？</h3><p>(简单点说 在执行渲染函数的途中读取到了data.XX，就触发了defineReactive函数中劫持的get，进行dep.depend)</p><p>先过一遍初始化流程</p><p>new Vue =&gt; initMixin(vue) =&gt; initState(vm) =&gt; initData =&gt; observer(data) =&gt; new Observe() =&gt; walk(value)<br>(到这里基本结束了，如果date没有值的话)<br>=&gt; defineReactive =&gt; function reactiveGetter =&gt; Dep.target =&gt; dep.depend =&gt; Watcher.addDep(dep) =&gt; dep.addSub(Watcher) =&gt; subs.push(Watcher)</p><p>先编译成渲染函数，完了会执行$mount,开始挂载</p><p>$mount -&gt; mountComponent -&gt; new Watcher(vm, updateComponent) =&gt; Watcher.get() =&gt; updateComponent =&gt; this.getter(Dep.target: true 开始收集依赖啦!!!,这里的getter就是vm._render) =&gt; vm._update =&gt; vm._render() 生成Vnode(虚拟dom) =&gt; patch方法把虚拟DOM转换成真正的DOM节点</p><p>核心还是 Watcher观察者中的getter方法，触发收集依赖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    vm,</span><br><span class="line">    expOrFn,</span><br><span class="line">    cb,</span><br><span class="line">    options,</span><br><span class="line">    isRenderWatcher</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.expression = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line">      ? expOrFn.toString()</span><br><span class="line">      : <span class="string">''</span>;</span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = expOrFn;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解</span></span><br><span class="line">      <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</span><br><span class="line">        ? <span class="literal">undefined</span></span><br><span class="line">        : <span class="keyword">this</span>.get();</span><br><span class="line">    &#125;,</span><br><span class="line">   <span class="keyword">get</span> () &#123;</span><br><span class="line">      <span class="comment">// 该函数用于缓存 Watcher</span></span><br><span class="line">      <span class="comment">// 因为在组件含有嵌套组件的情况下，需要恢复父组件的 Watcher</span></span><br><span class="line">      pushTarget(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">let</span> value</span><br><span class="line">      <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 触发getter，添加自己到属性订阅器中</span></span><br><span class="line">      <span class="comment">// 调用回调函数，也就是 updateComponent 函数 vm._update(vm._render(), hydrating);</span></span><br><span class="line">      <span class="comment">// this.getter ƒ () &#123;</span></span><br><span class="line">      <span class="comment">//  vm._update(vm._render(), hydrating);</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">      <span class="comment">// 实例化Watcher 会读取双向绑定的值，从而触发依赖收集 最最最重要的一步 关键环节</span></span><br><span class="line">      <span class="comment">// 如果这步注释掉 vue的双向绑定就会失效 game over</span></span><br><span class="line">        value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 恢复 Watcher</span></span><br><span class="line">        popTarget()</span><br><span class="line">        <span class="comment">// 清理依赖，判断是否还需要某些依赖，不需要的清除</span></span><br><span class="line">        <span class="comment">// 这是为了性能优化</span></span><br><span class="line">        <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再拉通串一下整个流程：Vue 通过 defineProperty 完成了 Data 中所有数据的代理，当数据触发 get 查询时，会将当前的 Watcher 对象加入到依赖收集池 Dep 中，当数据 Data 变化时，会触发 set 通知所有使用到这个 Data 的 Watcher 对象去 update 视图。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend();</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend();</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function setter() &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="keyword">if</span> (!value || (<span class="keyword">typeof</span> value !== <span class="string">'object'</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  walk(obj) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      defineReactive(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 订阅者Dep，存放观察者对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*添加一个观察者对象*/</span></span><br><span class="line">  addSub (sub) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*依赖收集，当存在Dep.target的时候添加观察者对象*/</span></span><br><span class="line">  depend() &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知所有watcher对象更新视图</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function">(<span class="params">sub</span>) =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">/* 在new一个Watcher对象时将该对象赋值给Dep.target，在get中会用到 */</span></span><br><span class="line">    Dep.target = <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'视图更新啦'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*添加一个依赖关系到Deps集合中*/</span></span><br><span class="line">  addDep (dep) &#123;</span><br><span class="line">    dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      dep.depend() <span class="comment">/*进行依赖收集*/</span></span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal === val) <span class="keyword">return</span></span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (options) &#123;</span><br><span class="line">    <span class="keyword">this</span>._data = options.data</span><br><span class="line">    <span class="keyword">new</span> Observer(<span class="keyword">this</span>._data) <span class="comment">// 所有data变成可观察的</span></span><br><span class="line">    <span class="keyword">new</span> Watcher() <span class="comment">// 创建一个观察者实例</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render~'</span>, <span class="keyword">this</span>._data.test)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    test: <span class="string">'hello vue.'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">o._data.test = <span class="string">'hello mvvm!'</span></span><br><span class="line"></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.首先 Vue 通过 defineProperty 完成了 Data 中所有数据的代理，<br>2.在Vue中模版编译过程中的 指令或者数据绑定 都会实例化一个Watcher实例，实例化过程中触发get()将自身指向Dep.target，会将当前的 Watcher 对象加入到依赖收集池 Dep 中，即触发dep.depend()进行依赖收集<br>3.当数据 Data 变化时，会触发 set 通知所有使用到这个 Data 的 Watcher 对象去 update 视图，最后实际上调用的是当前Watcher中的回调函数cb,进而更新视图</p><h2 id="vue如何检测数组变化"><a href="#vue如何检测数组变化" class="headerlink" title="vue如何检测数组变化"></a>vue如何检测数组变化</h2><p>如果通过下标方式修改数组数据或者给对象新增属性并不会触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作，更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。</p><ul><li>使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法，当调用数组api时，可以通知依赖更新。</li><li>如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防止全局污染 重新定义数组原型</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="comment">// 创建新对象，原型指向Array.prototype</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"><span class="comment">// 重写以下函数</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存原生函数</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  <span class="comment">// 重写函数</span></span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先调用原生函数获得结果</span></span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="comment">// 调用以下几个函数时，监听新数据</span></span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">// 手动派发更新</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a property. 数据描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">def</span> (<span class="params">obj, key, val, enumerable</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    value: val,</span><br><span class="line">    enumerable: !!enumerable,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vue为何采用异步渲染，跟-nextTick有联系"><a href="#vue为何采用异步渲染，跟-nextTick有联系" class="headerlink" title="vue为何采用异步渲染，跟$nextTick有联系"></a>vue为何采用异步渲染，跟$nextTick有联系</h2><h3 id="为啥要异步渲染"><a href="#为啥要异步渲染" class="headerlink" title="为啥要异步渲染"></a>为啥要异步渲染</h3><ul><li>提升用户体验</li><li>提升性能 去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的</li></ul><p>例如，当你设置 vm.someData = ‘new value’，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用。</p><h3 id="Vue如何异步渲染"><a href="#Vue如何异步渲染" class="headerlink" title="Vue如何异步渲染"></a>Vue如何异步渲染</h3><p>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的<strong>Promise.then、MutationObserver 和 setImmediate</strong>，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。<br>即优先考虑 Promise.then =&gt; MutationObserver =&gt; setImmediate =&gt; setTimeout</p><p>接下来在源码层面梳理一下的Vue的异步渲染过程。(最终还是会异步执行run)</p><p>start =&gt; this.val = xxx =&gt; Object.defineProperty.setter =&gt; dep.notify() =&gt; subs[i].update() =&gt; 是否需要异步渲染sync,需要 =&gt; queueWatcher(this),新增全局变量queue = []存储更新操作函数 =&gt; nextTick(flushSchedulerQueue)批量将更新函数flushSchedulerQueue作为参数传入到nextTick =&gt; timerFunc =&gt; 异步api(Promise.then/MutationObserver/setImmediate/setTimeout) 开始执行 =&gt; flushCallbacks =&gt; 遍历执行订阅函数flushSchedulerQueue =&gt; queue.sort,按照id排序进行区分新旧值 =&gt;<br>Watcher.run() =&gt; Watcher.get() =&gt; this.getter() =&gt; uppdateComponent =&gt; _update =&gt; vm.<strong>patch</strong>比较新旧节点 =&gt; updateChildern =&gt; end</p><h3 id="nextTick-实现原理"><a href="#nextTick-实现原理" class="headerlink" title="nextTick 实现原理"></a>nextTick 实现原理</h3><p>首先nextTick并不是浏览器本身提供的一个异步API，而是Vue中，用由浏览器本身提供的原生异步API封装而成的一个异步封装方法</p><p>nextTick函数的执行后，把传入的flushSchedulerQueue函数push到callbacks全局数组里，pending在初始情况下是false，这时候将触发timerFunc。<br>timerFunc函数是由浏览器的Promise、MutationObserver、setImmediate、setTimeout这些异步API实现的，异步API的回调函数是flushCallbacks函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb, ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _resolve;</span><br><span class="line">  callbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">'nextTick'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span>;</span><br><span class="line">    timerFunc();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      _resolve = resolve;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timerFunc;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  timerFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    p.then(flushCallbacks);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">'undefined'</span> &amp;&amp; (</span><br><span class="line">  isNative(MutationObserver) ||</span><br><span class="line">  MutationObserver.toString() === <span class="string">'[object MutationObserverConstructor]'</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks);</span><br><span class="line">  <span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter));</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">  timerFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span>;</span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  timerFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setImmediate(flushCallbacks);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  timerFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(flushCallbacks, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它对于浏览器异步API的选用规则如下，Promise存在取由Promise.then，不存在Promise则取MutationObserver，MutationObserver不存在setImmediate，setImmediate不存在最后取setTimeout来实现。从上面的取用规则也可以看出来，nextTick即有可能是微任务，也有可能是宏任务，从优先去Promise和MutationObserver可以看出nextTick优先微任务，其次是setImmediate和setTimeout宏任务。</p><h3 id="Vue能不能同步渲染？"><a href="#Vue能不能同步渲染？" class="headerlink" title="Vue能不能同步渲染？"></a>Vue能不能同步渲染？</h3><ul><li>Vue.config.async = false</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span> (<span class="params">watcher</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 在全局队列里存储将要响应的变化update函数</span></span><br><span class="line">  queue.push(watcher);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 当async配置是false的时候，页面更新是同步的</span></span><br><span class="line">  <span class="keyword">if</span> (!config.async) &#123;</span><br><span class="line">    flushSchedulerQueue();</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将页面更新函数放进异步API里执行，同步代码执行完开始执行更新页面函数</span></span><br><span class="line">  nextTick(flushSchedulerQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们的开发代码里，只需要加入下一句即可让你的页面渲染同步进行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'Vue'</span></span><br><span class="line">Vue.config.async = <span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li>this._watcher.sync = true<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.update = <span class="function"><span class="keyword">function</span> <span class="title">update</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">    <span class="keyword">this</span>.run();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queueWatcher(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>vue中这么用<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">val</span>: <span class="number">0</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="keyword">this</span>._watcher.sync = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.val = <span class="number">1</span></span><br><span class="line">    <span class="keyword">this</span>._watcher.sync = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">this</span>.val = <span class="number">2</span></span><br><span class="line">    <span class="keyword">this</span>.val = <span class="number">3</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="v-model实现原理"><a href="#v-model实现原理" class="headerlink" title="v-model实现原理"></a>v-model实现原理</h2><p>v-model是如何实现双向绑定的？<br>v-model是用来在表单控件或者组件上创建双向绑定的<br>他的本质是<strong>v-bind和v-on的语法糖</strong><br>在一个组件上使用v-model，默认会为组件绑定名为value的prop和名为input的事件<br>使用场景： 子组件需要改变父组件 通过props传入的值，即子组件改变父组件的某一个值</p><h3 id="使用v-model模拟"><a href="#使用v-model模拟" class="headerlink" title="使用v-model模拟"></a>使用v-model模拟</h3><p>父组件</p><p>父组件通过v-model绑定值<br>如需根据v-model传入的值改变，而触发其他更新请通过watch传入的值</p><p>子组件</p><p>声明model对象，设置组件的event事件和prop值<br>通过props接受父组件传过来的值<br>修改通过this.$emit广播事件</p><p>父组件代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;children v-model=<span class="string">"message"</span>&gt;&lt;<span class="regexp">/children&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> children <span class="keyword">from</span> <span class="string">"./children.vue"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    children</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">"parent"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="comment">// 监听message变化</span></span><br><span class="line">    message(newV, oldV) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(newV, oldV);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;input </span><br><span class="line">      type=<span class="string">"text"</span></span><br><span class="line">      v-bind:value=<span class="string">'value'</span> </span><br><span class="line">      v-on:input=<span class="string">'onMessage'</span></span><br><span class="line">    /&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  model: &#123;</span></span><br><span class="line"><span class="regexp">    prop: "value", /</span><span class="regexp">/这个字段，是指父组件设置 v-model 时，将变量值传给子组件的 msg</span></span><br><span class="line"><span class="regexp">    event: "input" /</span><span class="regexp">/这个字段，是指父组件监听 parent-event 事件</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  props: &#123;</span></span><br><span class="line"><span class="regexp">    value: String /</span><span class="regexp">/此处必须定义和model的prop相同的props，因为v-model会传值给子组件</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  methods: &#123;</span></span><br><span class="line"><span class="regexp">    onMessage(e) &#123;</span></span><br><span class="line"><span class="regexp">      this.$emit('input', e.target.value)</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><h3 id="不使用v-model模拟"><a href="#不使用v-model模拟" class="headerlink" title="不使用v-model模拟"></a>不使用v-model模拟</h3><p>父组件代码修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Children v-bind:value=<span class="string">"message"</span> v-on:input=<span class="string">"(event) =&gt; &#123; message = event &#125;"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 不变</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>子组件修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input </span><br><span class="line">      type=<span class="string">"text"</span></span><br><span class="line">      v-bind:value=<span class="string">'value'</span> </span><br><span class="line">      v-on:input=<span class="string">'onMessage'</span></span><br><span class="line">    /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: <span class="built_in">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onMessage(e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, e.target.value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.cn/post/6844904106612654088#heading-4" target="_blank" rel="noopener">高级前端开发者必会的34道Vue面试题解析（三）</a></li><li><a href="https://juejin.cn/post/6923105370596933645#heading-4" target="_blank" rel="noopener">Vue源码解析-初始化流程</a></li><li><a href="https://juejin.cn/post/6845166890575216648" target="_blank" rel="noopener">通俗易懂的Vue响应式原理以及依赖收集</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue进阶2-lifecycle生命周期</title>
      <link href="/2021/04/03/vue%E8%BF%9B%E9%98%B62-lifecycle%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2021/04/03/vue%E8%BF%9B%E9%98%B62-lifecycle%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<ul><li>vue的初始化流程(vue2.x运行机制)<a href="https://juejin.cn/post/6844904093425598471#heading-47" target="_blank" rel="noopener">Vue 2.x 的运行机制</a></li><li>vue组件的生命周期</li><li>描述组件渲染和更新过程</li><li>vue模板编译原理</li></ul><h2 id="vue运行机制"><a href="#vue运行机制" class="headerlink" title="vue运行机制"></a>vue运行机制</h2><p><a href="https://juejin.cn/post/6844904099704471559#heading-15" target="_blank" rel="noopener">初始化流程</a></p><ul><li><p>创建vue实例</p></li><li><p>initMixin(Vue) 初始化生命周期，初始化事件中心、初始化渲染，执行beforeCreate钩子函数，初始化props/methods/data/computed/watch,执行created函数</p></li><li><p>初始化之后，调用vm.$mount(vm.$options.el)方法对实例进行挂载(挂载核心包括模板编译，渲染以及 更新三个过程)</p></li><li><p>如果没有在Vue实例上定义render方法而是定义了template，那么需要经历编译阶段。需要先将template 字符串通过 compileToFunctions函数 编译成 render function，template 字符串编译步骤如下:</p><ul><li>parse正则解析template字符串形成AST描述符（抽象语法树，是源代码的抽象语法结构的树状表现形式）</li><li>optimize标记静态节点(跳过diff算法, vue Diff算法是逐层进行比对，只有同层级的节点进行比对，因此时间的复杂度只有 O(n))</li><li>generate将AST转化成 render function 字符串</li></ul></li><li><p>编译成render function之后，调用vm.$mount(vm.$mount(vm.$options.el))中的mountComponent方法，然后调用callHook(vm, ‘beforeMount’)钩子函数，然后核心是实例化一个渲染Watcher，在它的回调函数（初始化的时候执行，以及组件实例中监测到数据发生变化时执行）中调用updateComponent方法_update(此方法调用_render方法生成虚拟Node，最终调用_update方法更新DOM)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, <span class="string">'beforeMount'</span>)</span><br><span class="line">updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  vm._update(vm._render(), hydrating)</span><br><span class="line">&#125;</span><br><span class="line">callHook(vm, <span class="string">'mounted'</span>)</span><br></pre></td></tr></table></figure><ul><li>调用_render方法将render function渲染成虚拟的Node</li><li>生成虚拟DOM树后，需要将虚拟DOM树转化成真实的DOM节点，此时需要调用_update方法，update方法又会调用<strong>patch</strong>方法把虚拟DOM转换成真正的DOM节点</li></ul></li></ul><p>(编译成render function字符串之后的，生成虚拟dom, 然后是_update -&gt; <strong>patch</strong>方法这块在虚拟dom重点介绍)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode, hydrating</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> vm = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> prevVnode = vm._vnode;</span><br><span class="line">  vm._vnode = vnode;</span><br><span class="line">  <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">  <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">    <span class="comment">// initial render 初始化渲染</span></span><br><span class="line">    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// updates 更新</span></span><br><span class="line">    vm.$el = vm.__patch__(prevVnode, vnode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始化过程中，描述数据的响应式流程：</p><h3 id="响应式流程"><a href="#响应式流程" class="headerlink" title="响应式流程"></a>响应式流程</h3><p>在init的时候会利用Object.defineProperty方法（不兼容IE8）监听Vue实例的响应式数据的变化从而实现数据劫持能力（利用了JavaScript对象的存取器属性get和set）。在初始化流程中的编译阶段，当render function被渲染的时候，会读取Vue实例中和视图相关的响应式数据(这个就是重点，视图和响应式数据是如何关联的)，此时会触发getter函数进行依赖收集（将观察者Watcher对象存放到当前闭包的订阅者Dep的subs中），此时的数据劫持功能和观察者模式就实现了一个MVVM模式中的Binder，之后就是正常的渲染和更新流程。</p><p>当数据发生变化或者视图导致的数据发生了变化时，会触发数据劫持的setter函数，setter会通知初始化依赖收集中的Dep中的和视图相应的Watcher，告知需要重新渲染视图，Wather就会再次通过update方法来更新视图。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// new Vue 执行流程。</span></span><br><span class="line"><span class="comment">// 1. Vue.prototype._init(option) =&gt; initState =&gt; initData</span></span><br><span class="line"><span class="comment">// 2. vm.$mount(vm.$options.el)</span></span><br><span class="line"><span class="comment">// 3. render = compileToFunctions(template) ，编译 Vue 中的 template 模板，生成 render 方法。</span></span><br><span class="line"><span class="comment">// 4. Vue.prototype.$mount 调用上面的 render 方法挂载 dom。</span></span><br><span class="line"><span class="comment">// 5. mountComponent</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 创建 Watcher 实例</span></span><br><span class="line"><span class="keyword">const</span> updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  vm._update(vm._render());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 结合上文，我们就能得出，updateComponent 就是传入 Watcher 内部的 getter 方法。</span></span><br><span class="line"><span class="keyword">new</span> Watcher(vm, updateComponent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. new Watcher 会执行 Watcher.get 方法</span></span><br><span class="line"><span class="comment">// 8. Watcher.get 会执行 this.getter.call(vm, vm) ，也就是执行 updateComponent 方法</span></span><br><span class="line"><span class="comment">// 9. updateComponent 会执行 vm._update(vm._render())</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 10. 调用 vm._render 生成虚拟 dom</span></span><br><span class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> &#123; render &#125; = vm.$options;</span><br><span class="line">  <span class="keyword">let</span> vnode = render.call(vm._renderProxy, vm.$createElement);</span><br><span class="line">  <span class="keyword">return</span> vnode;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 11. 调用 vm._update(vnode) 渲染虚拟 dom</span></span><br><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">    <span class="comment">// 初次渲染</span></span><br><span class="line">    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">    vm.$el = vm.__patch__(prevVnode, vnode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 12. vm.__patch__ 方法就是做的 dom diff 比较，然后更新 dom。</span></span><br></pre></td></tr></table></figure><p>概括起来:</p><ul><li>从 new Vue 开始，首先通过 get、set 监听 Data 中的数据变化，同时创建 Dep 用来搜集使用该 Data 的 Watcher。</li><li>编译模板，创建 Watcher，并将 Dep.target 标识为当前 Watcher。</li><li>编译模板时，如果使用到了 Data 中的数据，就会触发 Data 的 get 方法，然后调用 Dep.addSub 将 Watcher 搜集起来。</li><li>数据更新时，会触发 Data 的 set 方法，然后调用 Dep.notify 通知所有使用到该 Data 的 Watcher 去更新 DOM。</li></ul><h2 id="生命周期的理解-精简，切中要害"><a href="#生命周期的理解-精简，切中要害" class="headerlink" title="生命周期的理解(精简，切中要害)"></a>生命周期的理解(精简，切中要害)</h2><p>created/mounted/updated/destroyed，以及对应的before钩子。分别是<strong>创建=&gt;挂载=&gt;更新=&gt;销毁</strong><br>Vue源码中定义了一个mergeHook函数来遍历一个常量数组LIFECYCLE_HOOKS，该数组实际上是由与生命周期钩子同名的字符串组成的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> LIFECYCLE_HOOKS = [</span><br><span class="line">  <span class="string">'beforeCreate'</span>,</span><br><span class="line">  <span class="string">'created'</span>,</span><br><span class="line">  <span class="string">'beforeMount'</span>,</span><br><span class="line">  <span class="string">'mounted'</span>,</span><br><span class="line">  <span class="string">'beforeUpdate'</span>,</span><br><span class="line">  <span class="string">'updated'</span>,</span><br><span class="line">  <span class="string">'beforeDestroy'</span>,</span><br><span class="line">  <span class="string">'destroyed'</span>,</span><br><span class="line">  <span class="string">'activated'</span>,</span><br><span class="line">  <span class="string">'deactivated'</span>,</span><br><span class="line">  <span class="string">'errorCaptured'</span>,</span><br><span class="line">  <span class="string">'serverPrefetch'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>其中，还有activated &amp; deactivated（keep-alive 组件激活/停用）、errorCaptured（v2.5 以上版本有的一个钩子，用于处理错误）<br>serverPrefetch: 这是用来处理ssr的。允许我们在渲染过程中“等待”异步数据。可在任何组件中使用，而不仅仅是路由组件。</p><h2 id="vue生命周期详细流程"><a href="#vue生命周期详细流程" class="headerlink" title="vue生命周期详细流程"></a>vue生命周期详细流程</h2><h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><p>new Vue<br>从 new Vue(options) 开始作为入口，Vue 只是一个简单的构造函数，内部是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入了 _init 函数之后，先初始化了一些属性，然后开始第一个生命周期：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, <span class="string">'beforeCreate'</span>)</span><br></pre></td></tr></table></figure><h4 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h4><ul><li>初始化 inject</li><li>初始化 state<br>初始化 props<br>初始化 methods<br>初始化 data<br>初始化 computed<br>初始化 watch</li><li>初始化 provide<br>然后进入 created 阶段：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, <span class="string">'created'</span>)</span><br></pre></td></tr></table></figure><h4 id="created被调用完成"><a href="#created被调用完成" class="headerlink" title="created被调用完成"></a>created被调用完成</h4>调用 $mount 方法，开始挂载组件到 dom 上。</li></ul><p>如果使用了 runtime-with-compile 版本，则会把你传入的 template 选项，或者 html 文本，通过一系列的编译生成 render 函数。</p><ul><li>编译这个 template，生成 ast 抽象语法树。</li><li>优化这个 ast，标记静态节点。（渲染过程中不会变的那些节点，优化性能）。</li><li>根据 ast，生成 render 函数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ast = parse(template.trim(), options)</span><br><span class="line"><span class="keyword">if</span> (options.optimize !== <span class="literal">false</span>) &#123;</span><br><span class="line">  optimize(ast, options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> code = generate(ast, options)</span><br></pre></td></tr></table></figure>如果果是脚手架cli搭建的项目的话，这一步 vue-cli 已经帮你做好了，所以就直接进入 mountComponent 函数。<br>那么，确保有了 render 函数后，我们就可以往渲染的步骤继续进行了</li></ul><h4 id="beforeMount被调用完成"><a href="#beforeMount被调用完成" class="headerlink" title="beforeMount被调用完成"></a>beforeMount被调用完成</h4><p>把 渲染组件的函数 定义好，具体代码是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  vm._update(vm._render(), hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拆解来看，vm._render 其实就是调用我们上一步拿到的 render 函数生成一个 vnode，而 vm._update 方法则会对这个 vnode 进行 patch 操作，帮我们把 vnode 通过 createElm函数创建新节点并且渲染到 dom节点 中。</p><p>接下来就是执行这段代码了，是由 响应式原理 的一个核心类 Watcher 负责执行这个函数，为什么要它来代理执行呢？因为我们需要在这段过程中去 观察 这个函数读取了哪些响应式数据，将来这些响应式数据更新的时候，我们需要重新执行 updateComponent 函数。</p><p>如果是更新后调用 updateComponent 函数的话，updateComponent 内部的 patch 就不再是初始化时候的创建节点，而是对新旧 vnode 进行 diff，最小化的更新到 dom节点 上去。<br>如果遇到 子组件，那么就会优先开始子组件的构建过程，也就是说，从 beforeCreated 重新开始。这是一个递归的构建过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">也就是说，如果我们有 父 -&gt; 子 -&gt; 孙 这三个组件，那么它们的初始化生命周期顺序是这样的：</span><br><span class="line">父 beforeCreate </span><br><span class="line">父 create </span><br><span class="line">父 beforeMount </span><br><span class="line">子 beforeCreate </span><br><span class="line">子 create </span><br><span class="line">子 beforeMount </span><br><span class="line">孙 beforeCreate </span><br><span class="line">孙 create </span><br><span class="line">孙 beforeMount </span><br><span class="line">孙 mounted </span><br><span class="line">子 mounted </span><br><span class="line">父 mounted</span><br></pre></td></tr></table></figure><h4 id="mounted被调用完成"><a href="#mounted被调用完成" class="headerlink" title="mounted被调用完成"></a>mounted被调用完成</h4><p>到此为止，组件的挂载就完成了，初始化的生命周期结束。</p><h3 id="更新流程"><a href="#更新流程" class="headerlink" title="更新流程"></a>更新流程</h3><p>当一个响应式属性被更新后，触发了 Watcher 的回调函数，也就是 vm._update(vm._render())，在更新之前，会先调用刚才在 before 属性上定义的函数，也就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br></pre></td></tr></table></figure><p>注意，由于 Vue 的异步更新机制，beforeUpdate 的调用已经是在 nextTick 中了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nextTick(flushSchedulerQueue)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class="line">    watcher = queue[index]</span><br><span class="line">    <span class="keyword">if</span> (watcher.before) &#123;</span><br><span class="line">     <span class="comment">// callHook(vm, 'beforeUpdate')</span></span><br><span class="line">      watcher.before()</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="beforeUpdate被调用完成"><a href="#beforeUpdate被调用完成" class="headerlink" title="beforeUpdate被调用完成"></a>beforeUpdate被调用完成</h3><p>然后经历了一系列的 patch、diff 流程后，组件重新渲染完毕，调用 updated 钩子。</p><p>注意，这里是对 watcher 倒序 updated 调用的。</p><p>也就是说，假如同一个属性通过 props 分别流向 父 -&gt; 子 -&gt; 孙 这个路径，那么收集到依赖的先后也是这个顺序，但是触发 updated 钩子确是 孙 -&gt; 子 -&gt; 父 这个顺序去触发的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callUpdatedHooks</span> (<span class="params">queue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = queue.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = queue[i]</span><br><span class="line">    <span class="keyword">const</span> vm = watcher.vm</span><br><span class="line">    <span class="keyword">if</span> (vm._watcher === watcher &amp;&amp; vm._isMounted) &#123;</span><br><span class="line">      callHook(vm, <span class="string">'updated'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="updated被调用完成"><a href="#updated被调用完成" class="headerlink" title="updated被调用完成"></a>updated被调用完成</h3><p>至此，渲染更新流程完毕。</p><h3 id="销毁流程"><a href="#销毁流程" class="headerlink" title="销毁流程"></a>销毁流程</h3><p>在刚刚所说的更新后的 patch 过程中，如果发现有组件在下一轮渲染中消失了，比如 v-for 对应的数组中少了一个数据。那么就会调用 removeVnodes 进入组件的销毁流程。</p><p>removeVnodes 会调用 vnode 的 destroy 生命周期，而 destroy 内部则会调用我们相对比较熟悉的 vm.$destroy()。（keep-alive 包裹的子组件除外）</p><p>这时，就会调用 callHook(vm, ‘beforeDestroy’)</p><h4 id="beforeDestroy被调用完成"><a href="#beforeDestroy被调用完成" class="headerlink" title="beforeDestroy被调用完成"></a>beforeDestroy被调用完成</h4><p>之后就会经历一系列的清理逻辑，清除父子关系、watcher 关闭等逻辑。但是注意，$destroy 并不会把组件从视图上移除，如果想要手动销毁一个组件，则需要我们自己去完成这个逻辑。</p><p>然后，调用最后的 callHook(vm, ‘destroyed’)</p><h4 id="destroyed被调用完成"><a href="#destroyed被调用完成" class="headerlink" title="destroyed被调用完成"></a>destroyed被调用完成</h4><h2 id="组件渲染和更新过程"><a href="#组件渲染和更新过程" class="headerlink" title="组件渲染和更新过程"></a>组件渲染和更新过程</h2><p>组件渲染过程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 从模板编译开始，当发现一个自定义组件时，会执行以下函数</span></span><br><span class="line"><span class="comment">// 1. compileToFunctions(template)</span></span><br><span class="line"><span class="comment">// 2. compile(template, options);</span></span><br><span class="line"><span class="comment">// 3. const ast = parse(template.trim(), options)</span></span><br><span class="line"><span class="comment">// 4. const code = generate(ast, options)</span></span><br><span class="line"><span class="comment">// 5. createElement</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. createComponent</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  Ctor: Class&lt;Component&gt; | Function | Object | void,</span></span></span><br><span class="line"><span class="function"><span class="params">  data: ?VNodeData,</span></span></span><br><span class="line"><span class="function"><span class="params">  context: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  children: ?Array&lt;VNode&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag?: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// $options._base 其实就是全局 Vue 构造函数，在初始化时 initGlobalAPI 中定义的：Vue.options._base = Vue</span></span><br><span class="line">  <span class="keyword">const</span> baseCtor = context.$options._base;</span><br><span class="line">  <span class="comment">// Ctor 就是 Vue 组件中 &lt;script&gt; 标签下 export 出的对象</span></span><br><span class="line">  <span class="keyword">if</span> (isObject(Ctor)) &#123;</span><br><span class="line">    <span class="comment">// 将组件中 export 出的对象，继承自 Vue，得到一个构造函数</span></span><br><span class="line">    <span class="comment">// 相当于 Vue.extend(YourComponent)</span></span><br><span class="line">    Ctor = baseCtor.extend(Ctor);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> vnode = <span class="keyword">new</span> VNode(<span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> vnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 实现组件继承 Vue，并调用 Vue._init 方法，进行初始化</span></span><br><span class="line">Vue.extend = <span class="function"><span class="keyword">function</span> (<span class="params">extendOptions: Object</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Super = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 Vue.prototype._init，之后的流程就和首次加载保持一致</span></span><br><span class="line">    <span class="keyword">this</span>._init(options);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 原型继承，相当于：Component extends Vue</span></span><br><span class="line">  Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype);</span><br><span class="line">  Sub.prototype.constructor = Sub;</span><br><span class="line">  <span class="keyword">return</span> Sub;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.cn/post/6844903806782668814" target="_blank" rel="noopener">「从源码中学习」面试官都不知道的Vue题目答案</a></li><li><a href="https://juejin.cn/post/6857669921166491662#comment" target="_blank" rel="noopener">图解 Vue 响应式原理</a></li><li><a href="https://github.com/sl1673495/blogs/issues/40" target="_blank" rel="noopener">Vue 的生命周期之间到底做了什么事清？（源码详解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue进阶1-mvvm</title>
      <link href="/2021/04/03/vue%E8%BF%9B%E9%98%B61-mvvm/"/>
      <url>/2021/04/03/vue%E8%BF%9B%E9%98%B61-mvvm/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍mvvm和mvc"><a href="#介绍mvvm和mvc" class="headerlink" title="介绍mvvm和mvc"></a>介绍mvvm和mvc</h2><p>MVVM 是 Model-View-ViewModel 的缩写</p><p>Model: 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。我们可以把Model称为数据层，因为它仅仅关注数据本身，不关心任何行为.</p><p>View: 用户操作界面(UI组件)。当ViewModel对Model进行更新的时候，会通过数据绑定更新到View</p><p>ViewModel：业务逻辑层，View需要什么数据，ViewModel要提供这个数据；View有某些操作，ViewModel就要响应这些操作，所以可以说它是Model for View. ViewModel把Model和View关联起来</p><p>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p><p>总结：MVVM模式简化了界面与业务的依赖，解决了数据频繁更新。MVVM 在使用当中，利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化</p><h2 id="实现一个简易mvvm"><a href="#实现一个简易mvvm" class="headerlink" title="实现一个简易mvvm"></a>实现一个简易mvvm</h2><p>强烈推荐大佬的 gitHub地址(剖析Vue实现原理 - 如何实现双向绑定mvvm)[<a href="https://github.com/DMQ/mvvm]" target="_blank" rel="noopener">https://github.com/DMQ/mvvm]</a><br>最终效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;person&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="actionscript">      msg: <span class="string">'模拟vue'</span>,</span></span><br><span class="line">      count: 22,</span><br><span class="line"><span class="actionscript">      person: <span class="string">'cpp'</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="actionscript">  vm.person = <span class="string">'陈大鹏'</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>vue.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Observer: 监听器 能够对数据所有属性监听，如有变动拿到最新值并通知Dep</span></span><br><span class="line"><span class="comment">// Dep: 订阅器，又称消息订阅器，主要是收集订阅者watcher(或者称收集依赖)，主要属性有 subs、addSub/notify，数据变动触发notify，再调用订阅者的update方法</span></span><br><span class="line"><span class="comment">// Watcher: 订阅者，又称观察者，订阅Observer中的属性值变化的信息,连接监听器和compiler的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数</span></span><br><span class="line"><span class="comment">// Compiler: 指令解析器 解析Vue模板指令 将模板中的变量替换成数据，绑定相应的更新函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// 保存选项中的数据</span></span><br><span class="line">    <span class="keyword">this</span>.$options = options || &#123;&#125; </span><br><span class="line">    <span class="keyword">this</span>.$data = options.data || &#123;&#125;</span><br><span class="line">    <span class="keyword">this</span>.$el = <span class="keyword">typeof</span> options.el === <span class="string">'string'</span> ? <span class="built_in">document</span>.querySelector(options.el) : options.el;</span><br><span class="line">    <span class="comment">// 将data中的成员转挂载到this上</span></span><br><span class="line">    <span class="comment">// this._proxyData(this.$data)</span></span><br><span class="line">    <span class="comment">// 调用Observer 监听数据变化</span></span><br><span class="line">    <span class="keyword">new</span> Observer(<span class="keyword">this</span>.$data)</span><br><span class="line">    <span class="comment">// 调用compiler 解析vue模板指令和差值表达式</span></span><br><span class="line">    <span class="keyword">new</span> Compiler(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  _proxyData(data) &#123;</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">          <span class="keyword">return</span> data[key]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(val) &#123;</span><br><span class="line">          <span class="keyword">if</span> (val === data[key]) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">          &#125;</span><br><span class="line">          data[key] = val</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据观测</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.walk(data)</span><br><span class="line">  &#125;</span><br><span class="line">  walk(data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.defineReactive(data, key, data[key]);</span><br><span class="line">      <span class="keyword">this</span>.walk(data[key])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  defineReactive(obj, key, val) &#123;</span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">        <span class="comment">// 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Dep.target 当前的wtacher 才能收集依赖'</span>)</span><br><span class="line">        Dep.target &amp;&amp; dep.addSub(Dep.target)</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>: function reactiveSetter(newValue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val === newValue) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        that.walk(newValue);</span><br><span class="line">        dep.notify()</span><br><span class="line">        val = newValue</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Compile 模板解析</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compiler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(vm) &#123;</span><br><span class="line">    <span class="keyword">this</span>.el = vm.$el;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm;</span><br><span class="line">    <span class="keyword">this</span>.compile(<span class="keyword">this</span>.el)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译模板 处理文本节点 3和元素节点 1</span></span><br><span class="line">  compile(el) &#123;</span><br><span class="line">    <span class="keyword">let</span> childNodes = el.childNodes</span><br><span class="line">    <span class="built_in">Array</span>.from(childNodes).forEach(<span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.isTextNode(node)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.compileText(node)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.isElementNode(node)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.compileElement(node)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node &amp;&amp; node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">        <span class="keyword">this</span>.compile(node)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译元素节点 nodeType:1</span></span><br><span class="line">  compileElement(node) &#123;</span><br><span class="line">    <span class="built_in">Array</span>.from(node.attributes).forEach(<span class="function">(<span class="params">attr</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 判断是否是指令</span></span><br><span class="line">     <span class="keyword">let</span> attrName = attr.name</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.isDirective(attrName)) &#123;</span><br><span class="line">       <span class="comment">// v-text --&gt; text</span></span><br><span class="line">       attrName = attrName.substr(<span class="number">2</span>)</span><br><span class="line">       <span class="keyword">let</span> key = attr.value</span><br><span class="line">       <span class="comment">// 处理textUpdater/modelUpdater</span></span><br><span class="line">       <span class="keyword">this</span>.update(node, key, attrName)</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  update(node, key, attrName) &#123;</span><br><span class="line">    <span class="keyword">this</span>[attrName + <span class="string">'Updater'</span>] &amp;&amp; <span class="keyword">this</span>[attrName + <span class="string">'Updater'</span>](node, <span class="keyword">this</span>.vm.$data[key], key)</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">// 处理 v-text 指令</span></span><br><span class="line"> textUpdater(node, value, key) &#123;</span><br><span class="line">    node.textContent = value</span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="keyword">this</span>.vm.$data, key, (newValue) =&gt; &#123;</span><br><span class="line">      node.textContent = newValue</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// v-model</span></span><br><span class="line">  modelUpdater (node, value, key) &#123;</span><br><span class="line">    node.value = value;</span><br><span class="line">    <span class="keyword">new</span> Watcher(<span class="keyword">this</span>.vm.$data, key, (newValue) =&gt; &#123;</span><br><span class="line">      node.value = newValue</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 双向绑定</span></span><br><span class="line">   node.addEventListener(<span class="string">'input'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm.$data[key] = node.value</span><br><span class="line">  &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译文本节点 3 插值</span></span><br><span class="line">  compileText(node) &#123;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/</span>;</span><br><span class="line">    <span class="keyword">let</span> val = node.textContent;</span><br><span class="line">    <span class="keyword">if</span> (reg.test(val)) &#123;</span><br><span class="line">      <span class="keyword">let</span> key = <span class="built_in">RegExp</span>.$<span class="number">1.</span>trim()</span><br><span class="line">      node.textContent = val.replace(reg, <span class="keyword">this</span>.vm.$data[key]);</span><br><span class="line">      <span class="keyword">new</span> Watcher(<span class="keyword">this</span>.vm.$data, key, (val) =&gt; &#123;</span><br><span class="line">        node.textContent = val</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断元素属性是否是指令 ??</span></span><br><span class="line">  isDirective(attrName) &#123;</span><br><span class="line">    <span class="keyword">return</span> attrName.startsWith(<span class="string">'v-'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 是否是文本节点</span></span><br><span class="line">  isTextNode(node) &#123;</span><br><span class="line">    <span class="keyword">return</span> node.nodeType === <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 是否是元素节点</span></span><br><span class="line">  isElementNode(node) &#123;</span><br><span class="line">    <span class="keyword">return</span> node.nodeType === <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 订阅器 管理watcher</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 存放所有的订阅者</span></span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加订阅者 watcher</span></span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'addSub 开始收集依赖'</span>, sub)</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 通知订阅者执行订阅者里的update方法</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function">(<span class="params">sub</span>) =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 订阅者 Watcher</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(vm, key, cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="comment">// 回调函数负责更新视图</span></span><br><span class="line">    <span class="keyword">this</span>.cb = cb;</span><br><span class="line">    <span class="comment">// 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="comment">// 将当前订阅者指向自己</span></span><br><span class="line">    Dep.target = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 触发getter，添加自己到属性订阅器中</span></span><br><span class="line">    <span class="keyword">var</span> value = <span class="keyword">this</span>.vm[<span class="keyword">this</span>.key]</span><br><span class="line">    <span class="comment">// 添加完毕，重置</span></span><br><span class="line">    Dep.target = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="keyword">this</span>.get()</span><br><span class="line">    <span class="keyword">var</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">    <span class="keyword">if</span> (value !== oldValue) &#123;</span><br><span class="line">      <span class="keyword">this</span>.value = value</span><br><span class="line">      <span class="keyword">this</span>.cb(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/DMQ/mvvm" target="_blank" rel="noopener">剖析vue实现原理，自己动手实现mvvm</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> mvvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> mvvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶-vue全面瓦解-2</title>
      <link href="/2021/04/03/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-vue%E5%85%A8%E9%9D%A2%E7%93%A6%E8%A7%A3-2/"/>
      <url>/2021/04/03/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-vue%E5%85%A8%E9%9D%A2%E7%93%A6%E8%A7%A3-2/</url>
      
        <content type="html"><![CDATA[<p>尽力而为吧，作为每天都在用的工具，只是希望自己能了解的足够深一点，把用到的知识学好学精学神就好，对自己要求不高，尽力而为!!!</p><h2 id="mvvm"><a href="#mvvm" class="headerlink" title="mvvm"></a>mvvm</h2><ul><li>mvvm,介绍一下mwvm,和mvc的区别，viewModel有什么好处</li><li>实现一个简易的mvvm框架</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li>vue的初始化流程(vue2.x运行机制)<a href="https://juejin.cn/post/6844904093425598471#heading-47" target="_blank" rel="noopener">Vue 2.x 的运行机制</a></li><li>vue组件的生命周期</li><li>描述组件渲染和更新过程</li><li>vue模板编译原理</li></ul><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><ul><li>defineProperty和proxy区别</li><li>谈谈对vue响应式原理的理解(Vue双向绑定如何实现的)1.数据劫持2.发布订阅</li><li>vue中的依赖收集是怎么处理的</li><li>vue如何检测数组变化(重写数组方法)</li><li>为何采用异步渲染(Vue中的数据多次变化但只会更新一次)</li><li>nextTick实现原理</li><li>v-model实现原理</li></ul><h2 id="watch和computed"><a href="#watch和computed" class="headerlink" title="watch和computed"></a>watch和computed</h2><ul><li>computed如何实现</li><li>watch如何实现</li><li>computed的时候阔以引用其他computed属性是如何实现的</li></ul><h2 id="Virtual-Dom"><a href="#Virtual-Dom" class="headerlink" title="Virtual Dom"></a>Virtual Dom</h2><ul><li>virtual Dom 是什么</li><li>为什么需要虚拟dom</li><li>vue的虚拟dom</li><li>vue对Dom更新做了哪些标记优化处理</li></ul><h2 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h2><ul><li>vue的diff算法原理</li><li>v-for中为啥要是用key(key有啥用)</li><li>vue3.0diff算法</li></ul><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><ul><li>实现hash路由和history路由</li><li>实现一个简单的vue-router</li></ul><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><ul><li>什么是状态管理，为啥需要状态管理</li><li>action和mutation中的区别</li><li>实现一个简单的vuex</li></ul><h2 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h2><h2 id="vue能做哪些性能优化"><a href="#vue能做哪些性能优化" class="headerlink" title="vue能做哪些性能优化"></a>vue能做哪些性能优化</h2><ul><li>谈谈你对keep-alive的理解</li><li>Vue 3.0 性能提升主要是通过哪几方面体现的</li></ul><h2 id="vue-对比-react"><a href="#vue-对比-react" class="headerlink" title="vue 对比 react"></a>vue 对比 react</h2><ul><li>设计思路((React 与 Vue 框架的设计思路大 PK)[<a href="https://mp.weixin.qq.com/s/Rxc8yOvHqWKq-tBYu4akew]" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Rxc8yOvHqWKq-tBYu4akew]</a>)</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>说说你对<a href="https://mp.weixin.qq.com/s/HMMNqgVrkG7WPSq-ipR9WQ" target="_blank" rel="noopener">spa的理解</a></p></li><li><p>vue的事件绑定原理<br>原生事件绑定是通过addEventListener绑定给真实元素的，组件事件绑定是通过Vue自定义的$on实现的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件处理</span></span><br><span class="line">eventHandler: <span class="function"><span class="keyword">function</span>(<span class="params">node, vm, exp, dir</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> eventType = dir.split(<span class="string">':'</span>)[<span class="number">1</span>],</span><br><span class="line">      fn = vm.$options.methods &amp;&amp; vm.$options.methods[exp];</span><br><span class="line">    <span class="keyword">if</span> (eventType &amp;&amp; fn) &#123;</span><br><span class="line">      node.addEventListener(eventType, fn.bind(vm), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>vue中scoped属性有什么作用？原理是什么</p></li><li><p>keep-alive</p></li><li><p>vue性能优化</p></li><li><p>封装自己的全局vue实例组件(Vue.extends)</p></li><li><p>ssr渲染</p></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://juejin.cn/post/6844903636938522638" target="_blank" rel="noopener">vue中extend，mixins，extends，components,install的几个操作</a></li><li><a href="https://juejin.cn/post/6844904181443067912" target="_blank" rel="noopener">学习vue源码（5） 手写Vue.use、Vue.minxin、Vue.compile</a></li><li><a href="https://juejin.cn/post/6844904093425598471#heading-54" target="_blank" rel="noopener">在阿里我是如何当面试官的</a></li><li><a href="https://mp.weixin.qq.com/s/xjfKiH2_gqkvV67HZ1o0Sw" target="_blank" rel="noopener">Vue3.0高频出现的几道面试题</a></li><li><a href="https://juejin.cn/post/6844904116339261447#heading-19" target="_blank" rel="noopener">2021年前端面试必读文章【超三百篇文章/赠复习导图】</a></li><li><a href="https://ustbhuangyi.github.io/vue-analysis/v2/reactive/" target="_blank" rel="noopener">深入响应式原理</a></li><li><a href="https://mp.weixin.qq.com/s/Eeku_prayvdHbW0ynCtM3A" target="_blank" rel="noopener">【Vue.js】880- Vue 3.0 进阶之双向绑</a></li><li><a href="https://juejin.cn/post/6844904115886096392#comment" target="_blank" rel="noopener">请你说说 Vue 中 slot 和 slot-scope 的原理</a></li><li><a href="https://juejin.cn/post/6844904084374290446#heading-14" target="_blank" rel="noopener">面试题」20+Vue面试题整理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础: 设计模式</title>
      <link href="/2021/03/28/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/03/28/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>从架构层面考虑设计，从上往下看，而不是只顾往下看<br>设计模式的定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。<br>设计模式就是一种理念，通过一些设计思维来解决平时编写底层或业务代码时遇到的场景问题。比如早期业务中的一个封装类，同时带有一些封装方法。如果现在该类不能再满足全部业务场景，且不允许修改原方法，此时就需要装饰器或适配器模式来解决；又比如当设计一个场景，在调用一个固定对象时一定要先执行某些方法，比如验证登录、验证身份ID等场景，此时就应该用到代理模式。</p><h2 id="装饰者模式-Decorator"><a href="#装饰者模式-Decorator" class="headerlink" title="装饰者模式 Decorator"></a>装饰者模式 Decorator</h2><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>在原来方法的基础上装饰一些针对特殊场景所适用的方法，即添加一些新功能，主要特征</p><ul><li>为对象添加新功能</li><li>不改变原有的结构和功能，即原本的功能得继续用<h3 id="实现-one"><a href="#实现-one" class="headerlink" title="实现 one"></a>实现 one</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    draw() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'画一个圆'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(circle) &#123;</span><br><span class="line">      <span class="keyword">this</span>.circle = circle</span><br><span class="line">    &#125;</span><br><span class="line">    draw() &#123;</span><br><span class="line">      <span class="keyword">this</span>.circle.draw()</span><br><span class="line">      <span class="keyword">this</span>.setRedBorder()</span><br><span class="line">    &#125;</span><br><span class="line">    setRedBorder() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'画一个红色的边框'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> circle = <span class="keyword">new</span> Circle()</span><br><span class="line">  <span class="keyword">const</span> decorator = <span class="keyword">new</span> Decorator(circle) <span class="comment">// 传入一个实例</span></span><br><span class="line">  decorator.draw()</span><br><span class="line"><span class="comment">// 画一个圆</span></span><br><span class="line"><span class="comment">// 画一个红色的边框</span></span><br></pre></td></tr></table></figure>该例中，我们写了一个Decorator装饰器类，它重写了实例对象的draw方法，给其方法新增了一个setRedBorder()，因此最后为其输出结果进行了装饰。<h3 id="实现-two"><a href="#实现-two" class="headerlink" title="实现 two"></a>实现 two</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装饰器，在当前函数执行前先执行另一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DecoratorBefore</span>(<span class="params">fn, beforeFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = beforeFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">     <span class="comment">// 在前一个函数中判断，不需要执行当前函数</span></span><br><span class="line">    <span class="keyword">if</span>(res !== <span class="literal">false</span>) &#123;</span><br><span class="line">        fn.apply(<span class="keyword">this</span>.arguments)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">learn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'learn 学习'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shufa</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'书法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'run'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> d = DecoratorBefore(shufa, run)</span><br><span class="line">d = DecoratorBefore(d, learn)</span><br><span class="line">d()</span><br><span class="line">VM3126:<span class="number">12</span> learn 学习</span><br><span class="line">VM3126:<span class="number">18</span> run</span><br><span class="line">VM3126:<span class="number">15</span> 书法</span><br></pre></td></tr></table></figure><h3 id="装饰器插件"><a href="#装饰器插件" class="headerlink" title="装饰器插件"></a>装饰器插件</h3>ES7 中就存在了装饰器语法，需要安装相应的babel插件，一起看一下该插件如何用，首先安装一下插件，并做相关的语法配置：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-plugin-transform-decorators-legacy </span><br><span class="line"></span><br><span class="line"><span class="comment">//.babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>: [<span class="string">"es2015"</span>, <span class="string">"latest"</span>],</span><br><span class="line">    <span class="string">"plugins"</span>: [<span class="string">"transform-decorators-legacy"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>给一个Demo类上添加一个装饰器 testDec，此时 Demo类就具有了 装饰器赋予的属性：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@testDec</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testDec</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">   target.isDec = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(Demo.isDec) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>得出结论<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@decorator </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line">A = decorator(A) || A;</span><br></pre></td></tr></table></figure></li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li>Vue项目里的 vue-property-decorator <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Vue &#125; <span class="keyword">from</span> <span class="string">'vue-property-decorator'</span></span><br><span class="line"><span class="meta">@Component</span>(&#123;&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> MaskLayer <span class="keyword">extends</span> Vue &#123;&#125;</span><br></pre></td></tr></table></figure></li><li>mixin 示例<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">Object</span>.assign(target.prototype, ...list)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">    foo() &#123;</span><br><span class="line">        alert(<span class="string">'foo'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>上例中，Foo作为target的实参，MyClass作为 list的实参，最终实现将Foo的所有原型方法（foo）装饰到 MyClass类上，成为了MyClass的方法。最终代码的运行结果是执行了foo()</li></ul><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p><a href="http://niaogege.cn/2020/12/13/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E8%A3%85%E9%A5%B0%E5%99%A8/">ts里的装饰器, 更新中</a></p><h2 id="发布-订阅模式（Observer-Pattern）"><a href="#发布-订阅模式（Observer-Pattern）" class="headerlink" title="发布-订阅模式（Observer Pattern）"></a>发布-订阅模式（Observer Pattern）</h2><p>发布-订阅模式又叫观察者模式，也称作观察者模式，定义了对象间的一种一对多的依赖关系，当一个对象的状态发 生改变时，所有依赖于它的对象都将得到通知。JavaScript 本身也是一门基于事件驱动的语言，也利用了发布订阅模式</p><p>它的作用是当一个对象的状态发生变化时，能够自动通知其他关联对象，自动刷新对象状态，或者说执行对应对象的方法。<br>这种设计模式可以大大降低程序模块之间的耦合度，便于更加灵活的扩展和维护。</p><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>观察者模式包含两种角色：</p><p>观察者（订阅者）<br>被观察者（发布者）</p><p>核心思想：订阅者只要订阅了发布者的事件，那么当发布者的状态改变时，发布者会主动去通知观察者，而无需关心订阅者得到事件后要去做什么，实际程序中可能是执行订阅者中的回调函数。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>支持简单的广播通信，当对象状态发生改变时，会自动通知已经订阅过的对象。</li><li>解耦, 发布者与订阅者耦合性降低，发布者只管发布一条消息出去，它不关心这条消息如何被订阅者使用，同时，订阅者只监听发布者的事件名，只要发布者的事件名不变，它不管发布者如何改变</li><li>缺点：创建订阅者本身要消耗一定的时间和内存，订阅的处理函数不一定会被执行，驻留内存有性能开销，弱化了对象之间的联系，复杂的情况下可能会导致程序难以跟踪维护和理解(如果过多的使用发布订阅模式, 会增加维护的难度)</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.watchers = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 订阅主题和回调函数</span></span><br><span class="line">  subscribe(key, fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.watchers[key] = <span class="keyword">this</span>.watchers[key] || []</span><br><span class="line">    <span class="keyword">this</span>.watchers[key].push(fn)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 主题发布以及传参</span></span><br><span class="line">  publish(key, data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.watchers[key] &amp;&amp; <span class="keyword">this</span>.watchers[key].length) &#123;</span><br><span class="line">      <span class="keyword">this</span>.watchers[key].forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">        fn(data);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取消主题或者指定事件退订</span></span><br><span class="line">  unsubscribe (key = <span class="string">''</span>, fn = <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fn) &#123;</span><br><span class="line">      <span class="comment">// 如果只取消</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.watchers[key] &amp;&amp; <span class="keyword">this</span>.watchers[key].length) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = <span class="keyword">this</span>.watchers[key].findIndex(<span class="function"><span class="params">cb</span> =&gt;</span> <span class="built_in">Object</span>.is(cb, fn))</span><br><span class="line">        <span class="keyword">this</span>.watchers[key].splice(index, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key) &#123;</span><br><span class="line">       <span class="keyword">this</span>.watchers[key] = []</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.watchers = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> Event();</span><br><span class="line"><span class="keyword">const</span> eatFn = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data, <span class="string">'eat'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> studyFn = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data, <span class="string">'come on 加油'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据主题 订阅</span></span><br><span class="line">event.subscribe(<span class="string">'eat'</span>, eatFn);</span><br><span class="line">event.subscribe(<span class="string">'study'</span>,studyFn);</span><br><span class="line"><span class="comment">// 根据主题进行发布</span></span><br><span class="line">event.publish(<span class="string">'study'</span>, <span class="string">'study PUBLISH'</span>);</span><br><span class="line">event.publish(<span class="string">'eat'</span>, <span class="string">'eat PUBLISH'</span>);</span><br></pre></td></tr></table></figure><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><ul><li>JS中的事件就是经典的发布-订阅模式的实现<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们向某dom文档订阅了点击事件，当点击发生时，他会执行我们传入的callback</span></span><br><span class="line">element.addEventListener(‘click’, callback2, <span class="literal">false</span>)</span><br><span class="line">element.addEventListener(‘click’, callback2, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>或者Vue<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">事件发布者使用<span class="string">'vm.$emit、vm.$dispatch(vue1.0)、vm.$broadcast(vue1.0)发布事件</span></span><br><span class="line"><span class="string">// 接受方使用$on方法或组件监听器订阅事件，传递一个回调函数</span></span><br><span class="line"><span class="string">vm.$emit(event, […args]) // publish</span></span><br><span class="line"><span class="string">vm.$on(event, callback) // subscribe</span></span><br><span class="line"><span class="string">vm.$off([event, callback]) // unsubscribe</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="外观模式（Facade-Pattern）"><a href="#外观模式（Facade-Pattern）" class="headerlink" title="外观模式（Facade Pattern）"></a>外观模式（Facade Pattern）</h2><p>也叫门面模式，外观模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用<br>实现:<br>外观设计模式就是把多个子系统中复杂逻辑进行抽象，从而提供一个更统一、更简洁、更易用的API。很多我们常用的框架和库基本都遵循了外观设计模式，比如JQuery就把复杂的原生DOM操作进行了抽象和封装，并消除了浏览器之间的兼容问题，从而提供了一个更高级更易用的版本。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三个处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'doing'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外观函数，将一些处理统一起来，方便调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    start();</span><br><span class="line">    doing();</span><br><span class="line">    end();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用init开始执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处直接调用了高层函数，也可以选择越过它直接调用相关的函数</span></span><br><span class="line">    execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init(); <span class="comment">// start doing end</span></span><br></pre></td></tr></table></figure><h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><p>我们可以应用外观模式封装一个统一的DOM元素事件绑定/取消方法，用于兼容不同版本的浏览器和更方便的调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">    element.addEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">    element.attachEvent(<span class="string">'on'</span> + event, handler);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    element[<span class="string">'on'</span> + event] = fn;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取消绑定</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeEvent</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">    element.removeEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">    element.detachEvent(<span class="string">'on'</span> + event, handler);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    element[<span class="string">'on'</span> + event] = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代理模式（Proxy-Pattern）"><a href="#代理模式（Proxy-Pattern）" class="headerlink" title="代理模式（Proxy Pattern）"></a>代理模式（Proxy Pattern）</h2><h3 id="核心-1"><a href="#核心-1" class="headerlink" title="核心"></a>核心</h3><p>为一个对象提供一个代用品或占位符，以便控制对它的访问。<br>使用者、目标对象和代理者，使用者的目的是直接访问目标对象，但却不能直接访问，而是要先通过代理者。因此该模式非常像明星代理人的场景。其特征为：</p><ul><li>使用者无权访问目标对象；</li><li>中间加代理，通过代理做授权和控制。</li></ul><p>代理模式确实很方便，通常如果面临一些很大开销的操作，就可以并采用虚拟代理的方式延迟到需要它的时候再去创建，比如懒加载操作。或者一些前置条件较多的操作，比如目标操作实现的前提必须是已登录，且Id符合一定特征，此时也可以将这些前置判断写到代理器中。举个加载图片的例子：</p><h3 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h3><ul><li><p>事件冒泡与事件捕获应用:事件代理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">"color_list"</span>&gt;        </span><br><span class="line">      &lt;li&gt;red&lt;<span class="regexp">/li&gt;        </span></span><br><span class="line"><span class="regexp">      &lt;li&gt;orange&lt;/</span>li&gt;        </span><br><span class="line">      &lt;li&gt;yellow&lt;<span class="regexp">/li&gt;        </span></span><br><span class="line"><span class="regexp">      &lt;li&gt;green&lt;/</span>li&gt;        </span><br><span class="line">      &lt;li&gt;blue&lt;<span class="regexp">/li&gt;        </span></span><br><span class="line"><span class="regexp">      &lt;li&gt;purple&lt;/</span>li&gt;    </span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">      function colorChange(e) &#123;</span></span><br><span class="line"><span class="regexp">        var e = e || window.event;</span></span><br><span class="line"><span class="regexp">        if (e.target.nodeName.toLowerCase === 'li') &#123;</span></span><br><span class="line"><span class="regexp">          box.innerHTML="该颜色为 "+e.target.innerHTML;         </span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">      color_list.addEventListener("click", colorChange, false)</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure><p>我们并未直接在元素上定义点击事件，而是通过监听元素点击事件，并通过定位元素节点名称来代理到<li>标签的点击，最终利用捕获事件来实现相应的点击效果。</p></li><li><p>缓存代理 可以为一些开销大的运算结果提供暂时的缓存，提升效率</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memo</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> key = [].join.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span>(cache.has(key))&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    cache.set(key, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getMemor = memo(<span class="function"><span class="keyword">function</span> <span class="title">slow</span>(<span class="params">x,y,z</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x + y + z, <span class="string">'total'</span>)</span><br><span class="line">  <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> test1 = getMemor(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> test2 = getMemor(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(test1)</span><br><span class="line"><span class="built_in">console</span>.log(test2)</span><br><span class="line"><span class="comment">// 6 "total" 只会执行一次</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure></li><li><p>ES6 proxy<br>ES6的 Proxy 相信大家都不会陌生，Vue 3.0 的双向绑定原理就是依赖 ES6 的 Proxy 来实现，给一个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proxy</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'cpp'</span>,</span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  obj,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">get</span>(target,key) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, key, val) &#123;</span><br><span class="line">      target[key] = val;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h2 id="工厂模式（Factory-Pattern）"><a href="#工厂模式（Factory-Pattern）" class="headerlink" title="工厂模式（Factory Pattern）"></a>工厂模式（Factory Pattern）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>当构造函数过多不方便管理，且需要创建的对象之间存在某些关联（有同一个父类、实现同一个接口,有同一个属性等）时，不妨使用工厂模式。工厂模式提供一种集中化、统一化的方式，避免了分散创建对象导致的代码重复、灵活性差/实例化重复的问题。</p><h3 id="核心-2"><a href="#核心-2" class="headerlink" title="核心"></a>核心</h3><ul><li>主要用于隐藏创建实例的复杂度，只需对外提供一个接口；</li><li>实现构造函数和创建者的分离，满足开放封闭的原则；</li></ul><p>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Suzuki汽车构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuzukiCar</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">  <span class="keyword">this</span>.brand = <span class="string">'Suzuki'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// BMW汽车构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BMWCar</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">  <span class="keyword">this</span>.brand = <span class="string">'BMW'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 汽车品牌枚举</span></span><br><span class="line"><span class="keyword">const</span> BRANDS = &#123;</span><br><span class="line">  suzuki: <span class="number">1</span>,</span><br><span class="line">  honda: <span class="number">2</span>,</span><br><span class="line">  bmw: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 汽车工厂 颜色一致 brand不一样</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CarFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">brand, color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (brand) &#123;</span><br><span class="line">      <span class="keyword">case</span> BRANDS.suzuki:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SuzukiCar(color);</span><br><span class="line">      <span class="keyword">case</span> BRANDS.bmw:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BMWCar(color);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> carFactory = <span class="keyword">new</span> CarFactory();</span><br><span class="line"><span class="keyword">const</span> cars = [];</span><br><span class="line">cars.push(carFactory.create(BRANDS.suzuki, <span class="string">'brown'</span>));</span><br><span class="line">cars.push(carFactory.create(BRANDS.bmw, <span class="string">'red'</span>));</span><br><span class="line"><span class="comment">// SuzukiCar &#123;color: "brown", brand: "Suzuki"&#125;</span></span><br><span class="line"><span class="comment">// BMWCar &#123;color: "red", brand: "BMW"&#125;</span></span><br></pre></td></tr></table></figure><p>使用工厂模式之后，不再需要重复引入一个个构造函数，只需要引入工厂对象就可以方便的创建各类对象。</p><h3 id="场景-4"><a href="#场景-4" class="headerlink" title="场景"></a>场景</h3><ul><li>jQuery的选择器$(selector)，$内置的实现机制是工厂模式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">jQuery</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(selector) &#123;</span><br><span class="line">        <span class="keyword">super</span>(selector)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.$ = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> jQuery(selector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Vue 异步组件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-example'</span> , (resolve , reject) =&gt; &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(&#123;</span><br><span class="line">            template: <span class="string">`&lt;div&gt;I am async!&lt;/div&gt;`</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="单例模式（Singleton-Pattern）"><a href="#单例模式（Singleton-Pattern）" class="headerlink" title="单例模式（Singleton Pattern）"></a>单例模式（Singleton Pattern）</h2><p>顾名思义，单例模式中Class的实例个数最多为1。当需要一个对象去贯穿整个系统执行某些任务时，单例模式就派上了用场。而除此之外的场景尽量避免单例模式的使用，因为单例模式会引入全局状态，而一个健康的系统应该避免引入过多的全局状态。</p><ul><li>确保只有一个实例</li><li>可以全局访问</li></ul><p>我们一般通过实现以下两点来解决上述问题：</p><ul><li>隐藏Class的构造函数，避免多次实例化</li><li>通过暴露一个 getInstance() 方法来创建/获取唯一实例<h3 id="实现-one-1"><a href="#实现-one-1" class="headerlink" title="实现 one"></a>实现 one</h3>Javascript中单例模式可以通过以下方式实现：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例构造器</span></span><br><span class="line"><span class="keyword">const</span> FooServiceSingleton = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 隐藏的Class的构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">FooService</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 未初始化的单例对象</span></span><br><span class="line">  <span class="keyword">let</span> fooService;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 创建/获取单例对象的函数</span></span><br><span class="line">    getInstance: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!fooService) &#123;</span><br><span class="line">        fooService = <span class="keyword">new</span> FooService();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> fooService;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>实现的关键点有：</li></ul><ol><li>使用 IIFE 创建局部作用域并即时执行；</li><li>getInstance() 为一个 闭包 ，使用闭包保存局部作用域中的单例对象并返回</li></ol><p>测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fooService1 = FooServiceSingleton.getInstance();</span><br><span class="line"><span class="keyword">const</span> fooService2 = FooServiceSingleton.getInstance();</span><br><span class="line"><span class="built_in">console</span>.log(fooService1 === fooService2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="实现-two-1"><a href="#实现-two-1" class="headerlink" title="实现 two"></a>实现 two</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result || (result = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getScript = singleton(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> script1 = getScript();</span><br><span class="line"><span class="keyword">const</span> script2 = getScript();</span><br><span class="line"><span class="built_in">console</span>.log(script1 === script2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="场景-5"><a href="#场景-5" class="headerlink" title="场景"></a>场景</h3><ul><li>因为 JavaScript 是无类的语言, 而且 JS 中的全局对象符合单例模式两个条件。很多时候我们把全局对象当成单例模式来使用,</li><li>Vue和React中的store</li></ul><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>解释: 对象有某个行为，但是在不同的场景中，该行为有不同的实现策略(根据不同参数可以命中不同的策略)<br>案例: 模式的场景如登录鉴权，鉴权算法取决于用户的登录方式是手机、邮箱或者第三方的微信登录等等，而且登录方式也只有在运行时才能获取，获取到登录方式后再动态的配置鉴权策略。所有这些策略应该实现统一的接口，或者说有统一的行为模式。<br>示例:<br>登录鉴权的例子我们仿照 passport.js 的思路通过代码来理解策略模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoginController</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.strategy = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">this</span>.setStrategy = <span class="function"><span class="keyword">function</span> (<span class="params">strategy</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    <span class="keyword">this</span>.login = <span class="keyword">this</span>.strategy.login;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户名、密码登录策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LocalStragegy</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.login = <span class="function">(<span class="params">&#123; username, password &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(username, password);</span><br><span class="line">    <span class="comment">// authenticating with username and password... </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手机号、验证码登录策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PhoneStragety</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.login = <span class="function">(<span class="params">&#123; phone, verifyCode &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(phone, verifyCode);</span><br><span class="line">    <span class="comment">// authenticating with hone and verifyCode... </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第三方社交登录策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SocialStragety</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.login = <span class="function">(<span class="params">&#123; id, secret &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(id, secret);</span><br><span class="line">    <span class="comment">// authenticating with id and secret... </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loginController = <span class="keyword">new</span> LoginController();</span><br><span class="line"><span class="comment">// 调用用户名、密码登录接口，使用LocalStrategy</span></span><br><span class="line">app.use(<span class="string">'/login/local'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  loginController.setStrategy(<span class="keyword">new</span> LocalStragegy());</span><br><span class="line">  loginController.login(req.body);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用手机、验证码登录接口，使用PhoneStrategy</span></span><br><span class="line">app.use(<span class="string">'/login/phone'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  loginController.setStrategy(<span class="keyword">new</span> PhoneStragety());</span><br><span class="line">  loginController.login(req.body);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用社交登录接口，使用SocialStrategy</span></span><br><span class="line">app.use(<span class="string">'/login/social'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  loginController.setStrategy(<span class="keyword">new</span> SocialStragety());</span><br><span class="line">  loginController.login(req.body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>特点:</p><ul><li>在运行时切换算法和策略</li><li>更简洁，避免使用大量的条件判断</li><li>分离，每个strategy类控制自己的算法逻辑，strategy和其使用者之间也相互独立</li></ul><h2 id="迭代-遍历器Iterator-pattern）"><a href="#迭代-遍历器Iterator-pattern）" class="headerlink" title="迭代(遍历器Iterator pattern）"></a>迭代(遍历器Iterator pattern）</h2><p>ES6中的迭代器 Iterator 相信大家都不陌生，迭代器用于遍历容器（集合）并访问容器中的元素，而且无论容器的数据结构是什么（Array、Set、Map等），迭代器的接口都应该是一样的，都需要遵循 迭代器协议。<br>迭代器模式解决了以下问题：<br>一种机制,各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p><p>ES6提供了更简单的迭代循环语法 for…of，使用该语法的前提是操作对象需要实现 可迭代协议（The iterable protocol），简单说就是该对象有个Key为 Symbol.iterator 的方法，该方法返回一个iterator对象。<br>比如我们实现一个 Range 类用于在某个数字区间进行迭代</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        next() &#123;</span><br><span class="line">          <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">value</span>: start++, <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: end &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (num <span class="keyword">of</span> Range(<span class="number">1</span>, <span class="number">5</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num); <span class="comment">//1 2 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://juejin.cn/post/6844903918330347533" target="_blank" rel="noopener">深入 JavaScript 设计模式，从此有了优化代码的理论依据</a></li><li><a href="https://zhuanlan.zhihu.com/p/133263261" target="_blank" rel="noopener">前端设计模式</a></li><li><a href="https://juejin.cn/post/6844903474535071752#heading-0" target="_blank" rel="noopener">JavaScript 常见设计模式解析</a></li><li><a href="https://mp.weixin.qq.com/s/Nlj_VOLDqUEPovdbk2uTiw" target="_blank" rel="noopener">【前端面试题】16道设计模式面试题（附答案）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础:js原型链与继承(六种常见的继承)</title>
      <link href="/2021/03/28/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-js%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
      <url>/2021/03/28/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-js%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>继承是OO语言中的一个最为人津津乐道的概念.许多OO语言都支持两种继承方式: 接口继承 和 实现继承 .接口继承只继承方法签名,而实现继承则继承实际的方法.由于js中方法没有签名,在ECMAScript中无法实现接口继承.ECMAScript只支持实现继承,而且其 实现继承 主要是依靠原型链来实现的. </p><p><img src= "/img/loading.gif" data-src="/images/extends/contructor.png" alt="js异步加载"></p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>简单回顾下构造函数,原型和实例的关系:<br>每个构造函数(constructor)都有一个原型对象(prototype),原型对象都包含一个指向构造函数的指针(constructor),而实例(instance)都包含一个指向原型对象的内部指针(<strong>proto</strong>)</p><blockquote><p><strong>proto</strong>是隐式原型，prototype是显式原型</p></blockquote><p>每个对象都有一个隐式原型，指向该对象的原型。实例化后通过<strong>proto</strong>属性指向构造函数的显式原型prototype,<br>原型链是由各个原型对象组成，每个对象都有<strong>proto</strong>属性，指向创建该对象的构造函数的原型，通过隐式原型<strong>proto</strong>属性将对象链起来，组成原型链，用来实现属性方法继承和共享</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.names = [<span class="string">'cpp'</span>, <span class="string">'wmh'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.names)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child()</span><br><span class="line">child1.names.push(<span class="string">'James'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child1.names) <span class="comment">// ["cpp", "wmh", "James"]</span></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="built_in">console</span>.log(child2.names) <span class="comment">// ["cpp", "wmh", "James"]</span></span><br><span class="line"><span class="built_in">console</span>.log(Parent.prototype.constructor === Parent)</span><br></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>当原型链中包含引用类型属性的时候，引用类型的属性会被所有实例共享</li><li>当创建Child子类的时候，不能向父类构造函数Parent传参<br>为此,下面将有一些尝试以弥补原型链的不足!</li></ul><h2 id="构造函数继承-constructor-stealing-经典继承"><a href="#构造函数继承-constructor-stealing-经典继承" class="headerlink" title="构造函数继承 constructor stealing (经典继承)"></a>构造函数继承 constructor stealing (经典继承)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.names = [<span class="string">'cpp'</span>, <span class="string">'wmh'</span>]</span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.names)</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">this</span>.getName()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="built_in">console</span>.log(child1)</span><br><span class="line"><span class="built_in">console</span>.log(child2)</span><br><span class="line"></span><br><span class="line">VM911:<span class="number">4</span> (<span class="number">2</span>) [<span class="string">"cpp"</span>, <span class="string">"wmh"</span>]</span><br><span class="line">VM911:<span class="number">4</span> (<span class="number">2</span>) [<span class="string">"cpp"</span>, <span class="string">"wmh"</span>]</span><br><span class="line">Child &#123;<span class="attr">names</span>: <span class="built_in">Array</span>(<span class="number">2</span>), <span class="attr">getName</span>: ƒ&#125; <span class="comment">// getName 调用1次</span></span><br><span class="line">Child &#123;<span class="attr">names</span>: <span class="built_in">Array</span>(<span class="number">2</span>), <span class="attr">getName</span>: ƒ&#125; <span class="comment">// getName 调用2次</span></span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>避免了引用类型的属性被所有实例共享</li><li>可以在 Child 中向 Parent 传参</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>方法都在构造函数中定义，导致每次创建实例都会执行constructor方法</p><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><h3 id="组合继承-有时候也叫做伪经典继承-指的是将原型链和借用构造函数的技术组合到一块-从而发挥两者之长的一种继承模式。即原型链继承-构造函数继承"><a href="#组合继承-有时候也叫做伪经典继承-指的是将原型链和借用构造函数的技术组合到一块-从而发挥两者之长的一种继承模式。即原型链继承-构造函数继承" class="headerlink" title="组合继承, 有时候也叫做伪经典继承,指的是将原型链和借用构造函数的技术组合到一块,从而发挥两者之长的一种继承模式。即原型链继承 + 构造函数继承"></a>组合继承, 有时候也叫做伪经典继承,指的是将原型链和借用构造函数的技术组合到一块,从而发挥两者之长的一种继承模式。即原型链继承 + 构造函数继承</h3><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路:"></a>基本思路:</h3><p>原型链实现对原型属性和方法的继承<br>构造函数实现对实例属性和方法的继承</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Parent const'</span>)</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'cpp'</span>)</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">'wmh'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child1)</span><br><span class="line"><span class="built_in">console</span>.log(child2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parent const</span></span><br><span class="line"><span class="comment">// Parent const</span></span><br><span class="line"><span class="comment">// Parent const</span></span><br><span class="line">VM1202:<span class="number">14</span> Child &#123;<span class="attr">name</span>: <span class="string">"cpp"</span>&#125;</span><br><span class="line">VM1202:<span class="number">15</span> Child &#123;<span class="attr">name</span>: <span class="string">"wmh"</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>融合原型链继承 + 构造函数继承两者优点，js常用的继承模式</p><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>创建实例会调用两次父类构造函数</li></ul><h2 id="原型式继承Object-create"><a href="#原型式继承Object-create" class="headerlink" title="原型式继承Object.create"></a>原型式继承Object.create</h2><p>ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型(对象的<strong>proto</strong>)。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockCreate</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  Fn.protptype = obj</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Fn()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'kevin'</span>,</span><br><span class="line">    friends: [<span class="string">'daisy'</span>, <span class="string">'kelly'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = mockCreate(person);</span><br><span class="line"><span class="keyword">var</span> person2 = mockCreate(person);</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">'person1'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line">person1.firends.push(<span class="string">'taylor'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// ["daisy", "kelly", "taylor"]</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的 name 值，而是因为person1.name = ‘person1’，给person1添加了 name 值，并非修改了原型上的 name 值。</p></blockquote><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>包含引用类型的属性值始终都会被实例共享，这点跟原型链继承缺点一样。</p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>创建一个<strong>仅用于封装继承过程的函数</strong>,该函数在内部以某种方式来<strong>增强对象</strong>,最后再返回对象. 如下.</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(o); <span class="comment">// 原型式继承</span></span><br><span class="line">    clone.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 增强对象</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone; <span class="comment">// 记得返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> parent = &#123;<span class="attr">name</span>: <span class="string">'cpp'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> child = createObj(parent)</span><br><span class="line"><span class="built_in">console</span>.log(child)</span><br></pre></td></tr></table></figure><p>这个例子中的代码基于parent返回了一个新对象child. 新对象不仅具有parent的所有属性和方法, 而且还被增强了, 拥有了sayName()方法.<br>缺点也是 父类包含引用类型的属性值会被实例继承</p><h2 id="寄生组合-继承"><a href="#寄生组合-继承" class="headerlink" title="寄生组合 继承"></a>寄生组合 继承</h2><p>组合继承最大的缺点就是会两次调用父类构造函数,先回顾下组合继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1)<span class="string">`</span></span><br></pre></td></tr></table></figure><p>一次是<strong>设置子类型实例的原型</strong>的时候：<br><code>Child.prototype = new Parent();</code><br>一次在<strong>创建子类型实例</strong>的时候：<br><code>var child1 = new Child(&#39;kevin&#39;, &#39;18&#39;);</code><br>寄生组合式继承就是为了降低调用父类构造函数的开销而出现的</p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">foo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.foo = foo</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.printFoo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">bar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.bar = bar</span><br><span class="line">  Parent.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype)</span><br><span class="line">Child.prototype.constructor = Child <span class="comment">// 重新指标指向自己</span></span><br></pre></td></tr></table></figure><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockObject</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototype</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    child.prototype = mockObject(parent.prototype);</span><br><span class="line">    child.prototype.constructor = child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当我们使用的时候：</span></span><br><span class="line">prototype(Child, Parent);</span><br></pre></td></tr></table></figure><h2 id="es6版继承"><a href="#es6版继承" class="headerlink" title="es6版继承"></a>es6版继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(foo) &#123;</span><br><span class="line">    <span class="keyword">this</span>.foo = foo</span><br><span class="line">  &#125;</span><br><span class="line">  printInfo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(foo, bar) &#123;</span><br><span class="line">    <span class="keyword">super</span>(foo)</span><br><span class="line">    <span class="keyword">this</span>.bar = bar</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES5的继承，实质是先创造子类的实例对象，然后将再将父类的方法添加到this上。<br>ES6的继承，先创造父类的实例对象（所以必须先调用super方法，然后再用子类的构造函数修改this)</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://segmentfault.com/a/1190000009389979" target="_blank" rel="noopener">JavaScript深入之继承的多种方式和优缺点</a></li><li><a href="http://louiszhai.github.io/2015/12/15/prototypeChain/#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">详解JS原型链与继承</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> prototype </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-handWritng-series-updating</title>
      <link href="/2021/03/27/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-handWritng-series-updating/"/>
      <url>/2021/03/27/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-handWritng-series-updating/</url>
      
        <content type="html"><![CDATA[<!-- * @Author: cpp * @Date: 2021-03-30 22:25:17 * @LastEditors: cpp * @LastEditTime: 2021-05-16 17:12:12 * @FilePath: \vite-project-based:\hexo\source\_posts\前端基础-handWritng-series-updating.md--><h1 id="js基础"><a href="#js基础" class="headerlink" title="js基础"></a>js基础</h1><h2 id="手写const"><a href="#手写const" class="headerlink" title="手写const"></a>手写const</h2><p>回到var和let/const的区别上：</p><p>var声明的变量会挂到window上，而let和const不会<br>var声明的变量存在变量提升，而let和const不会<br>let和const声明形成块作用域，只能在块作用域里访问，不能跨块访问，也不能跨函数访问<br>同一作用域下let和const不能声明同名变量，而var可以<br>暂时性死区，let和const声明的变量不能在声明前被使用</p><p>实现const的关键在于Object.defineProperty()这个API，这个API用于在一个对象上增加或修改属性。通过配置属性描述符，可以精确地控制属性行为。Object.defineProperty() 接收三个参数：<br><code>Object.defineProperty(obj, key, desc)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> __const = <span class="function"><span class="keyword">function</span> <span class="title">__const</span> (<span class="params">data, value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.data = value <span class="comment">// 把要定义的data挂载到window下，并赋值value</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, data, &#123; <span class="comment">// 利用Object.defineProperty的能力劫持当前对象，并修改其属性描述符</span></span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function (data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data !== value) &#123; <span class="comment">// 当要对当前属性进行赋值时，则抛出错误！</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Assignment to constant variable.'</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">__const(<span class="string">'a'</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="keyword">delete</span> a</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure><h2 id="mock-Promise-精简，重点是明白其中异步调用原理）"><a href="#mock-Promise-精简，重点是明白其中异步调用原理）" class="headerlink" title="mock Promise(精简，重点是明白其中异步调用原理）"></a>mock Promise(精简，重点是明白其中异步调用原理）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line"><span class="keyword">this</span>.cbs = [];</span><br><span class="line"><span class="keyword">this</span>.data = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">var</span> resolve = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.data = data</span><br><span class="line"><span class="keyword">this</span>.cbs.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(data))</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">executor(resolve)</span><br><span class="line">&#125;</span><br><span class="line">then(onResolved, onReject) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.cbs.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> data = onResolved(<span class="keyword">this</span>.data)</span><br><span class="line">        <span class="keyword">if</span> (data <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            data.then(resolve)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试案例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end line'</span>)</span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">//  end line</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure><h2 id="mock-Promise-all"><a href="#mock-Promise-all" class="headerlink" title="mock Promise.all"></a>mock Promise.all</h2><p>Promise.all() 方法会将多个 Promise 实例组合成一个新的 Promise 实例<br>1.传入的参数必须可迭代<br>2.传入的实例不一定是Promise,必须再用Promise.resolve()包装下<br>3.组合后的Promise实例，只有当每个包含的Promise实例都解决才去解决(fulFilled),当然如果有一个Promise实例被拒绝的话,则合成的Promise会拒绝(rejected)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mock</span></span><br><span class="line"><span class="built_in">Promise</span>.myAll = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> [i, item] <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(item).then(</span><br><span class="line">        data =&gt; &#123;</span><br><span class="line">          res.push(data)</span><br><span class="line">          <span class="keyword">if</span> (i === arr.length <span class="number">-1</span>) &#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">          &#125;    </span><br><span class="line">        &#125;,</span><br><span class="line">        error =&gt; &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve( <span class="number">1</span> );</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve( <span class="built_in">Promise</span>.resolve( <span class="string">'111'</span> ) );</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="string">'error'</span>)</span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(</span><br><span class="line">  res =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">Promise</span>.myAll([p1, p2, p3]).then(</span><br><span class="line">  res =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res,<span class="string">'my'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(err, <span class="string">'muy'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="Mock-Promise-any"><a href="#Mock-Promise-any" class="headerlink" title="Mock Promise.any"></a>Mock Promise.any</h2><p>Promise.all的反向操作，只有当每个包含的Promise实例都拒绝了，合成的promise才会拒绝rejected</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.myAny = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [index, item] <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(item).then(</span><br><span class="line">        (data) =&gt; &#123;</span><br><span class="line">          resolve(data)</span><br><span class="line">        &#125;,</span><br><span class="line">        (err) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (index === arr.length <span class="number">-1</span>) &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">          &#125;</span><br><span class="line">          res.push(err)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mock-Promise-race"><a href="#mock-Promise-race" class="headerlink" title="mock Promise.race"></a>mock Promise.race</h2><p>只要有一个请求有响应值，请求就会结束，返回有响应的那个promise结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.myAny = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [index, item] <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(item).then(</span><br><span class="line">        success: <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">          resolve(data)</span><br><span class="line">        &#125;,</span><br><span class="line">        error: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mock-Promise-allSettled-es7"><a href="#mock-Promise-allSettled-es7" class="headerlink" title="mock Promise.allSettled(es7+)"></a>mock Promise.allSettled(es7+)</h2><p>Promise.allSettled() 方法也是返回一个合成的 Promise，不过只有等到所有 Promise 实例都返回结果落定时，不管是解决(fulfilled)还是拒绝(rejected)，合成的 Promise 才会结束。一旦结束，状态总是 fulfilled。</p><p>等所有的成功和失败的结果都有了才会返回promise结果,成功的时候返回<code>[{value: &#39;&#39;, status: &#39;fifulled&#39;}]</code>，失败的时候返回<code>[{reason: &#39;&#39;, status: &#39;rejected&#39;}]</code>，组成一个失败和成功的组合的promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种实现</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.myAllSettled = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resove, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [index, item] <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(item).then(</span><br><span class="line">        data =&gt; &#123;</span><br><span class="line">          res[i] = &#123;</span><br><span class="line">            value: data,</span><br><span class="line">            status: <span class="string">'fifulled'</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (index + <span class="number">1</span> === arr.length) &#123;</span><br><span class="line">            resove(res)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        error =&gt; &#123;</span><br><span class="line">          res[i] = &#123;</span><br><span class="line">            value: error,</span><br><span class="line">            status: <span class="string">'rejected'</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (index + <span class="number">1</span> === arr.length) &#123;</span><br><span class="line">            resove(res)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种实现方式</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.myAllSettled = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> PromiseAll = [...arr]</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(PromiseAll.map(e) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(e).then(</span><br><span class="line">      data =&gt; &#123;<span class="attr">status</span>: <span class="string">'fulfilled'</span>, <span class="attr">value</span>: data&#125;,</span><br><span class="line">      err  =&gt; &#123;<span class="attr">status</span>: <span class="string">'rejected'</span>, <span class="attr">reason</span>: err&#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个并发控制器"><a href="#实现一个并发控制器" class="headerlink" title="实现一个并发控制器"></a>实现一个并发控制器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPool</span>(<span class="params">limit, arr, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [] <span class="comment">// 最终存放的promise的数组</span></span><br><span class="line">    <span class="keyword">let</span> executing = [] <span class="comment">// 正在执行的promise</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">      <span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> fn.call(<span class="keyword">this</span>, i))</span><br><span class="line">      res.push(p1)</span><br><span class="line">      <span class="keyword">if</span> (limit &lt;= arr.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> cur = <span class="built_in">Promise</span>.resolve(p1).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> executing.splice(executing.indeOf(cur),<span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        executing.push(cur)</span><br><span class="line">        <span class="keyword">if</span> (executing.length &gt;= limit) &#123;</span><br><span class="line">          <span class="keyword">await</span> <span class="built_in">Promise</span>.race(executing)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(res)</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> timeFn = <span class="function"><span class="params">i</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(i), i)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>]</span><br><span class="line">asyncPool(<span class="number">2</span>, arr2, <span class="literal">null</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`res`</span>, res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="mock-async"><a href="#mock-async" class="headerlink" title="mock async"></a>mock async</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getData = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"data"</span>), <span class="number">1000</span>))</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> getData()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'data: '</span>, data);</span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">await</span> getData()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'data2: '</span>, data2);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'success'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样的一个函数 应该再1秒后打印data 再过一秒打印data2 最后打印success</span></span><br><span class="line">test().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure><p>手写async(22行)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn 传入的generator生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncGenerator</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> gen = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">key, arg</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">let</span> generatorResult</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                generatorResult = gen[key](arg)</span><br><span class="line">              &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                reject(e)</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">const</span> &#123;value, done&#125; = generatorResult;</span><br><span class="line">              <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                <span class="keyword">return</span> resolve(value)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(value).then(</span><br><span class="line">                  val =&gt; step(<span class="string">'next'</span>, val),</span><br><span class="line">                  err =&gt; step(<span class="string">'throw'</span>, err)</span><br><span class="line">                )</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step(<span class="string">'next'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getData = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'data'</span>), <span class="number">1000</span>))</span><br><span class="line"><span class="keyword">var</span> test = asyncGenerator(</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">testG</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">yield</span> getData()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'data1: '</span>, data);</span><br><span class="line">    <span class="keyword">const</span> data2 = <span class="keyword">yield</span> getData()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'data2: '</span>, data2);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'success'</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">test().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res, <span class="string">'cpp'</span>))</span><br></pre></td></tr></table></figure><h2 id="封装一个类使对象可以被for-of遍历"><a href="#封装一个类使对象可以被for-of遍历" class="headerlink" title="封装一个类使对象可以被for of遍历"></a>封装一个类使对象可以被for of遍历</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MakeIterator</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(obj) &#123;</span><br><span class="line"><span class="keyword">this</span>.obj = obj;</span><br><span class="line"><span class="keyword">this</span>.len = <span class="built_in">Object</span>.keys(obj).length;</span><br><span class="line"><span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="built_in">Symbol</span>.iterator]() &#123;<span class="keyword">return</span> <span class="keyword">this</span>;&#125;</span><br><span class="line">next() &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.index &lt; <span class="keyword">this</span>.len) &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">value: <span class="keyword">this</span>.obj[<span class="keyword">this</span>.index ++],</span><br><span class="line">done: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">value: <span class="literal">undefined</span>,</span><br><span class="line">done: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">// 注意对象的格式 类数组</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'wmh'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'cpp'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'chendap'</span>,</span><br><span class="line">length: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">of</span> <span class="keyword">new</span> MakeIterator(obj)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h2><p>一句话介绍： bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。</p><blockquote><p>返回一个新函数<br>阔以传入多个参数<br>难点主要是在于：一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.protptyoe.mockBind = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...rest</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> fbound =  <span class="function"><span class="keyword">function</span>(<span class="params">...arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [...rest, ...arg];</span><br><span class="line">    <span class="comment">// 构造函数调用 为 true 的时候 this 指向实例 也就是通过new方式调用,因为下面一句 `fbound.prototype = this.prototype;`，已经修改了 fbound.prototype 为 绑定函数的 prototype</span></span><br><span class="line">    <span class="comment">// 普通函数调用 为false 的时候 this 指向window self指向绑定函数，此时结果为 false，当结果为 false 的时候，this 指向绑定的 context</span></span><br><span class="line">    self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> self ? <span class="keyword">this</span> : context, args)</span><br><span class="line">  &#125;</span><br><span class="line">  fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">  fbound.prototype = <span class="keyword">new</span> fNOP()</span><br><span class="line">  <span class="keyword">return</span> fbound</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.value); <span class="comment">// undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.mockBind = mockBind;</span><br><span class="line"><span class="keyword">var</span> sayFnMock = sayName.mockBind(obj2, <span class="string">'wmh'</span>)</span><br><span class="line"><span class="keyword">var</span> resMock = <span class="keyword">new</span> sayFnMock(<span class="string">'菜鸟Mock'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(resMock, <span class="string">'Mock的bind返回的值'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>感谢<a href="https://segmentfault.com/a/1190000009271416" target="_blank" rel="noopener">冴羽大佬提供的高水平文章-JavaScript深入之bind的模拟实现</a></p></blockquote><h2 id="Apply"><a href="#Apply" class="headerlink" title="Apply"></a>Apply</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.mockApply = <span class="function"><span class="keyword">function</span>(<span class="params">context, args</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(); <span class="comment">// 独一无二的值</span></span><br><span class="line">context[sym] = <span class="keyword">this</span>;</span><br><span class="line"><span class="comment">// 执行函数;</span></span><br><span class="line">  <span class="comment">// const result = context[sym](...args);</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">eval</span>(<span class="string">'context.sym(...args)'</span>)</span><br><span class="line"><span class="keyword">delete</span> context[sym]</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'cpp'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  alert(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.mockApply = mockApply</span><br><span class="line">sayName.mockApply(obj, [<span class="string">'菜鸟'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟实现call</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.mockCall = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn(...args)'</span>);</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>step one: 创建一个空对象 obj;<br>step two: 将空对象的隐式原型（proto）指向构造函数的prototype。<br>step three: 使用 apply 改变 this 的指向<br>step four: 如果无返回值或者返回一个非对象值，则将 obj 返回作为新对象；如果返回值是一个新对象的话那么直接返回该对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockNew</span>(<span class="params">con, ...rest</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(con.prototype) || <span class="built_in">window</span>; <span class="comment">// step one two</span></span><br><span class="line"><span class="keyword">let</span> res = con.apply(obj, rest) <span class="comment">// step three</span></span><br><span class="line"><span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? res : obj; <span class="comment">// step four</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SayName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">SayName.prototype.emit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> SayName(<span class="string">'cpp'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(test)</span><br><span class="line"><span class="keyword">var</span> test1 = mockNew(SayName, <span class="string">'cpp'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(test1)</span><br></pre></td></tr></table></figure><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>判断一个实例是否是其父类或者祖先类型的实例。<br>instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype查找失败，返回 false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockInstanceof</span>(<span class="params">target, origin</span>) </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(target) &#123;</span><br><span class="line"><span class="keyword">if</span>(target.__proto__ === origin.prototype) &#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;</span><br><span class="line">target = target.__proto__</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// true</span></span><br><span class="line">mockInstanceof([<span class="number">1</span>,<span class="number">2</span>], <span class="built_in">Array</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="curry-函数柯里化"><a href="#curry-函数柯里化" class="headerlink" title="curry 函数柯里化"></a>curry 函数柯里化</h2><h3 id="第一种-参数固定-有局限，形参个数固定"><a href="#第一种-参数固定-有局限，形参个数固定" class="headerlink" title="第一种 参数固定(有局限，形参个数固定)"></a>第一种 参数固定(有局限，形参个数固定)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> judge = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length === fn.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> judge(...args, ...arg)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> judge</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> a + b + c;</span><br><span class="line"><span class="keyword">var</span> addCurry = curry(add)</span><br><span class="line">addCurry(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) <span class="comment">// 必须是三个完整的参数</span></span><br></pre></td></tr></table></figure><h3 id="第二种，参数不固定-自由灵活"><a href="#第二种，参数不固定-自由灵活" class="headerlink" title="第二种，参数不固定(自由灵活)"></a>第二种，参数不固定(自由灵活)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = []</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">temp</span>(<span class="params">...rest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rest.length) &#123;</span><br><span class="line">      arr.push(...rest);</span><br><span class="line">      <span class="keyword">return</span> temp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> val = fn.apply(<span class="keyword">this</span>, arr)</span><br><span class="line">      arr = []</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> addFn = curry(add)</span><br><span class="line"><span class="keyword">var</span> test = addFn(<span class="number">3</span>)(<span class="number">1</span>)(<span class="number">5</span>)(<span class="number">44</span>)() <span class="comment">// 9 参数不固定</span></span><br></pre></td></tr></table></figure><h3 id="实现一个方法进行求和"><a href="#实现一个方法进行求和" class="headerlink" title="实现一个方法进行求和"></a>实现一个方法进行求和</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = foo(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line">f1.getValue()</span><br></pre></td></tr></table></figure><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> target = <span class="function">(<span class="params">...arg</span>) =&gt;</span> foo(...[...args, ...arg])</span><br><span class="line">  target.getValue = <span class="function"><span class="params">()</span> =&gt;</span> args.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>因为ECMAScript函数的参数是由零或多个值的类数组表示的，没有函数签名（接收的参数的类型和数量），真正的重载是不能做到的。<br>在JavaScript中，同一个作用域，出现两个名字一样的函数，后面的会覆盖前面的，所以 JavaScript 没有真正意义的重载。<br>但是我们可以通过检查传入函数中参数的类型和数量来执行不同的操作，从而实现“函数重载”。<br>核心思想: 通过判断arguments 对象的 length 属性来确定有几个参数，然后执行什么操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addMethod</span>(<span class="params">obj, name, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> old = obj[name]</span><br><span class="line">  obj[name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arg = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>); <span class="comment">// 转换成array</span></span><br><span class="line">    <span class="keyword">if</span>(fn.length === arg.length) &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, arg)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</span><br><span class="line">      old.apply(<span class="keyword">this</span>, arg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">userName</span>: <span class="string">'bear鲍的小小熊'</span>&#125;</span><br><span class="line">addMethod(person, <span class="string">'show'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.userName + <span class="string">'----&gt;'</span> + <span class="string">'show1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">addMethod(person, <span class="string">'show'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.userName + <span class="string">'----&gt;'</span> + str)</span><br><span class="line">&#125;)</span><br><span class="line">addMethod(person, <span class="string">'show'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.userName + <span class="string">'----&gt;'</span> + (a + b))</span><br><span class="line">&#125;)</span><br><span class="line">person.show()  </span><br><span class="line">person.show(<span class="string">'bkl'</span>)</span><br><span class="line">person.show(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><h2 id="防抖debounce"><a href="#防抖debounce" class="headerlink" title="防抖debounce"></a>防抖debounce</h2><p>核心：采用异步线程setTimeout进行延迟执行，多次触发之后执行一次，典型场景就是防止多次提交的按钮</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> timer</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...arg</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line"><span class="keyword">if</span>(timer) &#123;</span><br><span class="line">clearTimeout(timer)</span><br><span class="line">&#125;</span><br><span class="line">timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">fn.apply(that, arg)</span><br><span class="line">&#125;, wait)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流throttle"><a href="#节流throttle" class="headerlink" title="节流throttle"></a>节流throttle</h2><p>核心：每间隔多少秒执行一次，使之频率变低，典型场景：滚动事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件戳版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> pre = <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"><span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line"><span class="keyword">if</span>(now - pre &gt; wait) &#123;</span><br><span class="line">fn.apply(that, args)</span><br><span class="line">pre = now</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h2 id="Mock-webpack-模拟webpack打包构建过程"><a href="#Mock-webpack-模拟webpack打包构建过程" class="headerlink" title="Mock webpack,模拟webpack打包构建过程"></a>Mock webpack,模拟webpack打包构建过程</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="comment">// es6 code transform ast</span></span><br><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">'@babel/parser'</span>)</span><br><span class="line"><span class="comment">// traverse 依赖路径</span></span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">'@babel/traverse'</span>)</span><br><span class="line"><span class="comment">// paser transformFromAst es5代码</span></span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'@babel/core'</span>)</span><br><span class="line"><span class="keyword">const</span> getModuleInfo = <span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> body = fs.readFileSync(file, <span class="string">'utf-8'</span>)</span><br><span class="line">  <span class="keyword">const</span> ast = parser.parse(body, &#123;</span><br><span class="line">    sourceType: <span class="string">'module'</span> <span class="comment">// 解析的是es模块 default sourceType: 'script'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 收集依赖路径 win10系统下</span></span><br><span class="line">  <span class="keyword">const</span> deps = &#123;&#125;</span><br><span class="line">  traverse.default(ast, &#123;</span><br><span class="line">    ImportDeclaration(&#123;node&#125;) &#123;</span><br><span class="line">      <span class="keyword">const</span> dirname = path.dirname(file)</span><br><span class="line">      <span class="keyword">const</span> depsPath = node.source.value</span><br><span class="line">      <span class="keyword">const</span> abspath = <span class="string">'./'</span> + path.join(dirname, depsPath)</span><br><span class="line">      deps[depsPath] = abspath;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> &#123;code&#125; = babel.transformFromAst(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">    presets: [<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    file,</span><br><span class="line">    deps,</span><br><span class="line">    code,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解析模块深层次遍历模块 输出字符串</span></span><br><span class="line"><span class="keyword">const</span> parseModules = <span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> entry = getModuleInfo(file);</span><br><span class="line">  <span class="keyword">const</span> temp = [entry]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; temp.length; i ++) &#123;</span><br><span class="line">    <span class="keyword">const</span> deps = temp[i].deps;</span><br><span class="line">    <span class="keyword">if</span> (deps) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> deps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deps.hasOwnProperty(key)) &#123;</span><br><span class="line">          temp.push(getModuleInfo(deps[key]))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存储格式 add.js: &#123;deps: '', code: ''&#125;</span></span><br><span class="line">  <span class="keyword">const</span> depsGraph = &#123;&#125;</span><br><span class="line">  temp.forEach(<span class="function">(<span class="params">moduleInfo</span>) =&gt;</span> &#123;</span><br><span class="line">    depsGraph[moduleInfo.file] = &#123;</span><br><span class="line">      deps: moduleInfo.deps,</span><br><span class="line">      code: moduleInfo.code,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> depsGraph</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出bundle</span></span><br><span class="line"><span class="keyword">const</span> bundle = <span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> depsGraph = <span class="built_in">JSON</span>.stringify(parseModules(file));</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`(function (graph) &#123;</span></span><br><span class="line"><span class="string">    function require(file) &#123;</span></span><br><span class="line"><span class="string">      var exports = &#123;&#125;;</span></span><br><span class="line"><span class="string">      function absRequire(relPath) &#123;</span></span><br><span class="line"><span class="string">        console.log(relPath, 'relPath')</span></span><br><span class="line"><span class="string">        return require(graph[file].deps[relPath])</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      (function(require, exports, code)&#123;</span></span><br><span class="line"><span class="string">        console.log(code)</span></span><br><span class="line"><span class="string">        eval(code)</span></span><br><span class="line"><span class="string">      &#125;)(absRequire, exports, graph[file].code)</span></span><br><span class="line"><span class="string">      return exports</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    require('<span class="subst">$&#123;file&#125;</span>')</span></span><br><span class="line"><span class="string">  &#125;)(<span class="subst">$&#123;depsGraph&#125;</span>)`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照路径生成文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">emit</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> content = bundle(path)</span><br><span class="line">  <span class="keyword">const</span> distPath = <span class="string">'./dist'</span>;</span><br><span class="line">  <span class="keyword">const</span> bundlePath = <span class="string">'./dist/bundle.js'</span></span><br><span class="line">  fs.unlinkSync(bundlePath);</span><br><span class="line">  fs.rmdirSync(distPath);</span><br><span class="line">  fs.mkdirSync(distPath)</span><br><span class="line">  fs.writeFileSync(bundlePath, content)</span><br><span class="line">&#125;;</span><br><span class="line">emit(<span class="string">'./src/index.js'</span>)</span><br></pre></td></tr></table></figure><h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><p>手写一个给打包文件头部注入作者和描述信息的webpack plugin<br>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInfoPlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options = &#123;</span><br><span class="line">    author: <span class="string">'cpp'</span>,</span><br><span class="line">    description: <span class="string">'plugin name'</span></span><br><span class="line">  &#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.options = options</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> pluginName() &#123;</span><br><span class="line">    <span class="keyword">return</span> MyInfoPlugin.name</span><br><span class="line">  &#125;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    compiler.hooks.emit.tapPromise(</span><br><span class="line">      <span class="keyword">this</span>.pluginName,</span><br><span class="line">      <span class="keyword">async</span> (compilation) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> options = <span class="keyword">this</span>.options;</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> assets = compilation.assets;</span><br><span class="line">          <span class="built_in">Object</span>.keys(assets).forEach(<span class="function">(<span class="params">asset</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> source = assets[asset].source();</span><br><span class="line">            <span class="keyword">let</span> info = []</span><br><span class="line">            <span class="keyword">if</span> (options.author) &#123;</span><br><span class="line">              info.push(<span class="string">`@Author: <span class="subst">$&#123;options.author&#125;</span>`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (options.description) &#123;</span><br><span class="line">              info.push(<span class="string">`@Description: <span class="subst">$&#123;options.description&#125;</span>`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (info.length) &#123;</span><br><span class="line">              info.push(<span class="string">`@Date: <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span>`</span>)</span><br><span class="line">              source = <span class="string">`/*\n  <span class="subst">$&#123;info.join(<span class="string">'\n  '</span>)&#125;</span>\n*/\n <span class="subst">$&#123;source&#125;</span>`</span></span><br><span class="line">            &#125;</span><br><span class="line">            compilation.assets[asset].source = <span class="function"><span class="params">()</span> =&gt;</span> source;</span><br><span class="line">            compilation.assets[asset].size = <span class="function"><span class="params">()</span> =&gt;</span> source.size;</span><br><span class="line">          &#125;)</span><br><span class="line">          resolve(<span class="string">'Success'</span>)</span><br><span class="line">          reject(<span class="string">'MyInfoPlugin 插件出问题咯'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = MyInfoPlugin</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build\webpack.common.js</span></span><br><span class="line"><span class="keyword">const</span> MyInfoPlugin = <span class="built_in">require</span>(<span class="string">'../plugin/MyInfoPlugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MyInfoPlugin(&#123;</span><br><span class="line">      author: <span class="string">'chendapeng'</span>,</span><br><span class="line">      description: <span class="string">'Test test description'</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</span><br><span class="line"><span class="keyword">const</span> validateOptions = <span class="built_in">require</span>(<span class="string">'schema-utils'</span>);</span><br><span class="line"><span class="comment">// 定义loader里的options选项数据结构</span></span><br><span class="line"><span class="keyword">const</span> schema = &#123;</span><br><span class="line">  type: <span class="string">'object'</span>,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">      type: <span class="string">'string'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this指向当前的Loader Context,不是webpack实例也不是compilation</span></span><br><span class="line">  <span class="keyword">const</span> options = loaderUtils.getOptions(<span class="keyword">this</span>)</span><br><span class="line">  validateOptions(schema, options, <span class="string">'Example Loader'</span>)</span><br><span class="line">  <span class="keyword">return</span> source</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试<br>三种使用方式，推荐resolveLoader种的alias模式以及匹配(test)单个 loader还有常用的npm link软连接的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    resolveLoader: &#123;</span><br><span class="line">      alias: &#123;</span><br><span class="line">        <span class="string">'async-loader'</span>: path.resolve(__dirname, <span class="string">'../loader/async-loader.js'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">          exclude: <span class="string">'/node_modules/'</span>,</span><br><span class="line">          use: [</span><br><span class="line">            &#123;</span><br><span class="line">              loader: <span class="string">'async-loader'</span>,</span><br><span class="line">              options: &#123;</span><br><span class="line">                name: <span class="string">'test my loader cpp'</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="splitChunks"><a href="#splitChunks" class="headerlink" title="splitChunks"></a>splitChunks</h2><p>Webpack中一个提取或分离代码的插件，主要作用是提取公共代码，防止代码被重复打包，拆分过大的js文件，合并零散的js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    configureWebpack:<span class="function"><span class="params">config</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            optimization: &#123;</span><br><span class="line">                splitChunks: &#123;</span><br><span class="line">                    chunks: <span class="string">'async'</span>,  <span class="comment">// 默认是async：只提取异步加载的模块出来打包到一个文件中。 异步加载的模块：通过import('xxx')或require(['xxx'],() =&gt;&#123;&#125;)加载的模块</span></span><br><span class="line">                    minSize: <span class="number">30000</span>, <span class="comment">// 规定被提取的模块在压缩前的大小最小值，单位为字节，默认为30000，只有超过了30000字节才会被提取</span></span><br><span class="line">                    maxSize: <span class="number">0</span>, <span class="comment">// 把提取出来的模块打包生成的文件大小不能超过maxSize值，如果超过了，要对其进行分割并打包生成新的文件。单位为字节，默认为0，表示不限制大小</span></span><br><span class="line">                    minChunks: <span class="number">1</span>, <span class="comment">// 表示要被提取的模块最小被引用次数，引用次数超过或等于minChunks值，才能被提取。</span></span><br><span class="line">                    maxAsyncRequests: <span class="number">6</span>, <span class="comment">// 最大的按需(异步)加载次数，默认为 6</span></span><br><span class="line">                    maxInitialRequests: <span class="number">4</span>, <span class="comment">// 打包后的入口文件加载时，还能同时加载js文件的数量（包括入口文件），默认为4</span></span><br><span class="line">                    automaticNameDelimiter: <span class="string">'~'</span>, <span class="comment">// 打包生成的js文件名的分割符，默认为~</span></span><br><span class="line">                    <span class="comment">// 核心重点 配置提取模块的方案。里面每一项代表一个提取模块的方案。下面是cacheGroups每项中特有的选项，其余选项和外面一致，若cacheGroups每项中有，就按配置的，没有就使用外面配置的</span></span><br><span class="line">                    cacheGroups: &#123; </span><br><span class="line">                        vendors: &#123;</span><br><span class="line">                            name: <span class="string">`chunk-vendors`</span>,</span><br><span class="line">                            test: <span class="regexp">/[\\/]node_modules[\\/]/</span>, <span class="comment">// 用来匹配要提取的模块的资源路径或名称。值是正则或函数</span></span><br><span class="line">                            priority: <span class="number">-10</span>, <span class="comment">// 方案的优先级，值越大表示提取模块时优先采用此方案。默认值为0</span></span><br><span class="line">                            chunks: <span class="string">'initial'</span>,</span><br><span class="line">                            enfore: <span class="literal">false</span> <span class="comment">// 为true时，忽略minSize，minChunks，maxAsyncRequests和maxInitialRequests外面选项</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        common: &#123;</span><br><span class="line">                            name: <span class="string">`chunk-common`</span>,</span><br><span class="line">                            minChunks: <span class="number">2</span>,</span><br><span class="line">                            priority: <span class="number">-20</span>, </span><br><span class="line">                            chunks: <span class="string">'initial'</span>,</span><br><span class="line">                            reuseExistingChunk: <span class="literal">true</span> <span class="comment">// true/false。为true时，如果当前要提取的模块，在已经在打包生成的js文件中存在，则将重用该模块，而不是把当前要提取的模块打包生成新的js文件</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Vue-cli3中的默认配置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    configureWebpack:<span class="function"><span class="params">config</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            optimization: &#123;</span><br><span class="line">                splitChunks: &#123;</span><br><span class="line">                    chunks: <span class="string">'async'</span>,</span><br><span class="line">                    minSize: <span class="number">30000</span>,</span><br><span class="line">                    maxSize: <span class="number">0</span>,</span><br><span class="line">                    minChunks: <span class="number">1</span>,</span><br><span class="line">                    maxAsyncRequests: <span class="number">6</span>,</span><br><span class="line">                    maxInitialRequests: <span class="number">4</span>,</span><br><span class="line">                    automaticNameDelimiter: <span class="string">'~'</span>,</span><br><span class="line">                    cacheGroups: &#123;</span><br><span class="line">                        vendors: &#123;</span><br><span class="line">                            name: <span class="string">`chunk-vendors`</span>,</span><br><span class="line">                            test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">                            priority: <span class="number">-10</span>,</span><br><span class="line">                            chunks: <span class="string">'initial'</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        common: &#123;</span><br><span class="line">                            name: <span class="string">`chunk-common`</span>,</span><br><span class="line">                            minChunks: <span class="number">2</span>,</span><br><span class="line">                            priority: <span class="number">-20</span>,</span><br><span class="line">                            chunks: <span class="string">'initial'</span>,</span><br><span class="line">                            reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/152097785" target="_blank" rel="noopener">Webpack之SplitChunks插件用法详解</a></li></ul><h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h2 id="vue-instance"><a href="#vue-instance" class="headerlink" title="vue instance"></a>vue instance</h2><h3 id="vue-模板编译，正则解析"><a href="#vue-模板编译，正则解析" class="headerlink" title="vue 模板编译，正则解析"></a>vue 模板编译，正则解析</h3><p>输入: render(<code>-</code>, {msg: ‘chendap’, name: ‘wmh’})<br>输出: ‘chendap-wmh’</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">template, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span></span><br><span class="line">  <span class="keyword">if</span> (reg.test(template)) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="built_in">RegExp</span>.$<span class="number">1.</span>trim() <span class="comment">// name = reg.exec(template)[1]</span></span><br><span class="line">    template = template.replace(reg, data[name])</span><br><span class="line">    <span class="keyword">return</span> render(template, data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> template</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">render(<span class="string">`&#123;&#123;msg&#125;&#125;-&#123;&#123;name&#125;&#125;`</span>, &#123;<span class="attr">msg</span>: <span class="string">'chendap'</span>, <span class="attr">name</span>: <span class="string">'wmh'</span>&#125;) <span class="comment">// chendap-wmh</span></span><br></pre></td></tr></table></figure><blockquote><p>RegExp 是javascript中的一个内置对象。为正则表达式。RegExp.$1是RegExp的一个属性,指的是与正则表达式匹配的第一个 子匹配(以括号为标志)字符串，以此类推，RegExp.$2，RegExp.$3，..RegExp.$99总共可以有99个匹配</p></blockquote><h3 id="实现一个-Observer"><a href="#实现一个-Observer" class="headerlink" title="实现一个 Observer"></a>实现一个 Observer</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.data = data</span><br><span class="line">  <span class="keyword">this</span>.walk(data)</span><br><span class="line">&#125;</span><br><span class="line">Observer.prototype = &#123;</span><br><span class="line">  walk(data) &#123;</span><br><span class="line">    <span class="comment">//遍历,对这个对象的所有属性都进行监听</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.defineReactive(data, key, data[key])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  defineReactive(data, key, val) &#123;</span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="keyword">let</span> childObj = observe(val)</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>: function getter() &#123;</span><br><span class="line">        <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">          <span class="comment">// 在这里添加一个订阅者</span></span><br><span class="line">          <span class="built_in">console</span>.log(Dep.target)</span><br><span class="line">          dep.addSub(Dep.target)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>: function setter() &#123;</span><br><span class="line">        <span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        val = newVal</span><br><span class="line">        childObj = observe(newVal)</span><br><span class="line">        dep.notify()</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value, vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!value || <span class="keyword">typeof</span> value !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observer(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消息订阅器Dep，订阅器Dep主要负责收集订阅者，然后在属性变化的时候执行对应订阅者的更新函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subs = []</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;,</span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function">(<span class="params">sub</span>) =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">Dep.target = <span class="literal">null</span></span><br></pre></td></tr></table></figure><h3 id="实现一个-Watcher"><a href="#实现一个-Watcher" class="headerlink" title="实现一个 Watcher"></a>实现一个 Watcher</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm, exp, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.cb = cb</span><br><span class="line">  <span class="keyword">this</span>.vm = vm</span><br><span class="line">  <span class="keyword">this</span>.exp = exp</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="keyword">this</span>.get() <span class="comment">// 将自己添加到订阅器的操作</span></span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="keyword">this</span>.run()</span><br><span class="line">  &#125;,</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.vm.data[<span class="keyword">this</span>.exp]</span><br><span class="line">    <span class="keyword">let</span> oldVal = <span class="keyword">this</span>.value</span><br><span class="line">    <span class="keyword">if</span> (value !== oldVal) &#123;</span><br><span class="line">      <span class="keyword">this</span>.value = value</span><br><span class="line">      <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    Dep.target = <span class="keyword">this</span> <span class="comment">// 缓存自己</span></span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.vm.data[<span class="keyword">this</span>.exp] <span class="comment">// 强制执行监听器里的get函数</span></span><br><span class="line">    Dep.target = <span class="literal">null</span> <span class="comment">// 释放自己</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><h1 id="tool"><a href="#tool" class="headerlink" title="tool"></a>tool</h1><h2 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a>Array.prototype.map()</h2><p>1.不改变原数组<br>2.回调参数以及返回值如何处理<br>3.context 可选。对象作为该执行回调时使用，传递给函数，用作”this”的值。如果省略了 thisValue，或者传入 null、undefined，那么回调函数的 this 为全局对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">'cpp'</span>&#125;</span><br><span class="line"><span class="built_in">Array</span>.prototype.mockMap = <span class="function"><span class="keyword">function</span>(<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">var</span> mapArr = []</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; arr.length; i ++) &#123;</span><br><span class="line">    mapArr.push(fn.call(context, arr[i], i, <span class="keyword">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mapArr</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">var</span> test = arr.mockMap(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="string">'this指向obj'</span>)</span><br><span class="line">  <span class="keyword">return</span> e *<span class="number">2</span></span><br><span class="line">&#125;, obj)</span><br></pre></td></tr></table></figure><h2 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter()"></a>Array.prototype.filter()</h2><p>返回过滤后的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.Filter = <span class="function"><span class="keyword">function</span>(<span class="params">fn, context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> newArr = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i <span class="keyword">in</span> arr)&#123; <span class="comment">//判断当前的index是否已初始化</span></span><br><span class="line">            <span class="keyword">if</span>(fn.call(context, arr[i], i, arr))&#123;</span><br><span class="line">                newArr.push(arr[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Array-prototype-some"><a href="#Array-prototype-some" class="headerlink" title="Array.prototype.some()"></a>Array.prototype.some()</h2><p>一旦有一个值满足条件，即能返回true,否则返回false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.mySome = <span class="function"><span class="keyword">function</span>(<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">      <span class="keyword">if</span> (fn.call(context, arr[i], i, arr)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">12</span>]</span><br><span class="line"><span class="keyword">var</span> res = arr.mySome(<span class="function"><span class="params">e</span> =&gt;</span> e &gt; <span class="number">3</span>)</span><br><span class="line"> <span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure><h2 id="Array-prototype-find"><a href="#Array-prototype-find" class="headerlink" title="Array.prototype.find()"></a>Array.prototype.find()</h2><p>返回当前满足条件的那个数组项</p><h2 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce()"></a>Array.prototype.reduce()</h2><ul><li>初始值传不传 差距蛮大</li><li>返回值如何处理<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.mockReduce = <span class="function"><span class="keyword">function</span>(<span class="params">fn, initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">var</span> res, startIndex</span><br><span class="line">  res = initialValue ? initialValue : arr[<span class="number">0</span>];</span><br><span class="line">  startIndex = initialValue ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = startIndex; i &lt; arr.length; i ++) &#123;</span><br><span class="line">    res = fn.call(<span class="literal">null</span>, res, arr[i], i, <span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add2</span>(<span class="params">...arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.mockReduce(<span class="function">(<span class="params">a, b, i, ar</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, i, arr)</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">add2(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure></li></ul><h2 id="Array-prototype-flat"><a href="#Array-prototype-flat" class="headerlink" title="Array.prototype.flat()"></a>Array.prototype.flat()</h2><p>多维数组降到一维数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种 栈实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [...arr]</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> next = stack.pop() <span class="comment">// 栈尾</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(next)) &#123;</span><br><span class="line">      stack.push(...next)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.push(next)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.reverse()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.redece(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prev.concat(<span class="built_in">Array</span>.isArray(cur) ? flatten(cur) : cur)</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三种 迭代和展开运算符</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(arr.some(<span class="built_in">Array</span>.isArray)) &#123;</span><br><span class="line">    arr = [].concat(...arr)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">flatten([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>,<span class="number">5</span>], <span class="number">6</span>])</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// First</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">00</span>, <span class="number">99</span>,<span class="number">99</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!prev.includes(cur)) &#123;</span><br><span class="line">      prev.push(cur)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test = unique(arr)</span><br><span class="line"><span class="built_in">console</span>.log(tes) <span class="comment">// [1, 2, 3, 4, 00, 99]</span></span><br><span class="line"><span class="comment">// Second</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> arr.indexOf(item) === index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="URLSearchParams-url参数解析"><a href="#URLSearchParams-url参数解析" class="headerlink" title="URLSearchParams url参数解析"></a>URLSearchParams url参数解析</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> URL(<span class="string">'http://ccing.com/develop.html?systemId=111&amp;idc=cc'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParams</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams(url.search); <span class="comment">// 主要是url里的search属性</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> ([k, v] <span class="keyword">of</span> params.entries()) &#123;</span><br><span class="line">obj[k] = v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test = getParams(str)</span><br><span class="line"><span class="built_in">console</span>.log(test)<span class="comment">// &#123;systemId: '', idc:''&#125;</span></span><br></pre></td></tr></table></figure><p>存在缺陷，如果url里含有hash值，会优先解析hash参数，第二种</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'http://ccuning.com/d.html#/dashboard?reportId=1118&amp;versionId=1.0&amp;systemId=111'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParams</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> params = url.split(<span class="string">'?'</span>).pop().split(<span class="string">'#'</span>).shift().split(<span class="string">'&amp;'</span>);</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> ([k, v] <span class="keyword">of</span> params.entries()) &#123;</span><br><span class="line"><span class="keyword">const</span> [key, val] = v.split(<span class="string">'='</span>)</span><br><span class="line">obj[key] = val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test = getParams(str)</span><br><span class="line"><span class="built_in">console</span>.log(test)</span><br></pre></td></tr></table></figure><h2 id="缓存memorize函数"><a href="#缓存memorize函数" class="headerlink" title="缓存memorize函数"></a>缓存memorize函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> memorize = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> _args= <span class="built_in">JSON</span>.stringify(args)</span><br><span class="line">    <span class="keyword">return</span> cache[_args] || (cache[_args] = fn.apply(<span class="keyword">this</span>, args)) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'函数缓存'</span>)</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> addFn = memorize(add)</span><br><span class="line"><span class="keyword">var</span> a1 = addFn(<span class="number">2</span>, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">var</span> a2 = addFn(<span class="number">2</span>, <span class="number">6</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a1, a2)</span><br><span class="line"><span class="comment">// 函数缓存</span></span><br><span class="line"><span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h2 id="手写原始AJAX"><a href="#手写原始AJAX" class="headerlink" title="手写原始AJAX"></a>手写原始AJAX</h2><p>使用AJAX最主要的两个特性做下列事：</p><ul><li>在不重新加载页面的情况下发送请求给服务器。</li><li>接受并使用从服务器发来的数据。<br>具体步骤:<br>step one: 创建 XMLHttpRequest 实例<br>step two: 声明接到响应后要做啥事<br>step three: 发送一个实际的请求，通过调用HTTP请求对象的 open() 和 send() 方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeGetRequest</span>(<span class="params">url, cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// step one</span></span><br><span class="line">  <span class="keyword">let</span> httpRequst = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  <span class="comment">// step two</span></span><br><span class="line">  httpRequest.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 检查请求的状态 4</span></span><br><span class="line">    <span class="keyword">if</span> (httpRequest.readyState === XMLHttpRequest.done) &#123;</span><br><span class="line">      <span class="comment">// 检查请求状态码</span></span><br><span class="line">      <span class="keyword">if</span> (httpRequest.status === <span class="number">200</span>) &#123;</span><br><span class="line">        cb(httpRequest.responsText)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// step two</span></span><br><span class="line">  httpRequest.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>) </span><br><span class="line">  <span class="comment">// 第三个参数可选，用于设置请求是否是异步的。如果设为 true (默认值)，即开启异步，JavaScript就不会在此语句阻塞，使得用户能在服务器还没有响应的情况下与页面进行交互。</span></span><br><span class="line">  httpRequest.send(); </span><br><span class="line">  <span class="comment">// abort 取消请求</span></span><br><span class="line">  httpRequset.abort()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>如果你使用 POST 数据，那就需要设置请求的MIME类型。比如，在调用 send() 方法获取表单数据前要有下面这个：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makePostRequest</span>(<span class="params">url, cb, userName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> httpRequst = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  httpRequest.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (httpRequest.readyState === XMLHttpRequest.done) &#123;</span><br><span class="line">      <span class="keyword">if</span> (httpRequest.status === <span class="number">200</span>) &#123;</span><br><span class="line">        cb(httpRequest.responsText)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  httpRequest.open(<span class="string">'Post'</span>, url, <span class="literal">true</span>);</span><br><span class="line">  httpRequest.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">  httpRequest.send(<span class="string">'userName='</span> + <span class="built_in">encodeURIComponent</span>(userName));</span><br></pre></td></tr></table></figure></li></ul><h2 id="手写jsonp"><a href="#手写jsonp" class="headerlink" title="手写jsonp"></a>手写jsonp</h2><p>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, callBack</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> funcName = <span class="string">'jsonp_'</span> + <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">  script.src = url</span><br><span class="line">  script.async = <span class="literal">true</span></span><br><span class="line">  script.type = <span class="string">'text/javascript'</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">  <span class="built_in">window</span>[funcName] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    callBack &amp;&amp; callBack(data)</span><br><span class="line">    <span class="comment">// 重点清除全局函数和script标签</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">window</span>[funcName]</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(script)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line">  jsonp(<span class="string">'http://127.0.0.1:8080/api'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="RGB转16进制"><a href="#RGB转16进制" class="headerlink" title="RGB转16进制"></a>RGB转16进制</h2><p>1.| 运算符跟 &amp; 的区别在于如果对应的位中任一个操作数为1 那么结果就是1。<br>2. &lt;&lt; 运算符使指定值的二进制数所有位都左移指定次数，其移动规则：丢弃高位，低位补0即按二进制形式把所有的数字向左移动对应的位数，高位移出(舍弃)，低位的空位补零。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RGBToHex</span>(<span class="params">rgb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> rgbArr = rgb.split(<span class="regexp">/[^\d]+/</span>);</span><br><span class="line">  <span class="keyword">var</span> color = rgbArr[<span class="number">1</span>] &lt;&lt; <span class="number">16</span> | rgbArr[<span class="number">2</span>] &lt;&lt; <span class="number">8</span> | rgbArr[<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`#<span class="subst">$&#123;color.toString(<span class="number">16</span>)&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">'rgb(255,255,255)'</span></span><br><span class="line"><span class="built_in">console</span>.log(RGBToHex(test))<span class="comment">// #ffffff</span></span><br></pre></td></tr></table></figure><h2 id="16进制转RGB"><a href="#16进制转RGB" class="headerlink" title="16进制转RGB"></a>16进制转RGB</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HexToRgb</span>(<span class="params">hex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> hexx = hex.replace(<span class="string">'#'</span>, <span class="string">'0x'</span>);</span><br><span class="line">  <span class="keyword">var</span> r = hexx &gt;&gt; <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">var</span> g = hexx &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xff</span>;</span><br><span class="line">  <span class="keyword">var</span> b = hexx &amp; <span class="number">0xff</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`rgb(<span class="subst">$&#123;r&#125;</span>, <span class="subst">$&#123;g&#125;</span>, <span class="subst">$&#123;b&#125;</span>)`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">'#ffffff'</span></span><br><span class="line"><span class="built_in">console</span>.log(HexToRgb(test)) <span class="comment">// rgb(255, 255, 255)</span></span><br></pre></td></tr></table></figure><h2 id="实现一下es6的extends"><a href="#实现一下es6的extends" class="headerlink" title="实现一下es6的extends"></a>实现一下es6的extends</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="简单的算法"><a href="#简单的算法" class="headerlink" title="简单的算法"></a>简单的算法</h1><h2 id="滑动窗口，无重复字符的最长子串"><a href="#滑动窗口，无重复字符的最长子串" class="headerlink" title="滑动窗口，无重复字符的最长子串"></a>滑动窗口，无重复字符的最长子串</h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &amp;&amp; !s.length) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> arr = []</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> num = arr.indexOf(s[i])</span><br><span class="line">        <span class="keyword">if</span>(num &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">            arr.splice(<span class="number">0</span>, num + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        arr.push(s[i])</span><br><span class="line">        max = <span class="built_in">Math</span>.max(max, arr.length)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="计算容器的面积"><a href="#计算容器的面积" class="headerlink" title="计算容器的面积"></a>计算容器的面积</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">49</span> </span><br><span class="line">解释：图中垂直线代表输入数组 [<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="number">49</span>。</span><br></pre></td></tr></table></figure><ul><li>双指针解法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> right = height.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">      max = <span class="built_in">Math</span>.max(max, <span class="built_in">Math</span>.min(height[right], height[left]) * (right - left))</span><br><span class="line">      <span class="keyword">if</span> (height[right] &gt; height[left]) &#123;</span><br><span class="line">        left ++</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right -- </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="实现一个带缓存的求阶乘函数"><a href="#实现一个带缓存的求阶乘函数" class="headerlink" title="实现一个带缓存的求阶乘函数"></a>实现一个带缓存的求阶乘函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一版 迭代阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factoialIterative</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">let</span> total = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> num = n; num &gt; <span class="number">1</span>; num --) &#123;</span><br><span class="line">    total = total * num</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二版 递归阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = factorial(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三版 缓存阶乘？？</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">var</span> fn = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(m.has(n)) <span class="keyword">return</span> m.get(n)</span><br><span class="line">        <span class="keyword">let</span> res = n * fn(n - <span class="number">1</span>)</span><br><span class="line">        m.set(n, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四版 ES6尾调用优化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorialTail</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> factorialTail(n<span class="number">-1</span>, n * total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个带缓存斐波那契数列"><a href="#实现一个带缓存斐波那契数列" class="headerlink" title="实现一个带缓存斐波那契数列"></a>实现一个带缓存斐波那契数列</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记忆化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacciMemo</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> memo = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">const</span> fibonacci = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="literal">null</span>) <span class="keyword">return</span> momo[n]</span><br><span class="line">    <span class="keyword">return</span> memo[n] = fibonacci(n - <span class="number">1</span>, memo) + fibonacci(n - <span class="number">2</span>, memo)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fibonacci(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LRU-Cache"><a href="#LRU-Cache" class="headerlink" title="LRU Cache"></a>LRU Cache</h2><p>浏览器中的缓存是一种在本地保存资源副本，它的大小是有限的，当我们请求数过多时，缓存空间会被用满，此时，继续进行网络请求就需要确定缓存中哪些数据被保留，哪些数据被移除，这就是浏览器缓存淘汰策略，最常见的淘汰策略有 FIFO（先进先出）、LFU（最少使用）、LRU（最近最少使用）。<br>LRU(least recently used): 最近最少使用 缓存淘汰策略；根据数据的历史记录来进行淘汰数据，其核心思想是如果最近被访问过，那么将来被访问的几率也高，优先淘汰最近没有被访问的数据</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> LRUCache &#123;</span><br><span class="line">    <span class="keyword">private</span> caches: Map&lt;<span class="built_in">number</span>, <span class="built_in">number</span>&gt;</span><br><span class="line">    <span class="keyword">private</span> capacity:<span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">capacity: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.caches = <span class="keyword">new</span> Map()</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在key 则返回当前的key 同时更新缓存</span></span><br><span class="line">    <span class="comment">// 如果不存在 则返回-1</span></span><br><span class="line">    <span class="keyword">get</span>(key: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.caches.has(key)) &#123;</span><br><span class="line">            <span class="keyword">const</span> val = <span class="keyword">this</span>.caches.get(key)</span><br><span class="line">            <span class="keyword">this</span>.caches.delete(key)</span><br><span class="line">            <span class="keyword">this</span>.caches.set(key, val)</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在 删除当前的key</span></span><br><span class="line">    <span class="comment">// 如果不存在 则需要添加到缓存列表里 添加的时候需要判断缓存的长度，同时更新缓存</span></span><br><span class="line">    put(key: <span class="built_in">number</span>, value: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.caches.has(key)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.caches.delete(key)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">            <span class="keyword">this</span>.caches.size &gt;= <span class="keyword">this</span>.capacity</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">this</span>.caches.delete(<span class="keyword">this</span>.caches.keys().next().value)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.caches.set(key, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="验证回文字符串"><a href="#验证回文字符串" class="headerlink" title="验证回文字符串"></a>验证回文字符串</h2><p>示例 1:<br>输入: “A man, a plan, a canal: Panama”<br>输出: true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> s != <span class="string">'string'</span>) <span class="keyword">return</span> s = s.toString()</span><br><span class="line">    <span class="keyword">if</span>(s.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> r = <span class="regexp">/[^a-zA-Z0-9]/ig</span>;</span><br><span class="line">    s = s.replace(r, <span class="string">''</span>).toLowerCase()</span><br><span class="line">    <span class="keyword">return</span> s == s.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line">isPalindrome(<span class="string">'cppc'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>输入： [1,2,3]<br>输出： [<br>  [1,2,3],<br>  [1,3,2],<br>  …<br>]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> len = nums.length</span><br><span class="line">  <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> nums</span><br><span class="line">  <span class="keyword">var</span> res = []</span><br><span class="line">  <span class="keyword">var</span> path = []</span><br><span class="line">  <span class="keyword">var</span> backTrack = <span class="function">(<span class="params">path, nums</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length === nums.length) &#123;</span><br><span class="line">      res.push(path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!path.includes(num)) &#123;</span><br><span class="line">        path.push(num)</span><br><span class="line">        backTrack(path.slice(), nums)</span><br><span class="line">        path.pop()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  backTrack(path, nums)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">permute([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure><h2 id="驼峰转换"><a href="#驼峰转换" class="headerlink" title="驼峰转换"></a>驼峰转换</h2><p>// 输入：<br>content-type<br>// 输出：<br>contentType</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">camel</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="keyword">let</span> ans = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">let</span> upper = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; str.length; index++) &#123;</span><br><span class="line">        <span class="keyword">const</span> element = str[index];</span><br><span class="line">        <span class="keyword">if</span> (element == <span class="string">'_'</span> || element == <span class="string">'-'</span> || element == <span class="string">'@'</span>) &#123;</span><br><span class="line">          upper = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (upper) &#123;</span><br><span class="line">            ans += element.toUpperCase();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += element;</span><br><span class="line">          &#125;</span><br><span class="line">          upper = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>示例 1:</p><p>输入: nums = [-1,0,3,5,9,12], target = 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max = nums.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> min = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(max &gt;= min) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[max] === target) &#123;</span><br><span class="line">            <span class="keyword">return</span> max</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[max]) &#123;</span><br><span class="line">            max --</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[min])&#123;</span><br><span class="line">            min ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>第一家公司就跪了，这道题铭记在心</p></blockquote><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。<br>输入：head = [1,2,3,4,5]<br>输出：[5,4,3,2,1]</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseList</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="title">ListNode</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = head</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span>(current) &#123;</span><br><span class="line">        <span class="keyword">const</span> next = current.next</span><br><span class="line">        current.next = pre</span><br><span class="line">        pre = current</span><br><span class="line">        current = next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例 1：<br>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br>示例 2：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxSubArray</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ans = nums[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      sum = sum + num</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sum = num</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">Math</span>.max(ans, sum)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test </span></span><br><span class="line"><span class="keyword">var</span> nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line">maxSubArray(nums) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p>感谢各位大佬的倾情奉献，小弟只是代码搬运工！</p></blockquote><ul><li><a href="https://segmentfault.com/a/1190000009271416" target="_blank" rel="noopener">JavaScript深入之bind的模拟实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/345232890" target="_blank" rel="noopener">前端JavaScript高频手写面试大全，助你查漏补缺</a></li><li><a href="https://segmentfault.com/a/1190000022110467" target="_blank" rel="noopener">还得学习css</a></li><li><a href="https://juejin.cn/post/6844903924520992782" target="_blank" rel="noopener">关于JS中一些重要的api实现, 巩固你的原生JS功底</a></li><li><a href="https://juejin.cn/post/6844903568906911752#heading-8" target="_blank" rel="noopener">位运算符在JS中的妙用</a></li><li><a href="https://juejin.cn/post/6844904127948914701" target="_blank" rel="noopener">你也许不知道的javascript高级函数</a></li><li><a href="https://juejin.cn/post/6844904122496319495#heading-6" target="_blank" rel="noopener">10问10答，带你快速入门前端算法</a></li><li><a href="https://mp.weixin.qq.com/s/2COjA4ngJHAnKwYjJO8MYQ" target="_blank" rel="noopener">死磕 36 个 JS 手写题</a></li><li><a href="https://fanerge.github.io/2018/js%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88.html" target="_blank" rel="noopener">js算法集合</a></li><li><a href="https://juejin.cn/post/6844904116552990727#heading-1" target="_blank" rel="noopener">2万字 | 前端基础拾遗90问</a></li><li><a href="https://juejin.cn/post/6844903974378668039" target="_blank" rel="noopener">建议收藏)原生JS灵魂之问, 请问你能接得住几个？(上)</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端框架:vue-cli-service使用中遇到的问题 npm run build -- --report</title>
      <link href="/2021/03/27/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-vue-cli-service%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98-npm-run-build-report/"/>
      <url>/2021/03/27/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-vue-cli-service%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98-npm-run-build-report/</url>
      
        <content type="html"><![CDATA[<h2 id="vue-cli3执行打包命令时候的–report参数无效"><a href="#vue-cli3执行打包命令时候的–report参数无效" class="headerlink" title="vue-cli3执行打包命令时候的–report参数无效"></a>vue-cli3执行打包命令时候的–report参数无效</h2><p>项目里的scripts脚本</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scripts: &#123;</span><br><span class="line">  "build": "vue-cli-service build &amp;&amp; npm run test",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>npm 执行打包命令的时候 npm run build –report 却没有生成我想要的webpack-bundle-analyzer 分析报告，官网里明确写了支持的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--report 和 --report-json 会根据构建统计生成报告，它会帮助你分析包中包含的模块们的大小</span><br></pre></td></tr></table></figure><p><a href="https://cli.vuejs.org/zh/guide/cli-service.html#vue-cli-service-serve" target="_blank" rel="noopener">vue-cli-service build</a><br>刚开始找不到方向直到有一天看到大佬的文章才明白，(后面得学习从源码的角度思考问题)<br>找到打包命令的文件，打印args入参看下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules\@vue\cli-service\lib\commands\build\index.js</span></span><br><span class="line"> <span class="built_in">console</span>.log(args, <span class="string">'——————args'</span>)</span><br><span class="line"> <span class="keyword">if</span> (args.report || args[<span class="string">'report-json'</span>]) &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; BundleAnalyzerPlugin &#125; = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>)</span><br><span class="line">   <span class="built_in">console</span>.log(config)</span><br><span class="line">   modifyConfig(webpackConfig, config =&gt; &#123;</span><br><span class="line">     <span class="keyword">const</span> bundleName = args.target !== <span class="string">'app'</span></span><br><span class="line">       ? config.output.filename.replace(<span class="regexp">/\.js$/</span>, <span class="string">'-'</span>)</span><br><span class="line">       : isLegacyBuild ? <span class="string">'legacy-'</span> : <span class="string">''</span></span><br><span class="line">     config.plugins.push(<span class="keyword">new</span> BundleAnalyzerPlugin(&#123;</span><br><span class="line">       logLevel: <span class="string">'warn'</span>,</span><br><span class="line">       openAnalyzer: <span class="literal">false</span>,</span><br><span class="line">       analyzerMode: args.report ? <span class="string">'static'</span> : <span class="string">'disabled'</span>,</span><br><span class="line">       reportFilename: <span class="string">`<span class="subst">$&#123;bundleName&#125;</span>report.html`</span>,</span><br><span class="line">       statsFilename: <span class="string">`<span class="subst">$&#123;bundleName&#125;</span>report.json`</span>,</span><br><span class="line">       generateStatsFile: !!args[<span class="string">'report-json'</span>]</span><br><span class="line">     &#125;))</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>观察到打印的args携带的参数report: false，我发现俩个问题</p><ul><li>第一点：如果打包脚本是官方原本的命令行打包参数，即<code>vue-cli-service build</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scripts: &#123;</span><br><span class="line">  "buildReport": "vue-cli-service build",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二点：同时npm执行的时候，需要在–report前面加上–，也就是要这样: <code>npm run build -- --report</code><br>然后我们在看打印参数<br>args打印出<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  _: [],</span><br><span class="line">  modern: <span class="literal">false</span>,</span><br><span class="line">  report: <span class="literal">true</span>, <span class="comment">// 可行 </span></span><br><span class="line">  <span class="string">'report-json'</span>: <span class="literal">false</span>,</span><br><span class="line">  watch: <span class="literal">false</span>,</span><br><span class="line">  open: <span class="literal">false</span>,</span><br><span class="line">  copy: <span class="literal">false</span>,</span><br><span class="line">  https: <span class="literal">false</span>,</span><br><span class="line">  verbose: <span class="literal">false</span>,</span><br><span class="line">  clean: <span class="literal">true</span>,</span><br><span class="line">  target: <span class="string">'app'</span>,</span><br><span class="line">  entry: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>参考npm官网 <a href="https://docs.npmjs.com/cli/v7/commands/npm-run-script" target="_blank" rel="noopener">npm-run-script</a></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1.npm run build – –report 可行<br>2.1.npm run build &amp;&amp; run build test – –report 不可行<br>3.yarn run build  –report 可行<br>4.yarn run build &amp;&amp; run build test –report 不可行</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.npmjs.com/cli/v7/commands/npm-run-script" target="_blank" rel="noopener">npm-run-script</a></li><li><a href="https://blog.csdn.net/sanchuanhi/article/details/105259027" target="_blank" rel="noopener">vue-cli利用webpack-bundle-analyzer分析构建产物</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法基础: esay level</title>
      <link href="/2021/03/27/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E7%AE%80%E5%8D%95%E5%92%8C%E4%B8%AD%E7%AD%89/"/>
      <url>/2021/03/27/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E7%AE%80%E5%8D%95%E5%92%8C%E4%B8%AD%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-search" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-search</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br>示例<br>输入: nums = [-1,0,3,5,9,12], target = 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">nums: <span class="built_in">number</span>[], target: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max = nums.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> min = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(max &gt;= min) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[max] === target) &#123;</span><br><span class="line">            <span class="keyword">return</span> max</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[max]) &#123;</span><br><span class="line">            max --</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[min])&#123;</span><br><span class="line">            min ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first one</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; nums.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">let</span> item = nums[i];</span><br><span class="line">        <span class="keyword">let</span> diff = target - item;</span><br><span class="line">        j = nums.indexOf(diff)</span><br><span class="line">        <span class="keyword">if</span>(j &gt; <span class="number">-1</span> &amp;&amp; j != i) &#123;</span><br><span class="line">            <span class="keyword">return</span> [i,j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// second</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; nums.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.has(nums[i])) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(map)</span><br><span class="line">          <span class="keyword">return</span> [</span><br><span class="line">            map.get(nums[i]), i</span><br><span class="line">          ]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          map.set(target - nums[i], i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line">twoSum([<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], <span class="number">17</span>)</span><br></pre></td></tr></table></figure><h3 id="三数最接近之和"><a href="#三数最接近之和" class="headerlink" title="三数最接近之和"></a>三数最接近之和</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> res = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i ++) &#123;</span><br><span class="line">        res[i] = s[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> arr = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; res.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[i]</span><br><span class="line">        <span class="keyword">if</span> (arr.includes(temp)) &#123;</span><br><span class="line">            arr.push(temp)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(</span><br><span class="line">                temp === arr.pop() || </span><br><span class="line">                temp.reverse() === arr.pop()</span><br><span class="line">            ) &#123;</span><br><span class="line">                arr.pop()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.length === <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="正确解读"><a href="#正确解读" class="headerlink" title="正确解读"></a>正确解读</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  s = s.split(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">let</span> len = s.length;</span><br><span class="line">  <span class="keyword">if</span> (s % <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">')'</span>, <span class="string">'('</span>],</span><br><span class="line">    [<span class="string">']'</span>, <span class="string">'['</span>],</span><br><span class="line">    [<span class="string">'&#125;'</span>, <span class="string">'&#123;'</span>]</span><br><span class="line">  ])</span><br><span class="line">  <span class="keyword">let</span> stack = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.get(i)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        stack[stack.length - <span class="number">1</span>] !== map.get(i)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stack.pop()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      stack.push(i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> !stack.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正整数转罗马数字"><a href="#正整数转罗马数字" class="headerlink" title="正整数转罗马数字"></a>正整数转罗马数字</h3><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/integer-to-roman" target="_blank" rel="noopener">https://leetcode-cn.com/problems/integer-to-roman</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h4 id="首次尝试，好搓的解法"><a href="#首次尝试，好搓的解法" class="headerlink" title="首次尝试，好搓的解法"></a>首次尝试，好搓的解法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mapSep = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">[<span class="number">4</span>, <span class="string">'IV'</span>],</span><br><span class="line">[<span class="number">9</span>, <span class="string">'IX'</span>],</span><br><span class="line">[<span class="number">40</span>, <span class="string">'XL'</span>],</span><br><span class="line">[<span class="number">90</span>, <span class="string">'XC'</span>],</span><br><span class="line">[<span class="number">400</span>, <span class="string">'CD'</span>],</span><br><span class="line">[<span class="number">900</span>, <span class="string">'CM'</span>]    </span><br><span class="line">])</span><br><span class="line"><span class="keyword">var</span> mapCom = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">[<span class="number">1</span>, <span class="string">'I'</span>],</span><br><span class="line">[<span class="number">5</span>, <span class="string">'V'</span>],</span><br><span class="line">[<span class="number">10</span>, <span class="string">'X'</span>],</span><br><span class="line">[<span class="number">50</span>, <span class="string">'L'</span>],</span><br><span class="line">[<span class="number">100</span>, <span class="string">'C'</span>],</span><br><span class="line">[<span class="number">500</span>, <span class="string">'D'</span>],</span><br><span class="line">[<span class="number">1000</span>, <span class="string">'M'</span>]   </span><br><span class="line">])</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeatNum</span> (<span class="params">type, num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> type.repeat(num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> intToRoman = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> getOpt = <span class="function">(<span class="params">basis,spe = <span class="number">0</span>, num, max</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'basis'</span>, basis, spe, num)</span><br><span class="line"><span class="keyword">if</span>(num === spe) <span class="keyword">return</span> mapSep.get(num)</span><br><span class="line"><span class="keyword">var</span> reset = <span class="built_in">Math</span>.floor( num/basis )</span><br><span class="line"><span class="keyword">if</span> (num % basis === <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> repeatNum(mapCom.get(basis), num / basis)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( num &gt; spe &amp;&amp; num &lt; max &amp;&amp; spe !== <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> mapSep.get(spe) + countRest(num - spe)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> repeatNum(mapCom.get(basis), reset) + countRest(num - reset * basis)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> countRest = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> &lt;= num &amp;&amp; num &lt; <span class="number">5</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> getOpt(<span class="number">1</span>, <span class="number">4</span>, num, <span class="number">5</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">5</span> &lt;= num &amp;&amp; num &lt; <span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> getOpt(<span class="number">5</span>, <span class="number">9</span>, num, <span class="number">10</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">10</span> &lt;= num &amp;&amp; num  &lt; <span class="number">50</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> getOpt(<span class="number">10</span>, <span class="number">40</span>, num, <span class="number">50</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">50</span> &lt;= num &amp;&amp; num &lt; <span class="number">100</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> getOpt(<span class="number">50</span>, <span class="number">90</span>, num, <span class="number">100</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">100</span> &lt;= num &amp;&amp; num  &lt; <span class="number">500</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> getOpt(<span class="number">100</span>, <span class="number">400</span>, num, <span class="number">500</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">500</span> &lt;= num &amp;&amp; num  &lt; <span class="number">1000</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> getOpt(<span class="number">500</span>, <span class="number">900</span>, num, <span class="number">1000</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1000</span> &lt;= num &amp;&amp; num  &lt;= <span class="number">3999</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> getOpt(<span class="number">1000</span>, <span class="number">0</span>, num, <span class="number">3999</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> countRest(<span class="built_in">parseInt</span>(num))</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1994'</span>, intToRoman(<span class="number">1994</span>))</span><br></pre></td></tr></table></figure><h4 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intToRoman = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> keys = [<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">        values = [<span class="string">'M'</span>, <span class="string">'CM'</span>, <span class="string">'D'</span>, <span class="string">'CD'</span>, <span class="string">'C'</span>, <span class="string">'XC'</span>, <span class="string">'L'</span>, <span class="string">'XL'</span>, <span class="string">'X'</span>, <span class="string">'IX'</span>, <span class="string">'V'</span>, <span class="string">'IV'</span>, <span class="string">'I'</span>];</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (num &gt;= keys[i]) &#123;</span><br><span class="line">            num = num - keys[i];</span><br><span class="line">            res = res + values[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="驼峰转下划线"><a href="#驼峰转下划线" class="headerlink" title="驼峰转下划线"></a>驼峰转下划线</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虚拟dom<br>diff算法<br>双指针<br>更新<br>key有什么用，唯一性，相似节点 复用</p><h3 id="验证回文"><a href="#验证回文" class="headerlink" title="验证回文"></a>验证回文</h3><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p>说明：本题中，我们将空字符串定义为有效的回文串。</p><p>示例 1:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"A man, a plan, a canal: Panama"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"race a car"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="解法一-迭代循环"><a href="#解法一-迭代循环" class="headerlink" title="解法一: 迭代循环"></a>解法一: 迭代循环</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> s != <span class="string">'string'</span>) <span class="keyword">return</span> s = s.toString()</span><br><span class="line">    <span class="keyword">if</span>(s.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> r = <span class="regexp">/[a-zA-Z0-9]/g</span>;</span><br><span class="line">    <span class="keyword">var</span> arr = s.match(r) || [];</span><br><span class="line">    <span class="keyword">let</span> j = arr.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; j; i ++, j --) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i].toLowerCase() != arr[j].toLowerCase()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用正则表达式^以及replace优化下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> s != <span class="string">'string'</span>) <span class="keyword">return</span> s = s.toString()</span><br><span class="line">    <span class="keyword">if</span>(s.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> r = <span class="regexp">/[^a-zA-Z0-9]/ig</span>;</span><br><span class="line">    <span class="keyword">var</span> arr = s.replace(r, <span class="string">''</span>).toLowerCase()</span><br><span class="line">    <span class="keyword">let</span> j = arr.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; j; i ++, j --) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] != arr[j]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="解法二-String-prototype-reverse"><a href="#解法二-String-prototype-reverse" class="headerlink" title="解法二: String.prototype.reverse()"></a>解法二: String.prototype.reverse()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> s != <span class="string">'string'</span>) <span class="keyword">return</span> s = s.toString()</span><br><span class="line">    <span class="keyword">if</span>(s.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">var</span> r = <span class="regexp">/[^a-zA-Z0-9]/ig</span>;</span><br><span class="line">    s = s.replace(r, <span class="string">''</span>).toLowerCase()</span><br><span class="line">    <span class="keyword">return</span> s == s.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><h3 id="首次尝试，以失败告终，正解在下面"><a href="#首次尝试，以失败告终，正解在下面" class="headerlink" title="首次尝试，以失败告终，正解在下面"></a>首次尝试，以失败告终，正解在下面</h3><p>思路也是从中心点开始往俩边扩展，唯一不足的就是当遇到中心点是’aabbaa’这种偶数性的字符串没有很好的考虑到。漏掉了这种类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &amp;&amp; s.length &lt; <span class="number">2</span>) &#123;<span class="keyword">return</span> s&#125;</span><br><span class="line">    s = s.split(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">if</span> (s.length &gt;= <span class="number">2</span> &amp;&amp; s.every(<span class="function">(<span class="params">e</span>) =&gt;</span> e === s[<span class="number">0</span>])) <span class="keyword">return</span> s.join(<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">var</span> target = s[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">var</span> res = [s[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; s.length; i ++) &#123;</span><br><span class="line">        target = s[i]</span><br><span class="line">        <span class="keyword">var</span> left = s.slice(<span class="number">0</span>, i)</span><br><span class="line">        <span class="keyword">var</span> right = s.slice(i + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">while</span>(right[<span class="number">0</span>] &amp;&amp; left[left.length - <span class="number">1</span>] &amp;&amp; left[left.length - <span class="number">1</span>] == right[<span class="number">0</span>]) &#123;</span><br><span class="line">          str = left.pop() + target + right.shift()</span><br><span class="line">          res.push(str)</span><br><span class="line">          target = str</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(target === left[left.length - <span class="number">1</span>]) &#123;</span><br><span class="line">          str = left.pop() + target</span><br><span class="line">          res.push(str)</span><br><span class="line">          target = str</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(target === right[<span class="number">0</span>]) &#123;</span><br><span class="line">          str = target + right.shift()</span><br><span class="line">          res.push(str)</span><br><span class="line">          target = str</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> max = res[<span class="number">0</span>]</span><br><span class="line">    res.forEach(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> tempLength = e.length</span><br><span class="line">        <span class="keyword">if</span> (max.length &lt; tempLength) &#123;</span><br><span class="line">            max = e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a><br>inner [“c”] bb [“d”]</p><h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s || s.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="number">0</span>,end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> n = s.length;</span><br><span class="line">    <span class="comment">// 中心扩展法</span></span><br><span class="line">    <span class="keyword">let</span> centerExpend = <span class="function">(<span class="params">left,right</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> len1 = centerExpend(i, i);</span><br><span class="line">        <span class="keyword">let</span> len2 = centerExpend(i, i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 两种组合取最大回文串的长度</span></span><br><span class="line">        <span class="keyword">let</span> maxLen = <span class="built_in">Math</span>.max(len1, len2);</span><br><span class="line">        <span class="keyword">if</span>(maxLen &gt; end - start)&#123;</span><br><span class="line">          <span class="comment">// 更新最大回文串的首尾字符索引</span></span><br><span class="line">          <span class="comment">// start = i - ((maxLen - 1) &gt;&gt; 1);</span></span><br><span class="line">          <span class="comment">// end = i + (maxLen &gt;&gt; 1);</span></span><br><span class="line">          start = i - <span class="built_in">Math</span>.floor((len - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">          end = i + <span class="built_in">Math</span>.floor(len / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start,end+<span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：Alexer<span class="number">-660</span></span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/longest-palindromic-substring/solution/5-zui-chang-hui-wen-zi-chuan-by-alexer-660/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p>输入： [1,2,3]<br>输出： [<br>  [1,2,3],<br>  [1,3,2],<br>  …<br>]<br>题解：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> len = nums.length</span><br><span class="line">  <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> nums</span><br><span class="line">  <span class="keyword">var</span> res = []</span><br><span class="line">  <span class="keyword">var</span> path = []</span><br><span class="line">  <span class="keyword">var</span> backTrack = <span class="function">(<span class="params">path, nums</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length === nums.length) &#123;</span><br><span class="line">      res.push(path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!path.includes(num)) &#123;</span><br><span class="line">        path.push(num)</span><br><span class="line">        backTrack(path.slice(), nums)</span><br><span class="line">        path.pop()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  backTrack(path, nums)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">permute([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure><h3 id="计算容器的面积"><a href="#计算容器的面积" class="headerlink" title="计算容器的面积"></a>计算容器的面积</h3><ul><li>暴力解法 O(n^2)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; height.length - <span class="number">1</span>;i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i+ <span class="number">1</span>; j &lt; height.length; j ++) &#123;</span><br><span class="line">            max = <span class="built_in">Math</span>.max(max, <span class="built_in">Math</span>.min(height[i], height[j]) * (j - i))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>双指针解法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> right = height.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">      max = <span class="built_in">Math</span>.max(max, <span class="built_in">Math</span>.min(height[right], height[left]) * (right - left))</span><br><span class="line">      <span class="keyword">if</span> (height[right] &gt; height[left]) &#123;</span><br><span class="line">        left ++</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right -- </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h3><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<br>示例:</p><p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>说明:</p><p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveZeroes</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = nums.length</span><br><span class="line">    <span class="keyword">while</span>(len --) &#123;</span><br><span class="line">      <span class="keyword">var</span> index = nums.indexOf(<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        nums.splice(index, <span class="number">1</span>)</span><br><span class="line">        nums.push(<span class="number">0</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> res = []</span><br><span class="line">    <span class="keyword">var</span> sArr = s.split(<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sArr.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">var</span> temp = sArr[i]</span><br><span class="line">        <span class="keyword">var</span> index = res.indexOf(temp)</span><br><span class="line">        res.push(temp)</span><br><span class="line">        <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">            res.splice(<span class="number">0</span>, index + <span class="number">1</span>)</span><br><span class="line">        &#125; </span><br><span class="line">        max = <span class="built_in">Math</span>.max(max, res.length)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例 1：</p><p>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br>示例 2：</p><p>输入：nums = [1]<br>输出：1</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxSubArray</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> ans = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num of nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = sum + num</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum = num;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">Math</span>.max(sum, ans)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">var</span> nums = [<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-3</span>, <span class="number">4</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-5</span>,<span class="number">4</span>]</span><br><span class="line">maxSubArray(nums)</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://fanerge.github.io/2018/js%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88.html" target="_blank" rel="noopener">js算法集合</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络基础: tcp/udp/http</title>
      <link href="/2021/03/24/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80-tcp-udp-http/"/>
      <url>/2021/03/24/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80-tcp-udp-http/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/4/13/1717297c7324a8f0?imageslim" alt=""></p><h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><p>OSI（Open System Interconnect），即开放式系统互联。一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互连模型。ISO为了更好的使网络应用更为普及，推出了OSI参考模型，这样所有的公司都按照统一的标准来指定自己的网络，就可以互通互联了。<br>OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）。</p><h3 id="TCP-IP四层协议"><a href="#TCP-IP四层协议" class="headerlink" title="TCP/IP四层协议"></a>TCP/IP四层协议</h3><p>（数据链路层、网络层、传输层、应用层）</p><ul><li>应用层<br>应用层最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，TELNET等。</li><li>传输层<br>建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。</li><li>网络层<br>本层通过IP寻址来建立两个节点之间的连接。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</li><li>数据链路层<br>通过一些规程或协议来控制这些数据的传输，以保证被传输数据的正确性。实现这些规程或协议的硬件和软件加到物理线路，这样就构成了数据链路</li></ul><h3 id="什么是TCP-IP和UDP"><a href="#什么是TCP-IP和UDP" class="headerlink" title="什么是TCP/IP和UDP"></a>什么是TCP/IP和UDP</h3><h4 id="TCP-IP即传输控制-网络协议"><a href="#TCP-IP即传输控制-网络协议" class="headerlink" title="TCP/IP即传输控制/网络协议"></a>TCP/IP即传输控制/网络协议</h4><p>是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达</p><h4 id="UDP它是属于TCP-IP协议族中的一种。"><a href="#UDP它是属于TCP-IP协议族中的一种。" class="headerlink" title="UDP它是属于TCP/IP协议族中的一种。"></a>UDP它是属于TCP/IP协议族中的一种。</h4><p>是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。</p><h3 id="TCP与UDP区别："><a href="#TCP与UDP区别：" class="headerlink" title="TCP与UDP区别："></a>TCP与UDP区别：</h3><ul><li><p>TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达；<br>UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；</p></li><li><p>TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；<br>UDP通信类似于学校广播，靠着广播播报直接进行通信。</p></li><li><p>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；</p></li><li><p>TCP是面向字节流的，UDP是面向报文的；面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。</p></li><li><p>TCP首部开销（20字节）比UDP首部开销（8字节）要大</p></li></ul><h3 id="形容一下TCP和UDP"><a href="#形容一下TCP和UDP" class="headerlink" title="形容一下TCP和UDP"></a>形容一下TCP和UDP</h3><p>TCP通信可看作打电话：<br>    李三(拨了个号码)：喂，是王五吗？<br>    王五：哎，您谁啊？<br>    李三：我是李三，我想给你说点事儿，你现在方便吗？<br>    王五：哦，我现在方便，你说吧。<br>    甲：那我说了啊？<br>    乙：你说吧。<br>    (连接建立了，接下来就是说正事了…)</p><p>UDP通信可看为学校里的广播：<br>    播音室：喂喂喂！全体操场集合</p><h3 id="运行在TCP-或UDP的应用层协议分析"><a href="#运行在TCP-或UDP的应用层协议分析" class="headerlink" title="运行在TCP 或UDP的应用层协议分析"></a>运行在TCP 或UDP的应用层协议分析</h3><p>运行在TCP协议上的协议：</p><p>HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。<br>HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。<br>FTP（File Transfer Protocol，文件传输协议），用于文件传输。<br>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。<br>SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。</p><p>运行在UDP协议上的协议：</p><p>NTP（Network Time Protocol，网络时间协议），用于网络同步。<br>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。</p><p>运行在TCP和UDP协议上：</p><p>DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。<br>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。</p><h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><p>什么是TCP的三次握手<br>在网络数据传输中，传输层协议TCP是要建立连接的可靠传输，TCP建立连接的过程，我们称为三次握手。</p><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/4/13/1717297c73467e00?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="三次握手"></p><ul><li><p>第一次握手：Client将SYN置1，随机产生一个通讯初始序列号seq发送给Server，进入SYN_SENT状态</p></li><li><p>第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=sequence number+1，并随机产生一个自己的通讯初始序列号，发送给客户端；进入SYN_RCVD状态；</p></li><li><p>第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=服务器发的序列号+1，发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。</p></li></ul><p>简单来说就是 ：</p><ul><li>客户端向服务端发送SYN</li><li>服务端返回SYN,ACK</li><li>客户端发送ACK</li></ul><h3 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h3><p>什么是TCP的四次挥手<br>在网络数据传输中，传输层协议断开连接的过程我们称为四次挥手</p><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/4/13/1717297c746f6ee2?imageslim" alt="四次挥手"></p><ul><li><p>第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入FIN_WAIT_1状态；</p></li><li><p>第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。</p></li><li><p>第三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态；</p></li><li><p>第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。</p></li></ul><p>简单来说</p><ul><li>客户端向服务端发送FIN</li><li>服务端向客户端返回ACK</li><li>服务端向客户端返回FIN</li><li>客户端向服务端发送ACK</li></ul><h4 id="客户端TIME-WAIT状态的意义是什么？"><a href="#客户端TIME-WAIT状态的意义是什么？" class="headerlink" title="客户端TIME_WAIT状态的意义是什么？"></a>客户端TIME_WAIT状态的意义是什么？</h4><p>第四次挥手时，客户端发送给服务器的ACK有可能丢失，<em>TIME_WAIT</em>状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2<em>MSL</em>的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。 MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><ul><li><p>网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个Socket。Socket通常用来实现客户方和服务方的连接。Socket是TCP/IP协议的一个十分流行的编程界面，一个Socket由一个IP地址和一个端口号唯一确定。</p></li><li><p>但是，Socket所支持的协议种类也不光TCP/IP、UDP，因此两者之间是没有必然联系的。在Java环境下，Socket编程主要是指基于TCP/IP协议的网络编程。</p></li><li><p>socket连接就是所谓的长连接，客户端和服务器需要互相连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉的，但是有时候网络波动还是有可能的</p></li><li><p>Socket偏向于底层。一般很少直接使用Socket来编程，框架底层使用Socket比较多，</p></li><li><p>位于应用层和传输层之间，我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。</p></li></ul><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>Http协议是对客户端和服务器端之间数据之间实现可靠性的传输文字、图片、音频、视频等超文本数据的规范，格式简称为“超文本传输协议”</p><p>Http协议属于应用层，及用户访问的第一层就是http</p><h3 id="Socket和http的区别和应用场景"><a href="#Socket和http的区别和应用场景" class="headerlink" title="Socket和http的区别和应用场景"></a>Socket和http的区别和应用场景</h3><ul><li><p>Socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；</p></li><li><p>Socket适用场景：网络游戏，银行持续交互，直播，在线视屏等。</p></li><li><p>http连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断开等待下次连接</p></li><li><p>http适用场景：公司OA服务，互联网服务，电商，办公，网站等等等等</p></li></ul><h3 id="什么是http的请求体？"><a href="#什么是http的请求体？" class="headerlink" title="什么是http的请求体？"></a>什么是http的请求体？</h3><p>HTTP请求体由：请求行 、请求头、请求数据组成的</p><h3 id="http的响应报文有哪些？"><a href="#http的响应报文有哪些？" class="headerlink" title="http的响应报文有哪些？"></a>http的响应报文有哪些？</h3><p>http的响应报是服务器返回给我们的数据，必须先有请求体再有响应报文</p><p>响应报文包含三部分 状态行、响应首部字段、响应内容实体实现</p><h3 id="http和https的区别？"><a href="#http和https的区别？" class="headerlink" title="http和https的区别？"></a>http和https的区别？</h3><p>其实HTTPS就是从HTTP加上加密处理（一般是SSL安全通信线路）+认证+完整性保护</p><p>区别：<br>HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。<br>HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页;<br>HTTPS需要用到SSL证书，而HTTP不用;<br>Https默认端口号是443.而http默认端口号是80<br>HTTPS基于传输层(介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议)，HTTP基于应用层<br>HTTPS在浏览器显示安全锁，HTTP没有显示;</p><h3 id="https工作流程"><a href="#https工作流程" class="headerlink" title="https工作流程"></a>https工作流程</h3><p>1.Client发起一个HTTPS的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。<br>2.Server把事先配置好的公钥证书（public key certificate）返回给客户端。<br>3.Client验证公钥（RSA加密）证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。<br>4.Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密（RSA加密）这个对称密钥，发给Server。<br>5.Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。<br>6.Server使用对称密钥加密“明文内容A”，发送给Client。<br>7.Client使用对称密钥解密响应的密文，得到“明文内容A”。<br>8.Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”</p><h3 id="常用HTTP状态码是怎么分类的，有哪些常见的状态码？"><a href="#常用HTTP状态码是怎么分类的，有哪些常见的状态码？" class="headerlink" title="常用HTTP状态码是怎么分类的，有哪些常见的状态码？"></a>常用HTTP状态码是怎么分类的，有哪些常见的状态码？</h3><p>HTTP状态码表示客户端HTTP请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。<br>1xx：<br>指示信息–表示请求已接收，正在处理</p><p>2xx：<br>成功–表示请求已被成功接收、理解、接受</p><p>3xx：<br>重定向–要完成请求必须进行更进一步的操作</p><p>4xx：<br>客户端错误–请求有语法错误或请求无法实现</p><p>5xx：<br>服务器端错误–服务器未能实现合法的请求</p><h3 id="Http协议中有那些请求方式"><a href="#Http协议中有那些请求方式" class="headerlink" title="Http协议中有那些请求方式"></a>Http协议中有那些请求方式</h3><p>PUT：    传输文件，报文主体中包含文件内容，保存到对应URI位置。<br>HEAD：    获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有 &gt; 效。<br>DELETE：    删除文件，与PUT方法相反，删除对应URI位置的文件。</p><h3 id="GET方法与POST方法的区别"><a href="#GET方法与POST方法的区别" class="headerlink" title="GET方法与POST方法的区别"></a>GET方法与POST方法的区别</h3><p>区别一：<br>get重点在从服务器上获取资源，post重点在向服务器发送数据；</p><p>区别二：<br>Get传输的数据量小，因为受URL长度限制，但效率较高；<br>Post可以传输大量数据，所以上传文件时只能用Post方式；</p><p>区别三：<br>get是不安全的，因为get请求发送数据是在URL上，是可见的，可能会泄露私密信息，如密码等；<br>post是放在请求头部的，是安全的</p><h3 id="http版本的对比"><a href="#http版本的对比" class="headerlink" title="http版本的对比"></a>http版本的对比</h3><p>HTTP1.0版本的特性：</p><ul><li>早先1.0的HTTP版本，是一种无状态、无连接的应用层协议。</li><li>HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。</li></ul><p>HTTP1.1版本新特性</p><ul><li>默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求</li><li>管线化 HTTP Pipelining，客户端可以同时发出多个HTTP请求，而不用一个个等待响应(断点续传原理)</li></ul><p>HTTP2.0版本的特性</p><ul><li>二进制分帧（采用二进制格式的编码将其封装）</li><li>头部采用HPACK压缩（设置了专门的首部压缩设计的HPACK算法。）</li><li>流量控制（设置了接收某个数据流的多少字节一些流量控制）</li><li>多路复用（可以在共享TCP链接的基础上同时发送请求和响应）</li><li>请求优先级（可以通过优化这些帧的交错和传输顺序进一步优化性能）</li><li>服务器推送（就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资 源无需客户端明确的请求。（重大更新））</li></ul><h3 id="什么是对称加密与非对称加密"><a href="#什么是对称加密与非对称加密" class="headerlink" title="什么是对称加密与非对称加密"></a>什么是对称加密与非对称加密</h3><ul><li><p>对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；</p></li><li><p>而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢</p></li></ul><h3 id="cookie和session对于HTTP有什么用？"><a href="#cookie和session对于HTTP有什么用？" class="headerlink" title="cookie和session对于HTTP有什么用？"></a>cookie和session对于HTTP有什么用？</h3><p>HTTP协议本身是无法判断用户身份。所以需要cookie或者session</p><h4 id="什么是cookie"><a href="#什么是cookie" class="headerlink" title="什么是cookie"></a>什么是cookie</h4><p>cookie是由Web服务器保存在用户浏览器上的文件（key-value格式），可以包含用户相关的信息。客户端向服务器发起请求，就提取浏览器中的用户信息由http发送给服务器</p><h4 id="什么是session"><a href="#什么是session" class="headerlink" title="什么是session"></a>什么是session</h4><p>session 是浏览器和服务器会话过程中，服务器会分配的一块储存空间给session。</p><p>服务器默认为客户浏览器的cookie中设置 sessionid，这个sessionid就和cookie对应，浏览器在向服务器请求过程中传输的cookie 包含 sessionid ，服务器根据传输cookie 中的 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。</p><h4 id="cookie与session区别"><a href="#cookie与session区别" class="headerlink" title="cookie与session区别"></a>cookie与session区别</h4><ul><li>cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高</li><li>单个cookie保存的数据不能超过4K，session无此限制</li><li>session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.jianshu.com/p/88d69454bdde" target="_blank" rel="noopener">tcp、http和socket的区别</a></li><li><a href="https://juejin.cn/post/6844903889146216456" target="_blank" rel="noopener">TCP/UDP协议详解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
          <category> https </category>
          
          <category> http2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> tcp/udp </tag>
            
            <tag> https </tag>
            
            <tag> http2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chrome: 并行配置不正确导致无法启动</title>
      <link href="/2021/03/21/chrome-%E5%B9%B6%E8%A1%8C%E9%85%8D%E7%BD%AE%E4%B8%8D%E6%AD%A3%E7%A1%AE%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/"/>
      <url>/2021/03/21/chrome-%E5%B9%B6%E8%A1%8C%E9%85%8D%E7%BD%AE%E4%B8%8D%E6%AD%A3%E7%A1%AE%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>启动chrome.exe突然提示: 应用程序无法打开，因为应用查询的并行配置错误，然后上网百度了下，记录了下，三个步骤</p><h3 id="右击自己的chrome快捷键，找到chrome的安装位置"><a href="#右击自己的chrome快捷键，找到chrome的安装位置" class="headerlink" title="右击自己的chrome快捷键，找到chrome的安装位置"></a>右击自己的chrome快捷键，找到chrome的安装位置</h3><h3 id="然后会看到两个ip地址类型的文件夹-找到两个文件夹的区别，然后把一个少manifest的文件从另一个ip地址的文件夹拷贝过去，并改成-当前ip地址的文件名"><a href="#然后会看到两个ip地址类型的文件夹-找到两个文件夹的区别，然后把一个少manifest的文件从另一个ip地址的文件夹拷贝过去，并改成-当前ip地址的文件名" class="headerlink" title="然后会看到两个ip地址类型的文件夹,找到两个文件夹的区别，然后把一个少manifest的文件从另一个ip地址的文件夹拷贝过去，并改成 当前ip地址的文件名"></a>然后会看到两个ip地址类型的文件夹,找到两个文件夹的区别，然后把一个少manifest的文件从另一个ip地址的文件夹拷贝过去，并改成 当前ip地址的文件名</h3><p><img src= "/img/loading.gif" data-src="/images/chrome/1.png" alt="chrome"><br><img src= "/img/loading.gif" data-src="/images/chrome/2.png" alt="chrome"></p><h3 id="编辑下文件mainfest-里面涉及到的ip地址也对应改下即可"><a href="#编辑下文件mainfest-里面涉及到的ip地址也对应改下即可" class="headerlink" title="编辑下文件mainfest,里面涉及到的ip地址也对应改下即可"></a>编辑下文件mainfest,里面涉及到的ip地址也对应改下即可</h3><p><img src= "/img/loading.gif" data-src="/images/chrome/3.png" alt="chrome"></p>]]></content>
      
      
      <categories>
          
          <category> chrome </category>
          
          <category> manifest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome </tag>
            
            <tag> manifest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收机制: 标记清除和引用计数</title>
      <link href="/2021/03/20/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E5%92%8C%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
      <url>/2021/03/20/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E5%92%8C%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>像C语言这样的底层语言一般都有底层的内存管理接口，比如 malloc()和free()用于分配内存和释放内存。<br>而对于JavaScript来说，会在创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放内存，这个自动释放内存的过程称为垃圾回收。<br>因为自动垃圾回收机制的存在，让大多Javascript开发者感觉他们可以不关心内存管理，所以会在一些情况下导致内存泄漏。</p><p>JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p><h2 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h2><p>JS 环境中分配的内存有如下声明周期：<br><img src= "/img/loading.gif" data-src="/images/gc/memory.png" alt="内存生命周期"><br>内存分配：当我们申明变量、函数、对象的时候，系统会自动为他们分配内存<br>内存使用：即读写内存，也就是使用变量、函数等<br>内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存</p><h3 id="JS-的内存分配"><a href="#JS-的内存分配" class="headerlink" title="JS 的内存分配"></a>JS 的内存分配</h3><p>JavaScript 在定义变量时就完成了内存分配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span>; <span class="comment">// 给数值变量分配内存</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"azerty"</span>; <span class="comment">// 给字符串分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">null</span></span><br><span class="line">&#125;; <span class="comment">// 给对象及其包含的值分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给数组及其包含的值分配内存（就像对象一样）</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">null</span>, <span class="string">"abra"</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">2</span>;</span><br><span class="line">&#125; <span class="comment">// 给函数（可调用的对象）分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式也能分配一个对象</span></span><br><span class="line">someElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  someElement.style.backgroundColor = <span class="string">'blue'</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="JS-的内存使用"><a href="#JS-的内存使用" class="headerlink" title="JS 的内存使用"></a>JS 的内存使用</h3><p>使用值的过程实际上是对分配内存进行读取与写入的操作。 读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">// 分配内存</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 对内存的使用</span></span><br></pre></td></tr></table></figure><h3 id="JS的内存回收"><a href="#JS的内存回收" class="headerlink" title="JS的内存回收"></a>JS的内存回收</h3><p>JS 有自动垃圾回收机制，那么这个自动垃圾回收机制的原理是什么呢？<br>其实很简单，就是找出那些不再继续使用的值，然后释放其占用的内存。<br>大多数内存管理的问题都在这个阶段。<br>在这里最艰难的任务是<strong>找到不再需要使用的变量</strong>。<br>不再需要使用的变量也就是生命周期结束的变量，是局部变量，局部变量只在函数的执行过程中存在，<br>当函数运行结束，没有其他引用(闭包)，那么该变量会被标记回收。<br>全局变量的生命周期直至浏览器卸载页面才会结束，也就是说<em>全局变量</em>不会被当成垃圾回收。<br>因为自动垃圾回收机制的存在，开发人员可以不关心也不注意内存释放的有关问题，但对无用内存的释放这件事是客观存在的。<br>不幸的是，即使不考虑垃圾回收对性能的影响，目前最新的垃圾回收算法，也无法智能回收所有的极端情况</p><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>标记-清除算法包含三个步骤：</p><ul><li>根：一般来说，根指的是代码中引用的全局变量。就拿 JavaScript 来说，window 对象即是根的全局变量。Node.js 中相对应的变量为 “global”。垃圾回收器会构建出一份所有根变量的完整列表。</li><li>随后，算法会检测所有的根变量及他们的后代变量并标记它们为激活状态(表示它们不可回收)。任何根变量所到达不了的变量(或者对象等等)都会被标记为内存垃圾。</li><li>最后，垃圾回收器会释放所有非激活状态的内存片段然后返还给操作系统。<br><img src= "/img/loading.gif" data-src="https://user-images.githubusercontent.com/1475173/40289792-0436a5be-5ced-11e8-9471-37f13d00966b.gif" alt="sweep"></li></ul><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>这是最初级的垃圾回收算法。</p><p>引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。 如果没有其他对象指向它了，说明该对象已经不再需了。<br>统计引用类型变量声明后被引用的次数，当次数为 0 时，该变量将被回收。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func4</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> c = &#123;&#125; <span class="comment">// 引用类型变量 c的引用计数为 0</span></span><br><span class="line">      <span class="keyword">let</span> d = c <span class="comment">// c 被 d 引用 c的引用计数为 1</span></span><br><span class="line">      <span class="keyword">let</span> e = c <span class="comment">// c 被 e 引用 c的引用计数为 2</span></span><br><span class="line">      d = &#123;&#125; <span class="comment">// d 不再引用c c的引用计数减为 1</span></span><br><span class="line">      e = <span class="literal">null</span> <span class="comment">// e 不再引用 c c的引用计数减为 0 将被回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o</span></span><br><span class="line"><span class="comment">// 很显然，没有一个可以被垃圾收集</span></span><br><span class="line"><span class="keyword">var</span> o = &#123; </span><br><span class="line">  a: &#123;</span><br><span class="line">    b:<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = o; <span class="comment">// o2变量是第二个对“这个对象”的引用</span></span><br><span class="line"></span><br><span class="line">o = <span class="number">1</span>;      <span class="comment">// 现在，“这个对象”的原始引用o被o2替换了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oa = o2.a; <span class="comment">// 引用“这个对象”的a属性</span></span><br><span class="line"><span class="comment">// 现在，“这个对象”有两个引用了，一个是o2，一个是oa</span></span><br><span class="line"></span><br><span class="line">o2 = <span class="string">"yo"</span>; <span class="comment">// 最初的对象现在已经是零引用了</span></span><br><span class="line">           <span class="comment">// 他可以被垃圾回收了</span></span><br><span class="line">           <span class="comment">// 然而它的属性a的对象还在被oa引用，所以还不能回收</span></span><br><span class="line"></span><br><span class="line">oa = <span class="literal">null</span>; <span class="comment">// a属性的那个对象现在也是零引用了</span></span><br><span class="line">           <span class="comment">// 它可以被垃圾回收了</span></span><br></pre></td></tr></table></figure><p>但这种方式存在缺陷，就是互相引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func5</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> f = &#123;&#125;</span><br><span class="line">      <span class="keyword">let</span> g = &#123;&#125;</span><br><span class="line">      f.prop = g</span><br><span class="line">      g.prop = f</span><br><span class="line">      <span class="comment">// 由于 f 和 g 互相引用，计数永远不可能为 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能手动清除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.prop = <span class="literal">null</span></span><br><span class="line">g.prop = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>在现代浏览器中，Javascript 使用的方式是标记清除，所以我们无需担心循环引用的问题</p><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露?"></a>内存泄露?</h2><p>内存泄露就是不再被需要的内存, 由于某种原因, 无法被释放.</p><h3 id="意外的全局变量造成内存泄漏"><a href="#意外的全局变量造成内存泄漏" class="headerlink" title="意外的全局变量造成内存泄漏"></a>意外的全局变量造成内存泄漏</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"你我贷"</span> <span class="comment">// 全局变量 =&gt; window.name</span></span><br><span class="line">    bar = <span class="string">'come on'</span> <span class="comment">// 没有声明变量 实际上是全局变量 =&gt; window.bar</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br></pre></td></tr></table></figure><p>在这种情况下this指向了全局变量window对象，意外的创建了全局变量. 我们谈到了一些意外情况下定义的全局变量, 代码中也有一些我们明确定义的全局变量. 如果使用这些全局变量用来暂存大量的数据, 记得在使用后, 对其重新赋值为 null.</p><h3 id="未销毁的定时器和回调函数造成内存泄露"><a href="#未销毁的定时器和回调函数造成内存泄露" class="headerlink" title="未销毁的定时器和回调函数造成内存泄露"></a>未销毁的定时器和回调函数造成内存泄露</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">poll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        timer &amp;&amp; clearTimeout(timer)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'11'</span>)</span><br><span class="line">        poll()</span><br><span class="line">    &#125;, <span class="number">400</span>);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroyer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    timer &amp;&amp; clearTimeout(timer) <span class="comment">// 一定要记得销毁定时器，不能只销毁定时器的引用</span></span><br><span class="line">    timer = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">poll()</span><br><span class="line"><span class="built_in">console</span>.log(timer)</span><br></pre></td></tr></table></figure><h3 id="闭包造成内存泄露"><a href="#闭包造成内存泄露" class="headerlink" title="闭包造成内存泄露"></a>闭包造成内存泄露</h3><h3 id="dom引用造成内存泄漏"><a href="#dom引用造成内存泄漏" class="headerlink" title="dom引用造成内存泄漏"></a>dom引用造成内存泄漏</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> elements = &#123;</span><br><span class="line">    txt: <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    elements.txt.innerHTML = <span class="string">"1111"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeTxt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'test'</span>));</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">removeTxt()</span><br><span class="line"><span class="built_in">console</span>.log(elements.txt)</span><br></pre></td></tr></table></figure><p>我们对 Dom 的操作, 会把 Dom 的引用保存在一个数组或者 对象 中。上述案例中, 即使我们对于 test 元素进行了移除, 但是仍然有对 test 元素的引用, 依然无法对其进行内存回收。</p><p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>);</span><br><span class="line"></span><br><span class="line">wm.set(element, <span class="string">'some information'</span>);</span><br><span class="line">wm.get(element) <span class="comment">// "some information"</span></span><br></pre></td></tr></table></figure><p>上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。</p><p>也就是说，上面的 DOM 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。</p><p>总之，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。<br>注意，WeakMap 弱引用的只是<strong>键名</strong>，而不是键值。键值依然是正常引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> key = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">wm.set(key, obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">wm.get(key)</span><br><span class="line"><span class="comment">// Object &#123;foo: 1&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，键值obj是正常引用。所以，即使在 WeakMap 外部消除了obj的引用，WeakMap 内部的引用依然存在。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><ul><li>echarts 造成内存泄漏<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">destroyed () &#123;</span><br><span class="line">    <span class="keyword">this</span>.chart.destroy()</span><br><span class="line">    <span class="keyword">this</span>.chart = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>g2造成内存泄漏</li><li>WeakMap 应用的典型场合就是 DOM 节点作为键名<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">myWeakmap.set(</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>),</span><br><span class="line">  &#123;<span class="attr">timesClicked</span>: <span class="number">0</span>&#125;)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> logoData = myWeakmap.get(<span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>));</span><br><span class="line">  logoData.timesClicked++;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>document.getElementById(‘logo’)是一个 DOM 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是这个节点对象。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。</li></ul><h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><ul><li><p>尽可能避免创建对象，非必要情况下避免调用会创建对象的方法，如 Array.slice、Array.map、Array.filter、字符串相加、$(‘div’)、ArrayBuffer.slice 等。</p></li><li><p>不再使用的对象，手动赋为 null，可避免循环引用等问题。</p></li><li><p>使用 Weakmap</p></li><li><p>生产环境勿用 console.log 大对象，包括 DOM、大数组、ImageData、ArrayBuffer 等。因为 console.log 的对象不会被垃圾回收。详见Will console.log prevent garbage collection?。</p></li><li><p>合理设计页面，按需创建对象/渲染页面/加载图片等。</p></li></ul><p>避免如下问题：</p><p>为了省事儿，一次性请求全部数据。<br>为了省事儿，一次性渲染全部数据，再做隐藏。<br>为了省事儿，一次性加载/渲染全部图片。<br>使用重复 DOM 等，如重复使用同一个弹窗而非创建多个。</p><p>如 Vue-Element 框架中，PopOver/Tooltip 等组件用于表格内时会创建 m * n 个实例，可优化为只创建一个实例，动态设置位置及数据。</p><ul><li><p>ImageData 对象是 JS 内存杀手，避免重复创建 ImageData 对象。</p></li><li><p>重复使用 ArrayBuffer(前端的一个通用的二进制缓冲区，类似数组，但在API和特性上却有诸多不同)</p></li><li><p>压缩图片、按需加载图片、按需渲染图片，使用恰当的图片尺寸、图片格式，如 WebP 格式。</p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://hub.fastgit.org/Troland/how-javascript-works/blob/master/memory-management.md" target="_blank" rel="noopener">Javascript 的垃圾回收机制</a></li><li><a href="https://juejin.cn/post/6844903943722500110" target="_blank" rel="noopener">记录一次定时器及闭包问题造成的内存泄漏</a></li><li><a href="https://zhuanlan.zhihu.com/p/97768916" target="_blank" rel="noopener">ArrayBuffer</a></li><li><a href="https://juejin.cn/post/6877353084519972878" target="_blank" rel="noopener">一文搞懂JS系列（三）之垃圾回收机制，内存泄漏，闭包</a></li><li><a href="https://juejin.cn/post/6844903869525262349" target="_blank" rel="noopener">「前端进阶」JS中的内存管理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> Gc </category>
          
          <category> closure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> Gc </tag>
            
            <tag> closure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具进阶: 初识webpack原理</title>
      <link href="/2021/03/14/%E5%B7%A5%E5%85%B7%E8%BF%9B%E9%98%B6-%E5%88%9D%E8%AF%86webpack%E5%8E%9F%E7%90%86/"/>
      <url>/2021/03/14/%E5%B7%A5%E5%85%B7%E8%BF%9B%E9%98%B6-%E5%88%9D%E8%AF%86webpack%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>目前本文介绍的是webpack的打包原理，还会有涉及到的</p><ol><li>webpack 构建流程(编译原理？)是怎样的？(本文)</li><li>webpack loader 和 plugin 的原理和区别？(更新中)</li><li>plugin 中有异步请求会阻塞后面的 plugin 吗？</li><li>webpack 热更新原理？</li><li>你webpack 是怎么做拆包(分包)的？</li><li>做过webpack 性能优化吗？</li></ol><p>webpack是高度复杂抽象的插件集合，理解webpack的运行机制，对于我们日常定位构建错误以及写一些插件处理构建任务有很大的帮助。<br>webpack 的作用是根据入口文件将源代码编译（构建、打包）成最终代码。中间经过webpack打包，打包的过程就是编译</p><h2 id="核心打包原理"><a href="#核心打包原理" class="headerlink" title="核心打包原理"></a>核心打包原理</h2><h3 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h3><p>  初始化 -&gt; 编译 -&gt; 输出</p><ul><li>初始化这个阶段,webpack会将CLI参数、配置文件、默认配置进行融合，形成一个最终的配置对象</li><li>编译阶段，1.创建chunk 2.构建所有依赖模块 3.产生 chunk assets 4.合并 chunk assets，</li><li>输出阶段，利用node模块里的fs模块，根据编译产生总的asset以及结合output输出文件</li></ul><h3 id="具体webpack细节"><a href="#具体webpack细节" class="headerlink" title="具体webpack细节"></a>具体webpack细节</h3><ul><li>获取主模块内容</li><li>分析模块<br>安装@babel/parser包（转AST）</li><li>对模块内容进行处理<br>安装@babel/traverse包（遍历AST收集依赖）<br>安装@babel/core和@babel/preset-env包（es6转ES5）</li><li>递归所有模块生成最终代码</li></ul><h3 id="重要的构建节点"><a href="#重要的构建节点" class="headerlink" title="重要的构建节点"></a>重要的构建节点</h3><p>webpack的构建中总会经历如下几个事件节点。<br>  before-run 清除缓存<br>  run 注册缓存数据钩子<br>  compile 开始编译<br>  make 从入口分析依赖以及间接依赖模块，创建模块对象<br>  build-module 模块构建<br>  seal 构建结果封装， 不可再更改<br>  after-compile 完成构建，缓存数据<br>  emit 输出到dist目录</p><p>其中make是整个构建中最核心的部分编译，通过模块工厂函数创建模块，然后对模块进行编译。</p><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2018/4/3/162891e3306cf41e?imageslim" alt="在make钩子的编译"></p><h2 id="构建封装seal"><a href="#构建封装seal" class="headerlink" title="构建封装seal"></a>构建封装seal</h2><p>到构建封装阶段时候，代码构建已经完毕，但是如何将这些代码按照依赖引用逻辑组织起来，当浏览器将你构建出来的代码加载到浏览器的时候，仍然能够正确执行。在webpack中通过Manifest记录各个模块的详细要点，通过Runtime来引导，加载执行模块代码，特别是异步加载。</p><h2 id="参考文件"><a href="#参考文件" class="headerlink" title="参考文件"></a>参考文件</h2><ul><li><a href="https://juejin.cn/post/6844903586942451726" target="_blank" rel="noopener">webpack的编译&amp;构建</a></li><li><a href="https://juejin.cn/post/6854818576470933512#heading-4" target="_blank" rel="noopener">Webpack 原理浅析</a></li><li><a href="https://juejin.cn/post/6854573217336541192#heading-7" target="_blank" rel="noopener">手写webpack核心原理，再也不怕面试官问我webpack原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/58151131?utm_source=com.daimajia.gold&utm_medium=social&utm_oi=631273285770547200" target="_blank" rel="noopener">理解webpack原理，手写一个100行的webpack</a></li><li><a href="https://juejin.cn/post/6935217623487643656#comment" target="_blank" rel="noopener">为女朋友解梦之——webpack编译原理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端框架Vue: 面试相关1</title>
      <link href="/2021/03/06/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6Vue-%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B31/"/>
      <url>/2021/03/06/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6Vue-%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B31/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue响应式原理"><a href="#Vue响应式原理" class="headerlink" title="Vue响应式原理"></a>Vue响应式原理</h3><h3 id="computed实现原理"><a href="#computed实现原理" class="headerlink" title="computed实现原理"></a>computed实现原理</h3><h3 id="nextTick原理"><a href="#nextTick原理" class="headerlink" title="$nextTick原理"></a>$nextTick原理</h3><p>(Vue的数据为什么频繁变化但只会更新一次)</p><h3 id="virtual-Dom-实现原理"><a href="#virtual-Dom-实现原理" class="headerlink" title="virtual Dom 实现原理"></a>virtual Dom 实现原理</h3><h3 id="Vue-生命周期过程"><a href="#Vue-生命周期过程" class="headerlink" title="Vue 生命周期过程"></a>Vue 生命周期过程</h3><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>-<a href="https://juejin.cn/post/6844904116339261447#heading-13" target="_blank" rel="noopener">2021年前端面试必读文章【超三百篇文章/赠复习导图】</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端基础: 网络-1</title>
      <link href="/2021/03/06/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80-%E7%BD%91%E7%BB%9C-1/"/>
      <url>/2021/03/06/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80-%E7%BD%91%E7%BB%9C-1/</url>
      
        <content type="html"><![CDATA[<h3 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h3><p>HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。<br>HTTPS主要作用是：<br>（1）对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;<br>（2）对网站服务器进行真实身份认证。</p><h4 id="http存在的问题"><a href="#http存在的问题" class="headerlink" title="http存在的问题"></a>http存在的问题</h4><ul><li>通信使用明文，内容可能被窃听</li><li>无法证明报文的完整性，所以可能遭篡改</li><li>不验证通信方的身份，因此有可能遭遇伪装</li></ul><p>反观Https，相比http多了一下优势</p><ul><li>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</li><li>数据完整性：内容传输经过完整性校验</li><li>身份认证：第三方无法伪造服务端（客户端）身份</li></ul><h4 id="HTTPS如何解决HTTP上述问题"><a href="#HTTPS如何解决HTTP上述问题" class="headerlink" title="HTTPS如何解决HTTP上述问题?"></a>HTTPS如何解决HTTP上述问题?</h4><p>在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。也就是说HTTP加上加密处理和认证以及完整性保护后即是HTTPS。<br>1.解决内容可能被窃听的问题——加密 方法3.对称加密+非对称加密(HTTPS采用这种方式)<br>2.解决报文可能遭篡改问题——数字签名<br>3.解决通信方身份可能被伪装的问题——数字证书</p><h4 id="https工作流程"><a href="#https工作流程" class="headerlink" title="https工作流程"></a>https工作流程</h4><p><img src= "/img/loading.gif" data-src="/images/network/https1.png" alt="https工作流程"><br>1.Client发起一个HTTPS的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。<br>2.Server把事先配置好的公钥证书（public key certificate）返回给客户端。<br>3.Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。<br>4.Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。<br>5.Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。<br>6.Server使用对称密钥加密“明文内容A”，发送给Client。<br>7.Client使用对称密钥解密响应的密文，得到“明文内容A”。<br>8.Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。</p><h4 id="https和http区别"><a href="#https和http区别" class="headerlink" title="https和http区别"></a>https和http区别</h4><ul><li>HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li><li>HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页;</li><li>HTTPS需要用到SSL证书，而HTTP不用;</li><li>Https默认端口号是443.而http默认端口号是80</li><li>HTTPS基于传输层，HTTP基于应用层;</li><li>HTTPS在浏览器显示安全锁，HTTP没有显示;</li></ul><h3 id="https做什么用的，以及https握手过程"><a href="#https做什么用的，以及https握手过程" class="headerlink" title="https做什么用的，以及https握手过程"></a>https做什么用的，以及https握手过程</h3><h3 id="tcp的握手过程"><a href="#tcp的握手过程" class="headerlink" title="tcp的握手过程"></a>tcp的握手过程</h3><p>TCP是什么？<br>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><p><img src= "/img/loading.gif" data-src="/images/network/tcp1.jpg" alt="https工作流程"></p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；<br>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。<br>完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。</p><p>另一个版本的三次握手<br>第一次握手<br>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。<br>第二次握手<br>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。<br>第三次握手<br>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。<br>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；<br>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；<br>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；<br>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><p>另一个版本的四次挥手<br>TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。<br>第一次握手<br>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。<br>第二次握手<br>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。<br>第三次握手<br>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。<br>第四次握手<br>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p><h3 id="tcp-udp的区别"><a href="#tcp-udp的区别" class="headerlink" title="tcp/udp的区别"></a>tcp/udp的区别</h3><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>UDP协议全称是 用户数据报协议 USER DATA Protocol，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>1.面向无连接<br>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。<br>2.有单播，多播，广播的功能<br>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。<br>3.UDP是面向报文的<br>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文<br>4.不可靠性<br>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p><p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。<br>5.头部开销小，传输数据报文时是很高效的。</p><h3 id="TCp"><a href="#TCp" class="headerlink" title="TCp"></a>TCp</h3><p>TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li>面向连接</li></ul><p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p><ul><li>仅支持单播传输</li></ul><p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p><ul><li>面向字节流</li></ul><p>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p><ul><li>可靠传输</li></ul><p>对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p><ul><li>提供拥塞控制</li></ul><p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</p><ul><li>TCP提供全双工通信</li></ul><p>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p><h3 id="TCP-UDP区别"><a href="#TCP-UDP区别" class="headerlink" title="TCP/UDP区别"></a>TCP/UDP区别</h3><table><thead><tr><th>特点</th><th>UDP</th><th>TCP</th></tr></thead><tbody><tr><td>是否连接</td><td>无连接</td><td>面向连接</td></tr><tr><td>是否可靠</td><td>不可靠传输 不使用流量控制和拥塞控制</td><td>可靠传输</td></tr><tr><td>连接对象个数</td><td>支持一对一，一对多，多对一和多对多交互通信</td><td>只能是一对一通信</td></tr><tr><td>传输方式</td><td>面向报文</td><td>面向字节流</td></tr><tr><td>首部开销</td><td>首部开销小 仅8字节</td><td>首部最小20字节，最大60字节</td></tr><tr><td>适用场景</td><td>适用实时应用(视频会议/直播)</td><td>适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.cn/post/6844903830916694030" target="_blank" rel="noopener">深入理解HTTPS工作原理</a></li><li><a href="https://juejin.cn/post/6844903521272201223#heading-18" target="_blank" rel="noopener">九个问题从入门到熟悉HTTPS</a></li><li><a href="https://juejin.cn/post/6884813913259524104#heading-10" target="_blank" rel="noopener">HTTPS 工作原理详解 | TLS握手过程</a></li><li><a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="noopener">通俗大白话来理解TCP协议的三次握手和四次分手 </a></li><li><a href="https://juejin.cn/post/6844903800336023560" target="_blank" rel="noopener">TCP和UDP比较</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
          <category> https </category>
          
          <category> http2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> https </tag>
            
            <tag> http2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础-前端重学-7</title>
      <link href="/2021/03/03/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-7/"/>
      <url>/2021/03/03/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-7/</url>
      
        <content type="html"><![CDATA[<h2 id="事件冒泡和事件捕获"><a href="#事件冒泡和事件捕获" class="headerlink" title="事件冒泡和事件捕获"></a>事件冒泡和事件捕获</h2><h3 id="事件冒泡和事件捕获的区别"><a href="#事件冒泡和事件捕获的区别" class="headerlink" title="事件冒泡和事件捕获的区别"></a>事件冒泡和事件捕获的区别</h3>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  事件冒泡: 事件从最内层的元素开始，一直向上传播，直到document。则在事件冒泡的概念上，应该是p -&gt; div -&gt; body -&gt; html -&gt; document<br>  事件捕获: 与事件冒泡相反，从最外层开始，直到具体元素</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(event, <span class="function"><span class="keyword">function</span>, <span class="title">useCapture</span>)</span></span><br></pre></td></tr></table></figure><p>  第一个参数是需要绑定的元素<br>  第二个参数是触发事件后要执行的函数<br>  第三个元素就是为事件冒泡还是捕获准备的<br>  默认是false,表示在事件冒泡阶段处理函数，<br>  true 则表示在事件捕获阶段处理函数</p><p>addEventListener方法用来为一个特定的元素绑定一个事件处理函数，</p><h3 id="事件冒泡与事件捕获应用"><a href="#事件冒泡与事件捕获应用" class="headerlink" title="事件冒泡与事件捕获应用:"></a>事件冒泡与事件捕获应用:</h3><p>  在实际开发中，利用事件流的特性，事件代理<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">"color_list"</span>&gt;        </span><br><span class="line">    &lt;li&gt;red&lt;<span class="regexp">/li&gt;        </span></span><br><span class="line"><span class="regexp">    &lt;li&gt;orange&lt;/</span>li&gt;        </span><br><span class="line">    &lt;li&gt;yellow&lt;<span class="regexp">/li&gt;        </span></span><br><span class="line"><span class="regexp">    &lt;li&gt;green&lt;/</span>li&gt;        </span><br><span class="line">    &lt;li&gt;blue&lt;<span class="regexp">/li&gt;        </span></span><br><span class="line"><span class="regexp">    &lt;li&gt;purple&lt;/</span>li&gt;    </span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="box"&gt;&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><br>这时就需要事件代理出场了，利用事件流的特性，我们只绑定一个事件处理函数也可以完成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">colorChange</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> e = e || <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="keyword">if</span> (e.target.nodeName.toLowerCase === <span class="string">'li'</span>) &#123;</span><br><span class="line">     box.innerHTML=<span class="string">"该颜色为 "</span>+e.target.innerHTML;         </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">color_list.addEventListener(<span class="string">"click"</span>, colorChange, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h2 id="Cors中的简单请求和复杂请求"><a href="#Cors中的简单请求和复杂请求" class="headerlink" title="Cors中的简单请求和复杂请求"></a>Cors中的简单请求和复杂请求</h2><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>cors: cross origin resource share 跨域资源共享<br>允许浏览器向跨域服务器发出xhr,从而克服跨域问题，需要浏览器和服务器同时支持。</p><ul><li>浏览器会自动往请求header里添加origin字段表明当前请求来源</li><li>服务器端需要设置响应头的Access-Control-Allow-origin/Methods/Headers 源 方法 头部信息等</li><li>请求分为简单请求和复杂请求，复杂请求发之前会发生Options类型的预检请求，看是否允许当前跨域请求<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3>简单请求<br>请求方法是以下三种方法之一：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HEAD</span><br><span class="line">GET</span><br><span class="line">POST</span><br><span class="line"></span><br><span class="line">HTTP的请求头信息不超出以下几种字段：</span><br><span class="line"></span><br><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type：只限于三个值application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain</span><br></pre></td></tr></table></figure><h4 id="后端的头部响应设置"><a href="#后端的头部响应设置" class="headerlink" title="后端的头部响应设置"></a>后端的头部响应设置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin：该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个&lt;code&gt;*&lt;<span class="regexp">/code&gt;，表示接受任意域名的请求。</span></span><br><span class="line"><span class="regexp">Access-Control-Allow-Credentials：该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。</span></span><br><span class="line"><span class="regexp">Access-Control-Expose-Headers：该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。</span></span><br></pre></td></tr></table></figure><h3 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h3>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是<strong>application/json</strong>。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求<em>（preflight）</em>。<br>Access-Control-Request-Method: Put/Delete 必须，表示当前请求会用到哪些Http方法<br>Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。<br>如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。</li></ul><h3 id="和JSONP请求对比"><a href="#和JSONP请求对比" class="headerlink" title="和JSONP请求对比"></a>和JSONP请求对比</h3><ul><li>Jsonp只能支持get请求，而cors支持所有http请求方法</li><li>JSONP优势在于支持老是浏览器，以及可以向不支持CORS的网站请求数据</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.cn/post/6844903928442667015#heading-25" target="_blank" rel="noopener">面试分享：两年工作经验成功面试阿里P6总结</a></li><li><a href="https://juejin.cn/post/6844904150459908103" target="_blank" rel="noopener">CORS跨域请求[简单请求与复杂请求]</a></li></ul><h2 id="Set和Map的区别"><a href="#Set和Map的区别" class="headerlink" title="Set和Map的区别"></a>Set和Map的区别</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Es6新的数据结构。类似于数组，成员唯一，没有重复的值<br>Set本身是构造函数，用来生成Set数据结构.</p><h3 id="WeakSet-与-Set区别"><a href="#WeakSet-与-Set区别" class="headerlink" title="WeakSet 与 Set区别"></a>WeakSet 与 Set区别</h3><ul><li>WeakSet成员只能是对象，不能是其他类型的值</li><li>WeakSet的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。<br>因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</li></ul><p>由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。</p><h3 id="WeakSet应用"><a href="#WeakSet应用" class="headerlink" title="WeakSet应用"></a>WeakSet应用</h3><ul><li>WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</li><li>确保实例方法只能在实例上调用，<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foos = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    foos.add(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  method () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!foos.has(<span class="keyword">this</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Foo.prototype.method 只能在Foo的实例上调用！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>上面代码保证了Foo的实例方法，只能在Foo的实例上调用。这里使用 WeakSet 的好处是，foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑foos，也不会出现内存泄漏。</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>js对象，本质上是键值对的集合<em>(hash结构)</em>。</p><p>以前对象里的key只能是字符串，Map里阔以用对象当作key，Object结构提供了<em>字符串-值<em>的对应结构，Map结构提供了</em>值-值</em> 的数据结构，是一种更完善的hash结构实现。</p><ul><li>Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</li><li>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。</li></ul><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>WeakMap结构与Map结构类似，也是用于生成键值对的集合。</p><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p>weakMap只接受对象作为键名（null 除外），不接受其他类型的值作为键名key。<br>weakMap它的键名所指向的对象都是弱引用，即垃圾回收机制不会将该引用考虑在内。<br>因此只要所引用对象的<strong>其他引用</strong>都被清除，GC就会释放该引用对象所占的内存，也就是说，一旦不需要，weakMap里的键名对象和对应的键值对会自动消失，不用手动删除引用。</p><p>WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>);</span><br><span class="line"></span><br><span class="line">wm.set(element, <span class="string">'some information'</span>);</span><br><span class="line">wm.get(element) <span class="comment">// "some information"</span></span><br></pre></td></tr></table></figure><p>WeakMap对element就是弱引用，不会被计入垃圾回收机制。也就是说，上面dom节点引用计数是1，一旦消除该节点的引用，所占用的内存即会被释放，WeakMap里保存的键值对也会自动消失</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ol><li>DOM节点作为键名 注意是键名<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">myWeakmap.set(</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>),</span><br><span class="line">  &#123;<span class="attr">timesClicked</span>: <span class="number">0</span>&#125;)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> logoData = myWeakmap.get(<span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>));</span><br><span class="line">  logoData.timesClicked++;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>上面代码中，document.getElementById(‘logo’)是一个 DOM 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的<em>键名</em>就是这个节点对象。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。</li></ol><p>2.WeakMap 部署私有属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SimCard = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> _private = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">SimCard</span> </span>&#123;</span><br><span class="line">   <span class="keyword">constructor</span>(number, type, p1, p2) &#123;</span><br><span class="line">        _private.set(<span class="string">'p1'</span>, p1)</span><br><span class="line">        _private.set(<span class="string">'p2'</span>, p2)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> p1() &#123;</span><br><span class="line">        <span class="keyword">return</span> _private.get(<span class="string">'p1'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> p2() &#123;</span><br><span class="line">        <span class="keyword">return</span> _private.get(<span class="string">'p2'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> SimCard</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> SimCard(<span class="string">'one'</span>, <span class="string">'two'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(test.p1) <span class="comment">// 'one'</span></span><br><span class="line"><span class="built_in">console</span>.log(test.p2) <span class="comment">// 'two'</span></span><br><span class="line"><span class="built_in">console</span>.log(test._private) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.cn/post/6844903863921672200#heading-1" target="_blank" rel="noopener">ECMAScript 类 —— 定义私有属性</a></li><li><a href="https://es6.ruanyifeng.com/#docs/set-map#Map" target="_blank" rel="noopener">map</a></li></ul><h2 id="vue-slot是做什么的"><a href="#vue-slot是做什么的" class="headerlink" title="vue slot是做什么的"></a>vue slot是做什么的</h2><h2 id="实现bind函数"><a href="#实现bind函数" class="headerlink" title="实现bind函数"></a>实现bind函数</h2><h2 id="实现一个并发请求控制函数"><a href="#实现一个并发请求控制函数" class="headerlink" title="实现一个并发请求控制函数"></a>实现一个并发请求控制函数</h2><h2 id="参考链接-2"><a href="#参考链接-2" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://juejin.cn/post/6844903834075021326" target="_blank" rel="noopener">你真的理解 事件冒泡 和 事件捕获 吗？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 重新认识this</title>
      <link href="/2021/02/28/%E5%9F%BA%E7%A1%80-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86this/"/>
      <url>/2021/02/28/%E5%9F%BA%E7%A1%80-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86this/</url>
      
        <content type="html"><![CDATA[<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p><img src= "/img/loading.gif" data-src="/images/this/executable.png" alt="执行上下文生命周期"><br>当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p><p>可执行代码<br>这就要说到 JavaScript 的可执行代码(executable code)的类型有哪些了？<br>其实很简单，就三种，全局代码、函数代码、eval代码。<br>举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution contexts)”。</p><p>对于每个执行上下文，都有三个重要属性：</p><ul><li>变量对象(Variable object，VO)</li><li>作用域链(Scope chain)</li><li>this</li></ul><p>执行上下文的创建阶段，会分别生成变量对象，建立作用域链，确定this指向，谨记this的指向，是在<em>函数被调用<em>的时候确定的。也就是</em>执行上下文被创建时<em>确定的。且在函数执行过程中，</em>this一旦被确定，就不可更改了</em></p><p>this 并不是取决于他所在的位置，而是取决于他所在的Function是如何调用的<br>构造函数中的 this ，就是指向即将实例化的那个对象。谨记！</p><h2 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h2><p>在全局执行上下文中this都指代全局对象。<br>在浏览器里面this等价于window对象，如果你声明一些全局变量，这些变量都会作为this的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过this绑定到全局对象</span></span><br><span class="line"><span class="keyword">this</span>.a2 = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 通过声明绑定到变量对象，但在全局环境中，变量对象就是它自身</span></span><br><span class="line"><span class="keyword">var</span> a1 = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 仅仅只有赋值操作，标识符会隐式绑定到全局对象</span></span><br><span class="line">a3 = <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 输出结果会全部符合预期</span></span><br><span class="line"><span class="built_in">console</span>.log(a1);</span><br><span class="line"><span class="built_in">console</span>.log(a2);</span><br><span class="line"><span class="built_in">console</span>.log(a3);</span><br></pre></td></tr></table></figure><h2 id="函数上下文-函数中的this"><a href="#函数上下文-函数中的this" class="headerlink" title="函数上下文,函数中的this"></a>函数上下文,函数中的this</h2><ul><li>demo<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  c: <span class="keyword">this</span>.a + <span class="number">20</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.c); </span><br><span class="line"><span class="built_in">console</span>.log(obj.fn());</span><br></pre></td></tr></table></figure>注意这里的<br>obj: {<br>c: this.a + 20<br>} <blockquote><p>单独的{}不会形成新的作用域，因此这里的this.a，由于并没有作用域的限制，它仍然处于全局作用域之中。所以这里的this其实是指向的window对象。</p></blockquote></li></ul><h3 id="直接调用"><a href="#直接调用" class="headerlink" title="直接调用"></a>直接调用</h3><p>this指向全局变量, this === window </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo() === <span class="built_in">window</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="作为对象的一个方法"><a href="#作为对象的一个方法" class="headerlink" title="作为对象的一个方法"></a>作为对象的一个方法</h3><p>this指向调用函数的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"cpp"</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// cpp</span></span><br></pre></td></tr></table></figure><p>稍不留心写成了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"cpp"</span>,</span><br><span class="line">  getName: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// '' 返回空字符串</span></span><br></pre></td></tr></table></figure><p>这是因为下面要说的箭头函数</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>所有的箭头函数都没有自己的this，都指向外层,<br>1.没有自己的this、super、arguments和new.target绑定。<br>2.不能使用new来调用。<br>3.没有原型对象。<br>4.不可以改变this的绑定。<br>5.形参名称不能重复。<br>MDN中的解释</p><blockquote><p>An arrow function does not create its own this, the this value of the enclosing execution context is used.<br>箭头函数会捕获其所在上下文的this值，作为自己的this值。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"xb"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"sb"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.say()); <span class="comment">// sb</span></span><br></pre></td></tr></table></figure><h4 id="哪些场景下不能使用箭头函数"><a href="#哪些场景下不能使用箭头函数" class="headerlink" title="哪些场景下不能使用箭头函数"></a>哪些场景下不能使用箭头函数</h4><p>1.在一个对象上，定义一个指向函数的属性，当方法被调用时，方法内的this指向方法所属的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calculator = &#123;</span><br><span class="line">  array: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  sum: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// =&gt; true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.array.reduce(<span class="function">(<span class="params">result, item</span>) =&gt;</span> result + item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="comment">// Throws "TypeError: Cannot read property 'reduce' of undefined"</span></span><br><span class="line">calculator.sum();</span><br></pre></td></tr></table></figure><p>2.定义原型方法<br>3.定义事件回调函数<br>4.定义构造函数</p><h3 id="作为一个构造函数"><a href="#作为一个构造函数" class="headerlink" title="作为一个构造函数"></a>作为一个构造函数</h3><p>this被绑定到正在构造的实例中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">30</span>;</span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">":"</span> + <span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"cpp"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// cpp</span></span><br><span class="line">person.say(); <span class="comment">// cpp:30</span></span><br></pre></td></tr></table></figure><h2 id="this绑定优先级"><a href="#this绑定优先级" class="headerlink" title="this绑定优先级"></a>this绑定优先级</h2><p>优先级是new 调用 &gt; call、apply、bind 调用 &gt; 对象上的函数调用 &gt; 普通函数调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'person'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> doSth = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'return:'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Student = &#123;</span><br><span class="line">    name: <span class="string">'若川'</span>,</span><br><span class="line">    doSth: doSth</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通函数调用</span></span><br><span class="line">doSth(); <span class="comment">// window</span></span><br><span class="line"><span class="comment">// 对象上的函数调用</span></span><br><span class="line">Student.doSth(); <span class="comment">// '若川'</span></span><br><span class="line"><span class="comment">// call、apply 调用</span></span><br><span class="line">Student.doSth.call(person); <span class="comment">// 'person'</span></span><br><span class="line"><span class="keyword">new</span> Student.doSth.call(person) <span class="comment">//  VM36:21 Uncaught TypeError: Student.doSth.call is not a constructor</span></span><br></pre></td></tr></table></figure><p>最后一个执行报错<br>这是因为函数内部有两个不同的方法：[[Call]]和[[Constructor]]。<br>当使用普通函数调用时，[[Call]]会被执行。当使用构造函数调用时，[[Constructor]]会被执行。call、apply、bind和箭头函数内部没有[[Constructor]]方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>new 调用：绑定到新创建的对象，注意：显示return函数或对象，返回值不是新创建的对象，而是显式返回的函数或对象。</li><li>call 或者 apply（ 或者 bind） 调用：严格模式下，绑定到指定的第一个参数。非严格模式下，null和undefined，指向全局对象（浏览器中是window），其余值指向被new Object()包装的对象。</li><li>对象上的函数调用：绑定到那个对象。</li><li>普通函数调用： 在严格模式下绑定到 undefined，否则绑定到全局对象。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/axuebin/articles/issues/6" target="_blank" rel="noopener">JavaScript基础心法——this </a></li><li><a href="https://juejin.cn/post/6844903746984476686#heading-8" target="_blank" rel="noopener">面试官问：JS的this指向</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> this </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端安全-xss和csrf</title>
      <link href="/2021/02/28/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8-xss%E5%92%8Ccsrf/"/>
      <url>/2021/02/28/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8-xss%E5%92%8Ccsrf/</url>
      
        <content type="html"><![CDATA[<h2 id="csrf"><a href="#csrf" class="headerlink" title="csrf"></a>csrf</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>csrf: 跨站请求伪造 cross site Request <strong>forgery</strong> 或者简称xsrf。是指在挟持用户当前已经登录的web应用程序当中执行非本意操作的攻击方法。<br>另一个是xss cross site script 跨站脚本攻击，两者区别是 xss利用用户对网站的信任，csrf利用的则是网站对用户网页浏览器的信任</p><blockquote><p>简单来说就是利用用户的登录态发起恶意请求</p></blockquote><h3 id="如何攻击的"><a href="#如何攻击的" class="headerlink" title="如何攻击的"></a>如何攻击的</h3><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2018/8/8/1651a22ce6858fd9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="csrf"></p><h3 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h3><p>遵循以下几种原则:<br>1.get请求不对数据进行修改<br>2.禁止第三方网站访问到用户cookie<br>3.阻止第三方网站请求接口<br>4.请求时附带验证信息，比如tocken或者验证码</p><p>具体措施</p><h4 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h4><p>对cookie设置SameSite属性，设置之后cookie信息不会随着跨域请求发送，很大程度上减少CSRF攻击</p><h4 id="验证referer"><a href="#验证referer" class="headerlink" title="验证referer"></a>验证referer</h4><p>在对需要防范csrf的请求中，我们阔以根据请求头中的referer属性来判断请求来源</p><h4 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h4><p>服务器下发随机token，前端每次发请求携带token，后端验证token的有效性</p><h4 id="防抓包"><a href="#防抓包" class="headerlink" title="防抓包"></a>防抓包</h4><p>使用https替换http(https还是通过http进行传输，只是信息经过tls协议加密，对传输的数据进行加密，当请求的信息被抓包工具抓包时，无法修改提交的数据)</p><h2 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h2><p>xss cross site script 跨站脚本攻击<br>通过在客户端注入可执行脚本的方式实行攻击</p><h3 id="主要方式"><a href="#主要方式" class="headerlink" title="主要方式"></a>主要方式</h3><ul><li><p>劫持Html ,通过script标签进行注入</p></li><li><p>在可执行的js中，通过拼接数据来执行恶意脚本 </p></li><li><p>在页面可执行的dom元素，添加可执行代码，比如javascript:xx</p></li><li><p>在onload/onClick事件中注入不受控制的代码</p></li></ul><h3 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h3><p>有存储型Xss 反射型Xss 以及DOM型Xss,跟前端有关的是DOM型Xss,其他防范主要在后端</p><h4 id="存储型Xss"><a href="#存储型Xss" class="headerlink" title="存储型Xss"></a>存储型Xss</h4><p>恶意脚本存储在后端数据库，然后又传输到前台页面，从而发生攻击。防范主要是通过文本转义</p><h4 id="反射型Xss"><a href="#反射型Xss" class="headerlink" title="反射型Xss"></a>反射型Xss</h4><p>恶意脚本不是存储在后端，而是出现在url里，防范主要是<br>区分两者主要看恶意代码的存储位置</p><h4 id="Dom型Xss"><a href="#Dom型Xss" class="headerlink" title="Dom型Xss"></a>Dom型Xss</h4><p>不需要跟后端交互，主要是通过劫持Html文件进行修改实现恶意代码的注入<br>在DOM api中通过 textContext/setAttribute来代替.innerHtml/docuemnt.write Vue中不建议用v-html</p><h3 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h3><h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><p>在存储型XSS和反射型XSS攻击中，这个是一个关键的防范方式，通过对不同类型的<strong>文本和数据</strong>做对应的转义和很好的防止大部分的XSS攻击</p><h4 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h4><p>通过在脚本增加 <em>Content-security-Policy</em> 字段来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content-security-policy: <span class="keyword">default</span>-src <span class="string">'self'</span></span><br></pre></td></tr></table></figure><p>在较严格的CSP模式下，具有以下作用<br>1.禁止加载外域代码<br>2.禁止内联脚本执行<br>3.禁止外域提交<br>4.禁止未授权的脚本执行<br>5.通过csp上报 便于修复</p><h4 id="httponly"><a href="#httponly" class="headerlink" title="httponly"></a>httponly</h4><p>cookie里的一个属性，主要防止cookie属性被改写，该属性主要是防止cookie被js获取，只能通过http传输和访问<br>httpOnly本质上不能防止xss攻击，主要是起到缓解作用，在恶意脚本执行之后无法获取cookie,防止下一步的攻击和用户数据泄露</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://juejin.cn/post/6892938793901359112" target="_blank" rel="noopener">前端安全-XSS</a></li><li><a href="https://juejin.cn/post/6844903653757698062" target="_blank" rel="noopener">关于csrf,什么是csrf,怎么防范它?</a></li><li><a href="https://yuchengkai.cn/docs/frontend/#%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">前端面试</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> xss </category>
          
          <category> csrf </category>
          
          <category> csp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
            <tag> csrf </tag>
            
            <tag> csp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法基础: BFS和DFS</title>
      <link href="/2021/02/21/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-BFS%E5%92%8CDFS/"/>
      <url>/2021/02/21/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-BFS%E5%92%8CDFS/</url>
      
        <content type="html"><![CDATA[<h2 id="DFS-深度优先遍历"><a href="#DFS-深度优先遍历" class="headerlink" title="DFS 深度优先遍历"></a>DFS 深度优先遍历</h2><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output: [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = []</span><br><span class="line">  <span class="keyword">var</span> path = []</span><br><span class="line">  <span class="keyword">var</span> dfs = <span class="function">(<span class="params">path, nums</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length === nums.length) &#123;</span><br><span class="line">      res.push(path)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!path.includes(num)) &#123;</span><br><span class="line">          path.push(num)</span><br><span class="line">          dfs(path.slice(), nums)</span><br><span class="line">          path.pop()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(path, nums)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue进阶: 依赖收集原理</title>
      <link href="/2021/02/15/vue%E8%BF%9B%E9%98%B6-%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%E5%8E%9F%E7%90%86/"/>
      <url>/2021/02/15/vue%E8%BF%9B%E9%98%B6-%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>一对多关系解耦的行为设计模式，主要涉及两个角色，观察者和观察目标<br> 观察者直接订阅观察目标，观察目标(订阅中心)做出通知，观察者就要进行处理</p><h3 id="vue依赖收集"><a href="#vue依赖收集" class="headerlink" title="vue依赖收集"></a>vue依赖收集</h3><p>  <img src= "/img/loading.gif" data-src="/images/vue/depend.png" alt="vue依赖收集"><br>  每个组件实例都会有相应的Watcher实,渲染组件的过程，会把属性记录为依赖，当我们操作数据的时候，依赖项的setter会被调用，从而通知Watcher重新计算，从而使得相关的组件得以更新。</p><p>  Getter里进行依赖收集，当依赖的数据被更新时，会触发该数据的setter,setter里会触发render函数重新计算</p><h3 id="依赖收集与观察者模式"><a href="#依赖收集与观察者模式" class="headerlink" title="依赖收集与观察者模式"></a>依赖收集与观察者模式</h3><p>vue依赖收集的场景既是一对多，一个数据发生变更，多处用到该数据的地方都得处理。而且依赖的数据变了，即必须要做出处理。<br>vue里，<strong>依赖</strong>的数据是观察目标(Dep, 订阅中心)，依赖就是Dep<br>视图、计算属性、侦听器等算是观察者(watcher),用到该数据的就是观察者(Watcher)</p><h3 id="源码解析vue依赖收集"><a href="#源码解析vue依赖收集" class="headerlink" title="源码解析vue依赖收集"></a>源码解析vue依赖收集</h3><h4 id="三个角色"><a href="#三个角色" class="headerlink" title="三个角色"></a>三个角色</h4><p>Dep: 扮演观察目标的角色，每一个数据都会有一个Dep类的实例，内部有subs队列，保存着依赖本数据的观察者Watcher,当本数据变更时，调用实例dep.notify通知观察者Watcher</p><p>Watcher: 扮演观察者的角色，进行观察者函数 的包装处理，render函数会被包装成一个Watcher实例</p><p>Observer: 辅助的可观测类，数组和对象通过其转化，可成为可观测数据</p><h4 id="每一个数据都会有一个Dep类的实例：观察目标"><a href="#每一个数据都会有一个Dep类的实例：观察目标" class="headerlink" title="每一个数据都会有一个Dep类的实例：观察目标"></a>每一个数据都会有一个Dep类的实例：观察目标</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> target = <span class="literal">null</span> <span class="comment">// 指向对应的Watcher实例</span></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.uid ++;</span><br><span class="line">    <span class="keyword">this</span>.subs = []; <span class="comment">// 管理watcher实例</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加watcher实例</span></span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 依赖</span></span><br><span class="line">  depend() &#123;</span><br><span class="line">    <span class="comment">// Dep.target指向对应的watcher实例 </span></span><br><span class="line">    <span class="comment">// this 指向Dep实例</span></span><br><span class="line">    Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// setter触发watcher更新</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">var</span> subs = <span class="keyword">this</span>.subs.slice();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于JavaScript是单线程模型，所以虽然有多个观察者函数，但是一个时刻内，就只会有一个观察者函数在执行，那么此刻正在执行的那个观察者函数，所对应的Watcher实例，便会被赋给Dep.target这一类变量，从而只要访问Dep.target就能知道当前的观察者是谁。在后续的依赖收集工作里，getter里会调用dep.depend()，而setter里则会调用dep.notify();</p><h4 id="配置观测数据"><a href="#配置观测数据" class="headerlink" title="配置观测数据"></a>配置观测数据</h4><p>observe主要是给每层数据加一个私有属性<strong><strong>ob</strong></strong>，同时这个<strong>ob</strong>是 Observer类的一个实例，总结来说就是给对象和数组实例化一个Observer实例，且在依赖的数据是可配置的时候才会实例化。<br>在<strong>ob</strong>上挂载dep实例，用来处理改变内容的情况，以便能够形成追踪链路。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value, asRootData</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果不是Object类型则不能观测 </span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> ob;</span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Observer类代码: 辅助的可观测类，数组和对象通过其转化，可成为可观测数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Observer = <span class="function"><span class="keyword">function</span> <span class="title">Observer</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = value;</span><br><span class="line">  <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep(); <span class="comment">// 实例化一个观察目标对象，只管理当前的依赖</span></span><br><span class="line">  <span class="keyword">this</span>.vmCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// def(value, '__ob__', this);</span></span><br><span class="line">  <span class="comment">// this 既是当前实例化的Observer实例</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(value, <span class="string">'__ob__'</span>, &#123;</span><br><span class="line">    value: <span class="keyword">this</span>, <span class="comment">// 当前的Observer实例</span></span><br><span class="line">    enumerable: !!enumerable,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">      protoAugment(value, arrayMethods);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      copyAugment(value, arrayMethods, arrayKeys);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.observeArray(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.walk(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Observer.prototype.walk = <span class="function"><span class="keyword">function</span> <span class="title">walk</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    defineReactive$$<span class="number">1</span>(obj, keys[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">Observer.prototype.observeArray = <span class="function"><span class="keyword">function</span> <span class="title">observeArray</span> (<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">    observe(items[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>创建一个Dep管理当前依赖 （这里我们可以叫大管家dep后续会讲到为什么是大管家）</p></li><li><p>区分数组还是对象做不同的响应式处理</p></li><li><p>对象的情况直接调用walk方法</p></li><li><p>数组的情况需要判断是否有原型 （老的ie是没有的）<br>在数组有原型的情况直接调protoAugment进行原型覆盖（这里主要是为了数组的增删改因为Object.defineProperty在语言层面检测不到数组的变化所以需要自己覆盖下数组的原型使用自己的方法检测）<br>在数组没有原型的情况调copyAugment复制一份</p></li><li><p>Observer类就是: 将Observer实例挂载在<strong><em>ob</em></strong>属性上，提供后续观测数据使用。同时实例化一个Dep(观察目标)类实例。同时将对象、数组绑定在value对象上，即</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原数据</span></span><br><span class="line">data: &#123;</span><br><span class="line">  name: <span class="string">'cpp'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改造后</span></span><br><span class="line">data: &#123;</span><br><span class="line">  name: <span class="string">'cpp'</span>,</span><br><span class="line">  __ob__: &#123; <span class="comment">// Observer实例</span></span><br><span class="line">    dep: <span class="keyword">new</span> Dep(), <span class="comment">// dep依赖收集器 观察目标 订阅器 信息中心 各种叫法</span></span><br><span class="line">    value: data, <span class="comment">// 数据本身data</span></span><br><span class="line">    vmCount: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> name: ƒ reactiveGetter(),</span><br><span class="line">  <span class="keyword">get</span> name: ƒ reactiveSetter(newVal),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如果value是个对象，就执行walk-过程，遍历对象把每一项数据都变为可观测数据（调用defineReactive方法处理）"><a href="#如果value是个对象，就执行walk-过程，遍历对象把每一项数据都变为可观测数据（调用defineReactive方法处理）" class="headerlink" title="如果value是个对象，就执行walk()过程，遍历对象把每一项数据都变为可观测数据（调用defineReactive方法处理）"></a>如果value是个对象，就执行<em>walk()</em>过程，遍历对象把每一项数据都变为可观测数据（调用defineReactive方法处理）</h4><p>Observer里依赖收集：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据改造成属性getter/setter</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive$$1</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj,</span></span></span><br><span class="line"><span class="function"><span class="params">  key,</span></span></span><br><span class="line"><span class="function"><span class="params">  val,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 每个引用类型的属性都有自己的dep，用于收集该引用类型自动的依赖</span></span><br><span class="line">  <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep(); <span class="comment">// </span></span><br><span class="line">  <span class="keyword">var</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">  <span class="keyword">var</span> getter = property &amp;&amp; property.get;</span><br><span class="line">  <span class="keyword">var</span> setter = property &amp;&amp; property.set;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      <span class="keyword">var</span> value = getter ? getter.call(obj) : val; <span class="comment">// </span></span><br><span class="line">      <span class="comment">// Dep.target指向当前的Watcher</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend(); <span class="comment">// 把当前的Watcher添加到当前的dep.subs中</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal;</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">      <span class="comment">// 数据变更 观察目标通知观察者</span></span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>defineReactive</em>方法做了下面几件事</p><ul><li>为每个属性实例化一个dep依赖收集器，用于收集该属性的相关依赖(这里的dep我们可以看成 小管家dep只管理自己当前的依赖)</li><li>缓存属性原有的get和set方法，保证后面重写get、set方法时行为正常</li><li>对子属性进行observer递归</li><li>将对象中的每一个属性都加上<strong>getter、setter</strong>方法</li></ul><p>这里就是通过Object.defineProperty将数据变成响应式的过程并且和watcher创建依赖关系<br>经过defineReactive处理的数据变化如下, 每个属性都有自己的dep、childOb、getter、setter，并且每个object类型的属性都有<strong>ob</strong></p><p>getter方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line"><span class="comment">//调用原属性的get方法返回值</span></span><br><span class="line"><span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">    <span class="comment">//如果存在需要被收集的依赖 Dep.target指向当前的Watcher</span></span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        <span class="comment">/* 将依赖收集到该属性的dep中 */</span></span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          <span class="comment">//每个对象的childOb.__ob__.dep中也收集该依赖</span></span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="comment">//如果属性是array类型，进行dependArray操作</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>做了2件事<br>1.调用属性的getter方法返回值<br>2.收集依赖<br>  a.Dep.target表示一个依赖，即观察者Watcher类的实例，大部分情况下是一个依赖函数。<br>  b.如果存在需要被收集的依赖，则收集依赖的数据到该属性的dep依赖收集器中,每个属性都有一个dep(实例化的Dep)属性<br>  c.如果存在childOb,则依赖收集到value.<strong>ob</strong>.dep.depend();<br>  d.如果属性的值是数组，调用dependArray函数，将依赖收集到数组中的每一个对象元素的<strong>ob</strong>.dep中。确保在使用this.$set 或 Vue.set时，数组中嵌套的对象能正常响应。代码如下：<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  user: [</span><br><span class="line">    name: <span class="string">'cpp'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 页面显示</span></span><br><span class="line">&#123;&#123;user&#125;&#125;</span><br><span class="line">&lt;Button @click=<span class="string">"addAge()"</span>&gt;addAge&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/addAge方法,为数组中的嵌套对象添加age属性</span></span><br><span class="line"><span class="regexp">addAge: function()&#123;</span></span><br><span class="line"><span class="regexp">this.$set(this.user[0], 'age', 18)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><br>dependArray函数如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dependArray</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> e = (<span class="keyword">void</span> <span class="number">0</span>), i = <span class="number">0</span>, l = value.length; i &lt; l; i++) &#123;</span><br><span class="line">    e = value[i];</span><br><span class="line">     <span class="comment">//将依赖收集到每一个子对象/数组中</span></span><br><span class="line">    e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(e)) &#123;</span><br><span class="line">      dependArray(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化后的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//转化后数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  user: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'summer'</span>,</span><br><span class="line">      __ob__: &#123;user[<span class="number">0</span>], dep, vmCount&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    __ob__: &#123;user, dep, vmCount&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>（所谓依赖，就是这个组件所需要依赖到的数据）</strong></p></blockquote><h4 id="总结一句话就是在getter方法中，将存在的观察者Watcher收集到Dep中，由Dep中的subs统一管理，集中维护"><a href="#总结一句话就是在getter方法中，将存在的观察者Watcher收集到Dep中，由Dep中的subs统一管理，集中维护" class="headerlink" title="总结一句话就是在getter方法中，将存在的观察者Watcher收集到Dep中，由Dep中的subs统一管理，集中维护"></a>总结一句话就是在getter方法中，将存在的观察者Watcher收集到Dep中，由Dep中的subs统一管理，集中维护</h4><h4 id="如果value是个数组，就执行observeArray-过程，递归地对数组元素调用observe-，以便能够对元素还是数组的情况进行处理"><a href="#如果value是个数组，就执行observeArray-过程，递归地对数组元素调用observe-，以便能够对元素还是数组的情况进行处理" class="headerlink" title="如果value是个数组，就执行observeArray()过程，递归地对数组元素调用observe()，以便能够对元素还是数组的情况进行处理."></a>如果value是个数组，就执行observeArray()过程，递归地对数组元素调用observe()，以便能够对元素还是数组的情况进行处理.</h4><p>相关代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">    <span class="comment">// protoAugment(value, arrayMethods);</span></span><br><span class="line">    value.__proto__ = arrayMethods</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    copyAugment(value, arrayMethods, arrayKeys);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 递归观测数组中的每一个值</span></span><br><span class="line">  <span class="keyword">this</span>.observeArray(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Observer原型上的observeArray方法</span></span><br><span class="line">Observer.prototype.observeArray = <span class="function"><span class="keyword">function</span> <span class="title">observeArray</span> (<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">    observe(items[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>1.使用protoAugment方法指定value值的原型链为arrayMethods函数，<br>2.遍历数组中的每一个值，调用observer方法，使其观测</p><h4 id="arrayMethods-拦截修改数组方法"><a href="#arrayMethods-拦截修改数组方法" class="headerlink" title="arrayMethods 拦截修改数组方法"></a>arrayMethods 拦截修改数组方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayProto = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="keyword">var</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto);</span><br><span class="line"><span class="keyword">var</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">];</span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> original = arrayProto[method];</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [], len = <span class="built_in">arguments</span>.length;</span><br><span class="line">    <span class="keyword">while</span> ( len-- ) args[ len ] = <span class="built_in">arguments</span>[ len ];</span><br><span class="line">    <span class="keyword">var</span> result = original.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    <span class="keyword">var</span> ob = <span class="keyword">this</span>.__ob__;</span><br><span class="line">    <span class="keyword">var</span> inserted;</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对新增元素使用observerArray方法进行观测</span></span><br><span class="line">    <span class="keyword">if</span> (inserted) &#123; ob.observeArray(inserted); &#125;</span><br><span class="line">    <span class="comment">// notify change 触发__ob__.dep中的所有依赖</span></span><br><span class="line">    ob.dep.notify();</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>arrayMethods做了几件事<br>1.需要拦截的修改数组的方法有：push、pop、shift、unshift、splice、sort、reverse<br>2.当数组有新增元素时，使用observeArray对新增的元素进行观测<br>3.拦截数组的方法，当修改数组方法被调用时触发数组中的<strong>ob</strong>.dep的所有依赖(ob.dep.notify();)</p><h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4><p>只关心数据，数据发生变化的时候，Dep.notify() =&gt; Watcher.update()</p><p>Watcher扮演的角色是观察者，它关心数据，在数据变化后能够获得通知，并作出处理。一个组件里可以有多个Watcher类实例，Watcher类包装观察者函数，而观察者函数使用数据。 观察者函数经过Watcher是这么被包装的： </p><ul><li>模板渲染：<br><code>this._watcher = new Watcher(this, render, this._update)</code></li><li>计算属性：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    name() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">会包装成</span></span><br><span class="line"><span class="comment">new Watcher(this, function name() &#123;</span></span><br><span class="line"><span class="comment">    return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`</span></span><br><span class="line"><span class="comment">&#125;, callback);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>Watcher主要代码如下<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    vm: Component, // 组件实例</span><br><span class="line">    expOrFn: string | Function, // 观察者函数 即上述的function name函数 </span><br><span class="line">    cb: Function, // 回调函数</span><br><span class="line">    options?: ?Object, // 选项</span><br><span class="line">    isRenderWatcher?: boolean</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = !!options.deep</span><br><span class="line">      <span class="keyword">this</span>.user = !!options.user</span><br><span class="line">      <span class="keyword">this</span>.lazy = !!options.lazy</span><br><span class="line">      <span class="keyword">this</span>.sync = !!options.sync</span><br><span class="line">      <span class="keyword">this</span>.before = options.before</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = <span class="keyword">this</span>.user = <span class="keyword">this</span>.lazy = <span class="keyword">this</span>.sync = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.deps = [] <span class="comment">// 缓存上一轮执行观察者函数用到的dep实例</span></span><br><span class="line">    <span class="keyword">this</span>.newDeps = [] <span class="comment">// 存储本轮执行观察者函数用到的dep实例</span></span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>() <span class="comment">// Hash表，用于快速查找</span></span><br><span class="line">    <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>() <span class="comment">// Hash表，用于快速查找</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 视图更新</span></span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">      <span class="keyword">this</span>.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 订阅观察目标</span></span><br><span class="line">  addDep(dep) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.id</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">      <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">        dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/45081605" target="_blank" rel="noopener">深入解析Vue依赖收集原理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> vue源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 观察者模式 </tag>
            
            <tag> 依赖收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法基础: 树和二叉搜索树</title>
      <link href="/2021/02/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2021/02/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-src="/images/tree/tree.jpg" alt="树"></p><p>应用场景广泛，可惜我个小菜鸟几乎全跪！！！如何提高？</p><h2 id="二叉树和二叉搜索树"><a href="#二叉树和二叉搜索树" class="headerlink" title="二叉树和二叉搜索树"></a>二叉树和二叉搜索树</h2><p>二叉树: 书中的节点最多只能有2个节点，一个是左侧子节点，一个是右侧子节点<br>二叉搜索树(BST): 二叉树种的一种，但是只允许你在左侧存储比父节点小的值，右侧存储比父节点大的值 </p><h3 id="两颗相同的树"><a href="#两颗相同的树" class="headerlink" title="两颗相同的树"></a>两颗相同的树</h3><p>题目:<br>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>答案:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">p</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">q</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSameTree = <span class="function"><span class="keyword">function</span>(<span class="params">p, q</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  p.val === q.val &amp;&amp; isSameTree(p.right, q.right) &amp;&amp; isSameTree(p.left, q.left)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>链接: <a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">100. 相同的树</a></p><h3 id="二叉搜索树的中序遍历"><a href="#二叉搜索树的中序遍历" class="headerlink" title="二叉搜索树的中序遍历"></a>二叉搜索树的中序遍历</h3><p>中序遍历是一种上行顺序访问树中所有节点的遍历方式<br>中序遍历的应用场景就是对树进行排序，也就是一从最小到最大的顺序访问所有子节点</p><p>题目: 给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p><h4 id="解题1-递归遍历"><a href="#解题1-递归遍历" class="headerlink" title="解题1 递归遍历"></a>解题1 递归遍历</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = []</span><br><span class="line">    <span class="keyword">const</span> inOder = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node !== <span class="literal">null</span>) &#123;</span><br><span class="line">            inOder(node.left)</span><br><span class="line">            arr.push(node.val)</span><br><span class="line">            inOder(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    inOder(root)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="解题2-迭代遍历"><a href="#解题2-迭代遍历" class="headerlink" title="解题2 迭代遍历"></a>解题2 迭代遍历</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">inOrderTravserseIterator(root) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = []; <span class="comment">// 最终的结果</span></span><br><span class="line">  <span class="keyword">const</span> stack = []</span><br><span class="line">  <span class="keyword">while</span>(root) &#123;</span><br><span class="line">    stack.push(root)</span><br><span class="line">    root= root.left</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(stack.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = stack.pop(); <span class="comment">// 栈顶的节点出栈</span></span><br><span class="line">    res.push(current.val)</span><br><span class="line">    current = current.right; <span class="comment">// 获取右子树</span></span><br><span class="line">    <span class="keyword">while</span>(current) &#123;</span><br><span class="line">      stack.push(current)</span><br><span class="line">      current = current.left</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/images/tree/inOrder.png" alt="迭代遍历"><br>链接：</p><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/" target="_blank" rel="noopener">二叉搜索树的中序遍历</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/shou-hua-tu-jie-yong-zhan-mo-ni-zhong-xu-bian-li-z/" target="_blank" rel="noopener">「手画图解」用栈模拟中序遍历，怎么做以及为什么 | 递归与迭代</a></li></ul><h3 id="二叉树先序遍历"><a href="#二叉树先序遍历" class="headerlink" title="二叉树先序遍历"></a>二叉树先序遍历</h3><p>优先以后代节点的顺序访问每个节点的，跟中序不一样的是，先序遍历会优先访问节点本身，然后在访问她的左侧节点，最后是右侧子节点<br>应用场景是打印一个结构化的文档</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = []</span><br><span class="line">    <span class="keyword">const</span> inOder = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node !== <span class="literal">null</span>) &#123;</span><br><span class="line">            arr.push(node.val)</span><br><span class="line">            inOder(node.left)</span><br><span class="line">            inOder(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    inOder(root)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>先访问节点的后代节点，在访问节点本身，应用场景主要是计算一个目录及其子目录中所有文件所占空间的大小</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = []</span><br><span class="line">    <span class="keyword">const</span> postOrder = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">            postOrder(node.left)</span><br><span class="line">            postOrder(node.right)</span><br><span class="line">            arr.push(node.val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrder(root)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="层序遍历、"><a href="#层序遍历、" class="headerlink" title="层序遍历、"></a>层序遍历、</h3><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。<br>示例：<br>二叉树：[3,9,20,null,null,15,7],<br>得到:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="广度遍历bfs"><a href="#广度遍历bfs" class="headerlink" title="广度遍历bfs"></a>广度遍历bfs</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;<span class="keyword">return</span> []&#125;;</span><br><span class="line">    <span class="comment">// bfs</span></span><br><span class="line">    <span class="comment">// 根节点放入队列</span></span><br><span class="line">    <span class="keyword">let</span> queue = [root]</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">while</span>(queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> len = queue.length;</span><br><span class="line">        <span class="keyword">let</span> arr = []</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="comment">// 依次取出队列中的中塞到每一层的arr</span></span><br><span class="line">            <span class="keyword">let</span> node = queue.shift()</span><br><span class="line">            arr.push(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left) &#123;</span><br><span class="line">              queue.push(node.left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right) &#123;</span><br><span class="line">              queue.push(node.right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(arr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="dfs深度遍历"><a href="#dfs深度遍历" class="headerlink" title="dfs深度遍历"></a>dfs深度遍历</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">levelOrderdfs() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.root) &#123;<span class="keyword">return</span> []&#125;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">node, step, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!res[step]) &#123;</span><br><span class="line">        res[step] = []</span><br><span class="line">      &#125;</span><br><span class="line">      res[step].push(node.key)</span><br><span class="line">      dfs(node.left, step + <span class="number">1</span>, res);</span><br><span class="line">      dfs(node.right, step + <span class="number">1</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="keyword">this</span>.root, <span class="number">0</span>, res)</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>递归的结束条件：当遍历到 null 节点，它们的高度是 0，返回 0。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> leftMaxDepth = maxDepth(root.left);</span><br><span class="line">      <span class="keyword">const</span> rightMaxDepth = maxDepth(root.right);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">Math</span>.max(leftMaxDepth, rightMaxDepth)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最小深度"><a href="#最小深度" class="headerlink" title="最小深度"></a>最小深度</h3><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明：叶子节点是指没有子节点的节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span>  <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">Math</span>.min(minDepth(root.right), minDepth(root.left))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树所有路径"><a href="#二叉树所有路径" class="headerlink" title="二叉树所有路径"></a>二叉树所有路径</h3><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p>说明: 叶子节点是指没有子节点的节点。<br>实例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输入:</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span></span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">5</span></span><br><span class="line"></span><br><span class="line">输出: [<span class="string">"1-&gt;2-&gt;5"</span>, <span class="string">"1-&gt;3"</span>]</span><br><span class="line"></span><br><span class="line">解释: 所有根节点到叶子节点的路径为: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>, <span class="number">1</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-paths" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-paths</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 树 </category>
          
          <category> 二叉搜索树 </category>
          
          <category> 中序、先序、后序、层序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉搜索树 </tag>
            
            <tag> 中序、先序、后序、层序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构进阶: 链表</title>
      <link href="/2021/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6-%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>链表还是没啥数据概念，多做做点题目，理解理解链表</p><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ul><li>迭代<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = head</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">while</span>(current) &#123;</span><br><span class="line">        <span class="keyword">const</span> next = current.next</span><br><span class="line">        current.next = pre</span><br><span class="line">        pre = current</span><br><span class="line">        current = next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><p><img src= "/img/loading.gif" data-src="/images/linkedList/swap_ex1.jpg" alt="两两交换"></p><p>输入：head = [1,2,3,4]<br>输出：[2,1,4,3]</p><h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a>示例 1</h4><p>输入：head = [1]<br>输出：[1]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>对于不熟悉链表数据结构的同学还是画画流程图，图画好了基本能明白大概了</p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两两交换</span></span><br><span class="line">swapPairs() &#123;</span><br><span class="line">  <span class="keyword">const</span> head = <span class="keyword">this</span>.head</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> helper = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> tempNext = node.next</span><br><span class="line">    <span class="keyword">if</span> (tempNext) &#123;</span><br><span class="line">      <span class="keyword">const</span> tempNextNext = node.next.next</span><br><span class="line">      node.next.next = node</span><br><span class="line">      <span class="keyword">if</span> (tempNextNext) &#123;</span><br><span class="line">        node.next = helper(tempNextNext)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.next = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tempNext || node</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.head = helper(head);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'head'</span>, <span class="keyword">this</span>.head);</span><br><span class="line">  <span class="comment">// return res</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码位置 <a href="https://github.com/niaogege/webpack-learn/blob/linkedList/src/linkedList/main.js" target="_blank" rel="noopener">链表问题1</a></p></blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/submissions/" target="_blank" rel="noopener">两两交换链表中的节点</a></li><li><a href="https://juejin.cn/post/6847009772500156429#heading-8" target="_blank" rel="noopener">链表问题</a></li></ul><h2 id="环形链表一"><a href="#环形链表一" class="headerlink" title="环形链表一"></a>环形链表一</h2><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p><img src= "/img/loading.gif" data-src="/images/linkedList/circularlinkedlist.png" alt="两两交换"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><h3 id="解法1-hash表"><a href="#解法1-hash表" class="headerlink" title="解法1 hash表"></a>解法1 hash表</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hasCycle() &#123;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">  <span class="keyword">if</span> (!current || !current.next) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">while</span>(current.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.has(current)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    map.set(current, <span class="literal">true</span>)</span><br><span class="line">    current = current.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法2-数组"><a href="#解法2-数组" class="headerlink" title="解法2 数组"></a>解法2 数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = head</span><br><span class="line">    <span class="keyword">const</span> arr = [];</span><br><span class="line">    <span class="keyword">while</span>(current !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr.includes(current)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arr.push(current)</span><br><span class="line">      &#125;</span><br><span class="line">      current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解法3-快慢指针"><a href="#解法3-快慢指针" class="headerlink" title="解法3 快慢指针"></a>解法3 快慢指针</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fast = head;</span><br><span class="line">    <span class="keyword">let</span> slow = head;</span><br><span class="line">    <span class="keyword">while</span>(slow &amp;&amp; fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        slow = slow.next</span><br><span class="line">        <span class="keyword">if</span> (slow === fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://leetcode-cn.com/problems/linked-list-cycle" target="_blank" rel="noopener">判圈算法</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle/solution/shuang-jie-fa-floydsuan-fa-ha-xi-biao-javascriptsh/" target="_blank" rel="noopener">哈希表</a></li></ul><h2 id="环形链表二"><a href="#环形链表二" class="headerlink" title="环形链表二"></a>环形链表二</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：返回索引为 <span class="number">1</span> 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><h3 id="解法1-hash"><a href="#解法1-hash" class="headerlink" title="解法1 hash"></a>解法1 hash</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = head</span><br><span class="line">    <span class="keyword">if</span> (!current || !current.next) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">while</span>(current !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (map.has(current)) &#123;</span><br><span class="line">        <span class="keyword">return</span> current</span><br><span class="line">      &#125;</span><br><span class="line">      map.set(current, <span class="literal">true</span>)</span><br><span class="line">      current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解法2快慢指针"><a href="#解法2快慢指针" class="headerlink" title="解法2快慢指针"></a>解法2快慢指针</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fast = head,</span><br><span class="line">        slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针确定有环</span></span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确定有环，开始找环的第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (fast === slow) &#123;</span><br><span class="line">            slow = head;</span><br><span class="line">            <span class="keyword">while</span> (slow !== fast) &#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/submissions/" target="_blank" rel="noopener">环形链表二</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/142huan-xing-lian-biao-iishuang-zhi-zhen-ha-xi-bia/" target="_blank" rel="noopener">142.环形链表 II【双指针、哈希表】</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
            <tag> leetCode </tag>
            
            <tag> 排序链表 </tag>
            
            <tag> 两两反向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔: 35岁该何去何从</title>
      <link href="/2021/02/06/%E9%9A%8F%E7%AC%94-35%E5%B2%81%E8%AF%A5%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E/"/>
      <url>/2021/02/06/%E9%9A%8F%E7%AC%94-35%E5%B2%81%E8%AF%A5%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E/</url>
      
        <content type="html"><![CDATA[<p>马上就到了35岁，还有五年的光阴，想抓住最后的年轻红利，大声喊出我们的口号:<br>Formulation for decade, freedom forever.<br>五年布局，百年自由</p><p>接下来的时间(3月底)，重点关注</p><ul><li>webpack编译相关</li><li>vue源码级别的面试题</li><li>栈和队列<br>聚焦上面两项，为自由奋斗！！！</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 中年油腻大叔 </tag>
            
            <tag> 三十而立 </tag>
            
            <tag> 闲笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: Promise.all/any/race/allSettled手写</title>
      <link href="/2021/01/16/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-Promise-all-race-any-allSettled%E6%89%8B%E5%86%99/"/>
      <url>/2021/01/16/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-Promise-all-race-any-allSettled%E6%89%8B%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>Promise以下几个api，直接手写，便于理解。<br>学习就是一个渐进的过程，第一遍看不懂，第二遍只能领略皮毛，后面再看，仔细品味，感觉还是不错的</p><h3 id="Promise-all-Iterator"><a href="#Promise-all-Iterator" class="headerlink" title="Promise.all(Iterator)"></a>Promise.all(Iterator)</h3><p>Promise.all() 方法会将多个 Promise 实例组合成一个新的 Promise 实例<br>1.传入的参数必须可迭代<br>2.传入的实例不一定是Promise,必须再用Promise.resolve()包装下<br>3.组合后的Promise实例，只有当每个包含的Promise实例都解决才去解决（fulFilled）,当然如果有一个Promise实例被拒绝的话,则合成的Promise会拒绝(rejected)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写all</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve( <span class="number">1</span> );</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve( <span class="built_in">Promise</span>.resolve( <span class="string">'111'</span> ) );</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="built_in">Promise</span>.reject(<span class="string">'error'</span>)</span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(</span><br><span class="line">res =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;,</span><br><span class="line">err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(err)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">Promise</span>.myAll = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;    </span><br><span class="line">        <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> res = [];</span><br><span class="line">        <span class="keyword">var</span> len = arr.length</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> [i, p] <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(</span><br><span class="line">                data =&gt; &#123;</span><br><span class="line">                    res[i] = data;</span><br><span class="line">                    index ++</span><br><span class="line">                    <span class="keyword">if</span> (index === len) &#123;</span><br><span class="line">                        resolve(res)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                err =&gt; &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Promise</span>.myAll([p1, p2, p3]).then(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res, <span class="string">'res success'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(err, <span class="string">'err'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="comment">// error err</span></span><br></pre></td></tr></table></figure><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><p>Promise.all的反向操作，只有当每个包含的Promise实例都拒绝了，合成的promise才会拒绝rejected</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.reject( <span class="number">1</span> );</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.reject(<span class="built_in">Promise</span>.resolve( <span class="string">'222'</span> ));</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="built_in">Promise</span>.reject(<span class="string">'my error'</span>)</span><br><span class="line"><span class="built_in">Promise</span>.any([p1, p2, p3]).then(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(err)</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">Promise</span>.myAny = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> index= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> res = [];</span><br><span class="line">        <span class="keyword">var</span> len = arr.length</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> [i, p] <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(</span><br><span class="line">                data =&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> resolve(data)</span><br><span class="line">                &#125;,</span><br><span class="line">                err =&gt; &#123;</span><br><span class="line">                    res[i] = err;</span><br><span class="line">                    index ++</span><br><span class="line">                    <span class="keyword">if</span> (index === len) &#123;</span><br><span class="line">                        reject(<span class="string">'this is end'</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.myAny([p1, p2, p3]).then(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(err)</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// AggregateError: All promises were rejecte</span></span><br><span class="line"><span class="comment">// this is end</span></span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>只要有一个请求有响应值，请求就会结束，返回有响应的那个promise结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写race</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve( <span class="number">1</span> );</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="built_in">Promise</span>.resolve( <span class="string">'222'</span> ));</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="built_in">Promise</span>.reject(<span class="string">'my error'</span>)</span><br><span class="line"><span class="built_in">Promise</span>.race([p3, p2, p1]).then(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(err)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">Promise</span>.myRace = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> p <span class="keyword">of</span> arr) &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(</span><br><span class="line">              data =&gt; &#123;</span><br><span class="line">                  <span class="keyword">return</span> resolve(data)</span><br><span class="line">              &#125;,</span><br><span class="line">              err =&gt; &#123;</span><br><span class="line">                  reject(err, <span class="string">'myRace err'</span>)</span><br><span class="line">              &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.myRace([p3, p2, p1]).then(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(err)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// my error</span></span><br><span class="line"><span class="comment">// my error</span></span><br></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p>Promise.allSettled() 方法也是返回一个合成的 Promise，不过只有等到所有 Promise 实例都返回结果落定时，不管是解决(fulfilled)还是拒绝(rejected)，合成的 Promise 才会结束。一旦结束，状态总是 fulfilled。</p><p>等所有的成功和失败的结果都有了才会返回promise结果,失败的时候返回{}成功的时候返回，组成一个失败和成功的组合的promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写allSettled</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve( <span class="number">1</span> );</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve( <span class="built_in">Promise</span>.resolve( <span class="string">'111'</span> ) );</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="built_in">Promise</span>.reject(<span class="string">'error'</span>)</span><br><span class="line"><span class="built_in">Promise</span>.allSettled([p1, p2, p3]).then(</span><br><span class="line">  res =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 第一种实现</span></span><br><span class="line"><span class="built_in">Promise</span>.myAllSettled = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;    </span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> res = [];</span><br><span class="line">        <span class="keyword">const</span> len = arr.length</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> [i, p] <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(</span><br><span class="line">                data =&gt; &#123;</span><br><span class="line">                    res[i] = &#123;<span class="attr">status</span>: <span class="string">'fifilled'</span>, <span class="attr">value</span>: data&#125;;</span><br><span class="line">                    index ++</span><br><span class="line">                    <span class="keyword">if</span> (index === len) &#123;</span><br><span class="line">                        <span class="keyword">return</span> resolve(res)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                err =&gt; &#123;</span><br><span class="line">                    res[i] = &#123;<span class="attr">status</span>: <span class="string">'rejected'</span>, <span class="attr">reason</span>: err&#125;;</span><br><span class="line">                    index ++</span><br><span class="line">                    <span class="keyword">if</span> (index === len) &#123;</span><br><span class="line">                        <span class="keyword">return</span> resolve(res)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Promise</span>.myAllSettled([p1, p2, p3]).then(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res, <span class="string">'res success'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(err, <span class="string">'err'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 第二种实现</span></span><br><span class="line"><span class="built_in">Promise</span>.myAllSettled = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> promiseAll = [...arr]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promiseAll.map(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(e).then(</span><br><span class="line">            res =&gt; &#123;<span class="keyword">return</span> &#123;<span class="attr">status</span>: <span class="string">'fifilled'</span>, <span class="attr">value</span>: res&#125;&#125;,</span><br><span class="line">            err =&gt; &#123;<span class="keyword">return</span> &#123;<span class="attr">status</span>: <span class="string">'rejected'</span>, <span class="attr">reason</span>: err&#125;&#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;))  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的结果格式</span></span><br><span class="line">[</span><br><span class="line">  &#123;<span class="attr">status</span>: <span class="string">'fulfilled'</span>, <span class="attr">value</span>: <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">status</span>: <span class="string">'fulfilled'</span>, <span class="attr">value</span>: <span class="string">'111'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">status</span>: <span class="string">'rejected'</span>, <span class="attr">reason</span>: <span class="string">'error'</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.cn/post/6907673648216145928#heading-18" target="_blank" rel="noopener">一次写过瘾」手写Promise全家桶+Generator+async/await</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> promise </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-手写async/await</title>
      <link href="/2021/01/16/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-%E6%89%8B%E5%86%99async-await/"/>
      <url>/2021/01/16/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-%E6%89%8B%E5%86%99async-await/</url>
      
        <content type="html"><![CDATA[<p>手写之前先学习下async/await</p><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。<br><strong>异步</strong>的简写，用于申明一个函数是异步的，而await用于等待一个异步方法执行完成，await只能出现在async函数中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getData = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'data'</span>), <span class="number">3000</span>))</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> data = <span class="keyword">await</span> getData()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'data: '</span>, data);</span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">await</span> getData()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'data2: '</span>, data2);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'success'</span></span><br><span class="line">&#125;</span><br><span class="line">test().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="comment">// data: data</span></span><br><span class="line"><span class="comment">// data2: data</span></span><br><span class="line"><span class="comment">// success</span></span><br></pre></td></tr></table></figure><p>换成generator函数就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">yield</span> getData()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'data: '</span>, data);</span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">yield</span> getData()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'data2: '</span>, data2);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'success'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>async函数就是将  Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</p><p>async函数对 Generator 函数的改进，体现在以下四点。</p><ul><li>内置执行器。<br>Generator函数的执行必须靠执行器，而async函数自带执行器，不许再跳用next方法</li><li>更好的语义<br>async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</li><li>更广的适用性<br>yield/await</li><li>返回值是 Promise<br>async返回的是<strong>Promise</strong>,你阔以用then指定下一步操作。而Generator返回的是Iterator迭代器对象。<br>async函数完全能理解成多个异步操作，<strong>包装成</strong>一个Promise对象, async函数是Generator函数的语法糖，而<strong>await命令就是内部的then命令的语法糖</strong><br>总的解释就是:<br>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。<h2 id="手写async-单说async"><a href="#手写async-单说async" class="headerlink" title="手写async(单说async)"></a>手写async(单说async)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>模拟实现async<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'foo function'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data = foo()</span><br><span class="line">data.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟async</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_async</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="built_in">Promise</span>.resolve(fn(...args))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'foo function'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data = _async(foo)()</span><br><span class="line">data.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'data'</span>)</span><br><span class="line"><span class="comment">// foo function</span></span><br><span class="line"><span class="comment">// data</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>await使用场景</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(n + <span class="number">200</span>), n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step2 with <span class="subst">$&#123;m&#125;</span> and <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(m + n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">k, m, n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step3 with <span class="subst">$&#123;k&#125;</span>, <span class="subst">$&#123;m&#125;</span> and <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(k + m + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">const</span> time2 = <span class="keyword">await</span> step1(time1);</span><br><span class="line">    <span class="keyword">const</span> time3 = <span class="keyword">await</span> step2(time1, time2);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> step3(time1, time2, time3);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用<em>Promise</em>如何实现1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(n + <span class="number">200</span>), n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step2 with <span class="subst">$&#123;m&#125;</span> and <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(m + n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">k, m, n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step3 with <span class="subst">$&#123;k&#125;</span>, <span class="subst">$&#123;m&#125;</span> and <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(k + m + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    step1(time1)</span><br><span class="line">    .then(<span class="function">(<span class="params">time2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> step2(time1, time2).then(</span><br><span class="line">            time3 =&gt; [time1, time2,time3]</span><br><span class="line">        )</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">rest</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> [time1, time2, time3] = rest</span><br><span class="line">        <span class="keyword">return</span> step3(time1, time2, time3)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Promise解法二</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    step1(time1).then(<span class="function">(<span class="params">res1</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> time2 = res1;</span><br><span class="line">        step2(time1, time2).then(<span class="function">(<span class="params">res2</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> time3 = res2;</span><br><span class="line">            step3(time1, time2, time3).then(<span class="function">(<span class="params">res3</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;res3&#125;</span>`</span>);</span><br><span class="line">                <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><p>await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中，或者await后的Promise添加catch回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> read(<span class="string">'1.txt'</span>,<span class="string">'utf8'</span>)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="手写-await"><a href="#手写-await" class="headerlink" title="手写 await"></a>手写 await</h2><p>如果是手动执行里面的执行器，则需要这么实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getData = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'data'</span>), <span class="number">3000</span>))</span><br><span class="line"><span class="built_in">console</span>.log(getData(), <span class="string">'getData'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">testG</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="keyword">yield</span> getData()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'data1'</span>, data)</span><br><span class="line">    <span class="keyword">var</span> data2 = <span class="keyword">yield</span> getData()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'data2'</span>,data2)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'success'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> gg = testG()</span><br><span class="line"><span class="keyword">var</span> dataPromise = gg.next()</span><br><span class="line">dataPromise.value.then(<span class="function">(<span class="params">val1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data2proimse = gg.next(val1);</span><br><span class="line">    <span class="built_in">console</span>.log(data2proimse, <span class="string">'data2proimse'</span>)</span><br><span class="line">    data2proimse.value.then(<span class="function">(<span class="params">val2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> data3 = gg.next(val2);</span><br><span class="line">        gg.next()</span><br><span class="line">        <span class="built_in">console</span>.log(data3, <span class="string">'da ta3'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p> 大神版模拟async/await</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getData = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'data'</span>), <span class="number">3000</span>))</span><br><span class="line"><span class="built_in">console</span>.log(getData(), <span class="string">'getData'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncToGenerator</span>(<span class="params">generatorFunc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> gen = generatorFunc.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">key, arg</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">let</span> generatorResult</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            generatorResult = gen[key](arg)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">return</span> reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">const</span> &#123; value, done &#125; = generatorResult</span><br><span class="line">          <span class="keyword">if</span> (done) &#123;</span><br><span class="line">            <span class="keyword">return</span> resolve(value)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(value).then(</span><br><span class="line">            val =&gt; step(<span class="string">'next'</span>, val), </span><br><span class="line">            err =&gt; step(<span class="string">'throw'</span>, err))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step(<span class="string">"next"</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> gg = asyncToGenerator(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>* <span class="title">testG</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> data = <span class="keyword">yield</span> getData()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'data1'</span>, data)</span><br><span class="line">        <span class="keyword">var</span> data2 = <span class="keyword">yield</span> getData()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'data2'</span>,data2)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'success'</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">gg().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res, <span class="string">'res'</span>))</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://juejin.cn/post/6844904164133175309" target="_blank" rel="noopener">手写async、await、generator核心逻辑</a></li><li><a href="https://juejin.cn/post/6844904102053281806" target="_blank" rel="noopener">手写async await的最简实现（20行）</a></li><li><a href="https://juejin.cn/post/6844903586481209358" target="_blank" rel="noopener">Async +Await</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> Iterator </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
            <tag> Iterator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶:loader和plugin插件学习</title>
      <link href="/2021/01/09/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-loader%E5%92%8Cplugin%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/01/09/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-loader%E5%92%8Cplugin%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack-loader和plugin配置项"><a href="#webpack-loader和plugin配置项" class="headerlink" title="webpack loader和plugin配置项"></a>webpack loader和plugin配置项</h2><blockquote><p>npx webpack –mode=development</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    <span class="comment">// 转换 ES6 代码，解决浏览器兼容问题</span></span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="string">'/\.js$/'</span>,</span><br><span class="line">      exclude: <span class="string">'/node_modules/'</span>,</span><br><span class="line">      use: [</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'babel-loader'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: path.join(__dirname, <span class="string">'../loader/cpp-loader,js'</span>),</span><br><span class="line">          options: &#123;  </span><br><span class="line">            log: <span class="string">'hello loader'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>简单来说，loader就是一个nodejs模块，loader 是导出为一个函数的 node 模块。该函数在 loader 转换资源的时候调用。给定的函数将调用 <a href="https://www.webpackjs.com/api/loaders/#%E5%90%8C%E6%AD%A5-loader" target="_blank" rel="noopener">API</a>，并通过 this 上下文访问。<br>比如这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>); <span class="comment">// loader 工具库 ，调用loaderUtils.getOptions拿到webpack配置参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'————source'</span>, source);</span><br><span class="line">  <span class="keyword">const</span> options = loaderUtils.getOptions(<span class="keyword">this</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'————options'</span>, options);</span><br><span class="line">  <span class="keyword">return</span> source</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出一个函数</span></span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure><h3 id="loader前置知识"><a href="#loader前置知识" class="headerlink" title="loader前置知识"></a>loader前置知识</h3><ul><li><p>loader 支持链式调用。链中的每个 loader 会将转换应用在已处理过的资源上。一组链式的 loader 将按照相反的顺序执行。链中的第一个 loader 将其结果（也就是应用过转换后的资源）传递给下一个 loader，依此类推。最后，链中的最后一个 loader，返回 webpack 所期望的 JavaScript。</p></li><li><p>loader 可以是同步的，也可以是异步的。</p></li><li><p>loader 运行在 Node.js 中，并且能够执行任何操作。</p></li><li><p>loader 可以通过 options 对象配置（仍然支持使用 query 参数来设置选项，但是这种方式已被废弃）。</p></li><li><p>除了常见的通过 package.json 的 main 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 loader 字段直接引用一个模块。<br>插件(plugin)可以为 loader 带来更多特性。</p></li><li><p>loader 能够产生额外的任意文件</p></li></ul><h3 id="手写loader"><a href="#手写loader" class="headerlink" title="手写loader"></a>手写loader</h3><h4 id="4种本地开发测试的方法"><a href="#4种本地开发测试的方法" class="headerlink" title="4种本地开发测试的方法"></a>4种本地开发测试的方法</h4><ul><li><p>匹配(test)单个 loader，你可以简单通过在 rule 对象设置 <em>path.resolve</em> 指向这个本地文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          <span class="comment">// loader: path.join(__dirname, '../loader/cpp-loader,js'),</span></span><br><span class="line">          <span class="comment">// loader: 'cpp-test-loader',</span></span><br><span class="line">          loader: path.resolve(<span class="string">'./loader/cpp-test-loader.js'</span>),</span><br><span class="line">          options: &#123;  </span><br><span class="line">            log: <span class="string">'hello 这是我目前用的loader'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li><li><p>匹配(test)多个 loaders，你可以使用 <em>resolveLoader.modules</em> 配置，webpack 将会从这些目录中搜索这些 loaders。例如，如果你的项目中有一个 /loaders 本地目录：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolveLoader: &#123;</span><br><span class="line">   modules: [<span class="string">'node_modules'</span>, path.resolve(__dirname, <span class="string">'loader'</span>)]</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></li><li><p>还阔以通过<strong>resolveLoader</strong>配置别名的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">resolveLoader: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="string">'a-loader'</span>: path.resolve(__dirname, <span class="string">'loader/a.js'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'a-loader'</span>,</span><br><span class="line">        options: &#123;  </span><br><span class="line">          test: <span class="string">'hello this is options'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>npm link 软连接的方式调试独立库和包，来将其关联到你要测试的项目。node模块根目录下 运行 <strong>npm link</strong>,项目里使用 <em>npm link cpp-test-loader</em>。其实跟调试单独的npm包一模一样。</p></li></ul><h4 id="使用-loader-utils-能够编译-loader-的配置，还可以通过-schema-utils-对传递的配置进行验证"><a href="#使用-loader-utils-能够编译-loader-的配置，还可以通过-schema-utils-对传递的配置进行验证" class="headerlink" title="使用 loader-utils 能够编译 loader 的配置，还可以通过 schema-utils 对传递的配置进行验证"></a>使用 <em>loader-utils</em> 能够编译 loader 的配置，还可以通过 <em>schema-utils</em> 对传递的配置进行验证</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'a-loader'</span>,</span><br><span class="line">          options: &#123;  </span><br><span class="line">            test: <span class="string">'hello this is options'</span> <span class="comment">// test: string 跟下面的schema数据结构对应</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cpp-test-loader.js</span></span><br><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</span><br><span class="line"><span class="keyword">const</span> validateOptions = <span class="built_in">require</span>(<span class="string">'schema-utils'</span>);</span><br><span class="line"><span class="comment">// 定义loader里的options选项数据结构</span></span><br><span class="line"><span class="keyword">const</span> schema = &#123;</span><br><span class="line">  type: <span class="string">'object'</span>,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    test: &#123;</span><br><span class="line">      type: <span class="string">'string'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// source: 表示源文件字符串或者buffer</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options = loaderUtils.getOptions(<span class="keyword">this</span>)</span><br><span class="line">  validateOptions(schema, options, <span class="string">'Example Loader'</span>); <span class="comment">// 若当前传入的option不符合预期的数据结构 则会报错</span></span><br><span class="line">  <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure><h3 id="同步-loader"><a href="#同步-loader" class="headerlink" title="同步 loader"></a>同步 loader</h3><p>无论是 return 还是 <strong>this.callback</strong> 都可以同步地返回转换后的 content 内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content, map, meta</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//一些同步操作</span></span><br><span class="line">  outputContent = someSyncOperation(content)</span><br><span class="line">  <span class="keyword">return</span> outputContent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this.callback灵活 支持多个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content, map, meta</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.callback(<span class="literal">null</span>, someSyncOperation(content), map, meta);</span><br><span class="line">  <span class="keyword">return</span>; <span class="comment">// 当调用 callback() 时总是返回 undefined</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="异步-loader"><a href="#异步-loader" class="headerlink" title="异步 loader"></a>异步 loader</h3><p>对于异步 loader，使用 <strong>this.async</strong> 来获取 callback 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content, map, meta</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 做异步的任务</span></span><br><span class="line">  <span class="keyword">var</span> callback = <span class="keyword">this</span>.async();</span><br><span class="line">  someAsyncOperation(content, <span class="function"><span class="keyword">function</span>(<span class="params">err, result, sourceMaps, meta</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">    callback(<span class="literal">null</span>, result, sourceMaps, meta);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><p>为社区用户提供一种强大方式来触及webpack编译过程(compilation process),插件能够 钩入(hook) 到在每个编译(compilation)中触发的所有关键事件。在编译的每一步，插件都具备完全访问 compiler 对象的能力，如果情况合适，还可以访问当前 compilation 对象。</p><p>在插件开发中最重要的两个资源就是 compiler 和 compilation 对象。理解它们的角色是扩展 webpack 引擎重要的第一步。</p><p>compiler 对象代表了<strong>完整的 webpack 环境配置</strong>。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。</p><p>compilation 对象代表了<strong>一次资源版本构</strong>建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。</p><p>这两个组件是任何 webpack 插件不可或缺的部分（特别是 compilation），因此，开发者在阅读源码，并熟悉它们之后，会感到获益匪浅：</p><h3 id="plugin前置知识"><a href="#plugin前置知识" class="headerlink" title="plugin前置知识"></a>plugin前置知识</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="function">(<span class="params">options</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> compiler = <span class="keyword">new</span> Compiler();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> plugin <span class="keyword">of</span> options.plugins) &#123;</span><br><span class="line">    plugin.apply(compiler) <span class="comment">// 将plugin注册到compiler</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册结束</span></span><br><span class="line">  <span class="comment">// 开始执行</span></span><br><span class="line">  compiler.run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MyFirstWebpckPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 走一个</span></span><br><span class="line">webpack(options)</span><br></pre></td></tr></table></figure><h3 id="手写plugin"><a href="#手写plugin" class="headerlink" title="手写plugin"></a>手写plugin</h3><p>webpack 插件由以下组成：</p><ul><li>一个 JavaScript 命名函数，构造函数。</li><li>在插件函数的 prototype 上定义一个 apply 方法。</li><li>指定一个绑定到 webpack 自身的事件钩子。(compiler.hooks.emit // Compiler.emit() 输出到dist目录)</li><li>处理 webpack 内部实例的特定数据。(主要是处理compilation，比如检索遍历资源(asset)、chunk、模块和依赖、监听 chunk 的修改)</li><li>功能完成后调用 webpack 提供的回调</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plugin.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyFirstWebpckPlugin</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我的首个插件————————'</span>, options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> pluginName = <span class="string">'MyFirstWebpckPlugin'</span></span><br><span class="line">MyFirstWebpckPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// compiler对象代表了完整的webpack环境配置</span></span><br><span class="line">  <span class="comment">// 指定挂载到webpack自身的事件钩子</span></span><br><span class="line">  <span class="comment">// compiler.hooks.compile.tap(pluginName, function(compilationParams) &#123;</span></span><br><span class="line">  <span class="comment">//   console.log('环境准备好了', Object.keys(compilationParams))</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line">  compiler.hooks.emit.tap(pluginName, <span class="function"><span class="keyword">function</span>(<span class="params">compilation</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理内部实例的特定数据</span></span><br><span class="line">    <span class="comment">// console.log('————compilation————', Object.keys(compilation))</span></span><br><span class="line">    <span class="comment">// console.log('————compilation.hooks————', Object.keys(compilation.hooks))</span></span><br><span class="line">    <span class="keyword">if</span> (compilation.chunks &amp;&amp; compilation.chunks.length) &#123;</span><br><span class="line">      compilation.chunks.forEach(<span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 检索chunk模块</span></span><br><span class="line">        <span class="keyword">if</span> (chunk &amp;&amp; chunk.files &amp;&amp; chunk.files.length) &#123;</span><br><span class="line">          chunk.files.forEach(<span class="function">(<span class="params">fileName</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'fileName_____'</span>, fileName)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// compilation 代表一次资源版本构建</span></span><br><span class="line">    compilation.hooks.finishModules.tap(pluginName, (<span class="built_in">module</span>) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'——————chunks——————'</span>, <span class="built_in">module</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = MyFirstWebpckPlugin</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line"><span class="keyword">const</span> MyFirstWebpckPlugin = <span class="built_in">require</span>(<span class="string">'../plugin/plugin'</span>)</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MyFirstWebpckPlugin(&#123;</span><br><span class="line">      options: <span class="literal">true</span>,</span><br><span class="line">      name: <span class="string">'common'</span>,</span><br><span class="line">      mode: <span class="string">'Test'</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h3 id="plugin实例"><a href="#plugin实例" class="headerlink" title="plugin实例"></a>plugin实例</h3><p><em>island-webpack-plugin</em> 是一个在 bundle 中添加作者信息的插件，这个插件同样是在 emit 这个钩子上触发的，同样是获取 source 后对 source 添加作者信息的字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorPlugin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">        <span class="keyword">this</span>.options = options;</span><br><span class="line">    &#125;</span><br><span class="line">    apply(compiler) &#123;</span><br><span class="line">        compiler.hooks.emit.tap(<span class="string">'author-plugin'</span>, (compilation) =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> options = <span class="keyword">this</span>.options</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> assets = compilation.assets</span><br><span class="line">                <span class="built_in">Object</span>.keys(assets).forEach(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> source = assets[e].source()</span><br><span class="line">                    <span class="keyword">let</span> info = []</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (options.author) info.push(<span class="string">`@Author: <span class="subst">$&#123;options.author&#125;</span>`</span>)</span><br><span class="line">                    <span class="keyword">if</span> (options.email) info.push(<span class="string">`@Email: <span class="subst">$&#123;options.email&#125;</span>`</span>)</span><br><span class="line">                    <span class="keyword">if</span> (options.homepage) info.push(<span class="string">`@Homepage: <span class="subst">$&#123;options.homepage&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (info.length) &#123;</span><br><span class="line">                        info.push(<span class="string">`@Date: <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span>`</span>)</span><br><span class="line">                        source = <span class="string">`/*\n  <span class="subst">$&#123;info.join(<span class="string">'\n\n  '</span>)&#125;</span>\n*/\n<span class="subst">$&#123;source&#125;</span>`</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    compilation.assets[e].source = <span class="function"><span class="params">()</span> =&gt;</span> source</span><br><span class="line">                    compilation.assets[e].size = <span class="function"><span class="params">()</span> =&gt;</span> source.size</span><br><span class="line">                &#125;)</span><br><span class="line">                resolve()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = AuthorPlugin</span><br></pre></td></tr></table></figure><p>令人执行的compiler里的钩子函数<br><img src= "/img/loading.gif" data-src="/images/webpack/syncHook.png" alt="Tapable"></p><h2 id="参考文件"><a href="#参考文件" class="headerlink" title="参考文件"></a>参考文件</h2><ul><li><a href="https://webpack.docschina.org/concepts/loaders/#example" target="_blank" rel="noopener">loader</a></li><li><a href="https://imweb.io/topic/5baca58079ddc80f36592f1a" target="_blank" rel="noopener">Webpack揭秘——走向高阶前端的必经之路</a></li><li><a href="https://mp.weixin.qq.com/s/f200Q62XL50d0a_DgI6UlA" target="_blank" rel="noopener">webpack的几个常见loader源码浅析，以及动手实现一个md2html-loader</a></li><li><a href="https://www.webpackjs.com/api/loaders/#%E5%90%8C%E6%AD%A5-loader" target="_blank" rel="noopener">loader API</a></li><li><a href="https://www.webpackjs.com/contribute/writing-a-plugin/" target="_blank" rel="noopener">plugin</a></li><li><a href="https://blog.csdn.net/qdmoment/article/details/102833305" target="_blank" rel="noopener">基于数据结构从源码解析webpack核心模块tapable</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
          <category> node </category>
          
          <category> loader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> webpack </tag>
            
            <tag> loader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法基础-排序</title>
      <link href="/2021/01/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/01/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>感觉自己好磨蹭，1月3号建的文章题目，2个月之后还是没有深得精髓，对自己好失望！！</p><h3 id="冒泡排序-bubbleSort"><a href="#冒泡排序-bubbleSort" class="headerlink" title="冒泡排序 bubbleSort"></a>冒泡排序 bubbleSort</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bubbleSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;length&#125; = arr</span><br><span class="line">  <span class="comment">// let flag = false</span></span><br><span class="line">  <span class="keyword">if</span> (length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i ++) &#123;</span><br><span class="line">    <span class="comment">// flag = false</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j ++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        swap(arr, j, j + <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// flag = true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if (!flag) break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序-selectionSort"><a href="#选择排序-selectionSort" class="headerlink" title="选择排序 selectionSort"></a>选择排序 selectionSort</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序 找到数据结构中的最小的那个并将放到首位，接着找第二个放到第二位</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> selectionBubble = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;length&#125; = arr</span><br><span class="line">  <span class="keyword">let</span> indexMin</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">    indexMin = i</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; length; j ++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[indexMin] &gt; arr[j]) &#123;</span><br><span class="line">        indexMin = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( i !== indexMin) &#123;</span><br><span class="line">      swap(arr, i, indexMin)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序-insertionSort"><a href="#插入排序-insertionSort" class="headerlink" title="插入排序 insertionSort"></a>插入排序 insertionSort</h3><p>复杂度 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> insertionSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.length</span><br><span class="line">  <span class="keyword">let</span> temp</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i ++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'i'</span>, i)</span><br><span class="line">    <span class="keyword">let</span> j = i</span><br><span class="line">    temp = arr[i]</span><br><span class="line">    <span class="keyword">while</span>( j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">      arr[j] = arr[j - <span class="number">1</span>]</span><br><span class="line">      j --</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j] = temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序-mergeSort"><a href="#归并排序-mergeSort" class="headerlink" title="归并排序 mergeSort"></a>归并排序 mergeSort</h3><p>复杂度O(nlog(n))</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mergeSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length</span><br><span class="line">    <span class="keyword">const</span> middle = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">const</span> left = mergeSort(arr.slice(<span class="number">0</span>, middle))</span><br><span class="line">    <span class="keyword">const</span> right = mergeSort(arr.slice(middle, length))</span><br><span class="line">    arr = merge(left, right)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">left, right</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  <span class="keyword">while</span>(i &lt; left.length &amp;&amp; j &lt; right.length) &#123;</span><br><span class="line">    res.push(</span><br><span class="line">      left[i] &lt; right[j] ? left[i ++] : right[j ++]</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [...res, ...(i &lt; left.length ? left.slice(i) : right.slice(j))]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序-qucikSort"><a href="#快速排序-qucikSort" class="headerlink" title="快速排序 qucikSort"></a>快速排序 qucikSort</h3><h3 id="计数排序-countingSort"><a href="#计数排序-countingSort" class="headerlink" title="计数排序 countingSort"></a>计数排序 countingSort</h3><p>第一个分布式排序，一个整数排序算法，事件复杂度O(n+k), K是临时计数数组的大小，需要更多的内存来存放临时数组</p><h3 id="桶排序-bucketSort"><a href="#桶排序-bucketSort" class="headerlink" title="桶排序 bucketSort"></a>桶排序 bucketSort</h3><p>箱排序，也是分布式排序算法</p><h3 id="基数排序-radixSort"><a href="#基数排序-radixSort" class="headerlink" title="基数排序 radixSort"></a>基数排序 radixSort</h3><p>分布式排序算法，根据数字的有效位或基数将整数分不到桶中</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法基础: 链表</title>
      <link href="/2021/01/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/01/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的，每个元素由<strong>一个存储元素本身的节点和一个指向下一个元素</strong>的引用组成。<br>相当于传统数组，链表的好处在于，<em>添加或者移除元素的时候不需要移动</em>其他元素。然而链表需要使用指针，因此实现链表时要额外注意。在数组中，我们阔以访问任何位置的任何元素，而想要访问链表中的一个元素，则需要<strong>从头开始迭代链表</strong>直到找到所需的元素。</p><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，<br>  但是并不会按线性的顺序储存数据，而是在每一个节点里存到下一个节点的指针（Pointer）。<br>  由于不必须按顺序储存，链表在<em>插入</em>的时候可以达到 o(1)的复杂度，比另一种线性表顺序表快得多，<br>  但是<em>查找</em>一个节点或者访问特定编号的节点则需要 o(n)的时间，而顺序表响应的时间复杂度分别是 o(logn)和 o(1)。<br>特点：<br>  无需预先分配内存,可以充分利用计算机内存空间，实现灵活的内存动态管理<br>  插入/删除节点不影响其他节点<br>  随机访问速度较慢<br>  增加了结点的指针域，空间开销比较大<br>单向链表：<br>  是链表中最简单的一种，它包含两个域，一个信息域和一个指针域。<br>  这个链接指向列表中的下一个节点，而最后一个节点则指向一个空值。<br>应用：<br>  git commit、es6的Iterator、react的fiber算法。</p><h3 id="链表和数组的区别"><a href="#链表和数组的区别" class="headerlink" title="链表和数组的区别"></a>链表和数组的区别</h3><p>相比数组，链表(Linked List)是一种稍微复杂一点的数据结构，掌握起来也要比数组稍难一些。链表是通过“指针”将一组零散的内存块串联起来使用。数组的线性序是由数组的下标来决定的，而链表的的顺序是由各个对象中的指针来决定。</p><p>在多数编程语言中，数组的长度是固定的，一旦被填满，要再加入数据将会变得非常困难。在数组中，添加和删除元素也比较麻烦，因为需要把数组中的其他元素向前或向后移动。</p><h3 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h3><h4 id="前置基础"><a href="#前置基础" class="headerlink" title="前置基础"></a>前置基础</h4><p>表示链表中的第一个以及其他元素，需要一个 助手类 Node</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Node &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="comment">// this.element = element</span></span><br><span class="line">    <span class="comment">// this.next = undefined</span></span><br><span class="line">    [<span class="keyword">this</span>.element, <span class="keyword">this</span>.next] = [element, <span class="literal">null</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defaultEquals</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a === b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建链表-1"><a href="#创建链表-1" class="headerlink" title="创建链表"></a>创建链表</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> LinkedList &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">equalsFn = defaultEquals</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.head = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.equalsFn = equalsFn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表尾部添加元素"><a href="#链表尾部添加元素" class="headerlink" title="链表尾部添加元素"></a>链表尾部添加元素</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">push(element) &#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element)</span><br><span class="line">  <span class="keyword">let</span> current</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.head = node</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">while</span>(current.next != <span class="literal">null</span>) &#123;</span><br><span class="line">      current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    current.next = nide</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.count ++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表中移除元素"><a href="#链表中移除元素" class="headerlink" title="链表中移除元素"></a>链表中移除元素</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">removeAt(index) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">this</span>.count ) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.head = current.next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> previous</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; index; i ++) &#123;</span><br><span class="line">        previous = current</span><br><span class="line">        current = current.next</span><br><span class="line">      &#125;</span><br><span class="line">      previous.next = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count --</span><br><span class="line">    <span class="keyword">return</span> current.element</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环迭代链表直到找到目标位置"><a href="#循环迭代链表直到找到目标位置" class="headerlink" title="循环迭代链表直到找到目标位置"></a>循环迭代链表直到找到目标位置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getElementAt(index) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">this</span>.count ) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; index;  i++) &#123;</span><br><span class="line">      current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重构下remove方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">removeAt(index) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">this</span>.count ) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.head = current.next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> previous = <span class="keyword">this</span>.getElementAt(index)</span><br><span class="line">      current = previous.next</span><br><span class="line">      previous.next = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count --</span><br><span class="line">    <span class="keyword">return</span> current.element</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在任意位置插入元素"><a href="#在任意位置插入元素" class="headerlink" title="在任意位置插入元素"></a>在任意位置插入元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">insert(element, index) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">this</span>.count) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element) </span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = <span class="keyword">this</span>.head</span><br><span class="line">      node.next = current</span><br><span class="line">      <span class="keyword">this</span>.head = node</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> previous = <span class="keyword">this</span>.getElementAt(index - <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">const</span> current = previous.next</span><br><span class="line">      node.next = current</span><br><span class="line">      previous.next = node</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count ++</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回一个元素的位置"><a href="#返回一个元素的位置" class="headerlink" title="返回一个元素的位置"></a>返回一个元素的位置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">indexOf(element) &#123;</span><br><span class="line">  <span class="keyword">const</span> current = <span class="keyword">this</span>.head</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.count &amp;&amp; current != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.equalsFn(element, current.element)) &#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    current = current.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从链表中移除元素"><a href="#从链表中移除元素" class="headerlink" title="从链表中移除元素"></a>从链表中移除元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">remove(element) &#123;</span><br><span class="line">  <span class="keyword">const</span> index = <span class="keyword">this</span>.indexOf(element);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.removeAt(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>和普通链表的区别在于，在链表中 一个节点只有链向下一个节点的链接，而双向链表中，链接是双向的，一个链向下一个元素，一个链向前一个元素</p><p>工具类Node需要拓展DoublyLinkedList</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">DoublyNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element, next, prev) &#123; <span class="comment">// next好像没啥用</span></span><br><span class="line">    <span class="keyword">super</span>(element)</span><br><span class="line">    <span class="keyword">this</span>.prev = prev</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">DoublyLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(equalsFn = defaultEquals) &#123;</span><br><span class="line">    <span class="keyword">super</span>(equalsFn)</span><br><span class="line">    <span class="keyword">this</span>.tail = <span class="literal">undefined</span>; <span class="comment">// 最后一个元素的引用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="向链表尾部添加元素"><a href="#向链表尾部添加元素" class="headerlink" title="向链表尾部添加元素"></a>向链表尾部添加元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">push(element) &#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> DoublyNode(element);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.head = node;</span><br><span class="line">    <span class="keyword">this</span>.tail = node; <span class="comment">// NEW</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// attach to the tail node // NEW</span></span><br><span class="line">    <span class="keyword">this</span>.tail.next = node;</span><br><span class="line">    node.prev = <span class="keyword">this</span>.tail;</span><br><span class="line">    <span class="keyword">this</span>.tail = node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在任意位置插入新元素"><a href="#在任意位置插入新元素" class="headerlink" title="在任意位置插入新元素"></a>在任意位置插入新元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">insert(element, index) &#123;</span><br><span class="line">  <span class="keyword">if</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="keyword">this</span>.count) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> DoublyNode(element)</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="comment">// 起点位置插入一个新元素</span></span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果双向链表为空 只需要把head和tail执行这个新节点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.head = node</span><br><span class="line">        <span class="keyword">this</span>.tail = node</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// current变量将是链表中第一个元素的引用</span></span><br><span class="line">        node.next = <span class="keyword">this</span>.head</span><br><span class="line">        current.prev = node</span><br><span class="line">        <span class="keyword">this</span>.head = node</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="keyword">this</span>.count) &#123;</span><br><span class="line">      current = <span class="keyword">this</span>.tail</span><br><span class="line">      current.next = node</span><br><span class="line">      node.prev = current</span><br><span class="line">      <span class="keyword">this</span>.tail = node</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> previous = <span class="keyword">this</span>.getElementAt(index - <span class="number">1</span>)</span><br><span class="line">      current = previous.next</span><br><span class="line">      node.next = current</span><br><span class="line">      previous.next = node</span><br><span class="line">      node.prev = previous</span><br><span class="line">      current.prev = node</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count ++</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表尾部的next引用指向头部节点，定义<em>CircularLinkedList</em>类的insert方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(equalsFn = defaultEquals) &#123;</span><br><span class="line">    <span class="keyword">super</span>(equalsFn)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 链表尾部的next指向head</span></span><br><span class="line">  insert(element, index) &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="keyword">this</span>.count) &#123;</span><br><span class="line">      <span class="keyword">let</span> node = <span class="keyword">new</span> DoublyNode(element)</span><br><span class="line">      <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">      <span class="comment">// 起点位置插入一个新元素</span></span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果双向链表为空 只需要把head和tail执行这个新节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.head = node</span><br><span class="line">          node.next = <span class="keyword">this</span>.head</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// current变量将是链表中第一个元素的引用</span></span><br><span class="line">          node.next = current</span><br><span class="line">          current = <span class="keyword">this</span>.getElementAt(<span class="keyword">this</span>.size())</span><br><span class="line">          <span class="keyword">this</span>.head = node</span><br><span class="line">          current.next = <span class="keyword">this</span>.head</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> previous = <span class="keyword">this</span>.getElementAt(index - <span class="number">1</span>)</span><br><span class="line">        node.next = previous.next</span><br><span class="line">        previous.next = node</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.count ++</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从任意位置移除元素"><a href="#从任意位置移除元素" class="headerlink" title="从任意位置移除元素"></a>从任意位置移除元素</h4><p>考虑修改循环链表的head元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">removeAt(index) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="keyword">this</span>.count) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.size() === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="literal">undefined</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> removed = <span class="keyword">this</span>.head</span><br><span class="line">        current = <span class="keyword">this</span>.getElementAt(<span class="keyword">this</span>.size())</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next</span><br><span class="line">        current.next = <span class="keyword">this</span>.head</span><br><span class="line">        current = removed</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> previous = <span class="keyword">this</span>.getElementAt(index - <span class="number">1</span>)</span><br><span class="line">      current = previous.next</span><br><span class="line">      previous.next = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count --</span><br><span class="line">    <span class="keyword">return</span> current.element</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有序链表"><a href="#有序链表" class="headerlink" title="有序链表"></a>有序链表</h3><p>保持元素有序的链表结构,除了使用排序算法之外，我们还阔以将元素插入到正确的位置来保证链表的有序性</p><ul><li>声明SortedLinkedList类</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Compare = &#123;</span><br><span class="line">  LESS_THAN: <span class="number">-1</span>,</span><br><span class="line">  BIGGER_THAN: <span class="number">1</span>,</span><br><span class="line">  EQUALS: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defaultCompare</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a === b) &#123;</span><br><span class="line">    <span class="keyword">return</span> Compare.EQUALS</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(equalsFn = defaultEquals, compareFn = defaultCompare) &#123;</span><br><span class="line">    <span class="keyword">super</span>(equalsFn)</span><br><span class="line">    <span class="keyword">this</span>.equalsFn = equalsFn;</span><br><span class="line">    <span class="keyword">this</span>.compareFn = compareFn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有序插入元素"><a href="#有序插入元素" class="headerlink" title="有序插入元素"></a>有序插入元素</h4><p>会用下面代码覆盖insert方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">getIndexNextSortedElement(element) &#123;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; <span class="keyword">this</span>.size() &amp;&amp; current; i ++) &#123;</span><br><span class="line">    <span class="keyword">const</span> comp = <span class="keyword">this</span>.compareFn(element, current.element)</span><br><span class="line">    <span class="keyword">if</span> (comp === Compare.LESS_THAN) &#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    current = current.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">insert(element, index = <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.insert(element, index === <span class="number">0</span> ? index : <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> pos = <span class="keyword">this</span>.getIndexNextSortedElement(element) </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.insert(element, pos)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表内是否存在环"><a href="#链表内是否存在环" class="headerlink" title="链表内是否存在环"></a>链表内是否存在环</h3><h3 id="合并俩个有序链表"><a href="#合并俩个有序链表" class="headerlink" title="合并俩个有序链表"></a>合并俩个有序链表</h3><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p>示例1：</p><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!l1) &#123;</span><br><span class="line">    <span class="keyword">return</span> l2</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!l2) &#123;</span><br><span class="line">    <span class="keyword">return</span> l1</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">    l1.next = mergeTwoLists(l1.next, l2)</span><br><span class="line">    <span class="keyword">return</span> l1</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    l2.next = mergeTwoLists(l2.next, l1)</span><br><span class="line">    <span class="keyword">return</span> l2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">var</span> l1 = &#123;</span><br><span class="line">  val: <span class="number">1</span>,</span><br><span class="line">  next: &#123;</span><br><span class="line">    val: <span class="number">2</span>,</span><br><span class="line">    next: &#123;</span><br><span class="line">      val: <span class="number">4</span>,</span><br><span class="line">      next: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> l2 = &#123;</span><br><span class="line">  val: <span class="number">1</span>,</span><br><span class="line">  next: &#123;</span><br><span class="line">    val: <span class="number">3</span>,</span><br><span class="line">    next: &#123;</span><br><span class="line">      val: <span class="number">4</span>,</span><br><span class="line">      next: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> total = mergeTwoLists(l1,l2)</span><br><span class="line"><span class="built_in">console</span>.log(total)</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://github.com/PacktPublishing/Learning-JavaScript-Data-Structures-and-Algorithms-Third-Edition" target="_blank" rel="noopener">Learning-JavaScript-Data-Structures</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶-大杂烩2</title>
      <link href="/2021/01/01/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E5%A4%A7%E6%9D%82%E7%83%A92/"/>
      <url>/2021/01/01/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E5%A4%A7%E6%9D%82%E7%83%A92/</url>
      
        <content type="html"><![CDATA[<p>虽然早有准备，但还是被无情按在地上摩擦摩擦</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域是指程序源代码中定义变量的区域。<br>作用域规定了<em>如何查找变量</em>，也就是确定当前执行代码对<strong>变量的访问权限</strong>。<br>JavaScript 采用<em>词法作用域(lexical scoping)</em>，也就是静态作用域</p><h3 id="词法作用域-需要安静的理解下"><a href="#词法作用域-需要安静的理解下" class="headerlink" title="词法作用域(需要安静的理解下)"></a>词法作用域(需要安静的理解下)</h3><p>词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将<strong>变量和块作用域</strong>写在哪里来决定的，不是在执行它们的作用域里运行，因此当词法分析器处理代码时会保持作用域不变(大部分情况下是这样的)。而JavaScript采用的就是词法作用域，也称为<em>静态作用域</em>。<br>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够完全知道全部标识符在哪里以及如何声明的，从而能够预测在执行过程中如何对他们进行查找</p><p>因为 JavaScript 采用的是词法作用域，函数的作用域在<em>函数定义</em>的时候就决定了。</p><p>而与词法作用域相对的是动态作用域，函数的作用域是在<em>函数调用</em>的时候才决定的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Mr.Han'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(name);<span class="comment">//undefined</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Mrs.Han'</span>;</span><br><span class="line">  alert(name);<span class="comment">//'Mrs.Han'</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();<span class="comment">//1</span></span><br></pre></td></tr></table></figure><ul><li>假设JavaScript采用静态作用域，让我们分析下执行过程：</li></ul><p>执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。</p><p>假设JavaScript采用动态作用域，让我们分析下执行过程：</p><p>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</p><p>前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。</p><h3 id="闭包特性"><a href="#闭包特性" class="headerlink" title="闭包特性"></a>闭包特性</h3><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>利用js计算，最后一次性修改DOM，大大减少DOM交互，减少回流和重绘，提升网页性能，还能减少内存占用，使用事件委托，只要对元素的父级指定事件处理函数即可</p><h4 id="事件委托原理"><a href="#事件委托原理" class="headerlink" title="事件委托原理"></a>事件委托原理</h4><p>依赖事件冒泡原理实现的，事件冒泡指的是事件会从最深的节点处开始逐步往上传播事件，由于有这样的机制，我们可以只给最外面的元素添加事件，当内层的标签触发了某个事件，该事件会通过事件冒泡传播到最外层标签，从而触发真正的事件处理函数。这也就是事件委托的过程，子元素委托父级元素代为执行事件。</p><h4 id="如何阻止冒泡-amp-amp-取消默认事件"><a href="#如何阻止冒泡-amp-amp-取消默认事件" class="headerlink" title="如何阻止冒泡 &amp;&amp; 取消默认事件"></a>如何阻止冒泡 &amp;&amp; 取消默认事件</h4><p>w3c是event.stopPropagation，IE则是event.cancelBulle,事件的一个方法，作用是阻止目标元素的事件冒泡，但是不会阻止事件的默认行为，</p><p>W3c是event.preventDefault,IE则是event.rerturnValuee = false, 作用是取消一个目标元素的默认行为。只有元素本身有默认行为取消才有意义，什么元素具有默认行为呢?<br>比如<a href=''> 提交按钮<button type='submit'>等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">event.stopPropagation() <span class="comment">// 阻止事件冒泡</span></span><br><span class="line">event.preventDefault <span class="comment">// 取消事件的默认行为</span></span><br></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://juejin.cn/post/6850418111242305544" target="_blank" rel="noopener">深入理解事件委托（事件代理）以及取消冒泡和默认事件</a></li></ul><h3 id="实现new操作符"><a href="#实现new操作符" class="headerlink" title="实现new操作符"></a>实现new操作符</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现</span></span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">const</span> newOperator = <span class="function">(<span class="params">ctor: <span class="built_in">Function</span>, ...args: <span class="built_in">any</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> ctor !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span>(<span class="string">'第一个参数必须为函数'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建一个对象，同时继承构造函数上的原型属性</span></span><br><span class="line">  <span class="keyword">const</span> newObj = <span class="built_in">Object</span>.create(ctor.prototype);</span><br><span class="line">  <span class="comment">// 调用构造函数，绑定到构造函数上this对象上，并且传入剩余的参数</span></span><br><span class="line">  <span class="keyword">const</span> returnObj = ctor.apply(newObj, args)</span><br><span class="line">  <span class="comment">// 默认返回this，如果手动定义返回原始值不影响，返回对象需要正常处理</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> returnObj === <span class="string">'object'</span> ? returnObj : newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 vue文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; mockNewFn, newOperator &#125; <span class="keyword">from</span> <span class="string">'../utils/mockBind'</span></span><br><span class="line"><span class="keyword">const</span> girl3 = newOperator(Girl, <span class="string">'测试下我的小女生3'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'gril3 —————— newOperator'</span>, girl3, girl3.greetName());</span><br></pre></td></tr></table></figure><h3 id="模拟实现apply-call"><a href="#模拟实现apply-call" class="headerlink" title="模拟实现apply/call"></a>模拟实现apply/call</h3><p>两者区别在于apply第二个参数传入的是数组，而call是一个一个参数传入的</p><p>模拟的时候注意:</p><ul><li>this 参数可以传 null，当为 null 的时候，视为指向 window</li><li>函数是可以有返回值的！</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟实现apply</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.mockApply = <span class="function"><span class="keyword">function</span>(<span class="params">context, args</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line"><span class="keyword">var</span> sym = Symbol(); <span class="comment">// 独一无二的值</span></span><br><span class="line">context[sym] = <span class="keyword">this</span>;</span><br><span class="line"><span class="comment">// 执行函数;</span></span><br><span class="line">  <span class="comment">// const result = context[sym](...args);</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">eval</span>(<span class="string">'context.sym(...args)'</span>)</span><br><span class="line"><span class="keyword">delete</span> context[sym]</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'cpp'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  alert(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.mockApply = mockApply</span><br><span class="line">sayName.mockApply(obj, [<span class="string">'菜鸟'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟实现call</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.mockCall = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">'context.fn(...args)'</span>);</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="keyword">import</span> &#123; mockApply, mockCall &#125; <span class="keyword">from</span> <span class="string">'../utils/mockBind'</span></span><br><span class="line"></span><br><span class="line">(<span class="built_in">Function</span>.prototype <span class="keyword">as</span> <span class="built_in">any</span>).mockApply = mockApply;</span><br><span class="line">(<span class="built_in">Function</span>.prototype <span class="keyword">as</span> <span class="built_in">any</span>).mockCall = mockCall;</span><br><span class="line"><span class="keyword">const</span> test1 = (sayName <span class="keyword">as</span> <span class="built_in">any</span>).mockApply(TestObj, [<span class="string">'chendaoeng mockApply'</span>, <span class="number">30</span>])</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test1- mockApply'</span>, test1);</span><br><span class="line"><span class="keyword">const</span> testMockCall = (sayName <span class="keyword">as</span> <span class="built_in">any</span>).mockCall(TestObj, <span class="string">'chendaoeng mockCall'</span>, <span class="number">30</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'testMockCall- mockCall'</span>, testMockCall);</span><br></pre></td></tr></table></figure><h3 id="实现bind函数"><a href="#实现bind函数" class="headerlink" title="实现bind函数"></a>实现bind函数</h3><p>bind函数: bind()会创建一个方法，当这个新函数被调用的时候，bind()的第一个参数将作为它运行时的this,之后的序列参数会在传入的实参前传入作为它的参数。<br>需要理解下，bind函数有两种；</p><h4 id="手写mockBind"><a href="#手写mockBind" class="headerlink" title="手写mockBind"></a>手写mockBind</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mockBind = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, obj: <span class="built_in">any</span>, ...firstArgs: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>&#125;</span>.bind is not a function`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> context = obj || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> bindFn = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, ...bindFnArg: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 作为构造函数 this指向实例 self 指向绑定函数 this,因为下面一句 bindFn.prototype = this.prototype 已经修改了bindFn.prototype为绑定函数的prototype</span></span><br><span class="line">    <span class="comment">// instanceof self: true this指向实例</span></span><br><span class="line">    <span class="comment">// 作为普通函数 this指向window self 指向绑定函数 this instanceof self: false</span></span><br><span class="line">    <span class="comment">// instanceof self: true this指向window</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'context传入的————'</span>, context);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this————'</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'self————'</span>, self);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this instanceof self'</span>, <span class="keyword">this</span> <span class="keyword">instanceof</span> self);</span><br><span class="line">    <span class="keyword">return</span> self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> self ? <span class="keyword">this</span> : context, [...firstArgs, ...bindFnArg])</span><br><span class="line">  &#125;</span><br><span class="line">  bindFn.prototype = <span class="keyword">this</span>.prototype</span><br><span class="line">  <span class="keyword">return</span> bindFn</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TestObj = &#123;</span><br><span class="line">  name: <span class="string">'cpp'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str =  <span class="string">`我的名字是<span class="subst">$&#123;name&#125;</span>,年龄是<span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    tip: str</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="built_in">Function</span>.prototype <span class="keyword">as</span> <span class="built_in">any</span>).mockBind = mockBind</span><br><span class="line"><span class="keyword">const</span> bindName = sayName.bind(TestObj, <span class="string">'niaogege bind'</span>);</span><br><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">const</span> testBind1 = bindName(<span class="number">29</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'第一种'</span>, testBind1); <span class="comment">// &#123;tip: "我的名字是niaogege bind,年龄是29"&#125;</span></span><br><span class="line"><span class="keyword">const</span> bindName2 = (sayName <span class="keyword">as</span> <span class="built_in">any</span>).mockBind(TestObj, <span class="string">'niaogege bind'</span>);</span><br><span class="line"><span class="keyword">const</span> testBind2 = bindName2(<span class="number">29</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'第一种'</span>, testBind2); <span class="comment">// &#123;tip: "我的名字是niaogege bind,年龄是29"&#125;</span></span><br></pre></td></tr></table></figure><h4 id="mockBind之后new操作符调用"><a href="#mockBind之后new操作符调用" class="headerlink" title="mockBind之后new操作符调用"></a>mockBind之后new操作符调用</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">const</span> newTestBind1 = <span class="keyword">new</span> (bindName <span class="keyword">as</span> <span class="built_in">any</span>)(<span class="number">30</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newTestBind1, <span class="string">'newTestBind1'</span>, <span class="built_in">Object</span>.prototype.toString.call(newTestBind1))</span><br><span class="line"><span class="keyword">const</span> mockBindName = (sayName <span class="keyword">as</span> <span class="built_in">any</span>).mockBind(TestObj, <span class="string">'niaogege mockBind'</span>)</span><br><span class="line"><span class="keyword">const</span> newTestBind2 = <span class="keyword">new</span> mockBindName(<span class="number">30</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newTestBind2, <span class="string">'newTestBind2'</span>, <span class="built_in">Object</span>.prototype.toString.call(newTestBind2));</span><br></pre></td></tr></table></figure><h3 id="vue渲染原理"><a href="#vue渲染原理" class="headerlink" title="vue渲染原理"></a>vue渲染原理</h3><h3 id="vue数据双向绑定"><a href="#vue数据双向绑定" class="headerlink" title="vue数据双向绑定"></a>vue数据双向绑定</h3><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://segmentfault.com/a/1190000009257663" target="_blank" rel="noopener">JavaScript深入之call和apply的模拟实现</a></li><li><a href="https://mp.weixin.qq.com/s/TG87bWiLyv1b8Ho4afaNUA" target="_blank" rel="noopener">面试系列——手写代码实现（一）</a></li><li><a href="https://segmentfault.com/a/1190000009271416" target="_blank" rel="noopener">JavaScript深入之bind的模拟实现</a></li><li><a href="https://segmentfault.com/a/1190000008972987" target="_blank" rel="noopener">JavaScript深入之词法作用域和动态作用域</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础: Iterator</title>
      <link href="/2020/12/29/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-Iterator/"/>
      <url>/2020/12/29/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-Iterator/</url>
      
        <content type="html"><![CDATA[<h3 id="面试题，给出一个对象，如何封装一个类使其可遍历，就是算是手写一个Generator函数吧"><a href="#面试题，给出一个对象，如何封装一个类使其可遍历，就是算是手写一个Generator函数吧" class="headerlink" title="面试题，给出一个对象，如何封装一个类使其可遍历，就是算是手写一个Generator函数吧"></a>面试题，给出一个对象，如何封装一个类使其可遍历，就是算是手写一个Generator函数吧</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'chen'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'da'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'peng'</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考一会，小试牛刀！！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'chen'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'da'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'peng'</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MakeIterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(obj) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = <span class="built_in">Object</span>.keys(obj).length;</span><br><span class="line">        <span class="keyword">this</span>.index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">this</span>.obj = obj</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;<span class="keyword">return</span> <span class="keyword">this</span>&#125;; <span class="comment">// 这个是难点也是最重要的一点</span></span><br><span class="line">    next() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.index &lt; <span class="keyword">this</span>.length</span><br><span class="line">        ? &#123;<span class="attr">value</span>: <span class="keyword">this</span>.obj[<span class="keyword">this</span>.index ++], <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">        : &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(item <span class="keyword">of</span> <span class="keyword">new</span> MakeIterator(test)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>遍历器(Iterator)是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就阔以完成遍历操作；</p><h4 id="模拟next方法返回值的例子"><a href="#模拟next方法返回值的例子" class="headerlink" title="模拟next方法返回值的例子"></a>模拟next方法返回值的例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">it.next() <span class="comment">// &#123;value: 'a', done: false&#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123;value: 'b', done: false&#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &lt; array.length ?</span><br><span class="line">      &#123;<span class="attr">value</span>: array[index++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">      &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认-Iterator-接口"><a href="#默认-Iterator-接口" class="headerlink" title="默认 Iterator 接口"></a>默认 Iterator 接口</h3><p>Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即<strong>for…of</strong>循环。当使用for…of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。<br>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。<br>ES6 规定，默认的 Iterator 接口部署在数据结构的<strong>Symbol.iterator</strong>属性，或者说，一个数据结构只要具有<strong>Symbol.iterator</strong>属性，就可以认为是<em>可遍历的</em>（iterable）。<br>Symbol.iterator本身是一个函数，数据结构默认的遍历器生成函数，执行这个函数就会返回一个遍历器。<br>原生具备 Iterator 接口的数据结构如下:</p><ul><li><p>Array</p></li><li><p>Set</p></li><li><p>Arguments</p></li><li><p>Map</p></li><li><p>String</p></li><li><p>NodeList对象</p></li><li><p>typedArray</p><p>对于类似数组的对象（存在数值键名和length属性），部署 Iterator 接口，有一个简便方法，就是Symbol.iterator方法直接引用数组的 Iterator 接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> it = arr[<span class="built_in">Symbol</span>.iterator](); <span class="comment">// 得到遍历器对象</span></span><br><span class="line">it.next()</span><br><span class="line">it.next()</span><br><span class="line">it.next()</span><br></pre></td></tr></table></figure><p>变量arr是一个数组，原生就具有遍历器接口，部署在arr的Symbol.iterator属性上面。所以，调用这个属性，就得到<strong>遍历器对象</strong>。</p></li></ul><p>类似数组的对象调用数组的Symbol.iterator方法的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iterable = &#123;</span><br><span class="line"> <span class="number">0</span>: <span class="string">'a'</span>,</span><br><span class="line"> <span class="number">1</span>: <span class="string">'b'</span>,</span><br><span class="line"> <span class="number">2</span>: <span class="string">'c'</span>,</span><br><span class="line"> length: <span class="number">3</span>,</span><br><span class="line"> [<span class="built_in">Symbol</span>.iterator]: [][<span class="built_in">Symbol</span>.iterator]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item, <span class="string">'eee'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a eee</span></span><br><span class="line"><span class="comment">// b eee</span></span><br><span class="line"><span class="comment">// c eee</span></span><br></pre></td></tr></table></figure><p>若没有部署[].Symbol.iterator则会报错 <em>iterable is not iterable</em></p><h4 id="普通对象部署数组的Symbol-iterator方法无效"><a href="#普通对象部署数组的Symbol-iterator方法无效" class="headerlink" title="普通对象部署数组的Symbol.iterator方法无效"></a>普通对象部署数组的Symbol.iterator方法无效</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iterable = &#123;</span><br><span class="line"> a: <span class="string">'a'</span>,</span><br><span class="line"> b: <span class="string">'b'</span>,</span><br><span class="line"> c: <span class="string">'c'</span>,</span><br><span class="line"> length: <span class="number">3</span>,</span><br><span class="line"> [<span class="built_in">Symbol</span>.iterator]: [][<span class="built_in">Symbol</span>.iterator]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item, <span class="string">'eee'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// undefined "eee"</span></span><br></pre></td></tr></table></figure><blockquote><p>手动部署iterator属性的时候记得是 [Symbol.iterator]: [][Symbol.iterator] 这种写法</p></blockquote><h3 id="手写实现一个遍历器"><a href="#手写实现一个遍历器" class="headerlink" title="手写实现一个遍历器"></a>手写实现一个遍历器</h3><p>目的: 定义一个对象，通过调用类Iterator实现可遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">"a"</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">"b"</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">"c"</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  Uncaught TypeError: obj is not iterable</span></span><br></pre></td></tr></table></figure><p>如何调用类Iterator实现可遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIterator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(obj) &#123;</span><br><span class="line">      <span class="keyword">this</span>.obj = obj;</span><br><span class="line">      <span class="keyword">this</span>.length = <span class="built_in">Object</span>.keys(obj).length;</span><br><span class="line">      <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;<span class="keyword">return</span> <span class="keyword">this</span>&#125;</span><br><span class="line">  next() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.index &lt; <span class="keyword">this</span>.length</span><br><span class="line">      ? &#123;<span class="attr">value</span>: <span class="keyword">this</span>.obj[<span class="keyword">this</span>.index ++], <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">      : &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">"a"</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">"b"</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">"c"</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> <span class="keyword">new</span> MyIterator(obj)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法），除了下文会介绍的for…of循环，还有其他场合</p><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">set</span> = new Set().add('a').add('b').add('c')</span><br><span class="line">var [x, ...y] = <span class="keyword">set</span>;</span><br><span class="line">console.log(x, y) // a ['b', 'c']</span><br></pre></td></tr></table></figure><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">[<span class="string">'a'</span>, ...arr, <span class="string">'d'</span>] <span class="comment">// a b c d</span></span><br></pre></td></tr></table></figure><p>上面代码的扩展运算符内部就调用 Iterator 接口。<br>只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</p><h4 id="yield"><a href="#yield" class="headerlink" title="yield*"></a>yield*</h4><p>yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ge = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">55</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ite = ge();</span><br><span class="line">ite.next() <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">ite.next() <span class="comment">// &#123;value: [2, 3, 4], done: false&#125;</span></span><br><span class="line">ite.next() <span class="comment">// &#123;value: 55, done: false&#125;</span></span><br><span class="line">ite.next() <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>思考 如何让第二个next里的数据遍历呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ge = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">55</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ite = ge();</span><br></pre></td></tr></table></figure><h4 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h4><p>由于数组的遍历回调用遍历器接口，所以任何接受数组作为参数的场景都会调用遍历器</p><ul><li>for…of</li><li>Array.from()</li><li>Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])）</li><li>Promise.all()</li><li>Promise.race()</li></ul><h3 id="字符串的-Iterator-接口"><a href="#字符串的-Iterator-接口" class="headerlink" title="字符串的 Iterator 接口"></a>字符串的 Iterator 接口</h3><p>字符串是一个类似数组的对象，也原生具有 Iterator 接口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someString = <span class="string">"hi"</span>;</span><br><span class="line"><span class="keyword">typeof</span> someString[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line"><span class="comment">// "function"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = someString[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: "h", done: false &#125;</span></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: "i", done: false &#125;</span></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中 调用<strong>Symbol.iterator</strong>方法返回一个遍历器对象，在这个遍历器上可以调用 <strong>next</strong> 方法，实现对于字符串的遍历</p><h3 id="Iterator与Generator"><a href="#Iterator与Generator" class="headerlink" title="Iterator与Generator"></a>Iterator与Generator</h3><p>Symbol.iterator()方法的最简单实现, 两者关系</p><p>任意一个对象的<strong>Symbol.iterator</strong>方法 === 该对象的遍历器生成函数<strong>Generator</strong>，调用该函数会生成该对象的遍历器对象.<br>Generator函数就是遍历器生成函数，因此能把Generator赋值给对象的Symbol.iterator属性，从而使该对象具有iterator接口</p><ul><li>第一种<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = &#123;</span><br><span class="line">   [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log([...it]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li>第二种<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it2 = &#123;</span><br><span class="line">    * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(...it2) <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h3><p>一个结构只要部署了Symbol.iterator属性，就被视为具体Iterator接口，就能用for of 循环遍历成员，也就是for of 循环内部调用的是数据结构的Symbol.iterator属性</p><p>for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、Generator 对象，以及字符串</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>1.所有的模拟数据结构，用到的<em>Symbol.iterator</em> ，再用的时候都需要加上方括号，不管是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it2 = &#123;</span><br><span class="line">    * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.面试的时候如何用大白话说清楚，Iterator跟Generator俩者之间的关系</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://es6.ruanyifeng.com/#docs/iterator" target="_blank" rel="noopener">Iterator 和 for…of 循环</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> Iterator </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
            <tag> Iterator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: generator-1</title>
      <link href="/2020/12/29/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-generator-1/"/>
      <url>/2020/12/29/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-generator-1/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Generator(生成器) 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p><p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><p>形式上，Generator 函数是一个普通函数，但是有两个特征。</p><ul><li>function关键字与函数名之间有一个<strong>星号</strong></li><li>函数体内部使用<strong>yield</strong>表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'cpp'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'专注'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hG = hello()</span><br><span class="line"><span class="built_in">console</span>.log(hG, <span class="built_in">Object</span>.prototype.toString.call(hG)); <span class="comment">// hello &#123;&lt;suspended&gt;&#125;  "[object Generator]"</span></span><br><span class="line">hG.next() <span class="comment">// &#123;value: "hello", done: false&#125;</span></span><br></pre></td></tr></table></figure><h3 id="yield-表达式，暂停标记"><a href="#yield-表达式，暂停标记" class="headerlink" title="yield 表达式，暂停标记"></a>yield 表达式，暂停标记</h3><p>由于 Generator 函数返回的遍历器对象，只有调用<strong>next</strong>方法才会遍历下一个内部状态<br>遍历器对象的next方法的运行逻辑如下。</p><ul><li>遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</li><li>下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。</li><li>如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</li><li>如果该函数没有return语句，则返回的对象的value属性值为undefined。</li></ul><blockquote><p>另外需要注意，yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。</p></blockquote><p>yield表达式如果用在另一个表达式之中，必须放在圆括号里面;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">hello2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>+ (<span class="keyword">yield</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'专注'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hG = hello2()</span><br><span class="line">hG.next(); <span class="comment">// &#123;value: undefined, done: false&#125;</span></span><br><span class="line">hG.next(); <span class="comment">// helloundefined &#123;value: "专注", done: true&#125;</span></span><br><span class="line">hG.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><h4 id="return-amp-yield区别"><a href="#return-amp-yield区别" class="headerlink" title="return &amp; yield区别"></a>return &amp; yield区别</h4><ul><li>相似之处在于，都能返回紧跟在语句后面的那个表达式的值</li><li>不同:<br>a: return语句不具备位置记忆的功能,每次遇到yield函数暂停执行，并将紧跟yield后面的表达式的值作为返回对象的value属性值<br>b：一个函数只能执行一个return语句，而能执行多个yield语句</li></ul><h4 id="如何模拟-yield关键词？"><a href="#如何模拟-yield关键词？" class="headerlink" title="如何模拟 yield关键词？"></a>如何模拟 yield关键词？</h4><h3 id="与-Iterator-接口的关系"><a href="#与-Iterator-接口的关系" class="headerlink" title="与 Iterator 接口的关系"></a>与 Iterator 接口的关系</h3><p>Iterator Generator<br>It/Gen erator 从命名上有点关系哈</p><p>任意一个对象的<strong>Symbol.iterator</strong>方法 === 该对象的遍历器生成函数Generator，调用该函数会生成该对象的遍历器对象.<br>Generator函数就是遍历器生成函数，因此能把Generator赋值给对象的Symbol.iterator属性，从而使该对象具有iterator接口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterator = &#123;&#125;</span><br><span class="line">myIterator[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log([...myIterator]) <span class="comment">//  [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>Generator函数执行后返回一个遍历器对象，该对象本身也具有Symbol.iterator属性，所以执行后返回自身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> gg = gen()</span><br><span class="line">gg[<span class="built_in">Symbol</span>.iterator]() === gg <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> gg = (<span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;&#125;)()</span><br><span class="line">gg[<span class="built_in">Symbol</span>.iterator]() === gg</span><br></pre></td></tr></table></figure><h3 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a>next 方法的参数</h3><p>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作<strong>上一个yield</strong>表达式的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> reset = <span class="keyword">yield</span> i; <span class="comment">// yield i 上一次的结果</span></span><br><span class="line">    <span class="keyword">if</span>(reset) &#123; i = <span class="number">-1</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f();</span><br><span class="line"></span><br><span class="line">g.next() <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next(<span class="literal">true</span>) <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br></pre></td></tr></table></figure><p>当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。</p><p>注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的<br>再看一个通过next方法的参数，向 Generator 函数内部输入值的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">dataConsumer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Started'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`1. <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`2. <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'result'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> genObj = dataConsumer();</span><br><span class="line">genObj.next(); <span class="comment">// started &#123;value: undefined, done: false&#125;</span></span><br><span class="line">genObj.next(<span class="string">'a'</span>); <span class="comment">//  1. a &#123;value: undefined, done: false&#125;</span></span><br><span class="line">genObj.next(<span class="string">'b'</span>); <span class="comment">// 2. b  &#123;value: "result", done: true&#125;</span></span><br></pre></td></tr></table></figure><h3 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for of 循环"></a>for of 循环</h3><p>for of 阔以自动遍历Generator函数生成的遍历器对象，不需要next方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'end'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的end，不包括在for…of循环之中。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">Generator 函数的语法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> generator </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
            <tag> generator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶-手写promise</title>
      <link href="/2020/12/27/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E6%89%8B%E5%86%99promise/"/>
      <url>/2020/12/27/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E6%89%8B%E5%86%99promise/</url>
      
        <content type="html"><![CDATA[<p>promise基本用法以及手写</p><h2 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h2><h3 id="20行手写promise"><a href="#20行手写promise" class="headerlink" title="20行手写promise"></a>20行手写promise</h3><p>目前见过最容易理解的promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Promise resolve时的回调函数集</span></span><br><span class="line">  <span class="keyword">this</span>.callbacks = []</span><br><span class="line">  <span class="keyword">const</span> resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 注意promise的then函数需要异步执行</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.data = val;</span><br><span class="line">      <span class="comment">// cbs里用户传入的函数执行一遍</span></span><br><span class="line">      <span class="keyword">this</span>.callbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">        cb(val)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  executor(resolve)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// promise2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this指的是promise1</span></span><br><span class="line">    <span class="keyword">this</span>.callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// onResolved对应用户在then里传入的函数</span></span><br><span class="line">      <span class="keyword">const</span> res = onResolved(<span class="keyword">this</span>.data)</span><br><span class="line">      <span class="keyword">if</span> (res <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">        <span class="comment">// 只有promise2被resolve以后</span></span><br><span class="line">        <span class="comment">// then下面的链式调用函数才会继续执行</span></span><br><span class="line">        res.then(resolve)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// onResolved</span></span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">2</span>);</span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="built_in">console</span>.log);</span><br><span class="line">  <span class="comment">// 500s后输出 1</span></span><br><span class="line">  <span class="comment">// 500s后输出 2</span></span><br></pre></td></tr></table></figure><h2 id="面试版"><a href="#面试版" class="headerlink" title="面试版"></a>面试版</h2><p>在基础版基础上增加reject部分功能; </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进阶版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cppPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 收集链式调用的函数集合cb</span></span><br><span class="line">  <span class="keyword">this</span>.onResolvedCallbacks = [];</span><br><span class="line">  <span class="keyword">this</span>.onRejectedCallbacks = [];</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">this</span>.reason = <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">this</span>.status = <span class="string">'pending'</span></span><br><span class="line">  <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.status = <span class="string">'fulfilled'</span></span><br><span class="line">      <span class="keyword">this</span>.value = value</span><br><span class="line">      <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">        cb(<span class="keyword">this</span>.value)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> reject = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.status = <span class="string">'rejected'</span></span><br><span class="line">      <span class="keyword">this</span>.reason = val</span><br><span class="line">      <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">        cb(<span class="keyword">this</span>.reason)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  executor(resolve, reject)</span><br><span class="line">&#125;</span><br><span class="line">handleResolve(resolve, reject, onFulledFn) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> cppPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = onFulledFn(<span class="keyword">this</span>.value);</span><br><span class="line">        <span class="keyword">if</span> (res <span class="keyword">instanceof</span> cppPromise) &#123;</span><br><span class="line">          res.then(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(res)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">handleReject(resolve, reject, onRejectedFn) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> cppPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = onRejectedFn(<span class="keyword">this</span>.reason);</span><br><span class="line">        <span class="keyword">if</span> (res <span class="keyword">instanceof</span> cppPromise) &#123;</span><br><span class="line">          res.then(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(res)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">cppPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulledFn, onRejectedFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> cppPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 收集成功的回调</span></span><br><span class="line">      <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        handleResolve(resolve, reject, onFulledFn)</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 收集失败的回调</span></span><br><span class="line">      <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        handleReject(resolve, reject, onRejectedFn)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'fulfilled'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> cppPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        handleResolve(resolve, reject, onFulledFn)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> cppPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        handleReject(resolve, reject, onRejectedFn)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例调用2</span></span><br><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> cppPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'promise1'</span>, promise1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'promise2'</span>, promise2)</span><br></pre></td></tr></table></figure><h2 id="专业版1"><a href="#专业版1" class="headerlink" title="专业版1"></a>专业版1</h2><h3 id="手写MockPromise"><a href="#手写MockPromise" class="headerlink" title="手写MockPromise"></a>手写MockPromise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.status = <span class="string">'pending'</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.onResolvedCallbacks = []</span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallbacks = []</span><br><span class="line">    <span class="comment">// 定义resolve</span></span><br><span class="line">    <span class="keyword">let</span> resolve = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'resolve'</span></span><br><span class="line">        <span class="keyword">this</span>.value = data</span><br><span class="line">        <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reject</span></span><br><span class="line">    <span class="keyword">let</span> reject = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'reject'</span></span><br><span class="line">        <span class="keyword">this</span>.reason = data</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description </span>then函数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;function&#125;</span> </span>onFufilled </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;function&#125;</span> </span>onRejected </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  then(onFufilled, onRejected) &#123;</span><br><span class="line">    <span class="comment">// console.log(`onFufilled`, onFufilled);</span></span><br><span class="line">    <span class="comment">// console.log(`onRejected`, onRejected);</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> onFufilled !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      onFufilled = <span class="function"><span class="params">res</span> =&gt;</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      onRejected = <span class="function"><span class="params">res</span> =&gt;</span> MockPromise.reject(res)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> promise2</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'resolve'</span>) &#123;</span><br><span class="line">      promise2 = <span class="keyword">new</span> MockPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onFufilled(<span class="keyword">this</span>.value)</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'reject'</span>) &#123;</span><br><span class="line">      promise2 = <span class="keyword">new</span> MockPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      promise2 = <span class="keyword">new</span> MockPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onFufilled(<span class="keyword">this</span>.value);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">` onFufilled x pending`</span>, x);</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">` onRejected x pending`</span>, x);</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span>(cb) &#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">this</span>.constructor</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">      val =&gt; P.resolve(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> val),</span><br><span class="line">      reason = P.reject(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> resolve(val) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MockPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      resolve(val)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MockPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      reject(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当数组中每个实例都成功时才会返回，返回的也是一个数组，每个参数为对应的promise返回的结果，如果有一项失败了，all方法都会返回失败</span></span><br><span class="line">  <span class="comment">// 谁跑得慢以谁为准 如果有一个失败 则返回失败结果</span></span><br><span class="line">  <span class="keyword">static</span> all(promiseList) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MockPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">      <span class="keyword">const</span> results = []</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promiseList.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">const</span> item = promiseList[i]</span><br><span class="line">        <span class="keyword">if</span> (!item <span class="keyword">instanceof</span> MockPromise) <span class="keyword">return</span></span><br><span class="line">        item.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">          index ++</span><br><span class="line">          results[i] = result</span><br><span class="line">          <span class="keyword">if</span> (index === promiseList.length) &#123;</span><br><span class="line">            resolve(results)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">reason</span> =&gt;</span> reject(reason))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Promise.all示例</span></span><br><span class="line">  <span class="comment">// 谁跑得快 以谁为准</span></span><br><span class="line">  <span class="keyword">static</span> race(promiseList) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MockPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      promiseList.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!item <span class="keyword">instanceof</span> MockPromise) <span class="keyword">return</span></span><br><span class="line">        item.then(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">          resolve(val)</span><br><span class="line">        &#125;, (err) =&gt; &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> <span class="variable">promise2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> </span>resolve reject 最外层的resolve reject</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环了'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> called</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.then</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`x then`</span>, then);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一个参数是将x这个promise方法作为this指向，后两个参数分别为成功失败回调</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`called`</span>, called);</span><br><span class="line">        then.call(x,</span><br><span class="line">          (</span><br><span class="line">            y =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">              called = <span class="literal">true</span></span><br><span class="line">              <span class="comment">//因为可能promise中还有promise，所以需要递归</span></span><br><span class="line">              <span class="comment">// this.resolvePromise(promise2, y, resolve, reject)</span></span><br><span class="line">              resolve(y)</span><br><span class="line">            &#125;,</span><br><span class="line">            err =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">              called = <span class="literal">true</span></span><br><span class="line">              reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">          )</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用MockPromise"><a href="#使用MockPromise" class="headerlink" title="使用MockPromise"></a>使用MockPromise</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = MockPromise.resolve(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = MockPromise.resolve(p1)</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> MockPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">'cpp MockPromise'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br><span class="line"><span class="built_in">console</span>.log(p2)</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p1) <span class="comment">// trye</span></span><br><span class="line">p3.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`p3: <span class="subst">$&#123;val&#125;</span> then1 ————`</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;val&#125;</span> then3 ————`</span>);</span><br><span class="line">  <span class="comment">// then返回的mockPromise还是有问题!!循环引用</span></span><br><span class="line">  <span class="keyword">return</span> MockPromise.reject(<span class="string">'then is reject'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;val&#125;</span> then4 ————`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="专业版-2"><a href="#专业版-2" class="headerlink" title="专业版 2"></a>专业版 2</h2><h3 id="手写-cppPromise"><a href="#手写-cppPromise" class="headerlink" title="手写 cppPromise"></a>手写 cppPromise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 专业版2</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">      <span class="keyword">this</span>.status = <span class="string">'pending'</span>;</span><br><span class="line">      <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">this</span>.onResolvedCallbacks = []</span><br><span class="line">      <span class="keyword">this</span>.onRejectedCallbacks = []</span><br><span class="line">      <span class="keyword">const</span> resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.status = <span class="string">'fulfilled'</span></span><br><span class="line">          <span class="keyword">this</span>.value = val</span><br><span class="line">          <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              cb(val)</span><br><span class="line">            &#125;, <span class="number">0</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> reject = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.status = <span class="string">'rejected'</span></span><br><span class="line">          <span class="keyword">this</span>.reason = val;</span><br><span class="line">          <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              cb(val)</span><br><span class="line">            &#125;, <span class="number">0</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 使用者传入的参数</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fn(resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造器中resolve和reject的结果传入onFufilled和onRejected中</span></span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">      onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function">(<span class="params">v</span>) =&gt;</span> v;</span><br><span class="line">      onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;<span class="keyword">throw</span> e&#125;;</span><br><span class="line">      <span class="keyword">let</span> promise2</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'fulfilled'</span>) &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> value = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                resolvePromise(promise2, value, resolve, reject)</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">              reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.onRejectedCallbacks(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> reason = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                resolvePromise(promise2, reason, resolve, reject)</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">              reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 成功回调的收集 </span></span><br><span class="line">          <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> value = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">            resolvePromise(promise2, value, resolve, reject)  </span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="comment">// 失败回调的收集</span></span><br><span class="line">          <span class="keyword">this</span>.onRejectedCallbacks(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> reason = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">            resolvePromise(promise2, reason, resolve, reject) </span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> promise2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统一处理</span></span><br><span class="line">    resolvePromise(myPromise, val, resolve, reject) &#123;</span><br><span class="line">      <span class="keyword">if</span> (myPromise === val) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>)) </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (val &amp;&amp; (<span class="keyword">typeof</span> val === <span class="string">'object'</span> || <span class="keyword">typeof</span> val === <span class="string">'function'</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (val <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">            val.then(resolve)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(val)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">let</span> thenFn = val.then</span><br><span class="line">          <span class="keyword">let</span> called</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> thenFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">            thenFn.call(val, value =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">              called = <span class="literal">true</span></span><br><span class="line">              resolvePromise(promise2, value, resolve, reject)</span><br><span class="line">            &#125;, err =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">              called = <span class="literal">true</span></span><br><span class="line">              reject(err)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 其实就相当于</span></span><br><span class="line">            <span class="comment">// if (val instanceof myPromise) &#123;</span></span><br><span class="line">            <span class="comment">//   val.then(resolve, reject)</span></span><br><span class="line">            <span class="comment">// &#125; else &#123;</span></span><br><span class="line">            <span class="comment">//   resolve(val)</span></span><br><span class="line">            <span class="comment">//   reject(val)</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(val)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">          called = <span class="literal">true</span></span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  myPromise.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(val)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  myPromise.reject = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(val)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 入参是个由Promise实例组成的数组</span></span><br><span class="line">  <span class="comment">// 返回值是个promise，因为可以使用.then</span></span><br><span class="line">  <span class="comment">// 如果全部成功，状态变为resolved, 并且返回值组成一个数组传给回调</span></span><br><span class="line">  <span class="comment">// 但凡有一个失败，状态变为rejected, 并将error返回给回调</span></span><br><span class="line">  myPromise.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = []</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> promises) &#123;</span><br><span class="line">        item.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          result[index] = res</span><br><span class="line">          index ++ </span><br><span class="line">          <span class="keyword">if</span> (index === promises.length) &#123;</span><br><span class="line">            resolve(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, (err) =&gt; &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myPromise.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">        promise.then(resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="专业版2-示例"><a href="#专业版2-示例" class="headerlink" title="专业版2 示例"></a>专业版2 示例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myPromise.all示例</span></span><br><span class="line"><span class="keyword">let</span> p1 = myPromise.resolve(<span class="number">1</span>),</span><br><span class="line">p2 = myPromise.resolve(<span class="number">2</span>),</span><br><span class="line">p3 = myPromise.resolve(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">myPromise.all([p1, p2, p3]).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="string">'res'</span>)</span><br><span class="line">&#125;, (err)=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err, <span class="string">'err'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://juejin.cn/post/6844904094079926286" target="_blank" rel="noopener">最简实现Promise，支持异步链式调用（20行）</a> </li><li><a href="https://juejin.cn/post/6844903629187448845#heading-12" target="_blank" rel="noopener">Promise之你看得懂的Promise</a></li><li><a href="https://juejin.cn/post/6844903509934997511" target="_blank" rel="noopener">Promise 必知必会（十道题）</a></li><li><a href="https://mp.weixin.qq.com/s/PhZrP1gCn_VxLub7-oh1_w" target="_blank" rel="noopener">15道ES6 Promise实战练习题，助你快速理解Promise</a></li><li><a href="https://juejin.cn/post/6844903488695042062#heading-6" target="_blank" rel="noopener">八段代码彻底掌握 Promise</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> promise </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: js执行机制</title>
      <link href="/2020/12/26/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/12/26/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="js执行是单线程的"><a href="#js执行是单线程的" class="headerlink" title="js执行是单线程的"></a>js执行是单线程的</h3><p>单线程是指Js引擎执行Js时只分了一个线程给他执行，也就是执行js时是单线程的。说白点就是一个时间点只能做一件事，这里只是说javascript,浏览器可不是单线程的，浏览器可是多进程的</p><h3 id="js引擎"><a href="#js引擎" class="headerlink" title="js引擎"></a>js引擎</h3><p>JS引擎是浏览器的重要组成部分，主要用于读取并执行js。js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</p><p>各大浏览器的JS引擎:</p><table><thead><tr><th>浏览器</th><th>Js引擎</th></tr></thead><tbody><tr><td>Chrome</td><td><em>V8</em></td></tr><tr><td>Firefox</td><td>SpiderMonkey</td></tr><tr><td>IE</td><td>Chakra（查克拉）</td></tr><tr><td>Safari</td><td>Nitro/JavaScript Core</td></tr></tbody></table><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>浏览器（多进程）包含了Browser进程（浏览器的主进程）、第三方插件进程和GPU进程以及浏览器渲染进程，</p><ul><li>浏览器进程<br>浏览器最核心的进程，负责管理各个标签页的创建和销毁、页面显示和功能（前进，后退，收藏等）、网络资源的管理，下载等。</li><li>插件进程<br>负责每个第三方插件的使用，每个第三方插件使用时候都会创建一个对应的进程、这可以避免第三方插件crash影响整个浏览器、也方便使用沙盒模型隔离插件进程，提高浏览器稳定性。</li><li>GPU进程<br>负责3D绘制和硬件加速</li><li>渲染进程即 <strong>浏览器内核</strong><br>浏览器会为每个窗口分配一个渲染进程,也就是我们常说的浏览器内核，这可以避免单个 page crash 影响整个浏览器。</li></ul><p>其中浏览器渲染进程（多线程）和Web前端密切相关，包含以下线程</p><ul><li>GUI渲染线程<br> GUI 渲染线程负责渲染浏览器页面， 解析HTML元素, render DOM Tree,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。</li><li>JS引擎线程<br> Javascript引擎，也可以称为JS内核，主要负责处理 Javascript 脚本程序，例如V8引擎。Javascript 引擎线程理所当然是负责解析 Javascript 脚本，运行代码。</li><li>事件触发线程（和EventLoop密切相关）<br> 当一个事件被触发时该线程会把事件添加到事件队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。</li><li>定时器触发器线程<br> 浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。</li><li>异步HTTP请求线程<br> 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。</li></ul><blockquote><p>GUI渲染线程和JS引擎线程是互斥的，为了防止DOM渲染的不一致性，其中一个线程执行时另一个线程会被挂起。</p></blockquote><p>那么既然 JavaScript 本身被设计为单线程，为何还会有像 WebWorker 这样的多线程 API 呢？我们来看一下 WebWorker 的核心特点就明白了？</p><ul><li>创建 Worker 时， JS 引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</li><li>JS 引擎线程与 worker 线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）</li></ul><h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><p>为了实现js执行时的单线程，js引擎维护一个<strong>执行栈(先进后出)</strong> FILO,(想象下桌子上的一摞书，最上面的先被拿走，最下面的后面才能拿走)(栈数据结构特点)，主线程运行js代码时，会生成执行栈，能处理嵌套的函数，入栈出栈等操作。</p><h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><p>task queue任务队列是不是一个队列? </p><blockquote><p>他是一个set 集合, 因为不是在取任务的时候不是像队列那般先进先出就完了, 而是先把最老的任务获取, 执行, 执行完毕之后才删除.</p></blockquote><p>任务队列中分微任务和宏任务，且都是已经完成的<em>异步操作</em>. 这里要重点说明一下，<em>宏任务并非全是异步任务，主代码块就是属于宏任务的一种!!XHR也是宏任务的一种</em>如果当前的微任务没有执行完成时，是不会执行下一个宏任务的!</p><ul><li><p>宏任务是每次执行栈执行的代码（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</p></li><li><p>浏览器为了能够使得JS引擎线程与GUI渲染线程有序切换，会在当前宏任务结束之后，下一个宏任务执行开始之前，对页面进行重新渲染（宏任务 &gt;  微任务 &gt; 渲染 &gt; 宏任务 &gt; 微任务 &gt; 渲染…）</p></li><li><p>微任务是在当前宏任务执行结束之后立即执行的任务（在当前 宏任务执行之后，GUI渲染之前执行的任务）。微任务的响应速度相比setTimeout（下一个宏任务）会更快，因为无需等待UI渲染。</p></li><li><p>当前宏任务执行后，会将在它执行期间产生的所有微任务都执行一遍。</p><h4 id="微任务的产生时机"><a href="#微任务的产生时机" class="headerlink" title="微任务的产生时机"></a>微任务的产生时机</h4><p>主要有两种方式</p><ul><li>MutationObserver 监控某个DOM节点的变化, 绑定回调, 通过js来修改这个节点时(包括添加删除部分子节点)会将回调函数放入微任务队列中</li><li>Promise 当调用Promise.resolve()或Promise.reject()时会产生微任务, 即对应then的第一个和第二个参数放入到微任务队列中</li></ul></li></ul><ul><li>宏任务中的事件是由<strong>事件触发线程</strong>来维护的</li><li>微任务中的所有任务是由<strong>JS引擎线程</strong>维护的</li></ul><blockquote><p>下一个宏任务必然是在上一个微任务之后才会执行的</p></blockquote><table><thead><tr><th>macroTask宏任务</th><th>浏览器</th><th>node</th></tr></thead><tbody><tr><td>I/O用户交互(点击, 拖动, 触摸,放大缩小)</td><td>✅</td><td>✅</td></tr><tr><td>setTimeout</td><td>✅</td><td>✅</td></tr><tr><td>setImmediate</td><td>X</td><td>✅</td></tr><tr><td>requestAnimationFrame</td><td>✅</td><td>X</td></tr><tr><td>XMLHttpRequest</td><td>✅</td><td>✅</td></tr><tr><td>js脚本执行</td><td>✅</td><td>✅</td></tr></tbody></table><table><thead><tr><th>microTask微任务</th><th>浏览器</th><th>node</th></tr></thead><tbody><tr><td>process.nextTick</td><td>X</td><td>✅</td></tr><tr><td>MutationObserver</td><td>✅</td><td>X</td></tr><tr><td>Promise.then catch finally</td><td>✅</td><td>✅</td></tr></tbody></table><h3 id="js执行机制"><a href="#js执行机制" class="headerlink" title="js执行机制"></a>js执行机制</h3><p><img src= "/img/loading.gif" data-src="/images/eventLoop.png" alt="事件循环"></p><h4 id="大概过程"><a href="#大概过程" class="headerlink" title="大概过程:"></a>大概过程:</h4><ul><li><p>任务进入执行栈(js代码分同步任务和异步任务)</p></li><li><p>所有同步任务都在<em>主线程</em>执行。所有异步任务进入 <em>EventTable(事件表)</em>，执行异步任务，当事件表中的异步任务执行完成之后，会在<em>事件队列(event queue)</em>中注册回调函数(函数移入event Queue)</p></li><li><p>主线程里的同步任务全部完成之后，会读取事件队列(event Queue)中的异步任务,进入主线程执行</p></li><li><p>js解析器会不断重复检查主线程执行栈是否为空，然后重复第三步，即<em>Event Loop(事件循环)</em></p><blockquote><p>js引擎存在 monitoring process进程，会持续不断的检查主线程执行栈是否为空</p></blockquote><blockquote><p>在事件循环中，每进行一次循环操作称为tick</p></blockquote></li></ul><h4 id="JS引擎线程和事件触发线程"><a href="#JS引擎线程和事件触发线程" class="headerlink" title="JS引擎线程和事件触发线程"></a>JS引擎线程和事件触发线程</h4><p>浏览器页面初次渲染完毕后，JS引擎线程结合事件触发线程的工作流程如下：<br>（1）同步任务在JS引擎线程（主线程）上执行，形成执行栈（Execution Context Stack）。<br>（2）主线程之外，事件触发线程管理着一个任务队列（Task Queue）。只要异步任务有了运行结果，就在任务队列之中放置一个事件。<br>（3）执行栈中的同步任务执行完毕，系统就会读取任务队列，如果有异步任务需要执行，将其添加到主线程的执行栈并执行相应的异步任务。</p><p><img src= "/img/loading.gif" data-src="/images/macroTask.png" alt="执行过程"></p><h4 id="根据事件循环机制以及宏任务和微任务，重新梳理一下流程"><a href="#根据事件循环机制以及宏任务和微任务，重新梳理一下流程" class="headerlink" title="根据事件循环机制以及宏任务和微任务，重新梳理一下流程"></a>根据事件循环机制以及宏任务和微任务，重新梳理一下流程</h4><ul><li>执行一个宏任务（首次执行的主代码块 script 或者任务队列中的回调函数）</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有任务（依次执行）</li><li>JS引擎线程挂起，GUI线程执行渲染</li><li>GUI线程渲染完毕后挂起，JS引擎线程执行任务队列中的下一个宏任务</li></ul><h3 id="结合Promise实例看看执行机制"><a href="#结合Promise实例看看执行机制" class="headerlink" title="结合Promise实例看看执行机制"></a>结合Promise实例看看执行机制</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = <span class="function"><span class="params">()</span> =&gt;</span> <span class="function">(<span class="params"><span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">            resolve(<span class="number">6</span>);</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">        resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">    p.then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arg);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">first().then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>第一轮 事件循环，先执行宏任务，即主script,即new Promise立即执行，打印3 ，然后执行p这个new Promise,输出7，发现setTimeout,将回调函数放入下一轮宏任务队列中，p的then(then1),放入微任务队列，first的then(then2)放入微任务队列，执行打印4，第一轮tick执行结束<br>现在Event Queue中存在三个任务: 1个宏任务: setTimeout；2个微任务: then1.then2<br>执行微任务，先执行p.then打印1, 在执行first.then打印2</p><p>第一轮 事件循环结束，开始第二轮事件循环，先执行宏任务里面，打印5， resolve(6)不会生效，因为Promise状态一旦改变就不会发生变化,所以最终的打印顺序你都答对了吗</p><p>另外一个题目:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> rand = <span class="built_in">Math</span>.random()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>, rand);</span><br><span class="line">    <span class="keyword">if</span>(rand &gt; <span class="number">0.5</span>) resolve()</span><br><span class="line">    reject(rand)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(executor).then(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success-0'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(executor)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">_</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success-1'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(executor)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">er</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>, er)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>again</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"11111"</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"22222"</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  resolve();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"resolve"</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error"</span>); <span class="comment">// 注意这里是throw!!!</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"error"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"33333"</span>);</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"44444"</span>);</span><br><span class="line">      &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"reject"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"catch"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"55555"</span>);</span><br><span class="line"><span class="comment">// answer</span></span><br><span class="line"><span class="number">11111</span></span><br><span class="line">VM1014:<span class="number">7</span> resolve</span><br><span class="line">VM1014:<span class="number">26</span> <span class="number">55555</span></span><br><span class="line">VM1014:<span class="number">14</span> <span class="number">33333</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">VM1014:<span class="number">4</span> <span class="number">22222</span></span><br><span class="line">VM1014:<span class="number">16</span> <span class="number">44444</span></span><br></pre></td></tr></table></figure><h3 id="面试题之-了解v8引擎吗，一段js代码如何执行的-题外"><a href="#面试题之-了解v8引擎吗，一段js代码如何执行的-题外" class="headerlink" title="面试题之 了解v8引擎吗，一段js代码如何执行的(题外)"></a>面试题之 了解v8引擎吗，一段js代码如何执行的(题外)</h3><ul><li>在执行一段代码时，JS 引擎会首先创建一个执行栈，JS引擎会创建一个全局执行上下文，并push到执行栈中, 这个过程JS引擎会为这段代码中所有变量分配内存并赋一个初始值（undefined），在创建完成后，JS引擎会进入执行阶段，这个过程JS引擎会逐行的执行代码，即为之前分配好内存的变量逐个赋值(真实值)。</li><li>如果这段代码中存在function的声明和调用，那么JS引擎会创建一个函数执行上下文，并push到执行栈中，其创建和执行过程跟全局执行上下文一样。但有特殊情况，即当函数中存在对其它函数的调用时，JS引擎会在父函数执行的过程中，将子函数的全局执行上下文push到执行栈，这也是为什么子函数能够访问到父函数内所声明的变量。<br>还有一种特殊情况是，在子函数执行的过程中，父函数已经return了，这种情况下，JS引擎会将父函数的上下文从执行栈中移除，与此同时，JS引擎会为还在执行的子函数上下文创建一个闭包，这个闭包里保存了父函数内声明的变量及其赋值，子函数仍然能够在其上下文中访问并使用这边变量/常量。当子函数执行完毕，JS引擎才会将子函数的上下文及闭包一并从执行栈中移除。</li><li>last JS引擎是单线程的，那么它是如何处理高并发的呢？即当代码中存在异步调用时JS是如何执行的。比如setTimeout或fetch请求都是non-blocking的，当异步调用代码触发时，JS引擎会将需要异步执行的代码移出调用栈，直到等待到返回结果，JS引擎会立即将与之对应的回调函数push进任务队列中等待被调用，当调用(执行)栈中已经没有需要被执行的代码时，JS引擎会立刻将任务队列中的回调函数逐个push进调用栈并执行。这个过程我们也称之为事件循环。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>浏览器（多进程）包含了GPU进程（浏览器渲染进程），其中GPU进程（多线程）包含一下几个线程<br>  1.GUI渲染线程<br>  2.JS引擎线程<br>  3.事件触发线程（和EventLoop密切相关）<br>  4.定时触发器线程<br>  5.异步HTTP请求线程</li><li>javascript是一门单线程语言</li><li>Event Loop是javascript的执行机制</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.cn/post/6844903561164242952" target="_blank" rel="noopener">深入理解JavaScript执行（单线程的JS）</a></li><li><a href="https://juejin.cn/post/6844903667301089288" target="_blank" rel="noopener">图解JS执行机制</a></li><li><a href="https://juejin.cn/post/6844903512845860872" target="_blank" rel="noopener">这一次，彻底弄懂 JavaScript 执行机制</a></li><li><a href="https://juejin.cn/post/6844903843197616136" target="_blank" rel="noopener">你真的理解$nextTick么</a></li><li><a href="https://mp.weixin.qq.com/s/bkSmKYGHk0V5eZIfuSTNyQ" target="_blank" rel="noopener">浏览器是如何调度进程和线程的？</a></li><li><a href="https://juejin.cn/post/6844904115537969165" target="_blank" rel="noopener">任务队列,宏任务与微任务</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> 单线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
            <tag> 执行机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: promise-2</title>
      <link href="/2020/12/26/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-promise-2/"/>
      <url>/2020/12/26/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-promise-2/</url>
      
        <content type="html"><![CDATA[<p>先通过刷题熟悉下Promise的基本用法</p><h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="function"><span class="params">()</span> =&gt;</span> <span class="function">(<span class="params"><span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">            resolve(<span class="number">6</span>);</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">        resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">    p.then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arg);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;));</span><br><span class="line">first().then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  3 7 4 1 2 5</span></span><br></pre></td></tr></table></figure><h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'once'</span>)</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="built_in">Date</span>.now() - start)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="built_in">Date</span>.now() - start)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// once</span></span><br><span class="line"><span class="comment">// success 1001</span></span><br><span class="line"><span class="comment">// success 1001</span></span><br></pre></td></tr></table></figure><h3 id="03"><a href="#03" class="headerlink" title="03"></a>03</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then: '</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'catch: '</span>, err)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// then Error: error!!!</span></span><br><span class="line">  <span class="comment">// at &lt;anonymous&gt;</span></span><br></pre></td></tr></table></figure><p>.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获，需要改成其中一种：</p><ul><li>return Promise.reject(new Error(‘error!!!’))</li><li>throw new Error(‘error!!!’)</li></ul><p>因为返回任意一个<em>非 promise</em> 的值都会被包裹成 promise 对象，即 return new Error(‘error!!!’) 等价于 <strong>return Promise.resolve(new Error(‘error!!!’))</strong>。</p><h3 id="04"><a href="#04" class="headerlink" title="04"></a>04</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> <span class="title">success</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> <span class="title">fail1</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'fail1: '</span>, e)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> <span class="title">fail2</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'fail2: '</span>, e)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//  fail2:  Error: error</span></span><br><span class="line">  <span class="comment">//  at success (&lt;anonymous&gt;:3:11)</span></span><br></pre></td></tr></table></figure><h3 id="05"><a href="#05" class="headerlink" title="05"></a>05</h3><p>请实现一个mergePromise函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组data中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timeout = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;, ms);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax1 = <span class="function"><span class="params">()</span> =&gt;</span> timeout(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax2 = <span class="function"><span class="params">()</span> =&gt;</span> timeout(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax3 = <span class="function"><span class="params">()</span> =&gt;</span> timeout(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mergePromise = <span class="function"><span class="params">ajaxArray</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里实现你的代码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mergePromise([ajax1, ajax2, ajax3]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// data 为 [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> promise </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的2020年度总结</title>
      <link href="/2020/12/20/%E6%88%91%E7%9A%842020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2020/12/20/%E6%88%91%E7%9A%842020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[  <h4 style='color: green;font-style:italic'> 人生最曼妙的风景，是内心的淡定和从容</h4><pre><code>2020年一眨眼的功夫就没了，越来越觉得时间的重要性。人都是被逼出来的，我发现自己做事越来越专注，这是一种很好的趋势，希望自己能保持出。刚过去的2020年，是值得永远铭记的一年，两位至亲突然离世让我一时难以接受现实，总以为时间还很长很长。病魔说来就来，人在这方面太过于渺小，毫无还手之力，难以改变命运。每个人都有走到终点的那一天，我只希望自己在行将就木的时候，能坦然面对。2021年给自己提出的小目标就是身体健康永远是摆在第一位的，活一天就要健健康康一天。</code></pre><h2 id="工作和学习"><a href="#工作和学习" class="headerlink" title="工作和学习"></a>工作和学习</h2><p>  有一种感觉，到了2020年才感觉自己真正走进前端。以前总觉得很难理解的名词术语，现在慢慢开始理解了，刚开始第一遍不理解，过俩月，第二遍就理解加深一点，第三遍再去看的时候，是不是更加融会贯通一点，所以2021年给自己的目标是重学前端，从最基础的js/es6/css学起，到前端框架vue源码学习，前端工程化，如果有精力，nodejs这块，部署一个网站也是要学会和理解的。<br>  不能再像以前一样，埋头苦干业务，干五年和干一年都一个样，很没有意义。要着眼于未来，所以，哪怕是在忙，也要抽时间学习。学什么呢，什么不会就学什么，直到深刻领悟的地步。<br>  之前看过一篇文章，说程序员如何阅读源码，我觉得说得很有道理，原文是这么说的<br>    - 领悟思想：只需体会作者设计框架的初衷和目的<br>    - 把握设计：只需体会代码的接口和抽象类以及宏观的设计<br>    - 体会细节：是基于顶层的抽象接口设计，逐渐展开代码的画卷<br>  很有指导意义，希望能按照这几点，好好品读 vue/webpack/axios等生态相关库框架源码，并通过文字记录下来。内心其实是很想进大厂看看，不想老了后悔，但无奈不是科班出身，加上这两年的岁月蹉跎，结果就是(苦笑)！最近这几个月，好好苦读和学习吧。每天学习一点点，哪怕是一点点，坚持几个月也是不错的收获，真希望自己能厚积薄发一次</p><p>  今年开始学习前端基础知识，写了几篇入门的文章，但总感觉有些东西还是不能立马说出来</p><ul><li>Class 和 继承</li><li>手写代码系列(这部分现在让我说我感觉自己又忘了，不能深刻理解这很头疼啊)</li><li>Webpack初始化项目</li><li>Vscode插件学习</li><li>自己的脚手架搭建cpp-cli-test</li><li>设计模式之装饰器学习</li></ul><p>我发现自己还是比较喜欢前端<em>工程化</em>，所以有时间就好好研究一下吧.前几天看了一篇文章，说的是大龄海龟硕士求职前端故事，<a href="https://mp.weixin.qq.com/s/G0c3gGAvM8YQXCD4EiwLlg" target="_blank" rel="noopener">面试一位硕士海龟前端小姐姐有感</a>,其中的辛酸感觉就像发生在自己身上，况且我还没有人家这么高的学历，更应该提升技术深度。但什么技术深度呢？看源码吗？有点找不到答案，说不上什么感觉</p><h2 id="生活和书法"><a href="#生活和书法" class="headerlink" title="生活和书法"></a>生活和书法</h2><p>  生活不止有代码还有书法和健身，希望自己能够在坚持住自己的爱好，好好领悟生活的真谛</p><h2 id="理财和基金"><a href="#理财和基金" class="headerlink" title="理财和基金"></a>理财和基金</h2><p>  现在的职业不可能一直干下去，顶多也就还有五年的光阴，考虑后续的工作很有必要，除了现在的程序员，自己还能做什么？又是苦笑不得，确实目前还找不到答案。2021年，希望自己能学习一下理财方面的知识，虽然也没多少财阔以理的，技多不压身，学习到了总比没有强。</p><h2 id="后续安排"><a href="#后续安排" class="headerlink" title="后续安排"></a>后续安排</h2><p>  js基础永远不会过时，犹如内功，不管学什么招数都是手到擒来</p><ul><li><p>事件循环</p></li><li><p>promise/generator/async await(promise最难实现的是哪个点)</p></li><li><p>ts 泛型 装饰器</p></li><li><p>webpack plugin loader</p></li><li><p>nodejs </p></li><li><p>vue</p></li><li><p>算法</p></li><li><p>渲染器原理</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2></li><li><p><a href="http://www.ruanyifeng.com/blog/2015/04/generator.html" target="_blank" rel="noopener">Generator 函数的含义与用法</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 前端 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端之装饰者模式以及装饰器</title>
      <link href="/2020/12/13/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2020/12/13/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-src="/images/Decorator2.jpeg" alt="Decorator"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>给对象动态增加职责的方式称为装饰者模式。该模式能够在不改变对象自身的基础上，在程序运行期间给对象动态增加指责</p><h3 id="装饰函数"><a href="#装饰函数" class="headerlink" title="装饰函数"></a>装饰函数</h3><p>想要为函数增加额外功能，最简单粗暴的方式直接改写函数，但这很不友好，违反 <strong>封闭-开放原则</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="number">1</span>)&#125;</span><br><span class="line"><span class="comment">// 改成</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  alert(<span class="number">1</span>);</span><br><span class="line">  alert(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br></pre></td></tr></table></figure><p>在不改变函数源代码的方式能给函数增加功能，这正是开放-封闭原则。通过保存原引用的方式改写函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="number">1</span>)&#125;</span><br><span class="line"><span class="keyword">var</span> _a = a</span><br><span class="line">a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  _a()</span><br><span class="line">  alert(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br></pre></td></tr></table></figure><h3 id="编写装饰器"><a href="#编写装饰器" class="headerlink" title="编写装饰器"></a>编写装饰器</h3><p>class decorator 类装饰器<br>method decorator 方法装饰器<br>property decorator 属性装饰器<br>parameter decorator 参数装饰器</p><p>装饰器是一种特殊类型的声明，它能够被附加到<em>类声明，方法， 访问符，属性或参数</em>上。 装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。</p><h4 id="装饰器工厂"><a href="#装饰器工厂" class="headerlink" title="装饰器工厂"></a>装饰器工厂</h4><p>如果我们要定制一个修饰器如何应用到一个声明上，我们得写一个装饰器工厂函数。 装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thinFace</span>(<span class="params">name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, <span class="string">'开启瘦脸'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"thinFace(): called"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increaseEye</span>(<span class="params">name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, <span class="string">'增大眼睛'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target: <span class="built_in">string</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"increaseEye(): called"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@thinFace</span>(<span class="string">'cpp'</span>)</span><br><span class="line"><span class="meta">@increaseEye</span>(<span class="string">'niaogege'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Girl &#123;&#125;</span><br><span class="line"><span class="comment">// 打印参数</span></span><br><span class="line"></span><br><span class="line">cpp 开启瘦脸</span><br><span class="line">niaogege 增大眼睛</span><br><span class="line">increaseEye(): called</span><br><span class="line">thinFace(): called</span><br></pre></td></tr></table></figure><p>在TypeScript里，当多个装饰器应用在一个声明上时会进行如下步骤的操作：</p><ul><li>由上至下依次对装饰器表达式求值。</li><li>求值的结果会被当作函数，由下至上依次调用(装饰器函数)。</li></ul><h4 id="类装饰器-class-decorator-类装饰器"><a href="#类装饰器-class-decorator-类装饰器" class="headerlink" title="类装饰器 class decorator 类装饰器"></a>类装饰器 class decorator 类装饰器</h4><p>类装饰器在类声明之前被声明（紧靠着类声明）。<br>类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。即在执行装饰器函数时，会把类构造函数传递给装饰器函数。<br>如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thinFace</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  onsole.log(<span class="string">'thinFace Before'</span>, <span class="keyword">constructor</span>); <span class="comment">// 把Girl类构造函数传递给装饰器函数</span></span><br><span class="line">  <span class="keyword">constructor</span>.prototype.thinFaceF = function (<span class="params">params: <span class="built_in">any</span></span>) &#123; <span class="comment">// 给构造函数原型上增加新的方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'become thinFace'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classDecorator</span>(<span class="params">value: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'类的装饰器 Before'</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'接受一个构造函数'</span>, value); <span class="comment">// 如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@thinFace</span></span><br><span class="line"><span class="meta">@classDecorator</span>(<span class="string">'cpp'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Girl &#123;</span><br><span class="line">  <span class="keyword">private</span> greeting: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">msg: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = msg</span><br><span class="line">  &#125;</span><br><span class="line">  greetName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello!, <span class="subst">$&#123;<span class="keyword">this</span>.greeting&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  thinFaceF() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Grid 类里的函数'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> Girl(<span class="string">'wmh'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Girl类的实例'</span>, g);</span><br><span class="line">g.thinFaceF();</span><br><span class="line"><span class="comment">// 类的装饰器 Before</span></span><br><span class="line"><span class="comment">// 接受一个构造函数 cpp</span></span><br><span class="line"><span class="comment">// thinFace Before class Girl</span></span><br><span class="line"><span class="comment">// become thinFace</span></span><br></pre></td></tr></table></figure><h3 id="ts项目的运用"><a href="#ts项目的运用" class="headerlink" title="ts项目的运用"></a>ts项目的运用</h3><ul><li><a href="https://www.tslang.cn/docs/handbook/decorators.html" target="_blank" rel="noopener">装饰器</a></li></ul><h3 id="Ts项目中的’vue-property-decorator’拆解"><a href="#Ts项目中的’vue-property-decorator’拆解" class="headerlink" title="Ts项目中的’vue-property-decorator’拆解"></a>Ts项目中的’vue-property-decorator’拆解</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h3 id="ts报错信息"><a href="#ts报错信息" class="headerlink" title="ts报错信息"></a>ts报错信息</h3><ul><li><p>Unable to resolve signature of class decorator when called as an expression.<br>This expression is not callable.<br>  Type ‘void’ has no call signatures.</p></li><li><p>signature 签名</p></li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.tslang.cn/docs/handbook/decorators.html" target="_blank" rel="noopener">ts中的装饰器</a></li><li><a href="https://zhuanlan.zhihu.com/p/271226380" target="_blank" rel="noopener">设计模式大冒险第二关：装饰者模式，煎饼果子的主场</a></li><li><a href="https://segmentfault.com/a/1190000022415199" target="_blank" rel="noopener">装饰者模式和TypeScript装饰器</a></li><li><a href="https://juejin.cn/post/6895350355219972109" target="_blank" rel="noopener">从Typescript装饰器浅谈装饰者模式</a></li><li><a href="https://www.softwhy.com/article-9203-1.html" target="_blank" rel="noopener">Object.seal &amp; Object.freeze</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Decorator </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> Decorator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node包里的package.json文件</title>
      <link href="/2020/12/13/node%E5%8C%85%E9%87%8C%E7%9A%84package-json%E6%96%87%E4%BB%B6/"/>
      <url>/2020/12/13/node%E5%8C%85%E9%87%8C%E7%9A%84package-json%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>敲了两年业务代码，从来不会去留意node包里的配置，一般业务用到哪个包就去直接<em>npm i XX -D</em>, 也不会去想这包里都有啥，这样浑浑噩噩过了好长时间。其实这样很不好，就是一个单纯的切图仔，我可不想一直这样，所以最近就开始捣鼓node包，开始看的时候 对 <em>package.json</em> 里的配置项不是很熟悉，现阶段就是看一点理解了就记录一点。<br>先看下目前node包里的<em>package.json</em>文件配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"webpack-learn"</span>, <span class="comment">// 包名 一般采用中划线或者下划线，不建议采用小驼峰的形式命名</span></span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>, <span class="comment">// 版本</span></span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"vue webpack"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"dist/main.js"</span>,</span><br><span class="line">  <span class="attr">"module"</span>: <span class="string">"dist/main.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"webpack-dev-server --progress --config build/webpack.config.dev.js --inline --hot"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --progress --config build/webpack.config.prod.js"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [</span><br><span class="line">    <span class="string">"webpack init project"</span>,</span><br><span class="line">    <span class="string">"webpack"</span>,</span><br><span class="line">    <span class="string">"init Project"</span>,</span><br><span class="line">    <span class="string">"vue"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"engines"</span>: &#123;</span><br><span class="line">    <span class="attr">"node"</span>: <span class="string">"&gt;= 6"</span> <span class="comment">// node环境要求</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"cpp"</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"homepage"</span>: <span class="string">"https://github.com/niaogege/webpack-learn"</span>, <span class="comment">// 项目介绍主页</span></span><br><span class="line">  <span class="attr">"repository"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"git"</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"https://github.com/niaogege/webpack-learn.git"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"files"</span>: [</span><br><span class="line">    <span class="string">"dist"</span>,</span><br><span class="line">    <span class="string">"src"</span>,</span><br><span class="line">    <span class="string">"public"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"vue"</span>: <span class="string">"^2.6.12"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"babel-core"</span>: <span class="string">"^6.26.3"</span>,</span><br><span class="line">    <span class="attr">"babel-loader"</span>: <span class="string">"^8.2.2"</span>,</span><br><span class="line">    <span class="attr">"clean-webpack-plugin"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main-module"><a href="#main-module" class="headerlink" title="main / module"></a>main / module</h3><p><em>Main property in package.json defines package entry point 定义包的出口</em><br>简单说: 供项目用import导入的入口，主要作用是暴露此依赖包的出口，比如vue源码里的package.json中这么定义的</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">"main": "dist/vue.runtime.common.js", // 运行时用的common版本</span><br><span class="line">"module": "dist/vue.runtime.esm.js", // 运行用的es版本</span><br></pre></td></tr></table></figure><p>如果不定义main，项目中运用依赖包需要这样引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin.js'</span>);</span><br></pre></td></tr></table></figure><p>看了下vue-loader中该文件的出口定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">let</span> VueLoaderPlugin = <span class="literal">null</span></span><br><span class="line"><span class="keyword">if</span> (webpack.version &amp;&amp; webpack.version[<span class="number">0</span>] &gt; <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="comment">// webpack5 and upper</span></span><br><span class="line">  VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'./plugin-webpack5'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// webpack4 and lower</span></span><br><span class="line">  VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'./plugin-webpack4'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = VueLoaderPlugin</span><br></pre></td></tr></table></figure><h3 id="devDependencies-dependencies"><a href="#devDependencies-dependencies" class="headerlink" title="devDependencies / dependencies"></a>devDependencies / dependencies</h3><p>运行 <em>–save-dev</em> 或者 -D 安装的 插件，被写入到 <em>devDependencies</em> 域里面去，而使用 <em>–save</em> 或者 -S 安装的插件，则是被写入到 <em>dependencies</em> 区块里面去.<br>npm install 【插件名】或 npm install 【插件名】–save 归属dependencies，表示代码运行时所需要的包。</p><p>npm install 【插件名】–save-dev 归属 devDependencies，表示开发时依赖的插件（即不会打包至线上）。</p><p>dependencies, 生产环境依赖，也就是依赖会被打包到web就用中<br>devDependencies, 开发环境依赖，不会被打包，是保证web就用能运行起来的根本。</p><p>区别: </p><p>假设我是一名npm包的开发者，那么我发布的包的package.json就需要认真分好所依赖的包到底是dependencies还是devDependencies。因为我发布的包是给别人使用的，别人不会去管你是用什么环境开发的，别人要的是最终开发出来的源码。所以，当别人npm命令去安装时：</p><p><code>npm install xxx -D</code></p><p>只会把xxx里的dependencies的包下载下来，而不会去下载devDependencies里面的包。所以在发布npm包的时候，dependencies和devDependencies一定要严格区分开来!!</p><h3 id="files"><a href="#files" class="headerlink" title="files"></a>files</h3><p>这个就好理解，下载的依赖包里包含的文件名数组，像我在cpp-cli-test这个npm包里的files就是<br><code>files: [    &quot;dist&quot;,    &quot;src&quot;,    &quot;public&quot;]</code><br>因为我不想把npm包里的node_modules文件也上传，所以这里就只包含了三个文件夹</p><h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p>本人开发的脚手架会用到bin字段, 包的命令，比如<em>cpp -V</em>,</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"main": "./bin/index.js",</span><br><span class="line">"bin": &#123;</span><br><span class="line">  "cpp": "./bin/index.js" // 全局注册cpp命令</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><ul><li>废弃版本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm deprecate &lt;pkg-name&gt;[@&lt;version&gt;] &lt;message&gt;</span><br><span class="line">示例</span><br><span class="line">npm deprecate cpp-cli-test@&quot; &lt;1.0.1&quot; &quot;sorry 这个包已经被废弃了&quot;</span><br></pre></td></tr></table></figure></li><li>包的维护者和添加维护者<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm owner ls cpp-cli-test</span><br><span class="line"></span><br><span class="line">npm owner add 用户名字 包名</span><br></pre></td></tr></table></figure></li><li>打开一个模块的主页<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm home 包名</span><br></pre></td></tr></table></figure></li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><p><a href="https://bytearcher.com/articles/main-property-in-package.json-defines-entry-point/" target="_blank" rel="noopener">Main property in package.json defines package entry point</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/59601665" target="_blank" rel="noopener">package.json中的dependencies和devDependencies区别</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/z9hyaOf85DFMweBmtm1YRA" target="_blank" rel="noopener">发布NPM包</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
          <category> package.json </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> package.json </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>辅助开发工具和调试</title>
      <link href="/2020/12/12/%E8%BE%85%E5%8A%A9%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%92%8C%E8%B0%83%E8%AF%95/"/>
      <url>/2020/12/12/%E8%BE%85%E5%8A%A9%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%92%8C%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="安装-sourceTree"><a href="#安装-sourceTree" class="headerlink" title="安装 sourceTree"></a>安装 sourceTree</h3><ul><li><p>打开企业版<a href="https://www.sourcetreeapp.com/enterprise" target="_blank" rel="noopener">链接</a>,先下载，然后找到<em>C:\Program Files (x86)\Atlassian\Sourcetree</em>目录安装</p></li><li><p>在查询文件里输入 <em>%LocalAppData%\Atlassian\SourceTree\accounts.json</em>，编辑成以下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"$id"</span>: <span class="string">"1"</span>,</span><br><span class="line">    <span class="attr">"$type"</span>: <span class="string">"SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity"</span>,</span><br><span class="line">    <span class="attr">"Authenticate"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"HostInstance"</span>: &#123;</span><br><span class="line">      <span class="attr">"$id"</span>: <span class="string">"2"</span>,</span><br><span class="line">      <span class="attr">"$type"</span>: <span class="string">"SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount"</span>,</span><br><span class="line">      <span class="attr">"Host"</span>: &#123;</span><br><span class="line">        <span class="attr">"$id"</span>: <span class="string">"3"</span>,</span><br><span class="line">        <span class="attr">"$type"</span>: <span class="string">"SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount"</span>,</span><br><span class="line">        <span class="attr">"Id"</span>: <span class="string">"atlassian account"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"BaseUrl"</span>: <span class="string">"https://id.atlassian.com/"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"Credentials"</span>: &#123;</span><br><span class="line">      <span class="attr">"$id"</span>: <span class="string">"4"</span>,</span><br><span class="line">      <span class="attr">"$type"</span>: <span class="string">"SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account"</span>,</span><br><span class="line">      <span class="attr">"Username"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"Email"</span>: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"IsDefault"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>工具 -&gt; 选项 -&gt; 选择 <em>Dark</em> 主题</p></li></ul><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>如若遇到ssh-key已经生效 但每次git push的时候还需要登录github弹框，这时候受到删除 <strong>C:\Users%USERNAME%\AppData\Local\Atlassian\SourceTree 目录下的passwd文件</strong>,然后再通过命令行推送，第一次的时候还是需要手动push</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/qq_36735629/article/details/86422488" target="_blank" rel="noopener">企业版sourcetree</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> sourceTree </category>
          
          <category> git </category>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
            <tag> sourceTree </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶-大杂烩-1</title>
      <link href="/2020/12/05/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E5%A4%A7%E6%9D%82%E7%83%A9-1/"/>
      <url>/2020/12/05/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E5%A4%A7%E6%9D%82%E7%83%A9-1/</url>
      
        <content type="html"><![CDATA[<p>本周涉及内容</p><ul><li>vue 插槽</li><li>函数柯里化</li><li>装饰者模式 &amp;&amp; 装饰器</li><li>函数式编程 &amp;&amp; 命令式编程</li><li>proxy</li><li>css加速</li><li>cdn缓存</li></ul><h3 id="vue插槽slot"><a href="#vue插槽slot" class="headerlink" title="vue插槽slot"></a>vue插槽slot</h3><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><ul><li>函数参数固定<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry2 = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">judge</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length === fn.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn(...args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> judge(...args, ...arg)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> add2 = <span class="function">(<span class="params">a,b,c</span>) =&gt;</span> a + b + c;</span><br><span class="line"><span class="keyword">const</span> curryAdd2 = curry2(add2)</span><br><span class="line"><span class="built_in">console</span>.log(curryAdd2(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(curryAdd2(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(curryAdd2(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)) <span class="comment">// curryAdd2(...)(...) is not a function</span></span><br></pre></td></tr></table></figure></li><li>参数不固定<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> addFn = <span class="function">(<span class="params">...arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr, <span class="string">'arr'</span>, <span class="built_in">Object</span>.prototype.toString.call(arr));</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a +b )</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = []</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">temp</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length) &#123;</span><br><span class="line">      arr = [...arr, ...args]</span><br><span class="line">      <span class="keyword">return</span> temp</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`arr`</span>, arr);</span><br><span class="line">      <span class="keyword">const</span> val = fn.apply(<span class="keyword">this</span>, arr)</span><br><span class="line">      arr = []</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> curryAdd = curry(addFn)</span><br><span class="line"><span class="keyword">const</span> test1 = curryAdd(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)()</span><br><span class="line"><span class="keyword">const</span> test2 = curryAdd(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)()</span><br><span class="line"><span class="keyword">const</span> test3 = curryAdd(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)(<span class="number">5</span>, <span class="number">6</span>)()</span><br><span class="line"><span class="built_in">console</span>.log(test1) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(test2) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(test3); <span class="comment">// 21</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="装饰者模式-amp-amp-装饰器-Decorator"><a href="#装饰者模式-amp-amp-装饰器-Decorator" class="headerlink" title="装饰者模式 &amp;&amp; 装饰器(Decorator)"></a>装饰者模式 &amp;&amp; 装饰器(Decorator)</h3>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> vue </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 在学es6之class</title>
      <link href="/2020/11/15/%E5%9F%BA%E7%A1%80-%E5%9C%A8%E5%AD%A6es6%E4%B9%8Bclass/"/>
      <url>/2020/11/15/%E5%9F%BA%E7%A1%80-%E5%9C%A8%E5%AD%A6es6%E4%B9%8Bclass/</url>
      
        <content type="html"><![CDATA[<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>class是一个语法糖，其底层还是通过 构造函数 去创建的。新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><h4 id="es5实现"><a href="#es5实现" class="headerlink" title="es5实现"></a>es5实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h4 id="es6实现"><a href="#es6实现" class="headerlink" title="es6实现"></a>es6实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125; </span><br><span class="line">  toString () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>上面代码定义了一个“类”，可以看到里面有一个<strong>constructor</strong>方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5 的构造函数Point，对应 ES6 的Point类的构造方法。</p><h4 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h4><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> A()) <span class="keyword">instanceof</span> A);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h4><ul><li>生成类的实例的写法，与 ES5 完全一样，也是使用 new 命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。</li><li>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在<em>this</em>对象上），否则都是定义在原型上(即定义在<em>class</em>类上)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CppPerson</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(&#123;name, age, fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.showFn = fn</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="keyword">this</span>.name</span><br><span class="line">    <span class="keyword">return</span> name.charAt(<span class="number">0</span>).toUpperCase() + name.slice(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> CppPerson(&#123;</span><br><span class="line">  name: <span class="string">'cpp'</span>,</span><br><span class="line">  age: <span class="string">'30'</span>,</span><br><span class="line">  fn: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is fn'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">person.getName() </span><br><span class="line">person.showFn()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'person'</span>, person);</span><br><span class="line">person.hasOwnProperty(<span class="string">'name'</span>) <span class="comment">// true</span></span><br><span class="line">person.hasOwnProperty(<span class="string">'age'</span>) <span class="comment">// true</span></span><br><span class="line">person.hasOwnProperty(<span class="string">'getName'</span>) <span class="comment">// false</span></span><br><span class="line">person.__proto__.hasOwnProperty(<span class="string">'getName'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>与 ES5 一样，类的所有实例共享一个原型对象。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo.classMethod() <span class="comment">// 'hello'</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()<span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure><h3 id="实例属性的新写法"><a href="#实例属性的新写法" class="headerlink" title="实例属性的新写法"></a>实例属性的新写法</h3><p>实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncreasingCounter</span> </span>&#123;</span><br><span class="line">  _count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> value() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Getting the current value!'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    <span class="keyword">this</span>._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>突然联想到目前的业务项目，做了2年才发现也是这样的写法，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> item: <span class="built_in">number</span> = <span class="number">0</span> <span class="comment">// 快捷导航选中index</span></span><br><span class="line"><span class="keyword">private</span> url: <span class="built_in">any</span> = &#123;&#125;; <span class="comment">// 默认url赋值</span></span><br></pre></td></tr></table></figure><p>上面代码中，实例属性item与原型上的方法，处于同一个层级。这时，不需要在实例属性前面加上this。<br>这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。<br>原本应该是这样写的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">class</span> VueGrid <span class="keyword">extends</span> Vue &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.item = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.url = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line">Foo.prop <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面的写法为Foo类定义了一个静态属性prop。</p><p>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个提案提供了类的静态属性，写法是在实例属性的前面，加上static关键字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> myStaticProp = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(MyClass.myStaticProp); <span class="comment">// 42</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个新写法大大方便了静态属性的表达。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> prop = <span class="number">1</span>; <span class="comment">// 新写法是显式声明（declarative），而不是赋值处理，语义更好。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="extends继承"><a href="#extends继承" class="headerlink" title="extends继承"></a>extends继承</h3><p>Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。<br>这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。</p><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>在 super() 执行时，它指向的是 子类 B 的构造函数，而不是父类 A 的构造函数。也就是说，super() 内部的 this 指向的是 B<br><em>super()<em>相当于</em>Parent.prototype.constructor.call(this. props)</em><br>super本身是指向父类的构造函数但做函数调用后返回的是子类的实例，实际上做了<em>parent.prototype.constructor.call(this)</em>，做对象调用时指向父类 parent.prototype,从而实现继承</p><p>super这个关键字，既可以当作函数 Function 使用，也可以当作对象 Object 使用。在这两种情况下，它的用法完全不同。</p><h4 id="作函数-Function-使用"><a href="#作函数-Function-使用" class="headerlink" title="作函数 Function 使用"></a>作函数 Function 使用</h4><p>代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> A() <span class="comment">// A</span></span><br><span class="line"><span class="keyword">new</span> B() <span class="comment">// B</span></span><br></pre></td></tr></table></figure><p>虽然代表父类的构造函数，但是返回的是子类的实例，即super内部的this指的是B的实例，因此super()在这里相当于A.prototype.constructor.call(this)。</p><blockquote><p>有点绕！！！</p></blockquote><h4 id="当作对象-Object-使用"><a href="#当作对象-Object-使用" class="headerlink" title="当作对象 Object 使用"></a>当作对象 Object 使用</h4><p>super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  p() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.p()); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure><p>子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。注意是A类原型对象上的方法。<br>这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    name() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'cpp'</span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果属性定义在父类的原型对象上，super就可以取到。</span></span><br><span class="line">Test.prototype.age = <span class="number">29</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">super</span>.name())</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">super</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Test1()) <span class="comment">// 'cpp' 29</span></span><br></pre></td></tr></table></figure><p>实例属性和方法: constructor里的，就是绑定的this，比如this.name<br>原型属性和方法: class里除了构造函数以内，其他的方法就是原型方法，原型属性需要用到Test.prototype来定义<br>静态属性和方法: static关键字标识，只能类本身调用，类的实例不能调用<br>私有属性和方法: ts里的private关键字</p><h4 id="ES6-规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例"><a href="#ES6-规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例" class="headerlink" title="ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例"></a>ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  m() &#123;</span><br><span class="line">    <span class="keyword">super</span>.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.m() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。"><a href="#如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。" class="headerlink" title="如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。"></a>如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> myMethod(msg) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'static'</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'instance'</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> myMethod(msg) &#123;</span><br><span class="line">    <span class="keyword">super</span>.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    <span class="keyword">super</span>.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.myMethod(<span class="number">1</span>); <span class="comment">// static 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child();</span><br><span class="line">child.myMethod(<span class="number">2</span>); <span class="comment">// instance 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p><h3 id="ES5-和-ES6继承区别"><a href="#ES5-和-ES6继承区别" class="headerlink" title="ES5 和 ES6继承区别"></a><a href="https://es6.ruanyifeng.com/#docs/class-extends" target="_blank" rel="noopener">ES5 和 ES6继承区别</a></h3><p>ES5 的继承，通过prototype或构造函数机制来实现, 实质是先创造子类的实例对象this，再将父类的方法添加到this上面（Parent.apply(this)）。<br>ES6 的继承机制完全不同，实质是先创建父类的实例对象this(所以必须先调用父类的super()方法)，然后再用子类的构造函数修改this。</p><p>另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y, color) &#123;</span><br><span class="line">    <span class="keyword">this</span>.color = color; <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="keyword">super</span>(x, y);</span><br><span class="line">    <span class="keyword">this</span>.color = color; <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">Class 的基本语法</a></li><li><a href="https://juejin.im/post/6844904086089760775" target="_blank" rel="noopener">详解ES6中的class</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> class </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础-基于webpack搭建vue项目</title>
      <link href="/2020/11/14/%E5%9F%BA%E7%A1%80-webpack%E6%90%AD%E5%BB%BAvue%E9%A1%B9%E7%9B%AE/"/>
      <url>/2020/11/14/%E5%9F%BA%E7%A1%80-webpack%E6%90%AD%E5%BB%BAvue%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>学习如何用webpack搭建项目，成为模板，为后面的脚手架做准备，需要学习的有</p><ul><li>webpack</li><li>node</li><li>学会手写自己的loader</li><li>手写plugin</li><li>webpack的异步加载如何实现</li><li>webpack的分包策略</li></ul><h3 id="什么是webpack？"><a href="#什么是webpack？" class="headerlink" title="什么是webpack？"></a>什么是webpack？</h3><p>官网是这么描述的: </p><blockquote><p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p></blockquote><p>先理解四个核心概念：</p><ul><li>入口(entry)</li><li>输出(output)</li><li>加载器(loader)</li><li>插件(plugins)</li></ul><h3 id="webpack搭建vue项目"><a href="#webpack搭建vue项目" class="headerlink" title="webpack搭建vue项目"></a>webpack搭建vue项目</h3><p>即<a href="https://github.com/niaogege/webpack-learn" target="_blank" rel="noopener">webpack搭建vue</a></p><h4 id="本地项目涉及的webpack版本"><a href="#本地项目涉及的webpack版本" class="headerlink" title="本地项目涉及的webpack版本"></a>本地项目涉及的webpack版本</h4><p>webpack版本众多，有时会被这些琐粹的玩意搞得头晕</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"webpack"</span>: <span class="string">"^4.41.2"</span>,</span><br><span class="line">  <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.9"</span>,</span><br><span class="line">  <span class="attr">"webpack-dev-server"</span>: <span class="string">"^3.9.0"</span>,</span><br><span class="line">  <span class="attr">"webpack-merge"</span>: <span class="string">"^5.4.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="本项目文件结构"><a href="#本项目文件结构" class="headerlink" title="本项目文件结构"></a>本项目文件结构</h4><h4 id="引入babel"><a href="#引入babel" class="headerlink" title="引入babel"></a>引入babel</h4><p><em>npm i -D babel-core babel-loader</em><br>复制代码由于在使用vue时会用到很多es6的语法，但是现在很多浏览器对es6的支持不是很好，所以在编译时需要将这些语法转换es5的语法，此时我们使用babel来进行编译。<br>babel的使用请阅读官网文档<a href="http://babeljs.cn/" target="_blank" rel="noopener">http://babeljs.cn/</a></p><h4 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h4><p>这个插件可以自动为我们生成HTML并插入对应的js和css文件。这样子是很方便的，尤其是当文件名中包含了hash值，而这个hash值在webpack每次编译的时候都会发生改变的。下面我们就逐一来介绍HtmlWebpackPlugin的用法。<br>配置参数:</p><ul><li><p>filename<br>filename表示生成html文件的名字，如果没有设置的话默认为index.html。</p></li><li><p>template<br>　当webpack自动生成html文件的时候，会基于某个模板来进行。当然你也可以自定义自己的模板，如果没有定义webpack会使用默认的模板。但是需要指出的是，当你使用了其他模板类型（比如jade），那么你需要安装对应的loader。默认情况下webpack使用ejs模板。</p></li><li><p>inject<br>inject主要是设置将js和css文件插入在html的哪个位置，由于js的加载时同步进行的，所以它的位置对网页的加载速度是有影响的。inject共有四个可选项：true、body、head和false。</p></li><li><p>true：默认值，将js文件插入body的底部。注意这里是bool类型的true，并不是字符串。设置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">　　inject: <span class="literal">true</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure></li><li><p>body：和true的功能是一样的。需要设置为字符串body。设置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  inject: <span class="string">'body'</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure></li><li><p>head：表示将js文件插入在head标签内，这里是字符串head。</p></li><li><p>false：表示不插入生成的js文件，也不插入css文件。因为其他三个可选项css文件都是插入在head标签内的。</p></li><li><p><a href="https://www.npmjs.com/package/html-webpack-plugin" target="_blank" rel="noopener">htmlWebpackPlugin</a></p></li></ul><h4 id="区分生产环境和本地开发环境"><a href="#区分生产环境和本地开发环境" class="headerlink" title="区分生产环境和本地开发环境"></a>区分生产环境和本地开发环境</h4><p>采用<em><a href="https://www.npmjs.com/package/webpack-merge" target="_blank" rel="noopener">webpck-merge</a></em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;merge&#125; = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: <span class="number">3000</span>,</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    contentBase: path.join(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">    overlay: &#123;</span><br><span class="line">      errors: <span class="literal">true</span>,</span><br><span class="line">      warnings: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>此处栽了一个大坑，打印common就是一个包含dev环境的配置对象，因为之前写法有误 导致vue-loader一直报错</p></blockquote><h4 id="本地项目运行"><a href="#本地项目运行" class="headerlink" title="本地项目运行"></a>本地项目运行</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  hot: <span class="literal">true</span>,</span><br><span class="line">  contentBase: path.join(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">  overlay: &#123;</span><br><span class="line">    errors: <span class="literal">true</span>,</span><br><span class="line">    warnings: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>output的 <em>publicPath</em> 是用来给生成的静态资源路径添加前缀的；</li><li>devServer中的 <em>publicPath</em> 是用来本地服务拦截带publicPath开头的请求的；</li><li><em>contentBase</em> 是用来指定被访问html页面所在目录的；</li></ul><h3 id="针对已有项目git初始化"><a href="#针对已有项目git初始化" class="headerlink" title="针对已有项目git初始化"></a>针对已有项目git初始化</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m "first commit"</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/niaogege/XXX.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://ddrv.cn/a/314373" target="_blank" rel="noopener">配置vue+webpack踩过的坑</a></li><li><a href="https://www.webpackjs.com/concepts/" target="_blank" rel="noopener">weboack官网</a></li><li><a href="https://juejin.cn/post/6844903541962702855" target="_blank" rel="noopener">webpack 搭建 vue 项目</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode插件开发和学习</title>
      <link href="/2020/11/08/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%92%8C%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/11/08/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%92%8C%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>vsCode插件实现</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://mp.weixin.qq.com/s/rXL1qU4h7Ugy6o9YjM6PaQ" target="_blank" rel="noopener">手摸手带你从零实现VS Code基金插件</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vscode </category>
          
          <category> node </category>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> tool </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔: 秋天来了</title>
      <link href="/2020/10/18/%E9%9A%8F%E7%AC%94-%E7%A7%8B%E5%A4%A9%E6%9D%A5%E4%BA%86/"/>
      <url>/2020/10/18/%E9%9A%8F%E7%AC%94-%E7%A7%8B%E5%A4%A9%E6%9D%A5%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h3 id="湖人夺冠"><a href="#湖人夺冠" class="headerlink" title="湖人夺冠"></a>湖人夺冠</h3><p><img src= "/img/loading.gif" data-src="/images/lakes/101202.jpg" alt="lakes champions"></p><!-- ![lakes champions](/images/lakes/101205.jpg) --><p>看到上次更博是0718，一晃，三个月，从盛夏到深秋，难得周末清闲，好久没有静下心来写点东西了(虽然也不知道自己在写啥， hhhh)。<br>最近因为练字发了几条抖音有点着迷这玩意，果断卸载，还是得聚焦现实主要任务，有些东西，随着时间的流逝就很难追回来。最主要的任务是啥呢，说实话，我自己也有点蒙，最近都在忙啥呢，我自己也不知道忙啥。</p><ul><li>看看自己手机里收藏的微信好文，是否自己都仔细阅读过了？是否读完都明白了？明白了是否自己都能在现在的项目中熟练运用？</li><li>今年再不做打算的话，程序员这一站就到头了，还得想想自己的后路。30岁的中年烦恼，提前准备，提前应对，35岁之后，我能做啥？</li><li>自己得学习起来，1.搭建脚手架 2.vscode插件 3.webpack(从0开始配置项目) 4.<a href="https://juejin.im/post/6856410900577026061" target="_blank" rel="noopener">ts使用</a> 5.算法,上面这几块得干起来，少看手机，多思考思考</li><li>基础知识还得继续夯实，主要是继承/Promise</li><li>拉勾教育上也得看起来</li><li>现在所处的项目改造，减少代码的重复</li></ul><p><img src= "/img/loading.gif" data-src="/images/lakes/101204.jpg" alt="lakes champions"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 健康 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue: 常用技巧2</title>
      <link href="/2020/07/18/vue-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A72/"/>
      <url>/2020/07/18/vue-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A72/</url>
      
        <content type="html"><![CDATA[<p><strong>hook</strong>用法<br>源码涉及hook的较多，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function callHook (vm, hook) &#123;</span><br><span class="line">  &#x2F;&#x2F; #7573 disable dep collection when invoking lifecycle hooks</span><br><span class="line">  pushTarget();</span><br><span class="line">  var handlers &#x3D; vm.$options[hook];</span><br><span class="line">  var info &#x3D; hook + &quot; hook&quot;;</span><br><span class="line">  if (handlers) &#123;</span><br><span class="line">    for (var i &#x3D; 0, j &#x3D; handlers.length; i &lt; j; i++) &#123;</span><br><span class="line">      invokeWithErrorHandling(handlers[i], vm, null, vm, info);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (vm._hasHookEvent) &#123;</span><br><span class="line">    vm.$emit(&#39;hook:&#39; + hook);</span><br><span class="line">  &#125;</span><br><span class="line">  popTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="监听组件的生命周期"><a href="#监听组件的生命周期" class="headerlink" title="监听组件的生命周期"></a>监听组件的生命周期</h3><p>Before</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; child.vue</span><br><span class="line">privte mounted() &#123;</span><br><span class="line">  this.$emit(&#39;parentClick&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; parent.vue</span><br><span class="line">&lt;Child @mounted&#x3D;&#39;parentClick&#39;&gt;</span><br></pre></td></tr></table></figure><p>After</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;child.vue</span><br><span class="line">子组件不需要任何处理</span><br><span class="line">&#x2F;&#x2F;parent.vue</span><br><span class="line">&lt;Child @hook:mounted&#x3D;&#39;parentClick&#39;&gt;</span><br><span class="line">or</span><br><span class="line">&lt;Child @hook:created&#x3D;&#39;parentClick&#39;&gt;</span><br></pre></td></tr></table></figure><h3 id="事件侦听器"><a href="#事件侦听器" class="headerlink" title="事件侦听器"></a>事件侦听器</h3><p>问: 页面中定义一个定时器，在哪个阶段清除<br>答: 在beforeDestory中销毁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Before</span><br><span class="line">mounted() &#123;</span><br><span class="line">  this.timer &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">  &#125;, 3000)</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestory() &#123;</span><br><span class="line">  clearInterval(this.timer)</span><br><span class="line">&#125;</span><br><span class="line">After</span><br><span class="line">mounted() &#123;</span><br><span class="line">  const timer &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">  &#125;, 3000)</span><br><span class="line">  this.$once(&#39;hook:beforeDestory&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    clearInterval(timer)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件销毁"><a href="#事件销毁" class="headerlink" title="事件销毁"></a>事件销毁</h3><p>通过$mounted绑定的第三方实例组件销毁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">  var picker &#x3D; new Picker(&#123;</span><br><span class="line">    field: this.$refs.input,</span><br><span class="line">    format: &#39;YYYY-MM-DD&#39;</span><br><span class="line">  &#125;)</span><br><span class="line">  this.$once(&#39;hook: beforeDestory&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    picker.destory()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue: 常用技巧1</title>
      <link href="/2020/07/18/vue-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A71/"/>
      <url>/2020/07/18/vue-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A71/</url>
      
        <content type="html"><![CDATA[<p>如果存在组件之间层级大于2层，中间需要一个过渡层的时候，属性和事件的上传下达越简洁越好，重点就是采用vue里的<strong>$atts</strong> 和事件 <strong>$listeners</strong>,先打印看看这两者是什么玩意，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$attrs: object,</span><br><span class="line">$listeners: object</span><br></pre></td></tr></table></figure><p>两者都是绑定在组件里的，且是对象类型，所以在组件阔以之间用<code>this.$attrs.info</code>去获取祖父组件传来的info信息。</p><a id="more"></a><p>以下有三个组件，三者之间都是相关有联系的，阔以称之为 祖父组件、父组件以及子组件。<br>伪代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; grandParent.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;home&quot;&gt;</span><br><span class="line">    &lt;Parent </span><br><span class="line">     :childMsg&#x3D;&#39;childMsg&#39;</span><br><span class="line">     @triggerClickChild&#x3D;&#39;triggerClickChild&#39;</span><br><span class="line">     info&#x3D;&#39;父组件&#39;</span><br><span class="line">    &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import &#123; Component, Vue &#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line">import Parent from &#39;..&#x2F;components&#x2F;parent.vue&#39;; &#x2F;&#x2F; @ is an alias to &#x2F;src</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Parent,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; parent.vue</span><br><span class="line">&lt;Child</span><br><span class="line">      label&#x3D;&#39;子组件信息&#39;</span><br><span class="line">      class&#x3D;&#39;child&#39;</span><br><span class="line">      v-bind&#x3D;&#39;$attrs&#39;</span><br><span class="line">      v-on&#x3D;&#39;$listeners&#39;</span><br><span class="line">      @triggerClickChild&#x3D;&#39;parentC&#39;</span><br><span class="line">    &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">import Child from &#39;.&#x2F;child.vue&#39;</span><br><span class="line">@Component(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">export default class Parent extends Vue &#123;</span><br><span class="line">  @Prop() private childMsg!: any; &#x2F;&#x2F; 此时childMsg信息已用所以不会传递到子组件</span><br><span class="line">  private parentC(key: string) &#123;</span><br><span class="line">    console.log(key, &#39;中间层截胡&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  private mounted() &#123;</span><br><span class="line">    console.log(this.childMsg, &#39;props&#39;)</span><br><span class="line">    console.log(this, &#39;中间组件&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; child本身的组件</span><br><span class="line">  &lt;div class&#x3D;&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h1 @click&#x3D;&#39;triggerClickChild&#39;&gt;&#123;&#123;$attrs&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  inheritAttrs: false</span><br><span class="line">&#125;)</span><br><span class="line">export default class HelloWorld extends Vue &#123;</span><br><span class="line">  private triggerClickChild() &#123;</span><br><span class="line">    this.$emit(&#39;triggerClickChild&#39;, &#39;triggerClickChild子孙组件&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">  private mounted() &#123;</span><br><span class="line">    console.log(this, &#39;attrs&#39;) &#x2F;&#x2F; &#123;info: &#39;&#39;,label: &#39;&#39;,  &#125;</span><br><span class="line">    console.log(this.$listeners) &#x2F;&#x2F; fn triggerClickChild</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>梳理以上几个组件发现这几点：<br>1.v-bind=’$atts’ 和 v-on=’$listeners’只能用于中间组件的传递，也就是起到承上启下的作用<br>2.中间组件接受的props，一旦被采用，也就无法传递到下一层。but事件，中间层阔以截胡，因为事件是由下往上，父组件和祖父组件都能接收到<br>3.有个弊端，如果中间层需要对数据进行二次加工，$attrs也就无用武之地，所以最好就是在顶层组件进行处理，如果处理不了就只能Props一层层传<br>4.当然最大的优势还是免除一层层传递，事件和属性这样简写一下高效了许多。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: 搭建脚手架</title>
      <link href="/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E6%90%AD%E5%BB%BA%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
      <url>/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E6%90%AD%E5%BB%BA%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>全局安装，<em>cpp-cli-test</em>脚手架，shell执行<em>npm i -g cpp-cli-test</em>即可，<em>cpp</em>即被注册到全局bin里,<br>本脚手架已发布到npm上，npm包地址 <a href="https://www.npmjs.com/package/cpp-cli-test" target="_blank" rel="noopener">cpp-cli-test</a></p><h3 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h3><p><code>cpp rm &lt;dir&gt;</code> 删除文件夹命令</p><h3 id="升级模板"><a href="#升级模板" class="headerlink" title="升级模板"></a>升级模板</h3><p><em>cpp upgrade</em></p><h3 id="设置自己镜像"><a href="#设置自己镜像" class="headerlink" title="设置自己镜像"></a>设置自己镜像</h3><p><em>cpp mirror <template_mirror></em></p><p>这里的镜像地址，也就是模板的下载地址，比如: <code>https://github.com/mengdu/vue-element-admin-tpl/archive/master.zip</code>以zip为结尾的文件，执行命令行 <code>cpp mirror https://github.com/mengdu/vue-element-admin-tpl/archive/master.zip</code>就是把该模板下载下来.</p><p>需要先将自己的镜像写入本地的<em>config.json</em>文件中，代码逻辑就是根据输入的镜像写入到<em>config.json</em>。写入的时候判断有没有<em>config.json</em>，如果没有则初始化生成<em>config.json</em>，有的话，则先读取，然后设置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取 config.json 文件</span></span><br><span class="line"><span class="keyword">const</span> jsonConfig = <span class="keyword">await</span> fse.readJson(cfgPath);</span><br><span class="line">jsonConfig.mirror = link</span><br><span class="line"><span class="comment">// 再写入 config.json 文件</span></span><br><span class="line"><span class="keyword">await</span> fse.writeJson(cfgPath, jsonConfig)</span><br></pre></td></tr></table></figure><h3 id="下载模板"><a href="#下载模板" class="headerlink" title="下载模板"></a>下载模板</h3><p><em>cpp template</em></p><p>下载模板的时候，先判断当前根目录下是否存在<em>config.json</em>文件，如果不存在则去生成，存在的话，先删除模板文件夹，然后读取<em>config.json</em>文件中的<code>jsonConfig.mirror</code>,然后再根据设置好的路径去远程下载，放到<em>templateTemp</em>里，下载完还需要解压<br>核心代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> download(</span><br><span class="line">  jsonConfig.mirror, <span class="comment">// 远程连接,就是前一步设置的镜像地址</span></span><br><span class="line">  path.resolve(__dirname, <span class="string">'../templateTemp/'</span>), <span class="comment">// 模板存放位置</span></span><br><span class="line">  &#123;</span><br><span class="line">    extract: <span class="literal">true</span>, <span class="comment">// 解压模板</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>先下载到<em>templateTemp</em>到文件夹，然后开始一系列文件剪切操作，找到<em>templateTemp</em>里的文件夹，即从远程下载的文件夹，然后剪切到<em>template</em>里去。</p><h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><p><em>cpp init <project_name></em><br>最重要的部分, 通过<a href="https://www.npmjs.com/package/inquirer" target="_blank" rel="noopener">inquirer</a>来与控制台交互,获取用户所输的文件夹名和设置包名来初始化，主要还是文件夹的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> multiFiles = <span class="string">`<span class="subst">$&#123;targetPath&#125;</span>/package.json`</span></span><br><span class="line"><span class="comment">// 用条件循环把模板字符替换到文件去</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 等待读取文件</span></span><br><span class="line">  <span class="keyword">const</span> multiFilesContent = fse.readFileSync(multiFiles, <span class="string">'utf8'</span>).toString()</span><br><span class="line">  <span class="comment">// 等待替换文件，handlebars.compile(原文件内容)(模板字符)</span></span><br><span class="line">  <span class="keyword">const</span> multiFilesResult = handlebars.compile(multiFilesContent)(multiMeta)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'multiFilesResult'</span>, multiFilesResult);</span><br><span class="line">  <span class="comment">// 等待输出文件</span></span><br><span class="line">  <span class="keyword">await</span> fse.outputFile(multiFiles, multiFilesResult)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="comment">// 如果出错，Spinner 就改变文字信息</span></span><br><span class="line">  initSpinner.text = chalk.red(<span class="string">`Initialize project failed. <span class="subst">$&#123;err&#125;</span>`</span>)</span><br><span class="line">  <span class="comment">// 终止等待动画并显示 X 标志</span></span><br><span class="line">  initSpinner.fail()</span><br><span class="line">  <span class="comment">// 退出进程</span></span><br><span class="line">  process.exit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中有一个坑的地方就是<em>handlebars</em>库，用于替换模板字符的，这个比较坑的就是源文件夹里的属性，必须写成这种样式才能替换模板<br>比如</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"&#123;&#123;name&#125;&#125;"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"8.8.8"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"&#123;&#123;description&#125;&#125;"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"./index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"&#123;&#123;author&#125;&#125;"</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前我以为会直接替代<em>package.json</em>里的包名和描述等等。<br>最高级的应该是用户按照所输入的名称、包名以及依赖名等汇总到<em>package.json</em>里</p><h3 id="本地调试模块，不是项目哦"><a href="#本地调试模块，不是项目哦" class="headerlink" title="本地调试模块，不是项目哦"></a>本地调试模块，不是项目哦</h3><p>添加了bin命令之后，需要执行<em>npm link</em>将 npm 模块链接到对应的运行项目中去，方便地对模块进行调试和测试</p><h3 id="接下来需要做的事"><a href="#接下来需要做的事" class="headerlink" title="接下来需要做的事"></a>接下来需要做的事</h3><ul><li>动态修改模板里的<em>package.json</em>里的name和作者<br>已经解决，</li><li>运用webpack搭建自己的需要的模板</li><li>完善<em>cpp-cli-test</em>脚手架里的命令行和帮助文档</li><li>涉及到的几个包，学习下基本的api<br>已经解决，还需要继续学习</li></ul><h3 id="npm其他操作"><a href="#npm其他操作" class="headerlink" title="npm其他操作"></a>npm其他操作</h3><p>全局删除当前的模块</p><ul><li><p>使用命令<br><code>npm uninstall -g 包名</code></p></li><li><p>直接找到对应包删除<br><code>C:\Users\自己用户的文件夹\AppData\Roaming\npm</code><br>将对应的包删除即可</p></li></ul><h3 id="node里的一些常用的api"><a href="#node里的一些常用的api" class="headerlink" title="node里的一些常用的api"></a>node里的一些常用的api</h3><h4 id="路径拼接"><a href="#路径拼接" class="headerlink" title="路径拼接"></a>路径拼接</h4><ul><li><em>__dirname</em> // 返回当前文件所在的文件夹绝对路径，比如<em>D:\code\cpp-cli\lib</em></li><li><em>path.resolve</em> // 拼接当前文件路径</li><li><em>__filename</em>: 指当前执行文件的带有完整绝对路径的文件名</li><li><em>process.cwd()</em>: 指当前执行node命令时候的文件夹目录名<br>./: 指文件所在目录<br>比如:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> configPath = path.resolve(__dirname, <span class="string">'../config.json'</span>) <span class="comment">// 返回路径</span></span><br><span class="line"><span class="built_in">console</span>.log(configPath) <span class="comment">// configPath D:\code\cpp-cli\config.json</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = path.resolve(<span class="string">'/foo/bar'</span>, <span class="string">'/tmp/file/'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// /foo/bar/tmp/file</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="相关解析"><a href="#相关解析" class="headerlink" title="相关解析"></a>相关解析</h3><p><code>#!/usr/bin/env node</code><br>使用过Linux或者Unix的开发者，对于Shebang应该不陌生，它是一个符号的名称，#！。这个符号通常在Unix系统的基本中第一行开头中出现，用于指明这个脚本文件的解释程序。了解了Shebang之后就可以理解，增加这一行是为了指定用node执行脚本文件。<br>当你输入一个命令的时候，npm是如何识别并执行对应的文件的呢？<br>具体的原理阮一峰大神已经在npm scripts 使用指南中介绍过。简单的理解:<br>就是输入命令后，会有在一个新建的shell中执行指定的脚本，在执行这个脚本的时候，我们需要来指定这个脚本的解释程序是node。<br>在一些情况下，即使你增加了这一行，但还是可能会碰到一下错误，这是为什么呢？<br><code>No such file or directory</code><br>为了解决这个问题，首先需要了解一下/usr/bin/env。我们已经知道，Shebang是为了指定脚本的解释程序，可是不同用户或者不同的脚本解释器有可能安装在不同的目录下，系统如何知道要去哪里找你的解释程序呢？<br>/usr/bin/env就是告诉系统可以在PATH目录中查找。<br>所以配置<code>#!/usr/bin/env node</code>, 就是解决了不同的用户node路径不同的问题，可以让系统动态的去查找node来执行你的脚本文件。<br>看到这里你应该理解，为什么会出现No such file or directory的错误？因为你的node安装路径没有添加到系统的PATH中。所以去进行node环境变量配置就可以了。</p><h3 id="NPM-执行脚本的原理"><a href="#NPM-执行脚本的原理" class="headerlink" title="NPM 执行脚本的原理"></a>NPM 执行脚本的原理</h3><p>npm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。<br>比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/6874815221174075405" target="_blank" rel="noopener">【工具流脚手架cli】用脚手架整合模板和配置</a></li><li><a href="https://juejin.im/post/6844903912080670734#heading-8" target="_blank" rel="noopener">一步一步搭建脚手架</a></li><li><a href="https://mp.weixin.qq.com/s/z9hyaOf85DFMweBmtm1YRA" target="_blank" rel="noopener">发布NPM包</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> cli </category>
          
          <category> node </category>
          
          <category> cpp </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
            <tag> node </tag>
            
            <tag> cli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: webpack 配置项output</title>
      <link href="/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-webpack%20%E9%85%8D%E7%BD%AE%E9%A1%B9output/"/>
      <url>/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-webpack%20%E9%85%8D%E7%BD%AE%E9%A1%B9output/</url>
      
        <content type="html"><![CDATA[<h3 id="output配置项"><a href="#output配置项" class="headerlink" title="output配置项"></a>output配置项</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: path.resolve(__dirname, <span class="string">'../src/component/index.js'</span>),</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>), <span class="comment">// 输出的文件位置</span></span><br><span class="line">    filename: <span class="string">'main.js'</span>, <span class="comment">// 输出的文件名</span></span><br><span class="line">    libraryTarget: <span class="string">'umd'</span>, <span class="comment">// 输出格式</span></span><br><span class="line">    library: <span class="string">'cppVue'</span> <span class="comment">// 模块名称</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按不同的模块方式生成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commonjs&#x2F;commonjs2: 将你的library暴露为CommonJS模块</span><br><span class="line">amd: 将你的library暴露为amd模块</span><br><span class="line">umd: 将你的library暴露为所有的模块定义下都可运行的方式</span><br></pre></td></tr></table></figure><blockquote><p>注意：commonjs和commonjs2几乎相同，只不过commonjs只包含exports，而commonjs2还包含module.exports，所以直接使用commonjs2即可。</p></blockquote><h3 id="在实践项目中的运用"><a href="#在实践项目中的运用" class="headerlink" title="在实践项目中的运用"></a>在实践项目中的运用</h3><p>首先得在<em>src</em>中定义想要导出的文件，一般是采用es6里的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://segmentfault.com/a/1190000017960583" target="_blank" rel="noopener">为什么自己写的组件库被引用总是报错——详解webpack的library和libraryTarget</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> umd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> webpack </tag>
            
            <tag> umd </tag>
            
            <tag> output </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: vue</title>
      <link href="/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-vue/"/>
      <url>/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-vue/</url>
      
        <content type="html"><![CDATA[<h2 id="六月第三周-6-22-6-27-的安排"><a href="#六月第三周-6-22-6-27-的安排" class="headerlink" title="六月第三周(6.22-6.27)的安排"></a>六月第三周(6.22-6.27)的安排</h2><h3 id="vue源码学习"><a href="#vue源码学习" class="headerlink" title="vue源码学习"></a>vue源码学习</h3><ul><li>vue初始化流程</li><li>vue响应式原理</li><li>vue中的mvvm</li><li>vue虚拟Dom</li><li>vue生命周期的理解</li><li>vue如何检测数组变化</li><li>vue中如何实现异步渲染？</li></ul><a id="more"></a><p>vue运行机制</p><h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><ul><li>创建Vue实例对象</li><li>init过程会初始化生命周期/初始化事件中心/初始化渲染，执行beforeCreate周期函数</li><li>初始化调用 <em>$mount</em> 方法对Vue实例进行挂载(核心 模板编译 =&gt; 渲染函数 =&gt; 更新)</li><li>如果没有定义render方法，而是定义了template,需要经历编译阶段，需要将模板字符串编译成 <em>render function</em>,步骤如下 <ul><li>parse正则解析成AST</li><li>optimize标记静态节点</li></ul></li><li>编译成render function之后，调用$mount的<em>mountComponent</em>方法，先执行beforeMount钩子函数，然后实例化一个watcher</li><li>调用render方法将render function渲染成虚拟的VNode</li><li>生成虚拟DOM树后，需要将虚拟DOM树转化成真实的DOM节点，此时需要调用update方法，update方法又会调用<em>pacth</em>方法把虚拟DOM转换成真正的DOM节点</li></ul><h3 id="vue生命周期的理解"><a href="#vue生命周期的理解" class="headerlink" title="vue生命周期的理解"></a>vue生命周期的理解</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> LIFECYCLE_HOOKS = [</span><br><span class="line">  <span class="string">'beforeCreate'</span>,</span><br><span class="line">  <span class="string">'created'</span>,</span><br><span class="line">  <span class="string">'beforeMount'</span>,</span><br><span class="line">  <span class="string">'mounted'</span>,</span><br><span class="line">  <span class="string">'beforeUpdate'</span>,</span><br><span class="line">  <span class="string">'updated'</span>,</span><br><span class="line">  <span class="string">'beforeDestroy'</span>,</span><br><span class="line">  <span class="string">'destroyed'</span>,</span><br><span class="line">  <span class="string">'activated'</span>,</span><br><span class="line">  <span class="string">'deactivated'</span>,</span><br><span class="line">  <span class="string">'errorCaptured'</span>,</span><br><span class="line">  <span class="string">'serverPrefetch'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>常规来说 created -&gt; mounted -&gt; updated -&gt; destroyed 创建 挂载 更新 销毁<br>还有keep-alive组件的activated/deactivated 激活和停用还有最新的serverPrefetch,<br>允许我们在渲染过程中“等待”异步数据。可在任何组件中使用，而不仅仅是路由组件</p><h4 id="生命周期的钩子函数合并策略"><a href="#生命周期的钩子函数合并策略" class="headerlink" title="生命周期的钩子函数合并策略"></a>生命周期的钩子函数合并策略</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hooks and props are merged as arrays.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeHook</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = childVal</span><br><span class="line">    ? parentVal</span><br><span class="line">      ? parentVal.concat(childVal)</span><br><span class="line">      : <span class="built_in">Array</span>.isArray(childVal)</span><br><span class="line">        ? childVal</span><br><span class="line">        : [childVal]</span><br><span class="line">    : parentVal;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`res`</span>, dedupeHooks(res));</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">    ? dedupeHooks(res)</span><br><span class="line">    : res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断子组件是否含有对应名字的生命周期钩子，然后再合并父组件的生命周期钩子，还做了去重，生命周期钩子其实阔以写成数组</p><h4 id="created-amp-amp-mounted-创建和挂载顺序"><a href="#created-amp-amp-mounted-创建和挂载顺序" class="headerlink" title="created &amp;&amp; mounted(创建和挂载顺序)"></a>created &amp;&amp; mounted(创建和挂载顺序)</h4><p>根组件created -&gt; 子组件created<br>子组件mounted -&gt; 父组件mounted </p><h3 id="vue响应式原理-vue双向绑定原理的理解"><a href="#vue响应式原理-vue双向绑定原理的理解" class="headerlink" title="vue响应式原理(vue双向绑定原理的理解)"></a>vue响应式原理(vue双向绑定原理的理解)</h3><p>answer:</p><h4 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h4><p>vue 采用数据劫持+发布者-订阅者模式的方式，通过Object.defineproperty()的方式劫持各个属性的setter/getter,在数据改变时发布消息给订阅者，触发响应的监听回调</p><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><ul><li><p><strong>监听器Observer</strong> 对需要监听的数据对象进行递归遍历，包括子属性对象的属性，利用Object.defineProperty()对给所有属性都加上setter/getter,一旦某个值赋值，就会触发setter,就能监听到数据变化</p></li><li><p><strong>解析器Compiler</strong> 解析Vue模板指令，将模板中的变量都替换成数据，然后初始化页面视图，并将每个指令对应的节点绑定更新函数，一旦数据有变动，收到通知，调用更新函数进行数据更新</p></li><li><p><strong>订阅者Watcher</strong> 订阅者是Observer和Compile之间的通信桥梁，主要任务是订阅Observer中的属性值变化的消息，当收到属性值变化的消息，触发解析器对应的更新函数 1.自身实例化的时候往订阅器Dep添加自己 2.自身必须有update方法 3.待属性变动Dep.notice通知时，调用自身的update方法，并触发Compile中绑定的回调函数</p></li><li><p><strong>订阅器Dep</strong> 收集订阅者，数据变动触发notify，再调用订阅者的update方法</p></li></ul><p><strong>Last</strong> MVVM作为数据绑定的入口，整合Observe/Compile/Watcher三者，通过Observe来监听自己的model数据变化，通过Compile解析模板编译指令，最终利用Watcher搭起通信桥梁，达到数据变化-&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果</p><p>在init的时候会利用Object.defineProperty方法（不兼容IE8）监听Vue实例的响应式数据的变化从而实现数据劫持能力（利用了JavaScript对象的访问器属性get和set，在未来的Vue3中会使用ES6的Proxy来优化响应式原理）。在初始化流程中的编译阶段，当render function被渲染的时候，会读取Vue实例中和视图相关的响应式数据，此时会触发getter函数进行依赖收集（将观察者Watcher对象存放到当前闭包的订阅者Dep的subs中），此时的数据劫持功能和观察者模式就实现了一个MVVM模式中的Binder，之后就是正常的渲染和更新流程。<br>当数据发生变化或者视图导致的数据发生了变化时，会触发数据劫持的setter函数，setter会通知初始化<em>依赖收集中的Dep</em>中的和视图相应的Watcher，告知需要重新渲染视图，Wather就会再次通过update方法来更新视图。</p><h3 id="vue如何检测数组变化"><a href="#vue如何检测数组变化" class="headerlink" title="vue如何检测数组变化"></a>vue如何检测数组变化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; def &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"><span class="comment">// 原始Array未重写之前的API原型方法</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="comment">// 拷贝原型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"><span class="comment">// 重写原型的方法</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果插入的数据，将再次监听</span></span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">//  触发订阅，像页面更新响应就在这里触发</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>重写之后的数组会在每次在执行数组的原始方法之后手动触发响应页面的效果。<br>Vue2.x中并没有实现将已存在的数组元素做监听，而是去监听造成数组变化的方法，触发这个方法的同时去调用挂载好的响应页面方法，达到页面响应式的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="comment">// 监听数组元素</span></span><br><span class="line">    observe(items[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this.observeArray函数了，它的内部实现非常简单，它对数组元素进行了监听，什么意思呢，就是改变数组里的元素不能监听到，但是数组内的值是对象类型的，修改它依旧能得到监听响应，如改变list[0].val可以得到监听，但是改变list[0]不能，但是依旧没有对数组本身的变化进行监听。</p><h3 id="Vue中如何实现异步渲染？"><a href="#Vue中如何实现异步渲染？" class="headerlink" title="Vue中如何实现异步渲染？"></a>Vue中如何实现异步渲染？</h3><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/5e8b163ff265da47ee3f54a6" target="_blank" rel="noopener">2020年前端面试复习必读文章</a></li><li><a href="https://mp.weixin.qq.com/s/oAlVmZ4Hbt2VhOwFEkNEhw" target="_blank" rel="noopener">虚拟 DOM 到底是什么？(长文建议收藏)</a></li><li><a href="https://juejin.im/post/5cd8a7c1f265da037a3d0992#heading-15" target="_blank" rel="noopener">基于Vue实现一个简易MVVM</a></li><li><a href="https://juejin.im/post/5e778c71518825491d3240fd" target="_blank" rel="noopener">高级前端开发者必会的34道Vue面试题系列（二）</a></li><li><a href="https://juejin.im/post/5e8064c551882573a13777e2" target="_blank" rel="noopener">高级前端开发者必会的34道Vue面试题系列（三）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> 前端框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: promise-1</title>
      <link href="/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-promise-1/"/>
      <url>/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-promise-1/</url>
      
        <content type="html"><![CDATA[<h2 id="六月第三周-6-22-6-27-的安排"><a href="#六月第三周-6-22-6-27-的安排" class="headerlink" title="六月第三周(6.22-6.27)的安排"></a>六月第三周(6.22-6.27)的安排</h2><ul><li>promise用法1</li><li>promise用法2</li><li>promise手写</li></ul><a id="more"></a><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="promise状态不可逆性"><a href="#promise状态不可逆性" class="headerlink" title="promise状态不可逆性"></a>promise状态不可逆性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="string">"success1"</span>);</span><br><span class="line">  resolve(<span class="string">"success2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="string">"success"</span>);</span><br><span class="line">  reject(<span class="string">"reject"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">success1</span><br><span class="line">success</span><br></pre></td></tr></table></figure><h4 id="promise中的异常处理"><a href="#promise中的异常处理" class="headerlink" title="promise中的异常处理"></a>promise中的异常处理</h4><ul><li>first scene<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  foo.bar();</span><br><span class="line">  resolve( <span class="number">1</span> );  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then value: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then value: '</span>+value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 控制台输出</span></span><br><span class="line">p1 then err: <span class="built_in">ReferenceError</span> foo is not defined</span><br><span class="line">p1 then then err:  <span class="literal">undefined</span></span><br></pre></td></tr></table></figure></li><li>second scene<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  resolve( <span class="number">2</span> );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then value: '</span> + value);</span><br><span class="line">    foo.bar();</span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then value: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then err: '</span> + err);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then then value: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">p2 then value: <span class="number">2</span></span><br><span class="line">p2 then then err: <span class="built_in">ReferenceError</span> foo is not defined</span><br><span class="line">p2 then then then value: resolve</span><br></pre></td></tr></table></figure>知识点</li><li>Promise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。</li><li>then方法接受两个参数，第一个是promise成功的回调，一个是失败的回调，<em>两个函数只能一个被调用</em></li></ul><h4 id="promise-resolve"><a href="#promise-resolve" class="headerlink" title="promise.resolve()"></a>promise.resolve()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve( <span class="number">1</span> );</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve( p1 );</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2); </span><br><span class="line"><span class="built_in">console</span>.log(p1 === p3);</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p4);</span><br><span class="line"><span class="built_in">console</span>.log(p3 === p4);</span><br><span class="line"></span><br><span class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p4='</span> + value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p2='</span> + value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1='</span> + value);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 控制台输出</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">p2=<span class="number">1</span></span><br><span class="line">p1=<span class="number">1</span></span><br><span class="line">p4=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>Promise.resolve()阔以接受一个普通值或者一个Promise对象作为参数<br>当参数是普通值的时候，返回一个resolved状态的promise对象<br>当参数是Promise对象时，直接返回这个promise对象，所以p1 === p2</p><h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;               <span class="comment">//第一个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> value*<span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第二个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第三个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>); </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第四个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第五个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve: '</span>+ value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reject: '</span> + err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">resolve</span><br><span class="line">reject: reject</span><br></pre></td></tr></table></figure><p>then两个参数的返回值是以下三种情况的一种</p><ul><li>return 一个同步值或者undefined(没有返回一个值时默认是undefined),then 方法会返回一个resolved状态的promise对象，Promise对象的值就是这个返回值</li><li>return 另一个Promise，then会根据这个Promise的状态和值创建一个新的Promise对象返回</li><li>throw 一个同步异常 then方法返回一个rejected状态的promise,值是该异常</li></ul><h4 id="resolve-vs-reject"><a href="#resolve-vs-reject" class="headerlink" title="resolve vs reject"></a>resolve vs reject</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  reject(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">p2.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">p3.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 控制台输出</span></span><br><span class="line">rejected: [object <span class="built_in">Promise</span>]</span><br><span class="line">fulfilled: resolve</span><br><span class="line">rejected: resolve</span><br></pre></td></tr></table></figure><ul><li>Promise回调函数中的第一个参数resolve，会对Promise执行”拆箱”动作。即当resolve的参数是一个Promise对象时，resolve会”拆箱”获取这个Promise对象的状态和值，但这个过程是异步的。p1”拆箱”后，获取到Promise对象的状态是resolved，因此fulfilled回调被执行；</li><li>p2”拆箱”后，获取到Promise对象的状态是rejected，因此rejected回调被执行。</li><li>但Promise回调函数中的第二个参数reject不具备”拆箱“的能力，reject的参数会直接传递给then方法中的rejected回调。因此，即使p3 reject接收了一个resolved状态的Promise，then方法中被调用的依然是rejected，并且参数就是reject接收到的Promise对象。</li></ul><blockquote><p>拆箱是异步操作，所以不具备拆箱的3执行的是同步操作</p></blockquote><h4 id="扩展——-try-catch"><a href="#扩展——-try-catch" class="headerlink" title="扩展—— try catch"></a>扩展—— try catch</h4><p>问: 用一句话描述js异常是否能被try catch到<br>答: 能捕捉到的异常必须是线程执行已经进入try catch但try catch未执行完成的时候抛出来的</p><h3 id="红绿灯问题"><a href="#红绿灯问题" class="headerlink" title="红绿灯问题"></a>红绿灯问题</h3><p>Qs: 题目：红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次；如何让三个灯不断交替重复亮灯？（用 Promise 实现）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'red'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'green'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'yellow'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用then和递归实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'red'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'green'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'yellow'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> light = <span class="function"><span class="keyword">function</span>(<span class="params">timmer, cb</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            cb();</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, timmer);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> step = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> light(<span class="number">3000</span>, red);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> light(<span class="number">2000</span>, green);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> light(<span class="number">1000</span>, yellow);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        step();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 或者换种写法</span></span><br><span class="line">    <span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        resolve(<span class="string">'i am cpp'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(val) <span class="comment">// i am cpp</span></span><br><span class="line">        <span class="keyword">return</span> light(<span class="number">3000</span>, red);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> light(<span class="number">2000</span>, green);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> light(<span class="number">1000</span>, yellow);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">step();</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/597724c26fb9a06bb75260e8" target="_blank" rel="noopener">八段代码彻底掌握 Promise</a></li><li><a href="https://juejin.im/post/5e6f4579f265da576429a907" target="_blank" rel="noopener">最简实现Promise，支持异步链式调用（20行）</a></li><li><a href="https://juejin.im/post/5a04066351882517c416715d" target="_blank" rel="noopener">Promise 必知必会（十道题）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> promise </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 前端重学(6)</title>
      <link href="/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-6/"/>
      <url>/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-6/</url>
      
        <content type="html"><![CDATA[<h2 id="六月第二周-6-8-6-14-的安排"><a href="#六月第二周-6-8-6-14-的安排" class="headerlink" title="六月第二周(6.8-6.14)的安排"></a>六月第二周(6.8-6.14)的安排</h2><ul><li>观察者模式 vs 发布订阅模式</li><li>函数柯里化</li><li>prefetch 和 preload区别</li><li>实现一个正则表达式(匹配url连接)</li><li>内存溢出</li></ul><a id="more"></a><h2 id="观察者模式-vs-发布订阅模式"><a href="#观察者模式-vs-发布订阅模式" class="headerlink" title="观察者模式 vs 发布订阅模式"></a>观察者模式 vs 发布订阅模式</h2><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式指的是一个对象（Subject）维持一系列依赖于它的对象（Observer），当有关状态发生变更时 Subject 对象则通知一系列 Observer 对象进行更新。<br>在观察者模式中，Subject 对象拥有添加、删除和通知一系列 Observer 的方法等等，而 Observer 对象拥有更新方法(update)等等。<br>简单说，就是数据发生改变，对应的处理函数自动执行。<br>通过一个实例就能很好的明白观察者模式了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义综述主题</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Subject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.observers = []</span><br><span class="line">&#125;</span><br><span class="line">Subject.prototype = &#123;</span><br><span class="line">  <span class="comment">// 添加observe</span></span><br><span class="line">  add(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.push(observer)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 移除observe</span></span><br><span class="line">  remove(observer) &#123;</span><br><span class="line">    <span class="keyword">var</span> observers = <span class="keyword">this</span>.observers</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; observers.length; i ++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (observers[i] === observer) &#123;</span><br><span class="line">        observers.splice(i, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 通知 告诉observe 执行自己的方法</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">var</span> observers = <span class="keyword">this</span>.observers;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; observers.length;i++)&#123;</span><br><span class="line">      observers[i].update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 观察者定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义观察者里的更新方法</span></span><br><span class="line">Observer.prototype = &#123;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`观察者模式下 name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Subject</span></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Subject()</span><br><span class="line"><span class="keyword">var</span> obs1 = <span class="keyword">new</span> Observer(<span class="string">'cpp'</span>)</span><br><span class="line"><span class="keyword">var</span> obs2 = <span class="keyword">new</span> Observer(<span class="string">'chendapeng'</span>)</span><br><span class="line">sub.add(obs1)</span><br><span class="line">sub.add(obs2)</span><br><span class="line">sub.notify()</span><br></pre></td></tr></table></figure><p>应用:<br>Vue 通过观察者模式触发视图更新。Vue2.x通过Object.defineProperty劫持data数据，当数据变化后触发setter,setter内部通过订阅器notify消息，notify会调用watcher更新视图</p><h3 id="发布订阅模式-Publisher-amp-amp-Subscriber"><a href="#发布订阅模式-Publisher-amp-amp-Subscriber" class="headerlink" title="发布订阅模式(Publisher &amp;&amp; Subscriber)"></a>发布订阅模式(Publisher &amp;&amp; Subscriber)</h3><p>希望接受通知的对象基于一个主题通过自定义事件订阅主题<br>发布者通过调度中心基于一个主题向订阅者发布消息<br>代码示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调度中心</span></span><br><span class="line"><span class="keyword">let</span> pubsub = &#123;</span><br><span class="line">  list: &#123;&#125;, <span class="comment">// 订阅的数组</span></span><br><span class="line">  subscribe(key, fn) &#123; <span class="comment">// 订阅</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.list[key]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.list[key] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.list[key].push(fn)</span><br><span class="line">  &#125;,</span><br><span class="line">  publish(...args) &#123; <span class="comment">// 发布</span></span><br><span class="line">    <span class="built_in">console</span>.log(args);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(args).slice(<span class="number">8</span>, <span class="number">-1</span>))</span><br><span class="line">    <span class="keyword">const</span> key = args[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> fns = <span class="keyword">this</span>.list[key]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fns.length; i ++) &#123;</span><br><span class="line">      fns[i].apply(<span class="keyword">this</span>, [args[<span class="number">1</span>]])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 取消订阅</span></span><br><span class="line">  unSubscribe(key) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.list[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">pubsub.subscribe(<span class="string">'name'</span>, (name) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'订阅在发布模式下 name is'</span>, name);</span><br><span class="line">&#125;)</span><br><span class="line">pubsub.publish(<span class="string">'name'</span>, <span class="string">'cpp'</span>)</span><br><span class="line">pubsub.subscribe(<span class="string">'age'</span>, (age) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'订阅在发布模式下 age is'</span>, age);</span><br><span class="line">&#125;)</span><br><span class="line">pubsub.publish(<span class="string">'age'</span>, <span class="string">'18'</span>)</span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>观察者模式与发布订阅模式都是定义了<em>一个一对多的依赖关系</em>，当有关状态发生变更时则执行相应的更新。<br>不同的是，观察者模式依赖于主题(Subject)对象的一系列Observer对象被通知之后只能执行一个特定的更新方法(比如update等),而发布订阅模式阔以通过调度中心，<strong>基于不同的主题去执行不同的自定义事件</strong>，相对而言，发布订阅模式比观察者模式灵活一些。</p><h3 id="原生实现观察者模式"><a href="#原生实现观察者模式" class="headerlink" title="原生实现观察者模式"></a>原生实现观察者模式</h3><ul><li>es5实现<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> observer(mode: <span class="built_in">any</span>, old: <span class="built_in">any</span>, val: <span class="built_in">any</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;mode&#125;</span> name属性值从<span class="subst">$&#123;old&#125;</span> -&gt; <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> es5Implement() &#123;</span><br><span class="line">  <span class="keyword">const</span> targetObj = &#123;</span><br><span class="line">    age: <span class="number">28</span>,</span><br><span class="line">    name: <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">'cpp'</span></span><br><span class="line">  <span class="comment">// 定义name属性以及其设置方法</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(targetObj, <span class="string">'name'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> name</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(val) &#123;</span><br><span class="line">      <span class="keyword">this</span>.observer(<span class="string">'es5'</span>, name, val)</span><br><span class="line">      name = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  targetObj.name = <span class="string">'Martin'</span>;</span><br><span class="line">  targetObj.name = <span class="string">'Lucas'</span>;</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">'targetObj:'</span>, targetObj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>es6实现<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TargetObj</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(age, name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> name(val) &#123;</span><br><span class="line">    observer(name, val);</span><br><span class="line">    name = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> targetObj = <span class="keyword">new</span> TargetObj(<span class="number">1</span>, <span class="string">'Martin'</span>);</span><br><span class="line"><span class="comment">// 定义值改变时的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">oldVal, newVal</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 其他处理逻辑...</span></span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">'name属性的值从 '</span>+ oldVal +<span class="string">' 改变为 '</span> + newVal);</span><br><span class="line">&#125;</span><br><span class="line">targetObj.name = <span class="string">'Lucas'</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/5bb1bb616fb9a05d2b6dccfa" target="_blank" rel="noopener">谈谈观察者模式和发布订阅模式</a></li><li><a href="https://blog.csdn.net/lm278858445/article/details/78287492" target="_blank" rel="noopener">原生JavaScript实现观察者模式</a></li></ul><h2 id="函数柯里化-Curry"><a href="#函数柯里化-Curry" class="headerlink" title="函数柯里化(Curry)"></a>函数柯里化(Curry)</h2><h3 id="什么是curry"><a href="#什么是curry" class="headerlink" title="什么是curry"></a>什么是curry</h3><p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>柯里化实际是把简答的问题复杂化了，但是复杂化的同时，我们在使用函数时拥有了更加多的自由度。 而这里对于函数参数的自由处理，正是柯里化的核心所在。 柯里化本质上是降低通用性，提高适用性。</p><h2 id="prefetch-和-preload区别"><a href="#prefetch-和-preload区别" class="headerlink" title="prefetch 和 preload区别"></a>prefetch 和 preload区别</h2><p>通过插入一个页面元素来声明一个资源（比如img、script、link）。这种方式会将资源的加载和执行耦合。</p><p>用AJAX来加载资源。这种方式只有在时机成熟时才会加载资源，解决了执行时机问题。但是浏览器无法预解析，也就无法提前加载。另外如果页面有大量的阻塞脚本，就会造成延迟。<br>有没有办法既提前加载资源，又能解耦加载和执行呢?</p><h3 id="preload"><a href="#preload" class="headerlink" title="preload"></a>preload</h3><p>preload 提供了一种声明式的命令，让浏览器<em>提前加载</em>指定资源(加载后并不执行,加载和执行分离)，在需要执行的时候再执行。提供的好处主要是</p><ul><li>将加载和执行分离开，可不阻塞渲染和 document 的 onload 事件</li><li>提前加载指定资源，不再出现依赖的font字体隔了一段时间才刷出</li></ul><h3 id="如何区分-preload-和-prefetch"><a href="#如何区分-preload-和-prefetch" class="headerlink" title="如何区分 preload 和 prefetch"></a>如何区分 preload 和 prefetch</h3><ul><li>preload 告诉浏览器页面必定需要的资源，browser一定会加载这些资源</li><li>prefetch 告诉浏览器可能需要的资源，browser不一定会加载这些资源</li></ul><h3 id="用link标签创建preload"><a href="#用link标签创建preload" class="headerlink" title="用link标签创建preload"></a>用<code>link</code>标签创建preload</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'preload'</span> <span class="attr">href</span>=<span class="string">'/public/static/theme.css'</span> <span class="attr">as</span>=<span class="string">'style'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'preload'</span> <span class="attr">href</span>=<span class="string">'/public/static/vue.js'</span> <span class="attr">as</span>=<span class="string">'script'</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或者用script创建 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"> <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">'link'</span>)</span></span><br><span class="line"><span class="actionscript"> link.href=<span class="string">'/public/static/vue.js'</span></span></span><br><span class="line"><span class="actionscript"> link.rel = <span class="string">'preload'</span></span></span><br><span class="line"><span class="actionscript"> link.as = <span class="string">'script'</span></span></span><br><span class="line"><span class="javascript"> <span class="built_in">document</span>.head.appendChild(link)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="preload特点"><a href="#preload特点" class="headerlink" title="preload特点"></a>preload特点</h3><ul><li>提前加载资源</li><li>资源的加载和执行分离</li><li>不延迟网页的load事件（除非Preload资源刚好是阻塞 window 加载的资源）</li></ul><h3 id="Preload跟其他提前加载资源以及加载和执行分离的方案有什么区别？"><a href="#Preload跟其他提前加载资源以及加载和执行分离的方案有什么区别？" class="headerlink" title="Preload跟其他提前加载资源以及加载和执行分离的方案有什么区别？"></a>Preload跟其他提前加载资源以及加载和执行分离的方案有什么区别？</h3><h4 id="vs-aysnc"><a href="#vs-aysnc" class="headerlink" title="vs aysnc"></a>vs aysnc</h4><p>async 脚本是一加载完就立即执行，因此会阻塞window的onload事件。而且目前async仅限于脚本资源。<br>Preload可以实现async一样的异步加载功能。且不局限于脚本。比如以下代码实现了加载完CSS文件立即作用到网页的功能：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">as</span>=<span class="string">"style"</span> <span class="attr">onload</span>=<span class="string">"this.rel='stylesheet'"</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：如果页面存在同步阻塞脚本，等脚本执行完后，样式才会作用到网页。这样是因为Preload的资源不会阻塞window的onload事件。</p></blockquote><h4 id="vs-defer"><a href="#vs-defer" class="headerlink" title="vs defer"></a>vs defer</h4><p>defer实现了资源的加载和执行分离，并且它能保证defer的资源按照在HTML里的出现顺序执行。跟async一样，目前也只能作用于脚本资源。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>典型用例：</p><ul><li><p>在单页应用中，提前加载路由文件，提高切换路由时的渲染速度。现在大型的单页应用通常会异步加载路由文件。当用户切换路由时再异步加载相应的模块存在性能问题。可以用Preload提前加载，提升性能。</p></li><li><p>提前加载字体文件。由于字体文件必须等到CSSOM构建完成并且作用到页面元素了才会开始加载，会导致页面字体样式闪动（FOUT，Flash of Unstyled Text）。所以要用Preload显式告诉浏览器提前加载。假如字体文件在CSS生效之前下载完成，则可以完全消灭FOUT。</p></li></ul><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/5a7fb09bf265da4e8e785c38#heading-12" target="_blank" rel="noopener">用 preload 预加载页面资源</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMTcwOTM4Mg==&mid=2247484163&idx=1&sn=16b9c907971683dd61cee251adcde79b&chksm=f96edaaace1953bcaf65a1adcf30b6d3dd66cf7b648ae59c4bf807d3f8bf460d5cd638e54ca1&token=946370022&lang=zh_CN#rd" target="_blank" rel="noopener">有一种优化，叫Preload</a></li></ul><h2 id="实现一个正则表达式-匹配url连接"><a href="#实现一个正则表达式-匹配url连接" class="headerlink" title="实现一个正则表达式(匹配url连接)"></a>实现一个正则表达式(匹配url连接)</h2><p>url: <a href="http://niaogege.cn:80/index?title=1#more">http://niaogege.cn:80/index?title=1#more</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> patter = <span class="regexp">/^(http?:\/\/)([0-9a-zA-Z.]+)([:0-9]+)?([/0-9a-zA-Z.]+)?(\?[0-9a-zA-Z&amp;=]+)?(#[0-9a-zA-Z])?/</span></span><br><span class="line"><span class="comment">// 不区分大小写</span></span><br><span class="line"><span class="keyword">const</span> pattern = <span class="regexp">/^(http?:\/\/)([0-9a-z.]+)([:0-9]+)?([/0-9a-z.]+)?(\?[0-9a-z&amp;=]+)?(#[0-9a-z])?/i</span></span><br></pre></td></tr></table></figure><h3 id="匹配协议"><a href="#匹配协议" class="headerlink" title="匹配协议"></a>匹配协议</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(http?:\/\/)</span><br></pre></td></tr></table></figure><h3 id="匹配主域"><a href="#匹配主域" class="headerlink" title="匹配主域"></a>匹配主域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([<span class="number">0</span><span class="number">-9</span>a-z.]+)</span><br></pre></td></tr></table></figure><h3 id="匹配端口"><a href="#匹配端口" class="headerlink" title="匹配端口"></a>匹配端口</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([:<span class="number">0</span><span class="number">-9</span>]+)? <span class="comment">// :8080 可有可无 ？</span></span><br></pre></td></tr></table></figure><h3 id="匹配路径"><a href="#匹配路径" class="headerlink" title="匹配路径"></a>匹配路径</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([<span class="regexp">/0-9a-z.]+)? /</span><span class="regexp">/ /i</span>ndex.html 可有可无 ？</span><br></pre></td></tr></table></figure><h3 id="匹配查询"><a href="#匹配查询" class="headerlink" title="匹配查询"></a>匹配查询</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\?[<span class="number">0</span><span class="number">-9</span>a-z&amp;=]+)? <span class="comment">// ?query=1&amp;title=1&amp;keyword=2 可有可无 ？</span></span><br></pre></td></tr></table></figure><h3 id="匹配锚点"><a href="#匹配锚点" class="headerlink" title="匹配锚点"></a>匹配锚点</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(#[0-9a-z])? // #more 可有可无 ？</span><br></pre></td></tr></table></figure><h3 id="常用正则表达"><a href="#常用正则表达" class="headerlink" title="常用正则表达"></a>常用正则表达</h3><ul><li>匹配手机号码 <em>/(+86)1\d{10}/</em> </li><li>匹配身份证号码 <em>/^(\d{17}(\d|x))$/</em></li><li>匹配邮箱 <em>/^(\w)+(.\w+)</em>@(\w)+((.\w+)+)$/*</li></ul><h3 id="参考链接-2"><a href="#参考链接-2" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://louiszhai.github.io/2016/06/13/regexp/#%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">正则表达式前端使用手册</a></li><li><a href="https://blog.csdn.net/wulex/article/details/97050209" target="_blank" rel="noopener">正则匹配地址</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> http </tag>
            
            <tag> RegExp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 前端重学(5)</title>
      <link href="/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-5/"/>
      <url>/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-5/</url>
      
        <content type="html"><![CDATA[<h2 id="6-1-6-7-的安排"><a href="#6-1-6-7-的安排" class="headerlink" title="(6.1-6.7)的安排"></a>(6.1-6.7)的安排</h2><ul><li>vuex手写以及原理</li><li>mvvm理解(拖延症)</li><li>css问题(1px以及清楚浮动原理)</li><li>js基础(es5继承和es6继承的区别)</li></ul><a id="more"></a><h3 id="第二版vuex手写"><a href="#第二版vuex手写" class="headerlink" title="第二版vuex手写"></a>第二版vuex手写</h3><h3 id="mvvm理解"><a href="#mvvm理解" class="headerlink" title="mvvm理解"></a>mvvm理解</h3><h3 id="css之移动端-1px-问题"><a href="#css之移动端-1px-问题" class="headerlink" title="css之移动端 1px 问题"></a>css之移动端 1px 问题</h3><p>两个概念，一个是像素（pixel）可以简写为px，另外一个是设备像素比（DPR）devicePixelRadio</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">像素 ：指在由一个数字序列表示的图像中的一个最小单元，单位是 px，不可再次分割了。</span><br><span class="line">设备像素比（DPR）: 设备像素比 &#x3D; 设备像素 &#x2F; 设备独立像素。</span><br></pre></td></tr></table></figure><p>造成边框变粗的原因<br>其实这个原因很简单，因为css中的1px并不等于移动设备的1px，这些由于不同的手机有不同的像素密度。在window对象中有一个devicePixelRatio属性，他可以反应css中的像素与设备的像素比。</p><p>设计稿上的是<code>物理像素</code>,css中的像素是<code>逻辑像素</code><br>如果window.devicePixelRadio是2.0，即设计稿上的1px等于css中的0.5px<br>目前主流屏幕的DPR是2（8P+），拿2倍屏来说，设备的物理像素要实现1像素，而DPR=2，所以css 像素只能是 0.5。一般设计稿是按照750来设计的，它上面的1px是以750来参照的，而我们写css样式是以设备375为参照的，所以我们应该写0.5px</p><h3 id="主流方案一：利用伪元素（-after-transform）进行缩放"><a href="#主流方案一：利用伪元素（-after-transform）进行缩放" class="headerlink" title="主流方案一：利用伪元素（::after + transform）进行缩放"></a>主流方案一：利用伪元素（<code>::after + transform</code>）进行缩放</h3><p>为什么用伪元素？ 因为伪元素<code>::after或::before</code>是独立于当前元素，可以单独对其缩放而不影响元素本身的缩放<br>实现:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border-1px</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  &amp;::before&#123;</span><br><span class="line">    <span class="selector-tag">content</span>: "";</span><br><span class="line">    <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line">    <span class="selector-tag">left</span>: 0;</span><br><span class="line">    <span class="selector-tag">top</span>: 0;</span><br><span class="line">    <span class="selector-tag">width</span>: 200%;</span><br><span class="line">    <span class="selector-tag">border</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-tag">red</span>;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-tag">red</span>;</span><br><span class="line">    <span class="selector-tag">height</span>: 200%;</span><br><span class="line">    <span class="selector-tag">-webkit-transform-origin</span>: <span class="selector-tag">left</span> <span class="selector-tag">top</span>;</span><br><span class="line">    <span class="selector-tag">transform-origin</span>: <span class="selector-tag">left</span> <span class="selector-tag">top</span>;</span><br><span class="line">    <span class="selector-tag">-webkit-transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.5</span>);</span><br><span class="line">    <span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.5</span>);</span><br><span class="line">    <span class="selector-tag">pointer-events</span>: <span class="selector-tag">none</span>; <span class="comment">/* 防止点击触发 */</span></span><br><span class="line">    <span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>; <span class="comment">/*IE 盒模型 元素内容宽高 == 内容+ 内边距 + 边框*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主流方案二：针对不同的DPR设备增加媒体查询，进行对应的缩放"><a href="#主流方案二：针对不同的DPR设备增加媒体查询，进行对应的缩放" class="headerlink" title="主流方案二：针对不同的DPR设备增加媒体查询，进行对应的缩放"></a>主流方案二：针对不同的DPR设备增加媒体查询，进行对应的缩放</h3><p>实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border-1px</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  &amp;::before&#123;</span><br><span class="line">    <span class="selector-tag">content</span>: "";</span><br><span class="line">    <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line">    <span class="selector-tag">left</span>: 0;</span><br><span class="line">    <span class="selector-tag">top</span>: 0;</span><br><span class="line">    <span class="selector-tag">width</span>: 200%;</span><br><span class="line">    <span class="selector-tag">border</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-tag">red</span>;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-tag">red</span>;</span><br><span class="line">    <span class="selector-tag">height</span>: 200%;</span><br><span class="line">    <span class="selector-tag">-webkit-transform-origin</span>: <span class="selector-tag">left</span> <span class="selector-tag">top</span>;</span><br><span class="line">    <span class="selector-tag">transform-origin</span>: <span class="selector-tag">left</span> <span class="selector-tag">top</span>; <span class="comment">/* 允许改变转换元素的位置 */</span></span><br><span class="line">    <span class="selector-tag">-webkit-transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.5</span>);</span><br><span class="line">    <span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.5</span>);</span><br><span class="line">    <span class="selector-tag">pointer-events</span>: <span class="selector-tag">none</span>; <span class="comment">/* 防止点击触发 */</span></span><br><span class="line">    <span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>; <span class="comment">/* IE 盒模型 元素内容宽高 == 内容+ 内边距 + 边框 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-device-pixel-ratio:</span><span class="number">3</span>),(<span class="attribute">-webkit-min-device-pixel-ratio:</span><span class="number">3</span>) &#123;</span><br><span class="line">      <span class="selector-tag">width</span>: 300%;</span><br><span class="line">      <span class="selector-tag">height</span>: 300%;</span><br><span class="line">      <span class="selector-tag">-webkit-transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.33</span>);</span><br><span class="line">      <span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.33</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-device-pixel-ratio:</span><span class="number">2.75</span>),(<span class="attribute">-webkit-min-device-pixel-ratio:</span><span class="number">2.75</span>) &#123;</span><br><span class="line">      <span class="selector-tag">width</span>: 300%;</span><br><span class="line">      <span class="selector-tag">height</span>: 300%;</span><br><span class="line">      -webkit-transform: scale(1/2.75);</span><br><span class="line">      transform: scale(1/2.75);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-device-pixel-ratio:</span><span class="number">2</span>),(<span class="attribute">-webkit-min-device-pixel-ratio:</span><span class="number">2</span>)&#123;</span><br><span class="line">      <span class="selector-tag">width</span>: 300%;</span><br><span class="line">      <span class="selector-tag">height</span>: 300%;</span><br><span class="line">      <span class="selector-tag">-webkit-transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.5</span>);</span><br><span class="line">      <span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="css之清除浮动原理"><a href="#css之清除浮动原理" class="headerlink" title="css之清除浮动原理"></a>css之清除浮动原理</h2><p>清除浮动主要有两种方式，分别是clear清除浮动和BFC清除浮动</p><h3 id="浮动的三个特点很重要。"><a href="#浮动的三个特点很重要。" class="headerlink" title="浮动的三个特点很重要。"></a>浮动的三个特点很重要。</h3><ol><li>脱离文档流。</li><li>向左/向右浮动直到遇到父元素或者别的浮动元素。</li><li>浮动会导致父元素高度坍塌。</li></ol><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>clear属性不允许被清除浮动的元素的左边/右边挨着浮动元素，底层原理是<em>在被清除浮动的元素上边或者下边添加足够的清除空间</em></p><blockquote><p>要注意了，我们是通过在别的元素上清除浮动来实现撑开高度的，而不是在浮动元素上。</p></blockquote><p>clear浮动元素最佳实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 同时加入:before以解决现代浏览器上边距折叠的问题</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">    *zoom: 1; // 引入了zoom以支持IE6/7</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFC清除浮动"><a href="#BFC清除浮动" class="headerlink" title="BFC清除浮动"></a>BFC清除浮动</h3><p>原理就是 <em>浮动盒区域不会叠加到BFC上，(BFC区域不会与float的元素区域叠加)</em>,BFC的五条约束规则之一<br>实现就是触发BFC即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 根元素或其它包含它的元素；</span><br><span class="line">- 浮动 (元素的float不为none)；</span><br><span class="line">- 绝对定位元素 (元素的position为absolute或fixed)；</span><br><span class="line">- 行内块inline-blocks(元素的 display: inline-block)；</span><br><span class="line">- 表格单元格(元素的display: table-cell，HTML表格单元格默认属性)；</span><br><span class="line">- overflow的值不为visible的元素；</span><br><span class="line">- 弹性盒 flex boxes (元素的display: flex或inline-flex)；</span><br></pre></td></tr></table></figure><p>平常中，设置<code>overflow: hidden/scroll, float: right/left,position: absolute,display: flex/inline-flex;</code>即当前元素创建了一个BFC</p><h2 id="原型和es5继承和es6继承的区别"><a href="#原型和es5继承和es6继承的区别" class="headerlink" title="原型和es5继承和es6继承的区别"></a>原型和es5继承和es6继承的区别</h2><h3 id="原型-prototype-和-实例属性的-proto"><a href="#原型-prototype-和-实例属性的-proto" class="headerlink" title="原型(prototype) 和 实例属性的(proto)"></a>原型(prototype) 和 实例属性的(<strong>proto</strong>)</h3><ul><li>原型: 给其他对象提供共享属性的对象</li><li>隐式引用(<strong>proto</strong>): 所有实例对象都存在一个隐式引用，指向他的原型</li></ul><p>构造函数(constructor): 它的原型指向实例的原型(Person.prototype === person.<strong>proto</strong>)<br>构造函数和普通函数的区别</p><ul><li>使用new操作符生成实例的函数就是构造函数</li><li>直接调用的就是普通函数</li><li>Symbol是基础类型不是构造函数</li></ul><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p>之前已经详细阐述过es5中的继承，主要是经典继承(构造函数继承)/原型链继承/组合继承以及常用的寄生式组合继承，<a href="http://niaogege.cn/2020/05/05/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6/#more">前文链接</a>,(通过原型链实现原型属性的继承，通过构造函数实现实例属性的继承)</p><p>ES5 的继承，通过prototype或构造函数机制来实现, 实质是先创造子类的实例对象this，再将父类的方法添加到this上面（Parent.apply(this)）。<br>ES6 的继承机制完全不同，实质是先创建父类的实例对象this(所以必须先调用父类的super()方法)，然后再用子类的构造函数修改this。</p><p>ES6中新增了class关键字来定义类，通过保留的关键字<em>extends</em>实现了继承。实际上这些关键字只是一些语法糖，底层实现还是通过原型链之间的委托关联关系实现继承</p><p>如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</p><h3 id="super"><a href="#super" class="headerlink" title="super()"></a>super()</h3><p>在 super() 执行时，它指向的是 子类 B 的构造函数，而不是父类 A 的构造函数。也就是说，super() 内部的 this 指向的是 B<br><em>super()<em>相当于</em>Parent.prototype.constructor.call(this. props)</em><br>super本身是指向父类的构造函数但做函数调用后返回的是子类的实例，实际上做了<em>parent.prototype.constructor.call(this)</em>，做对象调用时指向父类.prototype,从而实现继承</p><h3 id="static-静态属性"><a href="#static-静态属性" class="headerlink" title="static 静态属性"></a>static 静态属性</h3><p>顾名思义是静态方法的意思，类相当于实例的原型，所有在类中定义的方法， 都会被实例继承。<br>如果在一个方法前， 加上static关键字， 就表示该方法不会被实例继承， 而是直接通过类来调用， 这就称为“ 静态方法”。静态方法调用直接在类上进行，而在类的实例上不可被调用。静态方法通常用于创建 实用/工具 函数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">  <span class="keyword">public</span> x!: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">public</span> y!: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">public</span> z!: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">x: <span class="built_in">any</span>, y: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">this</span>.y = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> print() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类的print方法'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.z = <span class="number">3</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> ColorPoint <span class="keyword">extends</span> Point &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">x: <span class="built_in">any</span>, y: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(x, y)</span><br><span class="line">    <span class="comment">// Point.prototype.constructor.call(this, x, y)</span></span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> m() &#123;</span><br><span class="line">    <span class="comment">// super.print() 难以调用，父类的print是静态属性，只能在类上直接调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，父类的静态方法，也会被子类继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> hello() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.hello()  <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>上面代码中，hello()是A类的静态方法，B继承A，也继承了A的静态方法。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://es6.ruanyifeng.com/#docs/class-extends" target="_blank" rel="noopener">es6之class</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> mvvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> vuex </tag>
            
            <tag> javascript </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 前端重学(4)</title>
      <link href="/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-4/"/>
      <url>/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-4/</url>
      
        <content type="html"><![CDATA[<p>重点js基础/Vue框架/typescript/Css/node/工具/网络基础</p><ul><li>Mvvm原理的解读以及模拟实现</li><li>Vuex源码以及模拟实现(a week)</li><li>Vue计算属性(原理及相关特性)</li><li>express完整应用(two week)</li></ul><p>前期还是需要在好好学学vue相关的源码知识，特别是mvvm以及vuex的源码阅读，大概领会其思想，目的很简单，就是面试的时候，不能被面试官问倒。<br>后面会尽量往node/webpack/ast靠拢，如果可能有时间的话，算法还是要了解。<br>源码调试不方便，不知道是自己的问题还是没有找到规律，vuex的源码是放在<code>vuex.esm.js</code>中，在2.0版本的时候，源码中还含有<code>src</code>文件夹，里面含有未压缩的各模块代码，现在vuex不是这个样子</p><a id="more"></a><h3 id="Mvvm的模拟实现"><a href="#Mvvm的模拟实现" class="headerlink" title="Mvvm的模拟实现"></a>Mvvm的模拟实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observer 数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现。</span><br><span class="line"></span><br><span class="line">Compile 指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。</span><br><span class="line"></span><br><span class="line">Watcher 订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。</span><br><span class="line"></span><br><span class="line">Dep 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。</span><br></pre></td></tr></table></figure><h2 id="Vuex源码以及模拟实现"><a href="#Vuex源码以及模拟实现" class="headerlink" title="Vuex源码以及模拟实现"></a>Vuex源码以及模拟实现</h2><p>源码这么多，不知道如何下手?不知道主线是什么，谁能告诉我如何把源码理清，其实，有好几篇文章里的思路还是比较明晰的，无奈自己太次，有点理解不了尤大大的用意，老是被一些api打断思路。<br>还有就是对数据结构没啥概念，比如说在deom里定义了两个模块，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    Test,</span><br><span class="line">    Fuck,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>modules</code>所包含的对象即使传入Store中的对象，即源码中的<code>options</code></p><h3 id="手写基础版的vuex"><a href="#手写基础版的vuex" class="headerlink" title="手写基础版的vuex"></a>手写基础版的vuex</h3><ul><li>install</li></ul><p>vuex对外暴露一个是install方法，传入vue，并把$cppStore绑定到组件上，到时候直接调用<code>this.$cppStore.state</code>即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue: any</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">initVue: any</span>) </span>&#123;</span><br><span class="line">  Vue = initVue</span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">      <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'this'</span>, options);</span><br><span class="line">      <span class="keyword">if</span> (options &amp;&amp; options.cppStore) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$cppStore = <span class="keyword">typeof</span> options.cppStore === <span class="string">'function'</span></span><br><span class="line">        ? options.cppStore()</span><br><span class="line">        : options.cppStore;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.$cppStore = options.parent &amp;&amp; options.parent.$cppStore;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CppStore</li></ul><p>第二个是对外暴露一个 <code>CppStore</code> class,这个class需要传入一个对象，一般是这种样子的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  state: &#123;&#125;,</span><br><span class="line">  actions: &#123;&#125;,</span><br><span class="line">  mutations: &#123;&#125;,</span><br><span class="line">  getters: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>安装引入以及使用<!-- main.ts --><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cppStore <span class="keyword">from</span> <span class="string">'./store/cppStore'</span>;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  cppStore: (cppStore <span class="keyword">as</span> <span class="built_in">any</span>),</span><br><span class="line">  render: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure>store/cppStore<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import vue from &#39;vue&#39;</span><br><span class="line">import CppVuex from &#39;.&#x2F;..&#x2F;..&#x2F;utils&#x2F;vuex&#39;</span><br><span class="line">vue.use(CppVuex)</span><br><span class="line">export default new CppVuex.CppStore(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 10000,</span><br><span class="line">    data: &#123;</span><br><span class="line">      age: 20,</span><br><span class="line">      name: &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    addCount(context: any, val: number) &#123;</span><br><span class="line">      const obj &#x3D; &#123;</span><br><span class="line">        age: val,</span><br><span class="line">        name: &#39;cpp&#39;</span><br><span class="line">      &#125;</span><br><span class="line">      context.commit(&#39;CHANGE_COUNT&#39;, obj)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    CHANGE_COUNT(state: any, val: any) &#123;</span><br><span class="line">      state.count +&#x3D; val.age</span><br><span class="line">      state.data &#x3D; val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    GetCount: (state: any) &#x3D;&gt; &#123;</span><br><span class="line">      return state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="Vuex-乞丐版如下"><a href="#Vuex-乞丐版如下" class="headerlink" title="Vuex 乞丐版如下"></a>Vuex 乞丐版如下</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一版的vuex</span></span><br><span class="line"><span class="keyword">let</span> Vue: <span class="built_in">any</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">initVue: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  Vue = initVue</span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">      <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'this'</span>, options);</span><br><span class="line">      <span class="keyword">if</span> (options &amp;&amp; options.cppStore) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$cppStore = <span class="keyword">typeof</span> options.cppStore === <span class="string">'function'</span></span><br><span class="line">        ? options.cppStore()</span><br><span class="line">        : options.cppStore;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.$cppStore = options.parent &amp;&amp; options.parent.$cppStore;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> CppStore &#123;</span><br><span class="line">  <span class="keyword">protected</span> $options: <span class="built_in">any</span> = &#123;&#125; </span><br><span class="line">  <span class="keyword">protected</span> state: <span class="built_in">any</span> = &#123;&#125;</span><br><span class="line">  <span class="keyword">protected</span> mutations: <span class="built_in">any</span> = &#123;&#125;</span><br><span class="line">  <span class="keyword">protected</span> actions: <span class="built_in">any</span> = &#123;&#125;</span><br><span class="line">  <span class="keyword">protected</span> getters: <span class="built_in">any</span> = &#123;&#125;</span><br><span class="line">  <span class="comment">// dispatch: any = &#123;&#125;</span></span><br><span class="line">  <span class="comment">// commit: any = &#123;&#125;</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">options: <span class="built_in">any</span> = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// 普通传来的对象</span></span><br><span class="line">    <span class="keyword">this</span>.$options = options</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      data: <span class="keyword">this</span>.$options.state</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.$options.getters &amp;&amp; <span class="keyword">this</span>.handleGetters(<span class="keyword">this</span>.$options.getters)</span><br><span class="line">    <span class="keyword">this</span>.actions = <span class="keyword">this</span>.$options.actions</span><br><span class="line">    <span class="keyword">this</span>.mutations = <span class="keyword">this</span>.$options.mutations</span><br><span class="line">    <span class="comment">// this.commit = (type: any, arg: any) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   this.mutations[type](this.state, arg)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">const</span> store = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> &#123; dispatch, commit &#125; = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// this.commit = function boundCommit (type: any, payload: any, options: any) &#123;</span></span><br><span class="line">    <span class="comment">//   return commit.call(store, type, payload, options)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// getters</span></span><br><span class="line">  <span class="keyword">protected</span> handleGetters(getters: <span class="built_in">any</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.getters = &#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(getters).forEach(<span class="function">(<span class="params">key: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>.getters, key, &#123;</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">          <span class="comment">// 执行getters中的方法</span></span><br><span class="line">          <span class="keyword">return</span> getters[key](<span class="keyword">this</span>.state)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发dispatch</span></span><br><span class="line">  <span class="keyword">protected</span> dispatch(<span class="keyword">type</span>: <span class="built_in">any</span>, arg: <span class="built_in">any</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.actions[<span class="keyword">type</span>](&#123; </span><br><span class="line">      commit: <span class="keyword">this</span>.commit, </span><br><span class="line">      state: <span class="keyword">this</span>.state, </span><br><span class="line">      getters: <span class="keyword">this</span>.getters, </span><br><span class="line">      dispatch: <span class="keyword">this</span>.dispatch </span><br><span class="line">    &#125;, arg)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// // 触发commit</span></span><br><span class="line">  <span class="keyword">protected</span> commit = <span class="function">(<span class="params"><span class="keyword">type</span>: <span class="built_in">any</span>, arg: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.mutations[<span class="keyword">type</span>](<span class="keyword">this</span>.state, arg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  CppStore,</span><br><span class="line">  install</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="intstall-vuex安装"><a href="#intstall-vuex安装" class="headerlink" title="intstall vuex安装"></a>intstall vuex安装</h3><p>安装部分，核心就是给Vue注入一个store属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Vuex init hook, injected into each instances init hooks list.</span><br><span class="line"> *&#x2F;</span><br><span class="line">function vuexInit () &#123;</span><br><span class="line">  const options &#x3D; this.$options</span><br><span class="line">  &#x2F;&#x2F; store injection</span><br><span class="line">  if (options.store) &#123;</span><br><span class="line">    this.$store &#x3D; options.store</span><br><span class="line">  &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">    this.$store &#x3D; options.parent.$store</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟action"><a href="#模拟action" class="headerlink" title="模拟action"></a>模拟action</h3><p>vuex中通过dispatch触发action</p><ul><li>知识点<br>如何判断函数是否是async函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;是否是async函数&#39;, this.action[type].constructor);</span><br><span class="line">console.log(&#39;是否是async函数&#39;, this.action[type].constructor.name &#x3D;&#x3D;&#x3D; &#39;AsyncFunction&#39;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/29982815" target="_blank" rel="noopener">Vuex2.0源码解析</a></li></ul><h2 id="手写简单的mvvm"><a href="#手写简单的mvvm" class="headerlink" title="手写简单的mvvm"></a>手写简单的mvvm</h2><p>使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"c"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./MVVM.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> mvvm = <span class="keyword">new</span> Mvvm(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      a: &#123;</span><br><span class="line">        b: 1</span><br><span class="line">      &#125;,</span><br><span class="line">      c: 2,</span><br><span class="line"><span class="actionscript">      message: <span class="string">'this is Message'</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'mvvm'</span>, mvvm);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>具体的实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创造一个实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mvvm</span>(<span class="params">options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$options = options</span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">this</span>._data = <span class="keyword">this</span>.$options.data</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 数据劫持</span></span><br><span class="line">  observe(data)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//this 代理了 this._data</span></span><br><span class="line">  <span class="comment">// mvvm._data.a.b 相等于 mvvm.a.b</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._data[key] <span class="comment">// 访问this.a.b</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">        <span class="keyword">this</span>._data[key] = newValue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initComputed.call(this);     </span></span><br><span class="line">  <span class="comment">// 数据编译</span></span><br><span class="line">  <span class="keyword">new</span> Compile(options.el, <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据劫持 给所有对象增加set get方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observe</span>(<span class="params">data = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="comment">// 给对象添加set get</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">    <span class="comment">// 把data属性通过defineProperty的方式定义属性</span></span><br><span class="line">    <span class="keyword">let</span> val = data[key];</span><br><span class="line">     <span class="comment">// 递归继续向下找，实现深度的数据劫持</span></span><br><span class="line">    observe(val);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="comment">// 将watcher添加到订阅事件中 [watcher]</span></span><br><span class="line">        Dep.target &amp;&amp; dep.addSub(Dep.target)</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val === newVal) <span class="keyword">return</span>;</span><br><span class="line">        val = newVal;</span><br><span class="line">        observe(newVal)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方便递归调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!val || <span class="keyword">typeof</span> val !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observe(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据编译</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compile</span>(<span class="params">el, vm</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将el挂载到实例上</span></span><br><span class="line">  vm.$el = <span class="built_in">document</span>.querySelector(el);</span><br><span class="line">  <span class="comment">// ?</span></span><br><span class="line">  <span class="keyword">let</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">  <span class="keyword">let</span> child</span><br><span class="line">  <span class="keyword">while</span>(child = vm.$el.firstChild) &#123;</span><br><span class="line">    fragment.appendChild(child)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child'</span>, child);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fragment'</span>, fragment);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对 el内容进行替换</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">frag</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Array</span>.from(frag.childNodes).forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> txt = node.textContent;</span><br><span class="line">      <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>;   <span class="comment">// 正则匹配&#123;&#123;&#125;&#125;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'node'</span>, node);</span><br><span class="line">      <span class="keyword">if</span> (node.nodeType === <span class="number">3</span> &amp;&amp; reg.test(txt)) &#123;</span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">replaceTxt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            node.textContent = txt.replace(reg, (matched, placeholder) =&gt; &#123;   </span><br><span class="line">              <span class="built_in">console</span>.log(placeholder);   <span class="comment">// 匹配到的分组 如：song, album.name, singer...</span></span><br><span class="line">              <span class="keyword">new</span> Watcher(vm, placeholder, replaceTxt);   <span class="comment">// 监听变化，进行匹配替换内容</span></span><br><span class="line">              <span class="keyword">return</span> placeholder.split(<span class="string">'.'</span>).reduce(<span class="function">(<span class="params">val, key</span>) =&gt;</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> val[key]; </span><br><span class="line">              &#125;, vm);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;;</span><br><span class="line">        <span class="comment">// 替换</span></span><br><span class="line">        replaceTxt();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.nodeType === <span class="number">1</span>) &#123;  <span class="comment">// 元素节点</span></span><br><span class="line">        <span class="keyword">let</span> nodeAttr = node.attributes; <span class="comment">// 获取dom上的所有属性,是个类数组</span></span><br><span class="line">        <span class="built_in">Array</span>.from(nodeAttr).forEach(<span class="function"><span class="params">attr</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> name = attr.name;   <span class="comment">// v-model  type</span></span><br><span class="line">            <span class="keyword">let</span> exp = attr.value;   <span class="comment">// c        text</span></span><br><span class="line">            <span class="keyword">if</span> (name.includes(<span class="string">'v-'</span>))&#123;</span><br><span class="line">                node.value = vm[exp];   <span class="comment">// this.c 为 2</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 监听变化</span></span><br><span class="line">            <span class="keyword">new</span> Watcher(vm, exp, <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">              node.value = newVal;   <span class="comment">// 当watcher触发时会自动将内容放进输入框中</span></span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            node.addEventListener(<span class="string">'input'</span>, e =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> newVal = e.target.value;</span><br><span class="line">                <span class="comment">// 相当于给this.c赋了一个新值</span></span><br><span class="line">                <span class="comment">// 而值的改变会调用set，set中又会调用notify，notify中调用watcher的update方法实现了更新</span></span><br><span class="line">                vm[exp] = newVal;   </span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果还有子节点，继续递归replace</span></span><br><span class="line">      <span class="keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">        replace(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 替换内容</span></span><br><span class="line">  replace(fragment);</span><br><span class="line">  vm.$el.appendChild(fragment); <span class="comment">// 文档碎片放到el元素中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发布订阅</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subs = []</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="comment">// 订阅就是放入subs</span></span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// this.subs数组里的每一项，都有一个update方法</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this.subs'</span>, <span class="keyword">this</span>.subs);</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听者</span></span><br><span class="line"><span class="comment">// 通过Watcher这个类创建的实例，都拥有update方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm, exp, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!vm &amp;&amp; !exp) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">this</span>.vm = vm;</span><br><span class="line">  <span class="keyword">this</span>.exp = exp;</span><br><span class="line">  <span class="keyword">this</span>.fn = fn;</span><br><span class="line">  Dep.target = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> arr = exp.split(<span class="string">'.'</span>);</span><br><span class="line">  <span class="keyword">let</span> val = vm;</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;    <span class="comment">// 取值</span></span><br><span class="line">     val = val[key];     <span class="comment">// 获取到this.a.b，默认就会调用get方法</span></span><br><span class="line">  &#125;);</span><br><span class="line">  Dep.target = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype.update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// notify的时候值已经更改了</span></span><br><span class="line">  <span class="comment">// 再通过vm, exp来获取新的值</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="keyword">this</span>.exp.split(<span class="string">'.'</span>);</span><br><span class="line">  <span class="keyword">let</span> val = <span class="keyword">this</span>.vm;</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;    </span><br><span class="line">      val = val[key];   <span class="comment">// 通过get获取到新的值</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.fn(val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let watcher = new Watcher(() =&gt; console.log(111));  // </span></span><br><span class="line"><span class="comment">// let dep = new Dep();</span></span><br><span class="line"><span class="comment">// dep.addSub(watcher);    // 将watcher放到数组中,watcher自带update方法， =&gt; [watcher]</span></span><br><span class="line"><span class="comment">// dep.addSub(watcher);</span></span><br><span class="line"><span class="comment">// dep.notify();   //  111, 111</span></span><br></pre></td></tr></table></figure><p>yun….一头雾水，我太难了!!!</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> mvvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> vuex </tag>
            
            <tag> javascript </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 前端重学(3)</title>
      <link href="/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-3/"/>
      <url>/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-3/</url>
      
        <content type="html"><![CDATA[<h2 id="五一之后第二周-5-11-5-17-的安排"><a href="#五一之后第二周-5-11-5-17-的安排" class="headerlink" title="五一之后第二周(5.11-5.17)的安排"></a>五一之后第二周(5.11-5.17)的安排</h2><p>重点js基础/Vue框架/Css/node</p><ul><li>Vuex模拟实现</li><li>手写一个简单的mvvm</li><li>BFC 以及 清除浮动以及原理</li><li>闭包</li><li>观察者模式</li><li>http1.x和http2.x</li></ul><a id="more"></a><h2 id="Vuex源码以及模拟实现"><a href="#Vuex源码以及模拟实现" class="headerlink" title="Vuex源码以及模拟实现"></a>Vuex源码以及模拟实现</h2><h3 id="vuex的模拟实现"><a href="#vuex的模拟实现" class="headerlink" title="vuex的模拟实现"></a>vuex的模拟实现</h3><h2 id="手写简单的mvvm"><a href="#手写简单的mvvm" class="headerlink" title="手写简单的mvvm"></a>手写简单的mvvm</h2><p>使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"c"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./MVVM.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> mvvm = <span class="keyword">new</span> Mvvm(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      a: &#123;</span><br><span class="line">        b: 1</span><br><span class="line">      &#125;,</span><br><span class="line">      c: 2,</span><br><span class="line"><span class="actionscript">      message: <span class="string">'this is Message'</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'mvvm'</span>, mvvm);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>具体的实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创造一个实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mvvm</span>(<span class="params">options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$options = options</span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">this</span>._data = <span class="keyword">this</span>.$options.data</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 数据劫持</span></span><br><span class="line">  observe(data)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//this 代理了 this._data</span></span><br><span class="line">  <span class="comment">// mvvm._data.a.b 相等于 mvvm.a.b</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._data[key] <span class="comment">// 访问this.a.b</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">        <span class="keyword">this</span>._data[key] = newValue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initComputed.call(this);     </span></span><br><span class="line">  <span class="comment">// 数据编译</span></span><br><span class="line">  <span class="keyword">new</span> Compile(options.el, <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据劫持 给所有对象增加set get方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observe</span>(<span class="params">data = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="comment">// 给对象添加set get</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">    <span class="comment">// 把data属性通过defineProperty的方式定义属性</span></span><br><span class="line">    <span class="keyword">let</span> val = data[key];</span><br><span class="line">     <span class="comment">// 递归继续向下找，实现深度的数据劫持</span></span><br><span class="line">    observe(val);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="comment">// 将watcher添加到订阅事件中 [watcher]</span></span><br><span class="line">        Dep.target &amp;&amp; dep.addSub(Dep.target)</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val === newVal) <span class="keyword">return</span>;</span><br><span class="line">        val = newVal;</span><br><span class="line">        observe(newVal)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方便递归调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!val || <span class="keyword">typeof</span> val !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observe(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据编译</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compile</span>(<span class="params">el, vm</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将el挂载到实例上</span></span><br><span class="line">  vm.$el = <span class="built_in">document</span>.querySelector(el);</span><br><span class="line">  <span class="comment">// ?</span></span><br><span class="line">  <span class="keyword">let</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">  <span class="keyword">let</span> child</span><br><span class="line">  <span class="keyword">while</span>(child = vm.$el.firstChild) &#123;</span><br><span class="line">    fragment.appendChild(child)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child'</span>, child);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fragment'</span>, fragment);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对 el内容进行替换</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">frag</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Array</span>.from(frag.childNodes).forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> txt = node.textContent;</span><br><span class="line">      <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>;   <span class="comment">// 正则匹配&#123;&#123;&#125;&#125;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'node'</span>, node);</span><br><span class="line">      <span class="keyword">if</span> (node.nodeType === <span class="number">3</span> &amp;&amp; reg.test(txt)) &#123;</span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">replaceTxt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            node.textContent = txt.replace(reg, (matched, placeholder) =&gt; &#123;   </span><br><span class="line">              <span class="built_in">console</span>.log(placeholder);   <span class="comment">// 匹配到的分组 如：song, album.name, singer...</span></span><br><span class="line">              <span class="keyword">new</span> Watcher(vm, placeholder, replaceTxt);   <span class="comment">// 监听变化，进行匹配替换内容</span></span><br><span class="line">              <span class="keyword">return</span> placeholder.split(<span class="string">'.'</span>).reduce(<span class="function">(<span class="params">val, key</span>) =&gt;</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> val[key]; </span><br><span class="line">              &#125;, vm);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;;</span><br><span class="line">        <span class="comment">// 替换</span></span><br><span class="line">        replaceTxt();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.nodeType === <span class="number">1</span>) &#123;  <span class="comment">// 元素节点</span></span><br><span class="line">        <span class="keyword">let</span> nodeAttr = node.attributes; <span class="comment">// 获取dom上的所有属性,是个类数组</span></span><br><span class="line">        <span class="built_in">Array</span>.from(nodeAttr).forEach(<span class="function"><span class="params">attr</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> name = attr.name;   <span class="comment">// v-model  type</span></span><br><span class="line">            <span class="keyword">let</span> exp = attr.value;   <span class="comment">// c        text</span></span><br><span class="line">            <span class="keyword">if</span> (name.includes(<span class="string">'v-'</span>))&#123;</span><br><span class="line">                node.value = vm[exp];   <span class="comment">// this.c 为 2</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 监听变化</span></span><br><span class="line">            <span class="keyword">new</span> Watcher(vm, exp, <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">              node.value = newVal;   <span class="comment">// 当watcher触发时会自动将内容放进输入框中</span></span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            node.addEventListener(<span class="string">'input'</span>, e =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> newVal = e.target.value;</span><br><span class="line">                <span class="comment">// 相当于给this.c赋了一个新值</span></span><br><span class="line">                <span class="comment">// 而值的改变会调用set，set中又会调用notify，notify中调用watcher的update方法实现了更新</span></span><br><span class="line">                vm[exp] = newVal;   </span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果还有子节点，继续递归replace</span></span><br><span class="line">      <span class="keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">        replace(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 替换内容</span></span><br><span class="line">  replace(fragment);</span><br><span class="line">  vm.$el.appendChild(fragment); <span class="comment">// 文档碎片放到el元素中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发布订阅</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subs = []</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="comment">// 订阅就是放入subs</span></span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// this.subs数组里的每一项，都有一个update方法</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this.subs'</span>, <span class="keyword">this</span>.subs);</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听者</span></span><br><span class="line"><span class="comment">// 通过Watcher这个类创建的实例，都拥有update方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm, exp, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!vm &amp;&amp; !exp) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">this</span>.vm = vm;</span><br><span class="line">  <span class="keyword">this</span>.exp = exp;</span><br><span class="line">  <span class="keyword">this</span>.fn = fn;</span><br><span class="line">  Dep.target = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> arr = exp.split(<span class="string">'.'</span>);</span><br><span class="line">  <span class="keyword">let</span> val = vm;</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;    <span class="comment">// 取值</span></span><br><span class="line">     val = val[key];     <span class="comment">// 获取到this.a.b，默认就会调用get方法</span></span><br><span class="line">  &#125;);</span><br><span class="line">  Dep.target = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype.update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// notify的时候值已经更改了</span></span><br><span class="line">  <span class="comment">// 再通过vm, exp来获取新的值</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="keyword">this</span>.exp.split(<span class="string">'.'</span>);</span><br><span class="line">  <span class="keyword">let</span> val = <span class="keyword">this</span>.vm;</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;    </span><br><span class="line">      val = val[key];   <span class="comment">// 通过get获取到新的值</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.fn(val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let watcher = new Watcher(() =&gt; console.log(111));  // </span></span><br><span class="line"><span class="comment">// let dep = new Dep();</span></span><br><span class="line"><span class="comment">// dep.addSub(watcher);    // 将watcher放到数组中,watcher自带update方法， =&gt; [watcher]</span></span><br><span class="line"><span class="comment">// dep.addSub(watcher);</span></span><br><span class="line"><span class="comment">// dep.notify();   //  111, 111</span></span><br></pre></td></tr></table></figure><p>yun….一头雾水，我太难了!!!</p><h2 id="BFC-以及-清除浮动以及原理"><a href="#BFC-以及-清除浮动以及原理" class="headerlink" title="BFC 以及 清除浮动以及原理"></a>BFC 以及 清除浮动以及原理</h2><p>BFC(block formatting context) 块级格式化上下文，用于决定块盒子(block box)的<em>布局及浮动</em>相互影响范围的一个区域，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p><h3 id="BFC创建触发条件"><a href="#BFC创建触发条件" class="headerlink" title="BFC创建触发条件"></a>BFC创建触发条件</h3><ul><li>根元素或其它包含它的元素；</li><li>浮动 (元素的float不为none)；</li><li>绝对定位元素 (元素的position为absolute或fixed)；</li><li>行内块inline-blocks(元素的 display: inline-block)；</li><li>表格单元格(元素的display: table-cell，HTML表格单元格默认属性)；</li><li>overflow的值不为visible的元素；</li><li>弹性盒 flex boxes (元素的display: flex或inline-flex)；<br>平常中，设置<code>overflow: hidden/scroll, float: right/left,position: absolute,display: flex/inline-flex;</code>即当前元素创建了一个BFC</li></ul><h3 id="BFC约束规则"><a href="#BFC约束规则" class="headerlink" title="BFC约束规则"></a>BFC约束规则</h3><ul><li>内部的盒会在垂直方向一个接一个排列（可以看作BFC中有一个的常规流）</li><li>处于同一个BFC中的元素相互影响，可能会发生外边距重叠(（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生重叠（塌陷），与方向无关。）)</li><li>每个元素的margin box的左边，与容器块border box的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</li><li>计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算</li><li>浮动盒区域不叠加到BFC上，(BFC区域不会与float的元素区域叠加)</li></ul><h3 id="BFC阔以解决的问题"><a href="#BFC阔以解决的问题" class="headerlink" title="BFC阔以解决的问题"></a>BFC阔以解决的问题</h3><ul><li>垂直外边距重叠问题</li><li>去除浮动 (BFC区域不会与float的元素区域叠加)</li><li>自适用两列布局（float + overflow）</li></ul><h3 id="实例中理解BFC的约束规则"><a href="#实例中理解BFC的约束规则" class="headerlink" title="实例中理解BFC的约束规则"></a>实例中理解BFC的约束规则</h3><ul><li><p>如何实现左侧宽度固定，右侧宽度自适应</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'box'</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'left'</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'right'</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>float + margin</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">10px</span> solid red;</span><br><span class="line">  <span class="attribute">background</span>: green;   </span><br><span class="line">  <span class="attribute">border</span>: <span class="number">3px</span> solid yellow;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;                    </span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">3px</span> solid black;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>:<span class="number">#888</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>float + calc</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left1</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: green;    <span class="comment">/* 绿色 */</span></span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right1</span>&#123;                        <span class="comment">/* 粉色 */</span></span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">200px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>float + overflow(BFC应用场景)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">background</span>: green; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right2</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>利用BFC约束规则第六点:浮动盒区域不叠加到BFC上，(BFC区域不会与float的元素区域叠加)</p></blockquote></li><li><p>最佳选择 flex</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  display: flex; // 触发BFC</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left3</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: green; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right3</span> &#123;</span><br><span class="line">  flex: 1; // flex-grow: 1;flex-shrink: 1;flex-basis: 0%;</span><br><span class="line">  <span class="selector-tag">background</span>: <span class="selector-tag">pink</span>;</span><br><span class="line">  <span class="selector-tag">outline</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">black</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>清除浮动主要有两种方式，分别是clear清除浮动和BFC清除浮动</p></li><li><p>clear清除浮动<br>底层原理是在被清除浮动的元素上边或者下边添加足够的清除空间;</p></li><li><p>浮动的三个特点很重要。</p></li></ul><ol><li>脱离文档流。</li><li>向左/向右浮动直到遇到父元素或者别的浮动元素。</li><li>浮动会导致父元素高度坍塌。</li></ol><ul><li>解决父元素高度坍塌的方式就是清除浮动，常规的方法是clear清除浮动和BFC清除浮动，推荐clearfix的方式</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 全浏览器通用的clearfix方案</span><br><span class="line">// 引入了zoom以支持IE6/7</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">" "</span>;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">  *zoom: 1; // 支持IE6/7</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/59b73d5bf265da064618731d" target="_blank" rel="noopener">学习 BFC (Block Formatting Context)</a></li><li><a href="https://www.jianshu.com/p/09bd5873bed4" target="_blank" rel="noopener">CSS中的浮动和清除浮动，梳理一下！</a></li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h2 id="http1-x和http2-x"><a href="#http1-x和http2-x" class="headerlink" title="http1.x和http2.x"></a>http1.x和http2.x</h2><h3 id="http1-x几大缺陷"><a href="#http1-x几大缺陷" class="headerlink" title="http1.x几大缺陷"></a>http1.x几大缺陷</h3><ul><li>规定客户端对同一域的并发连接最多只能2个(一般是2-8个)</li><li>线头阻塞(head of line block) 同一个连接中的请求，需要一个接一个串行发送和接收</li><li>基于文本协议，请求和响应头信息大，无法压缩</li><li>不能控制响应优先级，必须按照请求顺序响应</li><li>只能单向请求，客户端请求什么，服务器返回什么</li></ul><h3 id="Http2"><a href="#Http2" class="headerlink" title="Http2"></a>Http2</h3><p>HTTP2 的前身是 SPDY协议（一个 Google 主导推行的应用层协议，作为对 HTTP1 的增强）。HTTP2必须在维持原来 HTTP 的范式（不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段等等）前提下，实现突破性能限制，改进传输性能，实现<em>低延迟</em>和<em>高吞吐量</em>。</p><h3 id="Http2-特性"><a href="#Http2-特性" class="headerlink" title="Http2 特性"></a>Http2 特性</h3><ul><li>传输内容使用二进制协议</li><li>使用帧作为最小传输单位</li><li>多路复用</li><li>头压缩</li><li>服务器推送</li><li>优先级与依赖性</li><li>可重置</li><li>流量控制</li><li>HTTPS rfc 规范并没有要求 HTTP2 强制使用 TLS，但是目前世界所有浏览器和服务器实现都基于 HTTPS 来实现 HTTP2</li></ul><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>HTTP1.x 时代，无论是传输内容还是头信息，都是文本/ASCII编码的，虽然这有利于直接从请求从观察出内容，但是却使得想要实现并发传输异常困难（存在空格或其他字符，很难判断消息的起始和结束）。使用二进制传输可以避免这个问题，因为传输内容只有1和0，通过下面第二点的“帧”规范规定格式，即可轻易识别出不同类型内容。同时使用二进制有一个显而易见的好处是：更小的传输体积</p><h3 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h3><p> HTTP2 在维持原有 HTTP 范式的前提下，实现突破性能限制，改进传输性能，实现低延迟和高吞吐量的其中一个关键是：在应用层（HTTP2）和传输层（TCP or UDP）之间增加了二进制分帧层</p><h3 id="多路复用（Multiplexing）和流"><a href="#多路复用（Multiplexing）和流" class="headerlink" title="多路复用（Multiplexing）和流"></a>多路复用（Multiplexing）和流</h3><p>多路复用是解决 HTTP1.x 缺陷第一点（并发问题）和第二点（HOLB线头问题）的核心技术点</p><h3 id="头压缩"><a href="#头压缩" class="headerlink" title="头压缩"></a>头压缩</h3><p><em>HPACK</em>专门为头部压缩设计的算法，还被指定成单独的草案中。<br>HTTP2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送；通信期间几乎不会改变的通用键-值对（用户代理、可接受的媒体类型，等等）只需发送一次</p><h2 id="Http2-0优势"><a href="#Http2-0优势" class="headerlink" title="Http2.0优势"></a>Http2.0优势</h2><ul><li>更小的传输体积，更小或者省略重复的头消息</li><li>突破原有的 TCP 连接并发限制，使用一个 TCP 连接即可实现多请求并发，单链接也能减轻服务端的压力（更少的内存和 CPU 使用）</li><li>解决 HOLB 线头问题，慢的请求或者先发送的请求不会阻塞其他请求的返回</li><li>结合 CDN 提供实时性更高，延迟更低的内容分发代理服务，大大减少白屏时间</li><li>数据传输优先级可控，使网站可以实现更灵活和强大的页面控制</li><li>能在不中断 TCP 连接的情况下停止（重置）数据的发送</li></ul><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/5acccf966fb9a028d043c6ec" target="_blank" rel="noopener">HTTP2基本概念学习笔记</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> vuex </tag>
            
            <tag> javascript </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 前端重学(2)</title>
      <link href="/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-2/"/>
      <url>/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-2/</url>
      
        <content type="html"><![CDATA[<h2 id="五一之后第一周-5-6-5-9-的安排"><a href="#五一之后第一周-5-6-5-9-的安排" class="headerlink" title="五一之后第一周(5.6-5.9)的安排"></a>五一之后第一周(5.6-5.9)的安排</h2><ul><li>type 和 interface 区别</li><li>webpack中的externals配置使用</li><li>https和http协议的区别</li></ul><a id="more"></a><blockquote><p>ts语法强烈建议浏览<a href="https://www.tslang.cn/docs/handbook/interfaces.html" target="_blank" rel="noopener">官网</a>,英语理解力强的，阔推荐<a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">英文官网</a></p></blockquote><p>ts运行，本地tslint提示的各种报错有时真让人抓狂!!!(持续完善当中)</p><table><thead><tr><th>序列</th><th>提示</th><th align="center">描述</th></tr></thead><tbody><tr><td>1</td><td>Exceeds maximum line length of 150</td><td align="center">单行超150字符</td></tr><tr><td>2</td><td>expected an assignment or function call</td><td align="center">expected an assignment or function call</td></tr><tr><td>3</td><td>comment must start with a space</td><td align="center">// 注释应以空格开头</td></tr><tr><td>4</td><td>for (… in …) statements must be filtered with an if statement</td><td align="center">for in 循环体内应有if判断属性是否存在</td></tr><tr><td>5</td><td>Declaration of instance field not allowed after declaration of instance method. Instead, this should come at the beginning of the class/interface.</td><td align="center">class/interface的属性定义应放在方法前</td></tr><tr><td>6</td><td>Declaration of static method not allowed after declaration of instance method. Instead, this should come after instance fields.</td><td align="center">class/interface的静态方法定义应放在非静态方法前</td></tr><tr><td>7</td><td>Shadowed variable</td><td align="center">变量名重名</td></tr><tr><td>8</td><td>Missing radix parameter</td><td align="center">parseInt缺少转换基数，直接第二个参数为0即可</td></tr><tr><td>9</td><td>Class name must be in pascal case</td><td align="center">class类命名必须首字母大写</td></tr><tr><td>10</td><td>file should end with a newline</td><td align="center">文件末尾少个空行</td></tr><tr><td>11</td><td>Type ‘string’ is not assignable to type ‘number’</td><td align="center">接口规定的是number类型不是字符串类型</td></tr></tbody></table><blockquote><p>参考链接<a href="http://blog.dongsj.cn/20170715-team-review.html" target="_blank" rel="noopener">目前 Angular2 项目内的 TSLint 设置</a></p></blockquote><h2 id="ts中的type和interface区别"><a href="#ts中的type和interface区别" class="headerlink" title="ts中的type和interface区别"></a>ts中的type和interface区别</h2><p>interface 和 type interface 和 type 都可以用来定义一些复杂的类型结构，最很多情况下是通用的，最初我一直没能理解它们二者之间区别在哪里，后来发现，二者的区别在于：</p><ul><li>type 不能像 interface 那样合并，其在作用域内唯一</li><li>interface创建了一种新的类型，而 type 仅仅是别名，是一种引用；</li><li>如果 type 使用了 union operator （|） 操作符，则不能将 type implements 到 class 上；</li><li>如果 type 使用了 union（|） 操作符 ，则不能被用以 extends interface</li></ul><h2 id="interface阔以，type不行"><a href="#interface阔以，type不行" class="headerlink" title="interface阔以，type不行"></a>interface阔以，type不行</h2><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。</p><ul><li>优点一是可以对可能存在的属性进行预定义</li><li>优点二是可以捕获引用了不存在的属性时的错误<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Chart &#123;</span><br><span class="line">  Num: <span class="built_in">number</span>;</span><br><span class="line">  Type?: <span class="built_in">string</span>[];</span><br></pre></td></tr></table></figure><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3>初次创建的时候赋值，其他时候不允许再次赋值，在属性前用<code>readonly</code>指定<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  readonly x: <span class="built_in">number</span>;</span><br><span class="line">  readonly y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="额外属性检查"><a href="#额外属性检查" class="headerlink" title="额外属性检查"></a>额外属性检查</h3>当你不确定接口会有哪些其他的属性的时候，阔以用一个<code>字符串</code>索引签名<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  readonly x: <span class="built_in">number</span>;</span><br><span class="line">  readonly y: <span class="built_in">number</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Declaration-merging-type-不能像-interface-那样合并"><a href="#Declaration-merging-type-不能像-interface-那样合并" class="headerlink" title="Declaration merging, type 不能像 interface 那样合并"></a>Declaration merging, type 不能像 interface 那样合并</h3>接口阔以定义多次，而类型别名则不行<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> data &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> data &#123;</span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> serF: SearchFunc</span><br><span class="line">serF = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = source.search(subString);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配,这样也想<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> serF: SearchFunc</span><br><span class="line">serF = <span class="function"><span class="keyword">function</span>(<span class="params">sou: <span class="built_in">string</span>, sub: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = sou.search(sub);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可索引类型"><a href="#可索引类型" class="headerlink" title="可索引类型"></a>可索引类型</h3>索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> dataArray &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr:dataArray = [</span><br><span class="line">  <span class="string">'chen'</span>,</span><br><span class="line">  <span class="string">'peng'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>上面例子里，我们定义了dataArray接口，它具有索引签名。 这个索引签名表示了当用 <code>number</code> 去索引dataArray时会得到string类型的返回值。<blockquote><p>TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberDictionary &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  length: <span class="built_in">number</span>;    <span class="comment">// 可以，length是number类型</span></span><br><span class="line">  name: <span class="built_in">string</span>       <span class="comment">// 错误，`name`的类型与索引类型返回值的类型不匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><ul><li>实现接口<br>TypeScript也能够用它来明确的强制一个类去符合某种契约,用<code>implements</code>实现接口<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">    setTime(d: <span class="built_in">Date</span>); <span class="comment">// 在接口中描述一个方法，在类里实现它，如同下面的setTime方法一样：</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">    setTime(d: <span class="built_in">Date</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.currentTime = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>类静态部分与实例部分的区别<br>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名(new )去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</li></ul><p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只对其实例部分进行类型检查</span></span><br><span class="line"><span class="keyword">interface</span> ClockConstructor &#123;</span><br><span class="line">    <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockConstructor &#123;</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">    <span class="comment">// constructor存在于类的静态部分，所以不在检查的范围内</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口， ClockConstructor为构造函数所用和ClockInterface为实例方法所用。 为了方便我们定义一个构造函数 createClock，它用传入的类型创建实例。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数所用，这里用interface会报错？类的静态部分</span></span><br><span class="line"><span class="keyword">type</span> PerConstructor = <span class="keyword">new</span> (name: <span class="built_in">string</span>, age: <span class="built_in">number</span>) =&gt; PerInterface;</span><br><span class="line"><span class="comment">// 实例部分</span></span><br><span class="line"><span class="keyword">interface</span> PerInterface &#123;</span><br><span class="line">  sayName(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">ctor: PerConstructor, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>): <span class="title">PerInterface</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ctor(name, age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> P1Type <span class="keyword">implements</span> PerInterface &#123;</span><br><span class="line">  <span class="keyword">public</span> name!: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">public</span> age!: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`call sayName: <span class="subst">$&#123;(<span class="keyword">this</span> <span class="keyword">as</span> <span class="built_in">any</span>).name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为createPerson的第一个参数是PerConstructo类型，在createPerson(P1Type, 7, 32)里，会检查P1Type是否符合构造函数签名。</p><h4 id="访问修饰符：private、public、protected"><a href="#访问修饰符：private、public、protected" class="headerlink" title="访问修饰符：private、public、protected"></a>访问修饰符：private、public、protected</h4><ul><li>默认为public，public规定的属性必须在类的顶层</li><li>当成员被标记为private时，它就不能在声明它的类的外部访问</li><li>protected和private类似，但是，protected成员在派生类(子类)中可以访问。这是protected和privat最大的区别</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ClockInter &#123;</span><br><span class="line">  setTime(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ClockParent <span class="keyword">implements</span> ClockInter &#123;</span><br><span class="line">  <span class="keyword">public</span> currentTime!: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">protected</span> habit = <span class="string">'shufa'</span>; <span class="comment">// 受保护的属性</span></span><br><span class="line">  <span class="comment">// 限定于属性 在定义方法</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentTime = h</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> setTime() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'d'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出一个Clock 类 继承父类 并通过ClockInter实现接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Clock <span class="keyword">extends</span> ClockParent <span class="keyword">implements</span> ClockInter &#123;</span><br><span class="line">  <span class="keyword">public</span> currentTime!: <span class="built_in">any</span>;</span><br><span class="line">  <span class="comment">// 限定于属性 在定义方法</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>((<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime());</span><br><span class="line">    <span class="keyword">this</span>.currentTime = h</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> setTime() &#123;</span><br><span class="line">    <span class="comment">// 能访问受保护的属性 habit</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'d'</span>, <span class="keyword">this</span>.habit);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，Clock是一个 派生类，它派生自 ClockParent 基类，通过 extends关键字。 派生类通常被称作<em>子类</em>，基类通常被称作<em>超类</em>。<br>派生类包含了一个构造函数，它 必须调用 <em>super()</em>，它会执行基类的构造函数。 而且，在构造函数里访问 this的属性之前，我们 一定要调用 super()。 这个是TypeScript强制执行的一条重要规则。</p><blockquote><p>一个ts文件不能同时定义2个及以上的类？添加tslint.json中的规则即可</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"rules": &#123;</span><br><span class="line">  "max-classes-per-file": [</span><br><span class="line">    true,</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。主要<strong>type</strong>类型别名，也阔以继承，语法稍有不同</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape &#123;</span><br><span class="line">  sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> square = &#123;&#125; <span class="keyword">as</span> Square;</span><br><span class="line">square.color = <span class="string">'red'</span>;</span><br><span class="line">square.sideLength1 = <span class="number">10</span>;</span><br><span class="line">square.name = <span class="string">'cpp'</span></span><br></pre></td></tr></table></figure><p>也阔以继承多个接口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Shape2 &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, Shape2 &#123;</span><br><span class="line">  sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> square = &#123;&#125; <span class="keyword">as</span> Square;</span><br><span class="line">  square.color = <span class="string">'red'</span>;</span><br><span class="line">  square.name = <span class="string">'cpp'</span>;</span><br><span class="line">  square.sideLength = <span class="number">22</span></span><br></pre></td></tr></table></figure><h3 id="关键字implements有什么作用？"><a href="#关键字implements有什么作用？" class="headerlink" title="关键字implements有什么作用？"></a>关键字<code>implements</code>有什么作用？</h3><p>一句话即: 约束接口按照某种契约，举例说明</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implements的实现</span></span><br><span class="line"><span class="keyword">interface</span> ClockInter &#123;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  setTime(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInter &#123;</span><br><span class="line">  <span class="comment">// 如果age = '1111' Type 'string' is not assignable to type 'number'.</span></span><br><span class="line">  <span class="keyword">public</span> age = <span class="number">1111</span>;</span><br><span class="line">  <span class="comment">// !非空断言操作符 能确定变量一定不为空时使用</span></span><br><span class="line">  <span class="comment">// 非空断言操作符不会防止出现 null 或 undefined</span></span><br><span class="line">  <span class="keyword">public</span> currentTime!: <span class="built_in">any</span>;</span><br><span class="line">  <span class="comment">// 限定于属性 在定义方法</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentTime = h</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> setTime() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'d'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中ClockInter约束了age必须是数字类型，所以在通过ClockInter实现Clock这个类的时候，age必须按照接口定义的来约束。<br>如何引用这个<code>Clock</code>这个类呢，在<em>vue</em>文件直接import导入，然后new调用即可，如</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Clock &#125; <span class="keyword">from</span> <span class="string">'../../utils/implementsd2'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> HomeDem <span class="keyword">extends</span> Vue &#123;</span><br><span class="line">  <span class="keyword">private</span> person1: <span class="built_in">any</span> = <span class="string">''</span></span><br><span class="line">  <span class="keyword">private</span> mounted() &#123;</span><br><span class="line">    <span class="keyword">const</span> num =  (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line">    <span class="comment">// 创造一个实例并传入当前的时间戳</span></span><br><span class="line">    <span class="keyword">this</span>.person1 = <span class="keyword">new</span> Clock(num)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1'</span>, <span class="keyword">this</span>.person1);</span><br><span class="line">    <span class="keyword">this</span>.person1.setTime(num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Type类型别名"><a href="#Type类型别名" class="headerlink" title="Type类型别名"></a>Type类型别名</h3><p>type 会给一个类型起个新名字。 type 有时和 interface 很像，但是可以作用于原始值（基本类型），联合类型，元组以及其它任何你需要手写的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数所用，这里用interface会报错？</span></span><br><span class="line"><span class="keyword">type</span> PerConstructor = <span class="keyword">new</span> (name: <span class="built_in">string</span>, age: <span class="built_in">number</span>) =&gt; PerInterface;</span><br><span class="line"><span class="comment">// 实例所用</span></span><br><span class="line"><span class="keyword">interface</span> PerInterface &#123;</span><br><span class="line">  sayName(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>起别名不会新建一个类型 - 它创建了一个<code>新名字</code>来引用那个类型。给基本类型起别名通常没什么用，尽管可以做为文档的一种形式使用。</p><h3 id="interface-vs-type"><a href="#interface-vs-type" class="headerlink" title="interface vs type"></a>interface vs type</h3><ul><li><p>两者都可以用来描述对象或函数的类型，但是语法不同</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SetPoint = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">interface</span> SetPoint &#123;</span><br><span class="line">   (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tuple</span></span><br><span class="line"><span class="keyword">type</span> Data = [<span class="built_in">number</span>, <span class="built_in">string</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// dom</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">type</span> B = <span class="keyword">typeof</span> div;</span><br></pre></td></tr></table></figure></li><li><p>继承Extend<br>语法有所不同，interface继承用extends,type用 <em>&amp;</em> 继承</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PartialPointX = &#123; x: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="keyword">type</span> Point = PartialPointX &amp; &#123; y: <span class="built_in">number</span>; &#125;;</span><br></pre></td></tr></table></figure></li><li><p>class implements实现接口<br>类可以以相同的方式实现接口或类型别名。但是请注意，类和接口被认为是静态的。因此，它们不能实现/扩展命名联合类型的类型别名。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PartialPoint = &#123; x: <span class="built_in">number</span>; &#125; | &#123; y: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">FIXME:</span> can not implement a union type</span></span><br><span class="line"><span class="keyword">class</span> SomePartialPoint <span class="keyword">implements</span> PartialPoint &#123;</span><br><span class="line">  x: <span class="number">1</span>;</span><br><span class="line">  y: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>declaration mergeing</p></li></ul><p>与类型别名不同，接口可以定义多次，并将被视为单个接口(合并所有声明的成员)</p><ul><li>计算属性，生成映射类型<br>type 能使用 in 关键字生成映射类型，但 interface 不行。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Keys = <span class="string">"firstname"</span> | <span class="string">"surname"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DudeType = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> Keys]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test: DudeType = &#123;</span><br><span class="line">  firstname: <span class="string">"Pawel"</span>,</span><br><span class="line">  surname: <span class="string">"Grzybek"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="comment">//interface DudeType2 &#123;</span></span><br><span class="line"><span class="comment">//  [key in keys]: string</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>参考链接</p><ul><li><a href="https://www.tslang.cn/docs/handbook/interfaces.html" target="_blank" rel="noopener">tsHandBook</a></li><li><a href="https://juejin.im/post/5e889626f265da480c0315d8" target="_blank" rel="noopener">TypeScript 中 interface 和 type 使用区别介绍</a></li></ul><h2 id="webpack中的externals配置使用"><a href="#webpack中的externals配置使用" class="headerlink" title="webpack中的externals配置使用"></a>webpack中的externals配置使用</h2><h3 id="官网解释"><a href="#官网解释" class="headerlink" title="官网解释"></a>官网解释</h3><p>webpack 中的 externals 配置提供了不从 bundle 中引用依赖的方式。解决的是，所创建的 bundle 依赖于那些存在于用户环境(consumer environment)中的依赖。</p><p>意思是如果需要引用一个库，但是又不想让webpack打包（减少打包的时间），并且又不影响我们在程序中以CMD、AMD或者window/global全局等方式进行使用（一般都以import方式引用使用），那就可以通过配置externals;</p><h3 id="Vue项目中如何实践"><a href="#Vue项目中如何实践" class="headerlink" title="Vue项目中如何实践"></a>Vue项目中如何实践</h3><ul><li>在vue.config.js中更改<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">      config.externals = &#123;</span><br><span class="line">        echarts: <span class="string">'echarts'</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在<em>index.html</em>中引入vue.js,通过cdn方式或者本地资源引入都行</li></ul><h3 id="externals和libraryTarget的关系"><a href="#externals和libraryTarget的关系" class="headerlink" title="externals和libraryTarget的关系"></a>externals和libraryTarget的关系</h3><ul><li>libraryTarget配置如何暴露 library。如果不设置library,那这个library就不暴露。就相当于一个自执行函数</li><li>externals是决定的是以哪种模式去加载所引入的额外的包</li><li>libraryTarget决定了你的library运行在哪个环境，哪个环境也就决定了你哪种模式去加载所引入的额外的包。也就是说，externals应该和libraryTarget保持一致。library运行在浏览器中的，你设置externals的模式为commonjs，那代码肯定就运行不了了。</li><li>如果是应用程序开发，一般是运行在浏览器环境libraryTarget可以不设置，externals默认的模式是global，也就是以全局变量的模式加载所引入外部的库。</li></ul><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://www.jianshu.com/p/283b17d17b3c" target="_blank" rel="noopener">webpack 的externals配置</a></li></ul><h2 id="https和http协议的区别"><a href="#https和http协议的区别" class="headerlink" title="https和http协议的区别"></a>https和http协议的区别</h2><h3 id="HTTP和HTTPS的基本概念"><a href="#HTTP和HTTPS的基本概念" class="headerlink" title="HTTP和HTTPS的基本概念"></a>HTTP和HTTPS的基本概念</h3><p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，是http协议身披一层SSL(Secure Socket Layer，安全套阶 层)协议，SSL这层协议存在于应用层（http层）到TCP层之间:</p><p><strong>应用层(http) =&gt; ssl =&gt; TCP =&gt; IP</strong></p><p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><h3 id="HTTP缺点"><a href="#HTTP缺点" class="headerlink" title="HTTP缺点"></a>HTTP缺点</h3><ul><li>明文传输，私密信息已被窃取</li><li>无法验证通信者身份，可能存储伪装者(客户端和服务器)</li><li>http协议无法判断通信报文的完整性，通信报文在TCP/IP协议通信中可能会被篡改<br>http协议的缺点，只能是ssl协议来完成</li></ul><h3 id="HTTPS使用SSL（Secure-Scocket-Layer-，安全套阶层）和TLS-Transport-Layer-Secure，安全层传输协议-这两种协议。"><a href="#HTTPS使用SSL（Secure-Scocket-Layer-，安全套阶层）和TLS-Transport-Layer-Secure，安全层传输协议-这两种协议。" class="headerlink" title="HTTPS使用SSL（Secure Scocket Layer ，安全套阶层）和TLS(Transport Layer Secure，安全层传输协议)这两种协议。"></a>HTTPS使用SSL（Secure Scocket Layer ，安全套阶层）和TLS(Transport Layer Secure，安全层传输协议)这两种协议。</h3><p>IETF 以 SSL3.0 为基准，后又制定了 TLS1.0、TLS1.1 和TLS1.2。TSL 是以 SSL 为原型开发的协议，有时会统一称该协议 为 SSL。当前主流的版本是 SSL3.0 和 TLS1.0。由于 SSL1.0 协议在设计之初被发现出了问题，就没有实际投入 使用。SSL2.0 也被发现存在问题，所以很多浏览器直接废除了 该协议版本。</p><p><strong>HTTP + 认证 + 加密 + 完整性保护 = HTTPS</strong></p><h3 id="HTTPS和HTTP的区别主要如下："><a href="#HTTPS和HTTP的区别主要如下：" class="headerlink" title="HTTPS和HTTP的区别主要如下："></a>HTTPS和HTTP的区别主要如下：</h3><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl(Secure Scocket Layer 安全套阶层)加密传输协议。</p><p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者默认是80，后者默认是443。</p><p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h3 id="HTTPS优点"><a href="#HTTPS优点" class="headerlink" title="HTTPS优点"></a>HTTPS优点</h3><ul><li>seo方面<br>采用https的网站在搜索结果的排名中较高</li><li>安全性</li></ul><p>1.使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；<br>2.TTPS协议是由<em>SSL+HTTP</em>协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。<br>3.HTTPS是现行架构下最安全的解决方案，虽然不是<em>绝对安全</em>，但它大幅增加了中间人攻击的成本。</p><h3 id="HTTPS缺点"><a href="#HTTPS缺点" class="headerlink" title="HTTPS缺点"></a>HTTPS缺点</h3><ul><li><p>seo方面<br>使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电，此外，HTTPS协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响</p></li><li><p>经济方面</p></li></ul><p>1.ca证书需要费用<br>2.ssl证书需要绑定ip，不能在同一个IP上绑定多个域名<br>3.https连接缓存不如http高效，大流量网站不一定非要https<br>4.HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本</p><ul><li>使用ssl协议，处理速度会变得很慢<br>一种是指通信慢。另一种是指由于大量消耗CPU 及内存等资源，导致处理速度变慢。<br>由于https还需要做服务器/客户端加密以及解密处理，因此肯定会消耗CPU和内存等硬件资源。</li></ul><p>参考链接</p><ul><li><a href="http://www.mahaixiang.cn/internet/1233.html" target="_blank" rel="noopener">HTTP与HTTPS的区别</a></li><li><a href="https://juejin.im/post/5c1c9b50f265da616e4c695e" target="_blank" rel="noopener">前端面试http和https的区别</a></li><li><a href="https://juejin.im/post/5af3e002f265da0b7c074ada" target="_blank" rel="noopener">http与https的区别我真的知道吗</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> vue </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 前端重学(1)</title>
      <link href="/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-1/"/>
      <url>/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-1/</url>
      
        <content type="html"><![CDATA[<p>五一假期安排</p><ul><li>防抖和节流函数</li><li>new 构造函数实例</li><li>手写apply/bind/call</li><li>单例模式以及vue单组件</li><li>箭头函数</li><li>继承</li></ul><a id="more"></a><h2 id="函数防抖和节流"><a href="#函数防抖和节流" class="headerlink" title="函数防抖和节流"></a>函数防抖和节流</h2><p>都阔以用于持续触发函数的优化中，防抖是，触发事件后n秒内，函数只能执行一次。如果在N秒内又重新触发，则需要重新计时开始。或者简洁点：连续触发的时候，只会执行一次。在停止N秒之后才能继续执行，典型的案例就是防止多次提交的按钮</p><p>而节流呢，是每间隔N秒，只执行一次。就像水龙头里的水，节流只能减缓水流，但事件依然会执行。频率变少了。典型案例是滚动scroll/resize事件</p><p>两者最大的区别就是节流是依然执行，可用于滚动事件。而防抖，如果一直在触发中，只有停下来的时候才会执行一次。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 防抖</span></span><br><span class="line"><span class="comment"> * @param fn </span></span><br><span class="line"><span class="comment"> * @param wait </span></span><br><span class="line"><span class="comment"> * @param immedate 是否立即执行 true 立即执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> debounce = <span class="function">(<span class="params">fn: <span class="built_in">any</span>, wait: <span class="built_in">number</span> = 1000, immedate: <span class="built_in">boolean</span> = <span class="literal">true</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self: <span class="built_in">any</span> = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">      clearTimeout(timeout)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (immedate) &#123;</span><br><span class="line">      <span class="keyword">const</span> callNow = !timeout</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        timeout = <span class="literal">null</span></span><br><span class="line">      &#125;, wait)</span><br><span class="line">      <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">        fn.apply(self, args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        fn.apply(self, args)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>防抖函数，主要是采用异步线程setTimeout进行延时执行,立即执行，是在触发事件的开始的时候就立即执行。而非立即执行版的防抖，就是执行完N秒之后，不触发事件才会执行<br>箭头函数没有自己的arguments,但是阔以通过命名参数的形式或者rest参数的形式传参</p></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖 非立即执行</span></span><br><span class="line">    <span class="keyword">const</span> DivD: <span class="built_in">any</span> = <span class="built_in">document</span>.getElementById(<span class="string">'Test'</span>)</span><br><span class="line">    DivD.addEventListener(<span class="string">'mousemove'</span>, debounce(<span class="keyword">this</span>.dataSetting, <span class="number">1000</span>, <span class="literal">false</span>), <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><blockquote><p>addEventListener的第二个参数实际上是debounce函数里return回的方法，let timeout = null 这行代码只在addEventListener的时候执行了一次 触发事件的时候不会执行，那么每次触发scroll事件的时候都会清除上次的延时器同时记录一个新的延时器，当scroll事件停止触发后最后一次记录的延时器不会被清除可以延时执行，这是debounce函数的原理</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 函数节流</span></span><br><span class="line"><span class="comment"> * @param fn 执行函数</span></span><br><span class="line"><span class="comment"> * @param wait 等待的时间</span></span><br><span class="line"><span class="comment"> * @param type 默认是1 时间戳版 2定时器版</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn: <span class="built_in">any</span>, wait: <span class="built_in">number</span> = 1000, <span class="keyword">type</span>: <span class="built_in">number</span> = 1</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> timeout: <span class="built_in">any</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 时间戳版</span></span><br><span class="line">      <span class="keyword">const</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">      <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">        fn.apply(context, args);</span><br><span class="line">        previous = now</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">type</span> ===<span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">// 定时器版</span></span><br><span class="line">      <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">        timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          timeout = <span class="literal">null</span></span><br><span class="line">          fn.apply(context, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>节流最大的特点就是减少事件的频率，可能由1毫秒到1000毫秒才能触发事件。事件依然会执行，频率变少。时间戳版和定时器版各有特色，都是满足一个假设条件才能执行事件，执行事件都是用apply绑定</p></blockquote><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节流 定时器版</span></span><br><span class="line"><span class="keyword">const</span> iframe4: <span class="built_in">any</span> = <span class="built_in">document</span>.getElementById(<span class="string">'Test4'</span>)</span><br><span class="line">iframe4.addEventListener(<span class="string">'mousemove'</span>, throttle(<span class="keyword">this</span>.dataSetting, <span class="number">1000</span>, <span class="number">2</span>), <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h2 id="new-构造函数和模拟实现"><a href="#new-构造函数和模拟实现" class="headerlink" title="new 构造函数和模拟实现"></a>new 构造函数和模拟实现</h2><h3 id="如何理解执行上下文"><a href="#如何理解执行上下文" class="headerlink" title="如何理解执行上下文"></a>如何理解执行上下文</h3><p>context主要指代码执行环境，分为</p><ul><li>全局执行环境</li><li>函数执行环境</li><li>eval执行环境</li></ul><p>每一段js代码执行，都会先创建一个上下文环境</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域其实可理解为该上下文中声明的 <em>变量和声明的作用范围</em>。可分为 块级作用域 和 函数作用域</p><h3 id="如何理解作用域链"><a href="#如何理解作用域链" class="headerlink" title="如何理解作用域链"></a>如何理解作用域链</h3><p>我们知道，我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含 父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。</p><p>由两部分组成:</p><ul><li>[[scope]]属性: 指向父级变量对象和作用域链，也就是包含了父级的[[scope]]和AO</li><li>AO: 自身活动对象<br>如此 [[scope]]包含[[scope]]，便自上而下形成一条 链式作用域。</li></ul><p>从当前环境向父级一层一层查找<em>变量</em>的过程</p><ul><li><a href="https://juejin.cn/post/6844903776512393224#heading-18" target="_blank" rel="noopener">参考链接</a></li></ul><h3 id="如何理解原型链"><a href="#如何理解原型链" class="headerlink" title="如何理解原型链"></a>如何理解原型链</h3><p>前期: 每个函数都有prototype属性，每个函数实例对象都有一个<strong>proto</strong>对象，而这个对象指向函数的protoType属性。<br>当我们访问实例对象的属性或者方法时，首先从自身构造函数中查找，如果没有就通过<em><strong>proto</strong></em>去原型上查找，这个查找的过程我们称之为原型链。</p><h3 id="new-做了哪些操作"><a href="#new-做了哪些操作" class="headerlink" title="new 做了哪些操作"></a>new 做了哪些操作</h3><p>1.创建了一个新对象<br>2.这个对象也就是构造函数中的this,阔以访问挂载在this上的任意属性<br>3.这个对象还能访问构造函数原型上的属性，需要将对象与构造函数链接起来<br>4.默认返回this，如果手动定义返回原始值不影响，返回对象需要正常处理</p><p>手动实现一个new 操作符</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 手动实现一个new操作符</span></span><br><span class="line"><span class="comment"> * @param &#123;Funtion&#125; Con 构造函数</span></span><br><span class="line"><span class="comment"> * @param &#123;Array&#125; args 参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Create = <span class="function">(<span class="params">Con: <span class="built_in">any</span>, ...args: <span class="built_in">any</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 验证构造函数是否是函数类型</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> Con !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'Create Function this first param must be a function'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 继承Con原型上的prototype属性,又称原型上继承</span></span><br><span class="line">  <span class="keyword">const</span> obj: <span class="built_in">any</span> = <span class="built_in">Object</span>.create(Con.prototype);</span><br><span class="line">  <span class="comment">// or obj.__proto__ = Con.prototype</span></span><br><span class="line">  <span class="comment">// or Object.setPrototypeOf(obj, Con.prototype)</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'constructor'</span>, Con);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'obj'</span>, obj);</span><br><span class="line">  <span class="comment">// 除去构造函数的其他参数</span></span><br><span class="line">  <span class="comment">// 生成新的对象要绑定到构造函数上this对象上，并且传入剩余的参数</span></span><br><span class="line">  <span class="keyword">const</span> res = Con.apply(obj, args)</span><br><span class="line">  <span class="comment">// 如果返回是对象就是对象,否则返回obj</span></span><br><span class="line">  <span class="comment">// 默认构造函数返回的是undefined</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">'object'</span> ? res : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="create说明"><a href="#create说明" class="headerlink" title="create说明"></a>create说明</h4><p>1.接受构造函数和其他参数<br>2.创建obj对象，同时要继承构造函数的原型链上的属性和方法，所以我们通过 Object.create(Con.prototype)实现，或者通过<br>setPrototypeOf 将两者联系起来。这段代码等同于 <strong>obj.<strong>proto</strong> = Con.prototype</strong>，即继承构造函数的原型链上的属性和方法有三种</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(Con.prototype)</span><br><span class="line"><span class="comment">// second 原型链继承</span></span><br><span class="line">obj.__proto__ = Con.prototype</span><br><span class="line"><span class="comment">// third</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, Con.prototype)</span><br></pre></td></tr></table></figure><p>3.生成新的对象会绑定到构造函数上this对象上，并且传入剩余的参数即</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Con方法绑定this对象，这里的this即obj</span></span><br><span class="line"><span class="keyword">const</span> res = Con.apply(obj, args)</span><br></pre></td></tr></table></figure><p>4.返回值处理</p><p>用法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private mounted() &#123;</span><br><span class="line">  <span class="comment">// 箭头函数不能通过new关键字调用</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">this: any, name: any</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.habits = <span class="string">'Games'</span></span><br><span class="line">  &#125;</span><br><span class="line">  Person.prototype.age = <span class="number">30</span>;</span><br><span class="line">  Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sayName: i am'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建person1实例</span></span><br><span class="line">  <span class="keyword">this</span>.person1 = <span class="keyword">new</span> (Person <span class="keyword">as</span> any)(<span class="string">'cpp'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'typeof'</span>, <span class="keyword">typeof</span> Person);</span><br><span class="line">  <span class="comment">// 实例对象上的__proto__</span></span><br><span class="line">  <span class="comment">// console.log('__proto__', this.person1.__proto__);</span></span><br><span class="line">  <span class="comment">// console.log('prototype', Person.prototype);</span></span><br><span class="line">  <span class="comment">// 实例对象上的__proto__ 全等于 构造函数的原型</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'==='</span>,  <span class="keyword">this</span>.person1.__proto__ === Person.prototype);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'constructor'</span>, Person.prototype.constructor === Person);</span><br><span class="line">  <span class="keyword">this</span>.person1.sayName();</span><br><span class="line">  <span class="comment">// 模拟new的实现</span></span><br><span class="line">  <span class="keyword">const</span> person2 = Create(Person, <span class="string">'cpp222'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p2'</span>, person2.name);</span><br><span class="line">  person2.sayName()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟new简洁版</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Create</span>(<span class="params">Con, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个对象，继承构造函数上的原型属性</span></span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(Con.prototype);</span><br><span class="line">  <span class="comment">// 绑定到this上</span></span><br><span class="line">  <span class="keyword">const</span> res = Con.apply(obj, agrs)</span><br><span class="line">  <span class="keyword">return</span> res instanceOf <span class="string">'Object'</span> ? res : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="apply-amp-amp-call-amp-amp-bind-手动实现"><a href="#apply-amp-amp-call-amp-amp-bind-手动实现" class="headerlink" title="apply &amp;&amp; call &amp;&amp; bind()手动实现"></a>apply &amp;&amp; call &amp;&amp; bind()手动实现</h2><h3 id="call-用法"><a href="#call-用法" class="headerlink" title="call 用法"></a>call 用法</h3><blockquote><p>call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p></blockquote><p>说起来有点拗口，就是指定this值，调用某个函数<br>举例子:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar函数--this'</span>, <span class="keyword">this</span>); <span class="comment">// &#123;value: 'chendapepeng'&#125; 指向foo</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar函数--this.value'</span>, <span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  value: <span class="string">'cpp'</span>,</span><br><span class="line">&#125;</span><br><span class="line">bar.call(foo, <span class="string">'chendapeng'</span>, <span class="number">30</span>); <span class="comment">// 执行bar函数，且传参</span></span><br></pre></td></tr></table></figure><p>注意两点：</p><ul><li>call 改变了<strong>this</strong>的指向，指向到 foo</li><li>bar 函数执行了</li></ul><h3 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h3><p>假设这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  value: <span class="string">'cpp'</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo.bar(); <span class="comment">// 'cpp'</span></span><br></pre></td></tr></table></figure><p>但是这样多了一个属性，但是阔以删除,大体分为这几步,简单版的myCall</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCall</span>(<span class="params">con</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> context = con || <span class="built_in">window</span>; <span class="comment">// 相当于foo</span></span><br><span class="line">  context.fn = <span class="keyword">this</span> <span class="comment">// foo.bar</span></span><br><span class="line">  context.fn()</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar函数--this'</span>, <span class="keyword">this</span>); <span class="comment">// &#123;value: 'chendapepeng'&#125; 指向foo</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar函数--this.value'</span>, <span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  value: <span class="string">'cpp'</span>,</span><br><span class="line">&#125;</span><br><span class="line">Funtion.prototype.myCall = myCall</span><br><span class="line">bar.myCall(foo)</span><br></pre></td></tr></table></figure><h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><p>call 函数还能给定参数执行函数,直接上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mockCall: <span class="function"><span class="keyword">function</span> (<span class="params">con, ...args</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> context = con || <span class="built_in">window</span>;</span><br><span class="line">   <span class="comment">// 首先获取调用call的函数，比如bar.call(foo),就是bar函数</span></span><br><span class="line">   context.fn = <span class="keyword">this</span>;</span><br><span class="line">   context.fn(...args)</span><br><span class="line">   <span class="comment">// 用完记得删除调用对象里的方法</span></span><br><span class="line">   <span class="keyword">delete</span> context.fn</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><p>bar函数阔以有返回值的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar函数--this'</span>, <span class="keyword">this</span>); <span class="comment">// &#123;value: 'chendapepeng'&#125; 指向foo</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar函数--this.value'</span>, <span class="keyword">this</span>.value);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value: <span class="keyword">this</span>.value,</span><br><span class="line">    name,</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  value: <span class="string">'cpp'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以最终版的就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mockCall: <span class="function"><span class="keyword">function</span> (<span class="params">con, ...args</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> context = con || <span class="built_in">window</span>;</span><br><span class="line">   <span class="comment">// 首先获取调用call的函数，比如bar.call(foo),就是bar函数</span></span><br><span class="line">   context.fn = <span class="keyword">this</span>;</span><br><span class="line">   <span class="keyword">const</span> res = context.fn(...args)</span><br><span class="line">   <span class="comment">// 用完记得删除调用对象里的方法</span></span><br><span class="line">   <span class="keyword">delete</span> context.fn</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><h3 id="bind实现"><a href="#bind实现" class="headerlink" title="bind实现"></a>bind实现</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 模拟bind</span></span><br><span class="line"><span class="comment"> * @param this 调用的方法</span></span><br><span class="line"><span class="comment"> * @param con 当前调用者，对象</span></span><br><span class="line"><span class="comment"> * @param args </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mockBind = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, con: <span class="built_in">any</span>, ...args: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log('mock__this', this);</span></span><br><span class="line">  <span class="comment">// console.log('mock__con', con);</span></span><br><span class="line">  <span class="keyword">const</span> context = con || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> fbound = <span class="function">(<span class="params">...bindArgs: <span class="built_in">any</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log('context', context);</span></span><br><span class="line">    self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> self ? <span class="keyword">this</span> : context, [...args, ...bindArgs])</span><br><span class="line">  &#125;</span><br><span class="line">  fbound.prototype = <span class="keyword">this</span>.prototype</span><br><span class="line">  <span class="keyword">return</span> fbound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue手动挂载组件"><a href="#Vue手动挂载组件" class="headerlink" title="Vue手动挂载组件"></a>Vue手动挂载组件</h2><p>本文主要有以下内容</p><ul><li><em>Vue.extend()</em></li><li><em>单例模式</em></li><li><em>Vue.use() 和 Vue.prototype.myFunction</em></li></ul><h3 id="挂载组件步骤"><a href="#挂载组件步骤" class="headerlink" title="挂载组件步骤"></a>挂载组件步骤</h3><p>在一些需求中，手动挂载组件能够让我们实现起来更加优雅。比如一个弹窗组件，最理想的用法是通过命令式调用，就像 elementUI 的 this.$message</p><h4 id="vue-extend"><a href="#vue-extend" class="headerlink" title="vue.extend()"></a>vue.extend()</h4><p>使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。预设了部分选项的vue实例构造器，返回一个组件构造器，用来生成组件，可以在实例上扩展方法，从而使用更灵活</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 创建构造器</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> Profile = Vue.extend(&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: '<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123;firstName&#125;&#125;</span><span class="xml"> </span><span class="template-variable">&#123;&#123;lastName&#125;&#125;</span><span class="xml"> aka </span><span class="template-variable">&#123;&#123;alias&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span>',</span></span></span><br><span class="line"><span class="actionscript">    data: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        firstName: <span class="string">'Walter'</span>,</span></span><br><span class="line"><span class="actionscript">        lastName: <span class="string">'White'</span>,</span></span><br><span class="line"><span class="actionscript">        alias: <span class="string">'Heisenberg'</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="actionscript">  <span class="comment">// 创建 Profile 实例，并挂载到一个app元素上。</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">new</span> Profile().$mount(<span class="string">'#app'</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Walter White aka Heisenberg<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Vue.extend创建的是一个Vue组件构造器，而不是一个具体的组件实例；里面预设了很多vue实例选项</p></blockquote><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>先看一个简单的例子<code>getSingle</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Anima: any = <span class="function"><span class="keyword">function</span>(<span class="params">this: any, name: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> AnimalSingle: any = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> instance: any = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">name: string</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">      <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">return</span> instance = <span class="keyword">new</span> Anima(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> AnimalSingle(<span class="string">'cat'</span>)</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="keyword">new</span> AnimalSingle(<span class="string">'dog'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'==='</span>, a1, a2, a1 === a2); <span class="comment">// Anima&#123;name: 'cat'&#125; Anima&#123;name: 'cat'&#125; true</span></span><br></pre></td></tr></table></figure><ul><li>使用闭包封装了instance私有变量并返回一个函数</li><li>利用 || 语法判断如果instance不存在则执行后者的实例化Anima方法，存在则直接返回instance，确保了只存在一个弹框实例<br>实现方式：使用一个变量存储类实例对象（值初始为 null/undefined ）。进行类实例化时，判断类实例对象是否存在，存在则返回该实例，不存在则创建类实例后返回。多次调用类生成实例方法，返回同一个实例对象。</li></ul><h3 id="构建属于自己的封装组件"><a href="#构建属于自己的封装组件" class="headerlink" title="构建属于自己的封装组件"></a>构建属于自己的封装组件</h3><p>用法，首先<em>main.ts</em>中全局引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Toast <span class="keyword">from</span> <span class="string">'./components/Toast/index'</span>;</span><br><span class="line"><span class="comment">// vue.use注册</span></span><br><span class="line"><span class="comment">// Vue.use(Toast);</span></span><br><span class="line">Vue.prototype.$toast = Toast;</span><br></pre></td></tr></table></figure><p>具体的组件用法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private showSuccess() &#123;</span><br><span class="line">  (<span class="keyword">this</span> <span class="keyword">as</span> any).$toast.success(&#123;</span><br><span class="line">    type: <span class="string">'success'</span>,</span><br><span class="line">    content: <span class="string">'这是测试tosat11'</span>,</span><br><span class="line">    duration: <span class="number">2000</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看看如何实现的，主要思路是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> toast <span class="keyword">from</span> <span class="string">'./toast.vue'</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="comment">// Vue.extend()生成一个Vue组件构造器函数，需要new一个实例才行</span></span><br><span class="line"><span class="keyword">const</span> ToastConstructor = Vue.extend(toast);</span><br><span class="line"><span class="keyword">let</span> instance: any = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> Toast: any = <span class="function">(<span class="params">options: any</span>) =&gt;</span> &#123;</span><br><span class="line">  instance = <span class="keyword">new</span> ToastConstructor(&#123;</span><br><span class="line">    data: options</span><br><span class="line">  &#125;).$mount();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'instance'</span>, instance); <span class="comment">// vueCopmponent vue组件实例</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(instance.$el)</span><br><span class="line">&#125;</span><br><span class="line">[<span class="string">'success'</span>, <span class="string">'error'</span>, <span class="string">'info'</span>].forEach(<span class="function">(<span class="params">type: any</span>) =&gt;</span> &#123;</span><br><span class="line">  Toast[type] = <span class="function">(<span class="params">options: any</span>) =&gt;</span> &#123;</span><br><span class="line">    options.type = type;</span><br><span class="line">    <span class="keyword">return</span> Toast(options);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Toast</span><br></pre></td></tr></table></figure><p>如果想在main.ts中Vue.use()引入的话，导出一个传递参数的<code>install</code>方法即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'success'</span>, <span class="string">'error'</span>, <span class="string">'info'</span>].forEach(<span class="function">(<span class="params">type: any</span>) =&gt;</span> &#123;</span><br><span class="line">  Toast[type] = <span class="function">(<span class="params">options: any</span>) =&gt;</span> &#123;</span><br><span class="line">    options.type = type;</span><br><span class="line">    <span class="keyword">return</span> Toast(options);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">...(上面的都一样，只需暴露一个install方法)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install: <span class="function">(<span class="params">vue</span>) =&gt;</span> &#123;</span><br><span class="line">    vue.prototype.$toast = Toast</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在main.ts中直接引入即可</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Toast <span class="keyword">from</span> <span class="string">'./components/Toast'</span></span><br><span class="line">Vue.use(Toast)</span><br></pre></td></tr></table></figure><p>为啥需要用use才能用，源码看了下，在GlobalAPI下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initUse</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// toast导出的是funtion类型</span></span><br><span class="line">  Vue.use = <span class="function"><span class="keyword">function</span> (<span class="params">plugin: <span class="built_in">Function</span> | <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> installedPlugins = (<span class="keyword">this</span>._installedPlugins || (<span class="keyword">this</span>._installedPlugins = []))</span><br><span class="line">    <span class="comment">// 判断当前的插件是否在installedPlugins集合里，如果有立马返回</span></span><br><span class="line">    <span class="comment">// 解释了多次使用Vue.use()只会运行一次</span></span><br><span class="line">    <span class="keyword">if</span> (installedPlugins.indexOf(plugin) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// additional parameters 额外的参数，像options</span></span><br><span class="line">    <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    args.unshift(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 如果插件有install，则绑定到plugin,并全传参</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin.install === <span class="string">'function'</span>) &#123;</span><br><span class="line">      plugin.install.apply(plugin, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">'function'</span>) &#123;</span><br><span class="line">      plugin.apply(<span class="literal">null</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    installedPlugins.push(plugin)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert an Array-like object to a real Array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toArray</span> (<span class="params">list, start</span>) </span>&#123;</span><br><span class="line">  start = start || <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> i = list.length - start;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="keyword">new</span> <span class="built_in">Array</span>(i);</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    ret[i] = list[i + start];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Vue.use(plugin)和Vue.prototype.$plugin = Plugin的区别<br>Vue.use(): 插件必须是一个对象，拥有install方法的对象，初始化插件必须有Vue.use()引入。同一个插件多次使用Vue.use()也只会运行一次。且vue.use()必须在new Vue()之前使用。<br>Vue.prototype.$plugin = Plugin: 在Vue组件构造器函数的原型上增加一个方法，运用的是函数原型的特性，即函数原型上的属性和方法，实例都能共享</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p> 与变量解构结合，并隐式返回<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Test1 = <span class="function">(<span class="params">&#123;value, num&#125;: any</span>) =&gt;</span> (&#123;<span class="attr">total</span>: value * num&#125;)</span><br><span class="line"><span class="keyword">const</span> res = Test1(&#123;</span><br><span class="line">  value: <span class="number">100</span>,</span><br><span class="line">  num: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'res'</span>, res);</span><br></pre></td></tr></table></figure><br> 与普通函数的区别</p><h3 id="没有this"><a href="#没有this" class="headerlink" title="没有this"></a>没有this</h3><p>箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值。因为箭头函数没有 this，所以也不能用 call()、apply()、bind() 这些方法改变 this 的指向</p><h3 id="没有arguments"><a href="#没有arguments" class="headerlink" title="没有arguments"></a>没有arguments</h3><p>但命名参数或者 rest 参数的形式访问参数:</p><h3 id="不能通过-new-关键字调用"><a href="#不能通过-new-关键字调用" class="headerlink" title="不能通过 new 关键字调用"></a>不能通过 new 关键字调用</h3><p>当通过 new 调用函数时，执行 <code>[[Construct]]</code> 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上。<br>箭头函数并没有 <code>[[Construct]]</code>方法，不能被用作构造函数，如果通过 new 的方式调用，会报错。<br>于是箭头函数也不存在 prototype 这个属性。</p><h3 id="无new-target"><a href="#无new-target" class="headerlink" title="无new.target"></a>无new.target</h3><p>因为不能使用 new 调用，所以也没有 new.target 值</p><h3 id="哪些场景下不能使用箭头函数"><a href="#哪些场景下不能使用箭头函数" class="headerlink" title="哪些场景下不能使用箭头函数"></a>哪些场景下不能使用箭头函数</h3><p>借鉴知乎大佬王仕军的文章，原文请移步<a href="https://zhuanlan.zhihu.com/p/26540168" target="_blank" rel="noopener">什么时候你不能使用箭头函数？</a></p><h4 id="定义对象里的方法"><a href="#定义对象里的方法" class="headerlink" title="定义对象里的方法"></a>定义对象里的方法</h4><p>在一个对象上，定义一个指向函数的属性，当方法被调用时，方法内的this指向方法所属的对象</p><ul><li><p>定义字面量方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calculator = &#123;</span><br><span class="line">  array: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  sum: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// =&gt; true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.array.reduce(<span class="function">(<span class="params">result, item</span>) =&gt;</span> result + item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="comment">// Throws "TypeError: Cannot read property 'reduce' of undefined"</span></span><br><span class="line">calculator.sum();</span><br></pre></td></tr></table></figure><p>calculator.sum 使用箭头函数来定义，但是调用的时候会抛出 TypeError，因为运行时 this.array 是未定义的，调用 calculator.sum 的时候，执行上下文里面的 this 仍然指向的是 window，原因是箭头函数把函数上下文绑定到了 window 上，this.array 等价于 window.array，显然后者是未定义的。<br>改造普通函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calculator = &#123;</span><br><span class="line">    array: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    sum() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === calculator); <span class="comment">// =&gt; true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.array.reduce(<span class="function">(<span class="params">result, item</span>) =&gt;</span> result + item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">calculator.sum(); <span class="comment">// =&gt; 6</span></span><br></pre></td></tr></table></figure></li><li><p>定义原型方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">any</span>, game: <span class="built_in">string</span> = 'cf'</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.habits = game</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.age = <span class="number">30</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'sayName: i am'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.person1 = <span class="keyword">new</span> (Person <span class="keyword">as</span> <span class="built_in">any</span>)(<span class="string">'cpp'</span>)</span><br></pre></td></tr></table></figure><p>使用传统的函数表达式就能解决问题</p></li></ul><h4 id="定义事件回调函数"><a href="#定义事件回调函数" class="headerlink" title="定义事件回调函数"></a>定义事件回调函数</h4><p>this 是 JS 中很强大的特性，可以通过多种方式改变函数执行上下文，JS 内部也有几种不同的默认上下文指向，但普适的规则是在谁上面调用函数 this 就指向谁，这样代码理解起来也很自然，读起来就像在说，某个对象上正在发生某件事情。</p><p>但是，箭头函数在声明的时候就绑定了执行上下文，要动态改变上下文是不可能的，在需要动态上下文的时候它的弊端就凸显出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'myButton'</span>);</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// =&gt; true</span></span><br><span class="line">    <span class="keyword">this</span>.innerHTML = <span class="string">'Clicked button'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>修正后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'myButton'</span>);</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === button); <span class="comment">// =&gt; true</span></span><br><span class="line">    <span class="keyword">this</span>.innerHTML = <span class="string">'Clicked button'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="定义构造函数"><a href="#定义构造函数" class="headerlink" title="定义构造函数"></a>定义构造函数</h4><p>构造新的 Person 实例时，JS 引擎抛了错误,tslint也直接给出了提示<code>An arrow function cannot have a &#39;this&#39; parameter</code>,还有<code>Property &#39;name&#39; does not exist on type &#39;Home&#39;</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person =  <span class="function">(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">any</span>, game: <span class="built_in">string</span> = 'cf'</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.habits = game</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.age = <span class="number">30</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'sayName: i am'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.person1 = <span class="keyword">new</span> (Person <span class="keyword">as</span> <span class="built_in">any</span>)(<span class="string">'cpp'</span>)</span><br></pre></td></tr></table></figure><p>改成普通函数即可</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="借助原型链实现继承"><a href="#借助原型链实现继承" class="headerlink" title="借助原型链实现继承"></a>借助原型链实现继承</h3><p>子类Child的原型属性等价于父类的一个实例，并且传参</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> extendPrototype() &#123;</span><br><span class="line">  <span class="keyword">const</span> Parent: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> Child: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//重点在这句 子类的原型指向的父类的实例</span></span><br><span class="line">  Child.prototype = <span class="keyword">new</span> Parent(<span class="string">'chendapeng'</span>)</span><br><span class="line">  <span class="keyword">const</span> p1 = <span class="keyword">new</span> Parent(<span class="string">'wmh'</span>);</span><br><span class="line">  <span class="keyword">const</span> c1 = <span class="keyword">new</span> Child(<span class="string">'cpp'</span>, <span class="number">30</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1,'</span>, p1);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'c1,'</span>, c1);</span><br><span class="line">  p1.sayName() <span class="comment">// wmh ——this.name——</span></span><br><span class="line">  c1.sayName() <span class="comment">// chendapeng ——this.name——</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类能继承父类的属性和方法<br>缺点:</p><ul><li>创建child类的时候，不能像Parent传参</li><li>子类创建的实例所在的原型链上的属性共享<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private extendPrototype() &#123;</span><br><span class="line">  <span class="keyword">const</span> Parent: any = <span class="function"><span class="keyword">function</span>(<span class="params">this: any, name: string, arr: any</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.arr = arr</span><br><span class="line">  &#125;</span><br><span class="line">  Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="string">'——this.name——'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> Child: any = <span class="function"><span class="keyword">function</span> (<span class="params">this: any, name: string, age: number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  Child.prototype = <span class="keyword">new</span> Parent(<span class="string">'chendapeng'</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">  <span class="keyword">const</span> p1 = <span class="keyword">new</span> Parent(<span class="string">'wmh'</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">  <span class="keyword">const</span> c1 = <span class="keyword">new</span> Child(<span class="string">'cpp'</span>, <span class="number">30</span>);</span><br><span class="line">  c1.arr.push(<span class="number">4</span>)</span><br><span class="line">  <span class="keyword">const</span> c2 = <span class="keyword">new</span> Child(<span class="string">'pp'</span>, <span class="number">99</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1,'</span>, p1.arr); [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'c1,'</span>, c1.arr); <span class="comment">// [1,2,3,4]</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'c2,'</span>, c2.arr); <span class="comment">// [1,2,3,4]</span></span><br><span class="line">  <span class="comment">// p1.sayName() // wmh ——this.name——</span></span><br><span class="line">  <span class="comment">// c1.sayName() // c1.sayName is not a function</span></span><br><span class="line">&#125;</span><br><span class="line">子类实例c1和c2上的arr属性都是从父类继承过来的，改了c1.arr属性,c2.arr也发生了变化</span><br></pre></td></tr></table></figure><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A= &#123;<span class="attr">n</span>: <span class="number">4399</span>&#125;</span><br><span class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">this</span>.n = <span class="number">9999</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> C = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">var</span> n = <span class="number">8888</span>&#125;;</span><br><span class="line">B.prototype = A;</span><br><span class="line">C.prototype = A</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B()</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> C()</span><br><span class="line">A.n ++;</span><br><span class="line"><span class="built_in">console</span>.log(b.n) <span class="comment">// 9999</span></span><br><span class="line"><span class="built_in">console</span>.log(c.n) <span class="comment">// 4400</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="借助构造函数继承-经典继承"><a href="#借助构造函数继承-经典继承" class="headerlink" title="借助构造函数继承(经典继承)"></a>借助构造函数继承(经典继承)</h3><p>先看代码，Parent 是父类，Child 是子类。通过 Parent1.call(this, name)  改变了 this 指向，使子类继承了父类的属性，即 Child 也有了 name 属性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> extendConstructor() &#123;</span><br><span class="line">  <span class="keyword">const</span> Parent: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="string">'——this.name——'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> Child: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="comment">// 这里是重点</span></span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> p1 = <span class="keyword">new</span> Parent(<span class="string">'wmh'</span>);</span><br><span class="line">  <span class="keyword">const</span> c1 = <span class="keyword">new</span> Child(<span class="string">'cpp'</span>, <span class="number">30</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1,'</span>, p1);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'c1,'</span>, c1);</span><br><span class="line">  p1.sayName() <span class="comment">// wmh ——this.name——</span></span><br><span class="line">  c1.sayName() <span class="comment">// c1.sayName is not a function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点</p><ul><li>这种方式不能继承父类原型链上的属性，只能继承在父类显式声明的属性</li><li>方法都在构造函数中定义，每次创建实例都会创建一遍方法。</li></ul><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> extendTwo() &#123;</span><br><span class="line">   <span class="keyword">const</span> Parent: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.name = name</span><br><span class="line">     <span class="keyword">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   &#125;</span><br><span class="line">   Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="string">'——this.name——'</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">const</span> Child: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">     Parent.call(<span class="keyword">this</span>, name)</span><br><span class="line">     <span class="keyword">this</span>.age = age</span><br><span class="line">   &#125;</span><br><span class="line">   Child.prototype = <span class="keyword">new</span> Parent(<span class="string">'cpp'</span>)</span><br><span class="line">   <span class="keyword">const</span> c1 = <span class="keyword">new</span> Child(<span class="string">'wmh'</span>, <span class="number">22</span>);</span><br><span class="line">   c1.arr.push(<span class="number">5</span>)  </span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'c1'</span>, c1); <span class="comment">// [1,2,3, 5]</span></span><br><span class="line">   <span class="keyword">const</span> c2 = <span class="keyword">new</span> Child(<span class="string">'cpp'</span>, <span class="number">30</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'c2'</span>, c2); <span class="comment">// [1,2,3,</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p> ES5 <code>Object.create()</code> 的模拟实现，将传入的对象作为创建的对象的原型。根据自己的业务需求，定义自己的原型对象。<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">funtion createObj(o) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 测试下<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(&#123;<span class="attr">name</span>: <span class="string">'cpp'</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// name属性放在了首层下的__proto__属性上，</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> &#123;&#125;</span></span><br><span class="line"><span class="comment"> __proto__:</span></span><br><span class="line"><span class="comment">  name: 'cpp'</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">接着用 createObj测试</span><br><span class="line"><span class="keyword">var</span> b = createObj(&#123;<span class="attr">name</span>: <span class="string">'cpp'</span>&#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> &#123;&#125;</span></span><br><span class="line"><span class="comment"> __proto__:</span></span><br><span class="line"><span class="comment">  name: 'cpp'</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1)</span><br></pre></td></tr></table></figure><p>组合继承最大的缺点就是会两次调用父构造函数，<br>一次是子类型实例的原型的时候</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure><p>另外一次是创建子类型的实例的时候</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br></pre></td></tr></table></figure><p>如何避免一次重复调用呢</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line">Child.prototype.constructor = Child</span><br></pre></td></tr></table></figure><p>最后实现寄生组合继承如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child.prototype = new Parent();</span></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1)</span><br></pre></td></tr></table></figure><blockquote><p><strong>proto</strong>是隐式原型，prototype是显式原型</p></blockquote><h3 id="原型总结"><a href="#原型总结" class="headerlink" title="原型总结"></a>原型总结</h3><p>每个对象都有一个隐式原型，指向该对象的原型。实例化后通过<strong>proto</strong>属性指向构造函数的显式原型prototype,原型链是由原型对象组成，每个对象都有<strong>proto</strong>属性，指向创建该对象的构造函数的原型，通过隐式原型<strong>proto</strong>属性将对象链起来，组成原型链，用来实现属性继承和共享属性</p><h3 id="参考文件"><a href="#参考文件" class="headerlink" title="参考文件"></a>参考文件</h3><ul><li><a href="https://segmentfault.com/a/1190000009389979" target="_blank" rel="noopener">JavaScript深入之继承的多种方式和优缺点</a></li><li><a href="http://louiszhai.github.io/2015/12/15/prototypeChain/#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">详解JS原型链与继承</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> vue </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My First blog</title>
      <link href="/2020/07/05/My-First-blog/"/>
      <url>/2020/07/05/My-First-blog/</url>
      
        <content type="html"><![CDATA[<p>  感谢<a href="https://jerryc.me/posts/21cfbf15/" target="_blank" rel="noopener">Butterfly</a>提供的技术支持,希望自己也能参与到其，<br>  Jerryc个人博客有各种关于主题色彩的设置，<a href="https://demo.jerryc.me/posts/ceeb73f/#CDN" target="_blank" rel="noopener">请移步</a></p><p>  从去年五一到今年五一，365天，从最基础的class到后面的ts我感觉自己是在进步，前面三年，基本上是在混日子，业务需求太多，没时间提升自己，进入一种死循环，从去年五月开始，进行改变，开始学习最基本的js常识，练基本功，promise/async/bind手写等，到后面的前端内功也就是算法和数据结构。但仅仅是学习，还不够，很多东西还没有深入，稍微深一点说就完蛋，所以2021五一期间，重点关注vue diff核心算法，有时间就补补ts/http/axios等等</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/07/05/hello-world/"/>
      <url>/2020/07/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
