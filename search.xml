<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Bootstrap-Three:下拉菜单、导航、分页]]></title>
      <url>%2F2017%2F02%2F18%2FBootstrap-%E4%BA%8C-%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95%E3%80%81%E5%AF%BC%E8%88%AA%E3%80%81%E5%88%86%E9%A1%B5%2F</url>
      <content type="text"><![CDATA[一鼓作气，再而衰，三而竭 dropdown 下拉菜单：3个元素，1.父级元素添加class为”dropdown” 2.给button添加动态交互的自定义属性：data-toggle=”dropdown” 3.ul需要添加class为”dropdown-menu” 12345678910111213&lt;div class=&quot;dropdown&quot;&gt; &lt;button class=&quot;btn btn-default dropdown-toggle&quot; type=&quot;button&quot; id=&quot;dropdownMenu1&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;true&quot;&gt; Dropdown &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot; aria-labelledby=&quot;dropdownMenu1&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 下拉菜单样式1.父级元素添加class为”open”，默认展开2.默认左对齐，右对齐则为btn=”btn-blcok”,同时ul的class=”dropdown-menu-right”3.li的标题突出。class=”dropdown-header”4.分割线，给li添加class属性”divider”，内容居中用text-center input 输入框组：1.input-group :输入框组，只针对输入框 2.input-group-addon:给输入框组前后添加额外的元素 3.input-group-btn:给输入框添加的额外元素是按钮 4.给外层添加class为”input-group-btn”的包裹元素div,可以得到按钮组式的输入框组。不需要给父级元素添加class为”dropdown”12345678910111213&lt;div class=&quot;col-lg-3&quot;&gt; &lt;div class=&quot;input-group&quot;&gt; &lt;div class=&quot;input-group-btn&quot;&gt; &lt;button class=&quot;btn btn-info dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; type=&quot;button&quot;&gt;NIMa&lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;&lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot; title=&quot;&quot;&gt;action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot; title=&quot;&quot;&gt;action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot; title=&quot;&quot;&gt;action&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;按钮上输入框&quot;/&gt; &lt;/div&gt; &lt;/div&gt; imgimg的class为img-rounded(圆角图)、img-circle(圆图)、img-thumbnail(缩略图)、img-responsive(响应式图片)12345&lt;img src=&quot;img/map.jpg&quot; usemap=&quot;#planetmap&quot; alt=&quot;&quot;/&gt;&lt;map name=&quot;planetmap&quot;&gt; &lt;area shape=&quot;rect&quot; coords=&quot;510,240,660,300&quot; style=&quot;border:1px solid black&quot; href=&quot;index2.html&quot;/&gt; &lt;area shape=&quot;rect&quot; coords=&quot;900,240,1100,300&quot; style=&quot;border:1px solid black&quot; href=&quot;index2.html&quot;/&gt;&lt;/map&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Css特效：translate3d悬浮特效]]></title>
      <url>%2F2017%2F02%2F18%2Fcss%E7%89%B9%E6%95%88%EF%BC%9Atranslate3d%E6%82%AC%E6%B5%AE%E7%89%B9%E6%95%88%2F</url>
      <content type="text"><![CDATA[学习如逆水行舟，不进则退 感觉每天如果不做笔记，自己要垮掉！学习是持久的事，不能只靠一时的激情来完成，其实，我大体也能感觉得到真正从事web前端后，工作压力肯定是非常大的！ perspectiveperspective: 500;perspective 属性定义 3D 元素距视图的距离，以像素计。该属性允许您改变 3D 元素查看 3D 元素的视图。 transform-styletransform-style:preserve-3d;使被转换的子元素保留其 3D 转换,当值为flat时，子元素将不保留其 3D 位置。 transform: translate3d(x,y,z)transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。 Css部分1234567*&#123;margin: 0; padding: 0;&#125;ul,li&#123;list-style: none;&#125;.container&#123;perspective: 1300;-webkit-perspective:1300;&#125;.boxList&#123;position:absolute;width: 630px;height:630px;left:50%;margin-left:-315px; -webkit-transform-style: preserve-3d;transform-style: preserve-3d;/*animation: a1 2s 1;*/transition: all 2s;&#125;.boxList li&#123;float: left;width: 200px;height: 200px;margin:5px;background: darkcyan;-webkit-transition: all 0.3s;transition: all 0.3s;&#125;.on li:hover&#123;-webkit-transform: translate3d(0,10px,50px);transform: translate3d(0,10px,50px);background:deepskyblue;box-shadow: 30px 30px 10px rgba(0, 0, 0, 0.5);&#125;.on&#123;-webkit-transform: rotateX(55deg) rotateY(0deg) rotateZ(35deg);transform: rotateX(55deg) rotateY(0deg) rotateZ(35deg);&#125; Js部分12345678var list=document.querySelector(&apos;.boxList&apos;); window.onload=function()&#123; setInterval(transition,1000) &#125; function transition()&#123; list.className=&apos;on boxList&apos;; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[myHeart：我心永恒]]></title>
      <url>%2F2017%2F02%2F14%2FmyHeart%EF%BC%9A%E6%88%91%E5%BF%83%E6%B0%B8%E6%81%92%2F</url>
      <content type="text"><![CDATA[今天是情人节，微信/微博都在撒狗粮，看看myHeart吧 源代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;情人节心跳动动画&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; html, body&#123; width: 100%; height: 100%; min-width: 500px; min-height: 500px; overflow: hidden; &#125; .heart &#123; position: absolute; width: 100px; height: 90px; top: 50%; left: 50%; margin-top: -45px; margin-left: -50px; &#125; .heart:before, .heart:after &#123; position: absolute; content: &quot;&quot;; left: 50px; top: 0; width: 50px; height: 80px; background: #fc2e5a; border-radius: 50px 50px 0 0; transform: rotate(-45deg); transform-origin: 0 100%; &#125; .heart:after &#123; left: 0; transform: rotate(45deg); transform-origin :100% 100%; &#125; .heart1&#123; animation: heart-anim 1s linear .4s infinite; &#125; .heart2&#123; animation: pounding .5s linear infinite alternate; &#125; .heart1:after, .heart1:before&#123; background-color: #ff7693; &#125; @keyframes pounding&#123; 0%&#123; transform: scale(1.5); &#125; 100%&#123; transform: scale(1); &#125; &#125; @-moz-keyframes pounding&#123; 0%&#123; transform: scale(1.5); &#125; 100%&#123; transform: scale(1); &#125; &#125; @-webkit-keyframes pounding&#123; 0%&#123; transform: scale(1.5); &#125; 100%&#123; transform: scale(1); &#125; &#125; @-ms-keyframes pounding&#123; 0%&#123; transform: scale(1.5); &#125; 100%&#123; transform: scale(1); &#125; &#125; @keyframes heart-anim &#123; 46% &#123; transform: scale(1); &#125; 50% &#123; transform: scale(1.3); &#125; 52% &#123; transform: scale(1.5); &#125; 55% &#123; transform: scale(3); &#125; 100% &#123; opacity: 0; transform: scale(50); &#125; &#125; @-moz-keyframes heart-anim &#123; 46% &#123; transform: scale(1); &#125; 50% &#123; transform: scale(1.3); &#125; 52% &#123; transform: scale(1.5); &#125; 55% &#123; transform: scale(3); &#125; 100% &#123; opacity: 0; transform: scale(50); &#125; &#125; @-webkit-keyframes heart-anim &#123; 46% &#123; transform: scale(1); &#125; 50% &#123; transform: scale(1.3); &#125; 52% &#123; transform: scale(1.5); &#125; 55% &#123; transform: scale(3); &#125; 100% &#123; opacity: 0; transform: scale(50); &#125; &#125; @-ms-keyframes heart-anim &#123; 46% &#123; transform: scale(1); &#125; 50% &#123; transform: scale(1.3); &#125; 52% &#123; transform: scale(1.5); &#125; 55% &#123; transform: scale(3); &#125; 100% &#123; opacity: 0; transform: scale(50); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img scr=&quot;http://ojjsl7zpc.bkt.clouddn.com/myHeart.gif?e=1487091193&amp;token=NUT82f__mRq-ZGvkrbqw7Zxle80aB7nUArvrHibz:nDhjIQhcA5hcRQ-bZFh3skYsOls&quot; alt=&quot;niaogege-myHeart&quot; /&gt; &lt;p&gt; 情人节又到了，一大波男士在狠狠地吃狗粮！！ &lt;/p&gt; &lt;!--外圈大心--&gt; &lt;div class=&quot;heart heart1&quot;&gt;&lt;/div&gt; &lt;!--里面小心--&gt; &lt;div class=&quot;heart heart2&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery:常用的jQuery效果]]></title>
      <url>%2F2017%2F02%2F14%2FjQuery-%E5%B8%B8%E7%94%A8%E7%9A%84jQuery%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[“给我一个支点，我可以翘起整个世界”——阿基米德今天又面试了一家互联网公司，是做互联网在线教育的，很荣幸收到offer，我应聘的是web前端开发工程师这个岗位，到公司主要做静态页面制作以及一些跟后端数据的绑定和交互。真的十分感谢吴大哥和COO，你们都是我人生路上的贵人，我定不会辜负两位领导所托，一定加强自身的技术，为公司带来实质性的贡献。 淘宝网站的搜索框显示和隐藏效果12345678window.onscroll = function()&#123; var t = document.documentElement.scrollTop || document.body.scrollTop; //页面下拉时的数据 if(t&gt;80)&#123; //当页面下拉到大于80的时候显示下的DIV,默认是隐藏的。 $(&quot;.fdnav&quot;).css(&#123;display:&quot;block&quot;&#125;); &#125;else&#123; $(&quot;.fdnav&quot;).css(&#123;display:&quot;none&quot;&#125;); &#125;&#125; 网站侧边导航条伸缩效果的运用用到了mouseover事件和mouseleave事件，其实这里有个问题是往右移还是往左移，具体得实践实践，今天先放上代码，明天实践一下12345678$(document).ready(function()&#123; $(&quot;.wsde&quot;).mouseover(function()&#123;//class为wsde的默认css是:position: fixed; right: 1px; width:57px; overflow: hidden; $(&quot;.wsde&quot;).stop().animate(&#123;&apos;width&apos;:&apos;200px&apos;&#125;); &#125;); $(&quot;.wsde&quot;).mouseleave(function()&#123; $(&quot;.wsde&quot;).stop().animate(&#123;&apos;width&apos;:&apos;57px&apos;&#125;); &#125;); &#125;); 网站图片预加载Jquery教程效果一块是HTML代码，主要用到的是h5最新定义的自带属性，以data开头1&lt;img src=&quot;logo.png//默认图&quot; data=&quot;bg.png//最终的图片来源&quot;&gt; jQuery示例代码 12345678910111213141516171819$(&apos;img[data]&apos;).load(function()&#123;//运行Jquery库中的默认类 var __this = $(this); var url = __this.attr(&apos;data&apos;); var src = __this.attr(&apos;src&apos;); if(url ==&quot; &quot;|| url == src)//这里判断如果图片实际地址不存在或者已经加载不处理 &#123; return; &#125; var img =new Image();//实例化一个图片的对象，这里的Image居然也是引用数据类型 img.src = url;//将要显示的图片加载进来 if(img.complete)//如果图片已经加载存在浏览器缓存中直接处理, complete 属性来讲，IE是根据图片是否显示过来判断，就是说当加载的图片显示出来后，complete 属性的值才为 true ，否则一直是 false ，和以前是否加载过该张图片没有关系 &#123; __this.attr(&apos;src&apos;,url);//将要显示的图片替换过来 return; &#125; img.onload =function()&#123;//要显示的图片加载完成后做处理 __this.attr(&apos;src&apos;,url); //attr(&apos;src&apos;,url); &#125; &#125;); 自动验证提交表单的Jqeury效果网站上的select下拉菜单（二级select）美化体验Jquery效果:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//select下拉菜单html部分示例代码： &lt;div class=&quot;kscz1_1&quot;&gt;请选择游戏&lt;/div&gt; &lt;div class=&quot;kscz1_2&quot;&gt;请选择面值&lt;/div&gt; &lt;div class=&quot;kscz1_3&quot;&gt; &lt;form class=&quot;woqu&quot; action=&quot;/e/search/index.php&quot; method=&quot;post&quot; onSubmit=&quot;return checkSubmit();&quot;&gt; &lt;input id=&quot;proid&quot; type=&quot;hidden&quot; name=&quot;proid&quot; value=&quot;&quot;&gt; &lt;input id=&quot;price&quot; type=&quot;hidden&quot; name=&quot;price&quot; value=&quot;&quot;&gt; &lt;input type=&quot;submit&quot; class=&quot;dianji&quot; value=&quot;&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=&quot;kscz1_1se&quot; &gt; &lt;ul id=&quot;kscz1_1se&quot;&gt; &lt;li price=&quot;50,20&quot; proid=&quot;5&quot;&gt;大专自卫队苛夺&lt;/li&gt; //price中的为select二级选项 &lt;li price=&quot;70,50,30&quot; proid=&quot;33&quot;&gt;磊地在傜&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;kscz1_1pri&quot; &gt; &lt;ul id=&quot;kscz1_1pri&quot;&gt; &lt;/ul&gt; &lt;/div&gt; &lt;form class=&quot;woqu&quot; action=&quot;&quot; method=&quot;post&quot; onSubmit=&quot;return checkSubmit();&quot;&gt; &lt;input id=&quot;proid&quot; type=&quot;hidden&quot; name=&quot;proid&quot; value=&quot;&quot;&gt; &lt;input id=&quot;price&quot; type=&quot;hidden&quot; name=&quot;price&quot; value=&quot;&quot;&gt; &lt;input type=&quot;submit&quot; class=&quot;dianji&quot; value=&quot;&quot;&gt; &lt;/form&gt;主要CSS样式，过其实的都不写出来了，这是两个隐藏的下拉表div样式：.kscz1_1se &#123;overflow: hidden;width: 214px;height: 330px;position: absolute;border: 1px solid #E0E0E0;left: 50%;top: 0;z-index: 1000;display: none;&#125;.kscz1_1pri &#123;overflow: hidden;width: 94px;height: 130px;position: absolute;border: 1px solid #E0E0E0;left: 50%;top: 0;z-index: 1000;display: none;&#125;//select下拉菜单Jquery部分代码：&lt;script&gt;$(document).ready(function()&#123;$(&quot;.kscz1_1&quot;).mouseover(function()&#123;//鼠标移到select上显下拉效果$(&quot;.kscz1_1se&quot;).css(&#123;display:&apos;block&apos;&#125;);$(&quot;#kscz1_1se&quot;).css(&#123;display:&apos;block&apos;&#125;); &#125;);$(&quot;.kscz1_1se&quot;).mouseleave(function()&#123;//鼠标移出为隐藏下效果$(this).css(&#123;display:&apos;none&apos;&#125;);$(this).find(&quot;#kscz1_1se&quot;).css(&#123;display:&apos;none&apos;&#125;); &#125;);$(&quot;.kscz1_1se li&quot;).mousedown(function()&#123;//选择下拉中的一个选项，进行赋值，并对第二项下拉增加内容var value = $(this).attr(&quot;price&quot;); var value2 = $(this).text(); var value3 = $(this).attr(&quot;proid&quot;);var pricetext=&apos;&apos;;pricenum = value.split(&quot;,&quot;);for(var i=0;i&lt;pricenum.length;i++)&#123;pricetext=pricetext+&apos;&lt;li&gt;&apos;+pricenum[i]+&apos;&lt;/li&gt;&apos;;&#125;$(&quot;.kscz1_1&quot;).html(value2);$(&quot;.kscz1_1se&quot;).css(&#123;display:&apos;none&apos;&#125;);$(&quot;.kscz1_1se&quot;).find(&quot;#kscz1_1se&quot;).css(&#123;display:&apos;none&apos;&#125;);$(&quot;#kscz1_1pri&quot;).html(pricetext);$(&quot;.kscz1_2&quot;).html(&apos;请选择面值&apos;);$(&quot;#proid&quot;).val(value3); &#125;);$(&quot;.kscz1_2&quot;).mouseover(function()&#123;//对select二级赋值if($(&quot;.kscz1_1&quot;).text()!=&apos;请选择游戏&apos;)&#123;$(&quot;.kscz1_1pri&quot;).css(&#123;display:&apos;block&apos;&#125;);&#125; &#125;);$(&quot;.kscz1_1pri&quot;).mouseleave(function()&#123;//隐藏select二级下拉表单$(this).css(&#123;display:&apos;none&apos;&#125;);&#125;);$(&quot;.kscz1_1pri li&quot;).live(&apos;click&apos;,function()&#123;//对select二级赋值及表单input为price赋值var value2 = $(this).text(); $(&quot;.kscz1_2&quot;).html(value2);$(&quot;.kscz1_1pri&quot;).css(&#123;display:&apos;none&apos;&#125;);$(&quot;#price&quot;).val(value2); &#125;);&#125;);function checkSubmit()&#123;//验证提交表单if (document.getElementById(&apos;proid&apos;).value==&quot;&quot;) &#123;alert(&quot;请选择游戏&quot;);return false;&#125;if (document.getElementById(&apos;price&apos;).value==&quot;&quot;) &#123;alert(&quot;请选择充值金额&quot;);return false;&#125;&#125;&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端面试题（3）：知识点总结]]></title>
      <url>%2F2017%2F02%2F12%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%883%EF%BC%89%EF%BC%9A%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[“基础知识还是不够扎实啊” 最近，面试了一家高大上的公司，很感动，感动地快落泪了。面试完之后最大的感受就是：老子有生之年一定要去这种类似的公司上班，如果现在不够格的话，那就拿起键盘，使劲地给我敲打。面试的过程跟之前的不太一样，先是笔试，给你大约半个小时的时间填写，完了在面试你。 笔试题，下面我会一一列举出来，找到自己的不足，稳步提升，下次的面试成功的几率就大一点。面试的时候，感觉面试官应该不是技术岗位出身，面试的内容与产品的内容多一点，可惜了，自己答得不是很满意，其中，面试官问你：你觉得你的优点和缺点是什么，这时候我应该在开放一点，当时有点拘谨了，还有你对未来的发展规划是什么，我回答的很浅显。优点：1.积极进取，乐观向上2.乐于助人3.有很好的三观4.喜欢接受不同的chanllege 5.执行力较强。缺点1.自尊心较强2.有时比较喜欢钻牛角尖，反正类似的问题，自己面试之前要好好想想，不能浅显地回答。还是就是关于薪资的问题，不能说高也不能贬低自己，”每个人的劳动成果应该与所得薪水成正比，现阶段，技术不是很强，所以客观来讲5k差不多，重要的是多学习，多学本领”write less do more 面试题 w3c标准 说说对Html5和css3的了解 BFC的理解 iframe的缺点 this对象的理解 如何实现继承 console的属性和方法 从输入URL到网页最终展现到用户面前，发生了事情 如何选取10——99的5个随机数，并进行排序 网站性能优化 数组的合并和删除项 异步加载和延迟加载 webStorage 和cookie 的区别 你对前端工程师的理解和未来期望 参考答案w3c 标准W3C的各类技术标准在努力为各类应用的开发打造一个开放的Web平台（Open Web Platform）。尽管这个开放Web平台的边界在不断延伸，产业界认为HTML5将是这个平台的核心，平台的能力将依赖于W3C及其合作伙伴正在创建的一系列Web技术，包括CSS, SVG, WOFF, 语义Web，及XML和各类应用编程接口（APIs） 说说对Html5和css3的了解CSS 用于控制网页的样式和布局。 CSS3 是最新的 CSS 标准。HTML5 是定义 HTML 标准的最新进展，HTML 5有两大特点：首先，强化了 Web 网页的表现性能。其次，追加了本地数据库等 Web 应用的功能。 BFC的理解BFC(block formatting context)块级格式化上下文：是Web页面中盒模型布局的CSS渲染模式。它的定位体系属于常规文档流。一个独立的块级渲染区域，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。 CSS2.1中规定满足下列CSS声明之一的元素便会生成BFC。 根元素 float的值不为none，则float:right/left;float 属性定义元素在哪个方向浮动。 overflow的值不为visible,则overflow:hidden/scroll/auto(如果内容被修剪浏览器会显示滚动条以便查看其余的内容)+display的值为inline-block(行内块元素)、table-cell(此元素会作为一个表格单元格显示)、table-caption(此元素会作为一个表格标题显示) position的值为absolute或fixed,不为relative 浏览器对于BFC这块区域的约束规则如下：1.BFC导致的外边距折叠在常规文档流中，盒子都是从包含块的顶部开始一个接着一个垂直堆放。两个兄弟盒子之间的垂直距离是由他们个体的外边距所决定的，但不是他们的两个外边距之和。2.创建新的BFC来防止外边距折叠因为我们在前面讨论了BFC导致外边距折叠的问题。但我们必须牢记在心的是毗邻块盒子的垂直外边距折叠只有他们是在同一BFC时才会发生。如果他们属于不同的BFC，他们之间的外边距将不会折叠。所以通过创建一个新的BFC我们可以防止外边距折叠。3.使用BFC来包含浮动一个BFC可以包含浮动。很多时候我们会碰到这种情况，一个容器里有浮动元素。由于这个原因，容器元素没有高度，它的浮动孩子将会脱离页面的常规流。我们通常使用清除浮动来解决这个问题，最受欢迎的方法是使用一个clearfix的伪类元素。但我们同样可以通过定义一个BFC来达到这个目的。12.con1&#123;background:green;display:inline-block;或者overflow:hidden;&#125;.con1 div&#123;float:left;margin:10px;background-color:yellow;&#125; 4.在多列布局中使用BFC如果我们正在创建的一个多列布局占满了整个容器的宽度，在某些浏览器中最后一列有时候将会被挤到下一行。会发生这样可能是因为浏览器舍入（取整）了列的宽度使得总和的宽度超过了容器的宽度。然而，如果我们在一个列的布局中建立了一个新的BFC，它将会在前一列填充完之后的后面占据所剩余的空间。 iframe的缺点1.ifame框架结构会让人感到迷惑。框架较多的话可能会出现上下左右滚动，会分散访问者的注意力，用户体验差。2.无法被搜索引擎抓取，不利于搜索引擎优化3.设备兼容性差，不能适配移动设备4.会增加服务器的http请求。基本上都是用ajax来代替iframe，iframe慢慢淡出前端开发 浅谈对this对象的理解this对象是在运行时基于函数的执行环境绑定的，在全局函数中，this值window，而当函数被作为某个对象的方法调用时，this等于那个对象，如果有new关键字，this指向new出来的那个对象，在事件中，this指向出发这个事件的对象，特殊的是，在IE的attachEvent中this总是指向全局对象window console的属性和方法console的方法和属性，请移步不可思议的console：console方法属性大全 console.assert(exp,mes)作用：对输入的表达式进行判断，当表达式为true时，不执行在控制台输出信息的操作，当表达式为false时，在控制台中输出对应的信息。参数：exp表示表达式，mes表示想要输出的信息。 console.clear()作用：清空控制台输出的信息。参数：无参数。 console.count([mes])作用：用来统计函数被执行的次数。参数：可选的参数，主要用来标识是哪个函数执行的次数。eg:console.count(‘outputNumber被执行的次数’); console.debug(mes)作用：用于输出调试信息。参数：mes用于表示想要输出的信息。 console.dir(obj|dom)作用：可以详细查看对象的方法，将DOM节点以DOM树的结构进行输出。参数：二选一即可，obj表示对象，dom表示一个DOM节点。示例代码1：文章开始部分的console.dir(console)，这里不再做赘述。6.console.dirxml(dom)作用：打印对应都没元素中的html内容。参数：dom表示html中的DOM节点。7.console.error(mes)作用：输出错误信息。参数：mes表示想要输出的错误信息的内容。其他：可类比console.debug()。8.console.info(mes)作用：在控制台中输出提示信息。参数：mes表示输出信息的内容。说明：类比console.debug()与console.error()。9.console.log(mes)作用：在控制台输出普通信息，此项为console最为常用的方法。参数：mes标识想要输出的信息的内容。10.console.memory作用；用于显示此刻使用的内存信息11.console.profile(name)、console.profileEnd(name)作用：两个方法配合使用用来查看CPU使用相关信息。参数：name起一个标识的作用。12.console.trace([name])作用：用来追踪函数的调用轨迹。参数：name表示这个轨迹的名称，是一个可选的参数 console.warn(mes)作用：在控制台中显示警告信息。参数：mes表示警告信息的内容。 从输入URL到网页最终展现到用户面前，发生了事情1.查找浏览器缓存2.DNS解析，查找该域名对应的IP地址、重定向（301）3.进行http协议会话4.客户端发送报头(请求报头)5.服务器端回馈报头留(相应报头)6.html文档开始下载7.文档树建立，根据标记请求所需指定的MIME类型的文件8.文件显示 如何选取10——99的5个随机数，并进行从小到大排序1.Math对象的舍入方法和random()方法Math.floor()执行向下舍入，总是将数值向下舍入为最近的整数Math.floor(Math.random()*可能的总数+第一个可能的值);//2.compare()比较函数，夹杂sort()方法;1234567891011121314151617181920function suiJi(startNum,endNum,item)&#123; var compare = function(num1,num2)&#123; //排序的方法 if(num1&gt;num2)&#123;return 1;&#125; else if(num1&lt;num2)&#123;return -1;&#125; else&#123;return 0;&#125; &#125; var btn = document.querySelector(&apos;button&apos;); var span = document.getElementsByClassName(&apos;span&apos;)[0]; btn.onclick =function()&#123; var member =[]; while(member.length&lt;item)&#123; var a = Math.floor(Math.random()*(endNum-startNum+1) + startNum); //生成的随机数 if(member.indexOf(a) == -1)&#123; member.push(a); &#125; &#125;; span.innerHTML = member.sort(compare).join(&apos;|&apos;); &#125; &#125; suiJi(10,99,5); 网站性能优化数组的合并和删除项异步加载和延迟加载异步加载方案1.动态插入script标签2.通过ajax去获取js代码，然后通过eval()执行3.创建并插入iframe,让它异步执行js 延迟加载可视化加载，页面滑动到这里的时候才去加载 webStorage 和cookie 的区别cookie是网站为了标示用户身份而储存在用户本地终端上的数据（通常加密），会在服务器和浏览器来回传递sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存存储大小cookie大小不能超过4KB，两外两个不超过5Mb有效时间cookie 设置的cookie 过期时间之前一直有效，即使窗口或者浏览器关闭sessionStorage 存储持久数据，除非主动删除localStorage 窗口或者浏览器关闭自动删除 你对前端工程师的理解和未来期望1.针对服务器的优化，拥抱最新前端技术2.做好页面结构、页面重构和用户体验3.参与项目，高质量快效率完成效果图4.与团队成员UI设计沟通]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端面试题（2）：知识点总结]]></title>
      <url>%2F2017%2F02%2F10%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882%EF%BC%89%EF%BC%9A%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[1.box-sizing属性box-sizing属性主要用来控制元素的盒模型的解析模式。默认值是content-box。content-box：让元素维持W3C的标准盒模型。元素的宽度/高度由border + padding + content的宽度/高度决定，设置width/height属性指的是content部分的宽/高border-box：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置width/height属性指的是border + padding + content标准浏览器下，按照W3C规范对盒模型解析，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。CSS3中新增了一种盒模型计算方式：box-sizing。盒模型默认的值是content-box, 新增的值是padding-box和border-box，几种盒模型计算元素宽高的区别如下： 2.link 和@import 的区别是?（1）link属于XHTML标签，而@import是CSS提供的;（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;（3）import只在IE5以上才能识别，而link是XHTML标签，无兼容问题;（4）link方式的样式的权重高于@import的权重.example1234&lt;link rel=’stylesheet’ href=’a.css’&gt; 或者&lt;style&gt; @import url(’a.css’); &lt;/style&gt; 3.CSS3新增伪类举例：1234567 p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :enabled、:disabled 控制表单控件的禁用状态。 :checked，单选框或复选框被选中。 4.(写)描述一段语义的html代码吧。HTML5中新增加的很多标签（如： article、nav、header和footer就是基于语义化设计原则）1234&lt; div id=&quot;header&quot;&gt; &lt; h1&gt;标题&lt; /h1&gt; &lt; h2&gt;专注Web前端技术&lt; /h2&gt; &lt; /div&gt; 语义 HTML 具有以下特性：文字包裹在元素中，用以反映内容。例如：段落包含在 p 元素中。顺序表包含在ol元素中。从其他来源引用的大型文字块包含在blockquote元素中。HTML 元素不能用作语义用途以外的其他目的。例如：h1包含标题，但并非用于放大文本。blockquote包含大段引述，但并非用于文本缩进。空白段落元素 ( p) 并非用于跳行。文本并不直接包含任何样式信息。例如：不使用 font 或 center 等格式标记。类或 ID 中不引用颜色或位置。 5.对BFC规范的理解？ BFC(block formatting context)：块级格式化上下文，它是指一个独立的块级渲染区域，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。 既然上文提到BFC是一块渲染区域，那这块渲染区域到底在哪，它又是有多大，这些由生成BFC的元素决定，CSS2.1中规定满足下列CSS声明之一的元素便会生成BFC。+根元素+float的值不为none+overflow的值不为visible+display的值为inline-block、table-cell、table-caption+position的值为absolute或fixed浏览器对于BFC这块区域的约束规则如下：生成BFC元素的子元素会一个接一个的放置。垂直方向上他们的起点是一个包含块的顶部，两个相邻子元素之间的垂直距离取决于元素的margin特性。在BFC中相邻的块级元素外边距会折叠。生成BFC元素的子元素中，每一个子元素做外边距与包含块的左边界相接触，（对于从右到左的格式化，右外边距接触右边界），即使浮动元素也是如此（尽管子元素的内容区域会由于浮动而压缩），除非这个子元素也创建了一个新的BFC（如它自身也是一个浮动元素）。 有道友对它做了分解，我们直接拿来： 1.内部的Box会在垂直方向上一个接一个的放置2.垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生重叠，与方向无关。）3.每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）4.BFC的区域不会与float的元素区域重叠5.计算BFC的高度时，浮动子元素也参与计算6.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端面试题（1）：知识点总结]]></title>
      <url>%2F2017%2F02%2F09%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%881%EF%BC%89%EF%BC%9A%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[div在容器中左右上下居中的代码div上下左右居中第一种.box{width:500px;height:500px;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:red;}div上下左右居中第二种.wrapper{width:100vw;height:100vh;background:hsl(0,80%,90%);font-size:16px;}.box{width:20rem;height:20rem;background:red;position:absolute;top:0;left:0;margin:auto;bottom:0;right:0;font-size:1.4rem;}div上下左右居中第三种.wrapper{width:100vw;height:100vh;background:hsl(0,80%,90%);font-size:16px;}.box{width:30rem;height:30rem;background:red;position:absolute;left:50%;top:50%;margin-left:-15rem;margin-top:-15rem;} 线程与进程的区别 一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 你如何对网站的文件和资源进行优化？ 期待的解决方案包括：文件合并文件最小化/文件压缩使用 CDN 托管缓存的使用（多个域名来提供缓存）其他请说出三种减少页面加载时间的方法。1.优化图片2.图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）3.优化CSS（压缩合并css，如margin-top,margin-left…)4.网址后加斜杠（如www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。）5.标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。）6.减少http请求（合并文件，合并图片）。 你都使用哪些工具来测试代码的性能？7ofiler, JSPerf（http://jsperf.com/nexttick-vs-setzerotimeout-vs-settimeout）, Dromaeo什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？FOUC - Flash Of Unstyled Content 文档样式闪烁1&lt;style type="text/css" media="all"&gt;@import "../fouc.css";&lt;/style&gt; &lt;/code&gt; 而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。解决方法简单的出奇，只要在之间加入一个link或者script元素就可以了。 null和undefined的区别？ null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。 当声明的变量还未被初始化时，变量的默认值为undefined。 null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。 undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是： （1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。null表示”没有对象”，即该处不应该有值。典型用法是： （1） 作为函数的参数，表示该函数的参数不是对象。 （2） 作为对象原型链的终点。 new操作符具体干了什么呢? 1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 2、属性和方法被加入到 this 引用的对象中。 3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。var obj = {};obj.proto = Base.prototype;Base.call(obj); js延迟加载的方式有哪些？ defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js如何解决跨域问题? jsonp、 document.domain+iframe、window.name、window.postMessage、服务器上设置代理页面 jsonp的原理是动态插入script标签具体参见：详解js跨域问题（https://segmentfault.com/a/1190000000718840） documen.write和 innerHTML的区别 document.write只能重绘整个页面 innerHTML可以重绘页面的一部分 .call() 和 .apply() 的区别和作用？ 作用：动态改变某个类的某个方法的运行环境。 区别参见：JavaScript学习总结（四）function函数部分（https://segmentfault.com/a/1190000000660786#articleHeader15） 哪些操作会造成内存泄漏？ 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）详见：详解js变量、作用域及内存（https://segmentfault.com/a/1190000000687844） JavaScript中的作用域与变量声明提升？ 详见：详解JavaScript函数模式（https://segmentfault.com/a/1190000000758184#articleHeader5） 如何判断当前脚本运行在浏览器还是node环境中？ 通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中其他问题？ 你遇到过比较难的技术问题是？你是如何解决的？ 列举IE 与其他浏览器不一样的特性？ 什么叫优雅降级和渐进增强？ 优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效. 渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。详见：css学习归纳总结（一） WEB应用从服务器主动推送Data到客户端有那些方式？ Javascript数据推送Commet：基于HTTP长连接的服务器推送技术 基于WebSocket的推送方案 SSE（Server-Send Event）：服务器推送数据新方式 对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？ 前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。 1、实现界面交互 2、提升用户体验 3、有了Node.js，前端可以实现服务端的一些事情 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好， 参与项目，快速高质量完成实现效果图，精确到1px； 与团队成员，UI设计，产品经理的沟通； 做好的页面结构，页面重构和用户体验； 处理hack，兼容、写出优美的代码格式； 针对服务器的优化、拥抱最新前端技术。 你有哪些性能优化的方法？ （详情请看雅虎14条性能优化原则）（https://segmentfault.com/blog/trigkit4/1190000000656717）。 （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 （4） 当需要设置的样式很多时设置className而不是直接操作style。 （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 （7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。详情：http://segmentfault.com/blog/trigkit4/1190000000691919 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？ 分为4个步骤： （1），当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。 （2）， 浏览器与远程Web服务器通过TCP三次握手协商来建立一个TCP/IP连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。 （3），一旦TCP/IP连接建立，浏览器会通过该连接向远程服务器发送HTTP的GET请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。 （4），此时，Web服务器提供资源服务，客户端开始下载资源。 请求返回后，便进入了我们关注的前端模块简单来说，浏览器会解析HTML生成DOM Tree，其次会根据CSS生成CSS Rule Tree，而javascript又可以根据DOM API操作DOM详情：从输入 URL 到浏览器接收的过程中发生了什么事情？（https://segmentfault.com/a/1190000000697254） 平时如何管理你的项目？ 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等； 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）； 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； 页面进行标注（例如 页面 模块 开始和结束）； CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；JS 分文件夹存放 命名以该JS功能为准的英文翻译。 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理 说说最近最流行的一些东西吧？常去哪些网站？ Node.js、Mongodb、npm、MVVM、MEAN、three.js,React 。网站：w3cfuns,sf,hacknews,CSDN,慕课，博客园，InfoQ,w3cplus等 javascript对象的几种创建方式 1，工厂模式2，构造函数模式3，原型模式4，混合构造函数和原型模式5，动态原型模式6，寄生构造函数模式7，稳妥构造函数模式javascript继承的6种方法 1，原型链继承2，借用构造函数继承3，组合继承(原型+借用构造)4，原型式继承5，寄生式继承6，寄生组合式继承详情：JavaScript继承方式详解（https://segmentfault.com/a/1190000002440502） ajax过程 (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象. (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. (3)设置响应HTTP请求状态变化的函数. (4)发送HTTP请求. (5)获取异步调用返回的数据. (6)使用JavaScript和DOM实现局部刷新.详情：JavaScript学习总结（七）Ajax和Http状态字（https://segmentfault.com/a/1190000000691919） 异步加载和延迟加载 1.异步加载的方案： 动态插入script标签2.通过ajax去获取js代码，然后通过eval执行3.script标签上添加defer或者async属性4.创建并插入iframe，让它异步执行js5.延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。 前端安全问题？ sql注入原理 就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 总的来说有以下几点： 1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双”-“进行转换等。2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。XSS原理及防范 Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个 看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单， 当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。 XSS防范方法 1.代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。2.避免直接在cookie 中泄露用户隐私，例如email、密码等等。 3.通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。4.尽量采用POST 而非GET 提交表单 XSS与CSRF有什么区别吗？ XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。 要完成一次CSRF攻击，受害者必须依次完成两个步骤： 登录受信任网站A，并在本地生成Cookie。 在不登出A的情况下，访问危险网站B。 CSRF的防御 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。 使用验证码 ie各版本和chrome可以并行下载多少个资源 IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个 Firefox，chrome也是6个 javascript里面的继承怎么实现，如何避免原型链上面的对象共享 用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的extend()函数，很多前端框架都有封装的，就是用一个空函数当做中间变量grunt， YUI compressor 和 google clojure用来进行代码压缩的用法。 YUI Compressor 是一个用来压缩 JS 和 CSS 文件的工具，采用Java开发。 使用方法： //压缩JSjava -jar yuicompressor-2.4.2.jar –type js –charset utf-8 -v src.js &gt; packed.js//压缩CSSjava -jar yuicompressor-2.4.2.jar –type css –charset utf-8 -v src.css &gt; packed.css详情请见：你需要掌握的前端代码性能优化工具（https://segmentfault.com/a/1190000002585760） Flash、Ajax各自的优缺点，在使用中如何取舍？ 1、Flash ajax对比Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM请解释一下 JavaScript 的同源策略。 概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。 这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。 指一段脚本只能读取来自同一来源的窗口和文档的属性。 为什么要有同源限制？ 我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。 什么是 “use strict”; ? 使用它的好处和坏处分别是什么？ ECMAscript 5添加了第二种运行模式：”严格模式”（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。 设立”严格模式”的目的，主要有以下几个： 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。注：经过测试IE6,7,8,9均不支持严格模式。 缺点： 现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。 GET和POST的区别，何时使用POST？ GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符POST：一般用于修改服务器上的资源，对所发送的信息没有限制。 GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。 然而，在以下情况中，请使用 POST 请求：无法使用缓存文件（更新服务器上的文件或数据库）向服务器发送大量数据（POST 没有数据量限制）发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠哪些地方会出现css阻塞，哪些地方会出现js阻塞？ js的阻塞特性：所有浏览器在下载JS的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。直到JS下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。为了提高用户体验，新一代浏览器都支持并行下载JS，但是JS下载仍然会阻塞其它资源的下载（例如.图片，css文件等）。 由于浏览器为了防止出现JS修改DOM树，需要重新构建DOM树的情况，所以就会阻塞其他的下载和呈现。 嵌入JS会阻塞所有内容的呈现，而外部JS只会阻塞其后内容的显示，2种方式都会阻塞其后资源的下载。也就是说外部样式不会阻塞外部脚本的加载，但会阻塞外部脚本的执行。 CSS怎么会阻塞加载了？CSS本来是可以并行下载的，在什么情况下会出现阻塞加载了(在测试观察中，IE6下CSS都是阻塞加载） 当CSS后面跟着嵌入的JS的时候，该CSS就会出现阻塞后面资源下载的情况。而当把嵌入JS放到CSS前面，就不会出现阻塞的情况了。 根本原因：因为浏览器会维持html中css和js的顺序，样式表必须在嵌入的JS执行前先加载、解析完。而嵌入的JS会阻塞后面的资源加载，所以就会出现上面CSS阻塞下载的情况。 嵌入JS应该放在什么位置？ 1、放在底部，虽然放在底部照样会阻塞所有呈现，但不会阻塞资源下载。 2、如果嵌入JS放在head中，请把嵌入JS放在CSS头部。 3、使用defer（只支持IE） 4、不要在嵌入的JS中调用运行时间较长的函数，如果一定要用，可以用setTimeout来调用Javascript无阻塞加载具体方式 将脚本放在底部。还是放在head中，用以保证在js加载前，能加载出正常显示的页面。标签放在前。成组脚本：由于每个标签下载时阻塞页面解析过程，所以限制页面的总数也可以改善性能。适用于内联脚本和外部脚本。 非阻塞脚本：等页面完成加载后，再加载js代码。也就是，在window.onload事件发出后开始下载代码。 （1）defer属性：支持IE4和fierfox3.5更高版本浏览器 （2）动态脚本元素：文档对象模型（DOM）允许你使用js动态创建HTML的几乎全部文档内容。代码如下： var script=document.createElement(“script”);script.type=”text/javascript”;script.src=”file.js”;document.getElementsByTagName(“head”)[0].appendChild(script);此技术的重点在于：无论在何处启动下载，文件额下载和运行都不会阻塞其他页面处理过程。即使在head里（除了用于下载文件的http链接）。 闭包相关问题？ 详情请见：详解js闭包（https://segmentfault.com/a/1190000000652891） js事件处理程序问题？ 详情请见：JavaScript学习总结（九）事件详解（https://segmentfault.com/a/1190000002174034） eval是做什么的？ 它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。JavaScript原型，原型链 ? 有什么特点？ 原型对象也是普通的对象，是对象一个自带隐式的 proto 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链。 原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？ 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。 事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。； ev.stopPropagation();注意旧ie的方法 ev.cancelBubble = true;ajax 是什么?ajax 的交互模型?同步和异步的区别?如何解决跨域问题? 详情请见：JavaScript学习总结（七）Ajax和Http状态字（https://segmentfault.com/a/1190000000691919） 通过异步模式，提升了用户体验 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用 Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。 Ajax的最大的特点是什么。 Ajax可以实现动态不刷新（局部刷新）readyState属性 状态 有5个可取值： 0=未初始化 ，1=启动 2=发送，3=接收，4=完成 ajax的缺点 1、ajax不支持浏览器back按钮。 2、安全问题 AJAX暴露了与服务器交互的细节。 3、对搜索引擎的支持比较弱。 4、破坏了程序的异常机制。 5、不容易调试。 跨域： jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面js对象的深度克隆 function clone(Obj) { var buf; if (Obj instanceof Array) { buf = []; //创建一个空的数组 var i = Obj.length; while (i–) { buf[i] = clone(Obj[i]); } return buf; }else if (Obj instanceof Object){ buf = {}; //创建一个空对象 for (var k in Obj) { //为这个对象添加新的属性 buf[k] = clone(Obj[k]); } return buf; }else{ return Obj; } }AMD和CMD 规范的区别？ 详情请见：详解JavaScript模块化开发（https://segmentfault.com/a/1190000000733959） 网站重构的理解？ 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。 对于传统的网站来说重构通常是： 表格(table)布局改为DIV+CSS使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)对于移动平台的优化针对于SEO进行优化深层次的网站重构应该考虑的方面 减少代码间的耦合让代码保持弹性严格按规范编写代码设计可扩展的API代替旧有的框架、语言(如VB)增强用户体验通常来说对于速度的优化也包含在重构中 压缩JS、CSS、image等前端资源(通常是由服务器来解决)程序的性能优化(如数据读写)采用CDN来加速资源加载对于JS DOM的优化HTTP服务器的文件缓存如何获取UA？ function whatBrowser() { document.Browser.Name.value=navigator.appName; document.Browser.Version.value=navigator.appVersion; document.Browser.Code.value=navigator.appCodeName; document.Browser.Agent.value=navigator.userAgent; }js数组去重 以下是数组去重的三种方法： Array.prototype.unique1 = function () { var n = []; //一个新的临时数组 for (var i = 0; i &lt; this.length; i++) //遍历当前数组 { //如果当前数组的第i已经保存进了临时数组，那么跳过， //否则把当前项push到临时数组里面 if (n.indexOf(this[i]) == -1) n.push(this[i]); } return n;} Array.prototype.unique2 = function(){ var n = {},r=[]; //n为hash表，r为临时数组 for(var i = 0; i &lt; this.length; i++) //遍历当前数组 { if (!n[this[i]]) //如果hash表中没有当前项 { n[this[i]] = true; //存入hash表 r.push(this[i]); //把当前数组的当前项push到临时数组里面 } } return r;} Array.prototype.unique3 = function(){ var n = [this[0]]; //结果数组 for(var i = 1; i &lt; this.length; i++) //从第二项开始遍历 { //如果当前数组的第i项在当前数组中第一次出现的位置不是i， //那么表示第i项是重复的，忽略掉。否则存入结果数组 if (this.indexOf(this[i]) == i) n.push(this[i]); } return n;}HTTP状态码 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息200 OK 正常返回信息201 Created 请求成功并且服务器创建了新的资源202 Accepted 服务器已接受请求，但尚未处理301 Moved Permanently 请求的网页已永久移动到新位置。302 Found 临时性重定向。303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。304 Not Modified 自从上次请求后，请求的网页未修改过。 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。401 Unauthorized 请求未授权。403 Forbidden 禁止访问。404 Not Found 找不到如何与 URI 相匹配的资源。 500 Internal Server Error 最常见的服务器端错误。503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。js操作获取和设置cookie //创建cookiefunction setCookie(name, value, expires, path, domain, secure) { var cookieText = encodeURIComponent(name) + ‘=’ + encodeURIComponent(value); if (expires instanceof Date) { cookieText += ‘; expires=’ + expires; } if (path) { cookieText += ‘; expires=’ + expires; } if (domain) { cookieText += ‘; domain=’ + domain; } if (secure) { cookieText += ‘; secure’; } document.cookie = cookieText;} //获取cookiefunction getCookie(name) { var cookieName = encodeURIComponent(name) + ‘=’; var cookieStart = document.cookie.indexOf(cookieName); var cookieValue = null; if (cookieStart &gt; -1) { var cookieEnd = document.cookie.indexOf(‘;’, cookieStart); if (cookieEnd == -1) { cookieEnd = document.cookie.length; } cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)); } return cookieValue;} //删除cookiefunction unsetCookie(name) { document.cookie = name + “= ; expires=” + new Date(0);}说说TCP传输的三次握手策略 为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK。发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。说说你对Promise的理解 依照 Promise/A+ 的定义，Promise 有四种状态： pending: 初始状态, 非 fulfilled 或 rejected.fulfilled: 成功的操作.rejected: 失败的操作.settled: Promise已被fulfilled或rejected，且不是pending另外， fulfilled 与 rejected 一起合称 settled。 Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。 Promise 的构造函数构造一个 Promise，最基本的用法如下： var promise = new Promise(function(resolve, reject) { if (…) { // succeed resolve(result); } else { // fails reject(Error(errMessage)); }});Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为 thenable）。它的使用方法如下： promise.then(onFulfilled, onRejected)接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在 rejected 的时候被调用，接收参数就是 future，onFulfilled 对应 resolve, onRejected 对应 reject。 Javascript垃圾回收方法 标记清除（mark and sweep） 这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了 引用计数(reference counting) 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。 在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的，也就是说只要涉及BOM及DOM就会出现循环引用问题。 谈谈性能优化问题 代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。 缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等 请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。 请求带宽：压缩文件，开启GZIP， 移动端性能优化 尽量使用css3动画，开启硬件加速。适当使用touch事件代替click事件。避免使用css3渐变阴影效果。 尽可能少的使用box-shadow与gradients。box-shadow与gradients往往都是页面的性能杀手什么是Etag？ 浏览器下载组件的时候，会将它们存储到浏览器缓存中。如果需要再次获取相同的组件，浏览器将检查组件的缓存时间， 假如已经过期，那么浏览器将发送一个条件GET请求到服务器，服务器判断缓存还有效，则发送一个304响应， 告诉浏览器可以重用缓存组件。 那么服务器是根据什么判断缓存是否还有效呢?答案有两种方式，一种是前面提到的ETag，另一种是根据Last-Modified Expires和Cache-Control Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。 Cache-Control: no-cache, private, max-age=0ETag: abcdeExpires: Thu, 15 Apr 2014 20:00:00 GMTPragma: privateLast-Modified: $now // RFC1123 format栈和队列的区别? 栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。队列先进先出，栈先进后出。栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除栈和堆的区别？ 栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。堆（数据结构）：堆可以被看成是一棵树，如：堆排序；栈（数据结构）：一种先进后出的数据结构。关于Http 2.0 你知道多少？ HTTP/2引入了“服务端推（serverpush）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。 HTTP/2提供更多的加密支持 HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。 它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端：Accordion手风琴效果]]></title>
      <url>%2F2017%2F02%2F09%2F%E5%89%8D%E7%AB%AF%EF%BC%9Aaccordion%E6%89%8B%E9%A3%8E%E7%90%B4%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[knowledge:浮动布局.wrapper li{width:240px;height:225px;overflow:hidden;float:left;}1234567891011&lt;li class="big"&gt;&lt;a href="#"&gt; &lt;img src="img/demo.jpg"&gt; &lt;div class="info"&gt; &lt;h3 style="color:#f62368"&gt;聚美妆&lt;/h3&gt; &lt;p&gt;聚美妆1/2周年庆&lt;/p&gt; &lt;p class="price"&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;i&gt;折起&lt;/i&gt;&lt;/p&gt; &lt;/div&gt; &lt;i class="line"&gt;&lt;/i&gt; &lt;i class="mask"&gt;&lt;/i&gt; &lt;/a&gt; &lt;/li&gt; knowledge:遮罩层.wrapper .mask{position:absolute;top:0;height:225px;width:400px;opacity:0;background:#000;}.wrapper:hover .mask{opacity:0.15;} 绝对定位position:absolute.wrapper li a img{position:absolute;bottom:0;right:-20px;height:150px;width:240px;}.wrapper li a .info{position:absolute;left:0;top:0;width:120px;padding:4px 20px;} 原生js12345678910111213function initList()&#123;&#125; var subject = document.getElementById('subject') var oLi= subject.getElementsByTagName('li'); for(var i=0;i&lt;oLi.length;i++)&#123; oLi[i].index = i; oLi[i].onmouseover =function()&#123; for(var j=0;j&lt;oLi.length;j++)&#123; oLi[j].className=""; &#125; oLi[this.index].className = 'big'; &#125; &#125; initList(); jQuery 代码123456789101112function mouseover(e)&#123; var list = $('#subject li'); var target = $(e.target).parents('li'); list.removeClass('big'); target.addClass('big'); &#125; (function()&#123; var outer = $('#subject'); outer.find('li').on('mouseover', mouseover); &#125;)() Css中的手风琴效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flex-Box弹性盒模型初探]]></title>
      <url>%2F2017%2F02%2F07%2Fflex-box%E5%BC%B9%E6%80%A7%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%8E%A2%2F</url>
      <content type="text"><![CDATA[弹性布局（flexible box）模块（目前是w3c候选的推荐）旨在提供一个更加有效的方式来布置，对齐和分布在容器之间的各项内容，即使它们的大小是未知或者动态变化的。 由于flexbox是一个整体模块，而不是单一的一个属性，它涉及到了很多东西，包括它的整个属性集。它们之中有一些是在父容器上设置，而有一些则是在子容器上设置。 属性介绍 display: flex | inline-flex; (适用于父类容器元素上) box：将对象作为弹性伸缩盒显示。（伸缩盒最老版本）（css3）inline-box：将对象作为内联块级弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）flexbox：将对象作为弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）inline-flexbox：将对象作为内联块级弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）flex：将对象作为弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）inline-flex：将对象作为内联块级弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）注意:1.css 列（CSS columns）在弹性盒子中不起作用2.float, clear and vertical-align 在flex项目中不起作用 flex-direction (适用于父类容器的元素上)定义：设置或检索伸缩盒对象的子元素在父容器中的位置。row：横向从左到右排列（左对齐），默认的排列方式。row-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面。column：纵向排列。column-reverse：反转纵向排列，从后往前排，最后一项排在最上面。 flex-wrap (适用于父类容器上) 设置或检索伸缩盒对象的子元素超出父容器时是否换行。flex-wrap: nowrap(不换行) | wrap(换行) | wrap-reverse flex-flow (适用于父类容器上)设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。当弹性盒里一行上的所有子元素都不能伸缩或已经达到其最大值时，这一属性可协助对多余的空间进行分配。当元素溢出某行时，这一属性同样会在对齐上进行控制。justify-content: flex-start | flex-end | center | space-between | space-around flex (适用于弹性盒模型子元素)复合属性。设置或检索伸缩盒对象的子元素如何分配空间。 如果缩写flex:1, 则其计算值为：1 1 0 flex：none | [ flex-grow ] || [ flex-shrink ] || [ flex-basis ]none：none关键字的计算值为: 0 0 auto[ flex-grow ]：定义弹性盒子元素的扩展比率。[ flex-shrink ]：定义弹性盒子元素的收缩比率。[ flex-basis ]：定义弹性盒子元素的默认基准值。 常见的案例常见3栏移动优先布局css部分12345678910111213141516171819202122232425262728293031323334353637.wrapper &#123; display: flex; flex-flow: row wrap;&#125;/* We tell all items to be 100% width */.header, .main, .nav, .aside, .footer &#123; flex: 1 100%;&#125;/* We rely on source order for mobile-first approach * in this case: * 1. header * 2. nav * 3. main * 4. aside * 5. footer *//* Medium screens */@media all and (min-width: 600px) &#123; /* We tell both sidebars to share a row */ .aside &#123; flex: 1 auto; &#125;&#125;/* Large screens */@media all and (min-width: 800px) &#123; /* We invert order of first sidebar and main * And tell the main element to take twice as much width as the other two sidebars */ .main &#123; flex: 2 0px; &#125; .aside-1 &#123; order: 1; &#125; .main &#123; order: 2; &#125; .aside-2 &#123; order: 3; &#125; .footer &#123; order: 4; &#125;&#125; html部分123456789&lt;div class="wrapper"&gt; &lt;header class="header"&gt;Header&lt;/header&gt; &lt;article class="main"&gt; &lt;p&gt;Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vestibulum tortor quam, feugiat vitae, ultricies eget, tempor sit amet, ante. Donec eu libero sit amet quam egestas semper. Aenean ultricies mi vitae est. Mauris placerat eleifend leo.&lt;/p&gt; &lt;/article&gt; &lt;aside class="aside aside-1"&gt;Aside 1&lt;/aside&gt; &lt;aside class="aside aside-2"&gt;Aside 2&lt;/aside&gt; &lt;footer class="footer"&gt;Footer&lt;/footer&gt;&lt;/div&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Bootstrap-Two:0205 Button and Image-Study]]></title>
      <url>%2F2017%2F02%2F05%2Fbootstrap-two-0205-button-study%2F</url>
      <content type="text"><![CDATA[button 按钮 default button.btn-primary:首选项 .btn-default .btn-info 一般信息 button sizes.btn-lg .btn-default .btn-sm .btn-xs .btn-block(将其拉伸为父元素的100%宽度) disabled and active state1.anchor element disabled 1&lt;a href="#" class="btn btn-large btn-primary disabled"&gt;Primary link&lt;/a&gt; 2.button element1&lt;button type="button" class="btn btn-default btn-lg active"&gt;Button&lt;/button&gt; image 图片Add classes to an element to easily style images in any project.1234&lt;img src="..." alt="..." class="img-rounded"&gt; 圆角图片&lt;img src="..." alt="..." class="img-circle"&gt; 圆形图片 &lt;img src="..." alt="..." class="img-thumbnail"&gt;&lt;img src="" alt="" class="img-responsive"&gt; form .form-inline 内联表单，可以通过为label设置.sr-only类将其隐藏 .input-group 12345&lt;div class="input-group"&gt; &lt;div class="input-group-addon"&gt;$&lt;/div&gt; &lt;input type="text" class="form-control" id="exampleInputAmount" placeholder="Amount"&gt; &lt;div class="input-group-addon"&gt;.00&lt;/div&gt;&lt;/div&gt; .form-horizontal 水平排列的表单，并联合使用 Bootstrap 预置的栅格类 12345678910111213141516171819202122232425262728&lt;form class="form-horizontal"&gt; &lt;div class="form-group"&gt; &lt;label for="inputEmail3" class="col-sm-2 control-label"&gt;Email&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="email" class="form-control" id="inputEmail3" placeholder="Email"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="inputPassword3" class="col-sm-2 control-label"&gt;Password&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input type="password" class="form-control" id="inputPassword3" placeholder="Password"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-sm-offset-2 col-sm-10"&gt; //列偏移,对齐 &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox"&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-sm-offset-2 col-sm-10"&gt; //列偏移 &lt;button type="submit" class="btn btn-default"&gt;Sign in&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 内联单选和多选框通过将 .checkbox-inline 或 .radio-inline 类应用到一系列的多选框（checkbox）或单选框（radio）控件上，可以使这些控件排列在一行。 焦点状态我们将某些表单控件的默认 outline 样式移除即outline:0;box-shadow: 0 0 8px rgba(82,168,236,.6);，然后对 :focus 状态赋予 box-shadow 属性。 添加额外的图标,反馈图标（feedback icon）只能使用在文本输入框 元素上。123456&lt;div class="form-group has-success has-feedback"&gt; &lt;label class="control-label" for="inputSuccess2"&gt;Input with success&lt;/label&gt; &lt;input type="text" class="form-control" id="inputSuccess2" aria-describedby="inputSuccess2Status"&gt; &lt;span class="glyphicon glyphicon-ok form-control-feedback" aria-hidden="true"&gt;&lt;/span&gt; &lt;span id="inputSuccess2Status" class="sr-only"&gt;(success)&lt;/span&gt;&lt;/div&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端成长必备：Js继承(1)]]></title>
      <url>%2F2017%2F02%2F04%2F%E5%89%8D%E7%AB%AF%E6%88%90%E9%95%BF%E5%BF%85%E5%A4%87%EF%BC%9Ajs%E7%BB%A7%E6%89%BF-1%2F</url>
      <content type="text"><![CDATA[1.apply()与call()函数 两个非继承而来的方法,用途是在特定的作用域中调用函数，实际上等于设置函数体内的this对象的值 apply(1.运行函数的作用域，2.参数数组)function sum(n1,n2){ return n1+n2;}function callSum1(n1,n2){ return sum.apply(this,arguments);}function callSum2(n1,n2){ return sum.apply(this,[n1,n2]);}console.log(callSum1(10,20));console.log(callSum1(20,30)); call(1.运行函数的作用域，2.参数必须逐个列举)function sum(num1,num2){return num1+num2;}function callSum(q1,q2){return sum.call(this,q1,q2)} //sum.call()，传递给函数的参数必须逐个列举出来alert(callSum(5,3)); 传递参数并非apply和call用武之地，真正强大的地方是能够扩充函数赖以运行的作用域 window.color = ‘red’;var o ={color:’blue’};function sayColor(){ alert(this.color);}sayColor();sayColor.call(o);//blueo.sayColor = sayColor;o.sayColor();使用apply和calL扩充作用域的最大好处是对象不需要与方法有任何的耦合关系 原型链function Super(){this.name = ‘Super’;this.arr = [1,2,3,4];}//数组是引用类型值Super.prototype.sayName = function(){return this.name;}function Sub(){this.age = 12;}Sub.prototype = new Super();var test= new Sub();test.arr.push(‘black’);console.log(test.arr); //[1, 2, 3, 4, “black”]var test2 =new Sub();console.log(test2.arr);//[1, 2, 3, 4, “black”]*/ //原型链 》 test-Super实例-Super.prototype,改变子类的prototype,使其指向父类的一个实例//所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，这也是自定义类型都会继承toString()、valueOf()方法的根本原因//原型链的问题1.引用类型值的原型属性会被所有实例共享2.创建子类型实例时，不能向父类型的构造函数中传递参数 借用构造函数 constructor stealing 或者伪造对象 或者经典继承function Super(){ this.arr = [‘blue’,’red’,’green’];}function Suber(){ Super.call(this);}var instance1 = new Suber();instance1.arr.push(‘black’);console.log(instance1.arr);var instance2 = new Suber();console.log(instance2.arr);//通过借用构造函数，通过使用call或者apply(),我们实际上在新创建的实例环境下调用Super构造函数，这样在新Suber()函数中定义的所有对象初始化代码//2.传递参数function Super1(name){this.name = name;}function Suber1(){Super1.call(this,’chenpeng’);this.age = 29;}var instance = new Suber1();console.log(instance.name);console.log(instance.age) //借用构造函数的问题：方法都在构造函数中，无法复用 组合继承(combination inheritance)或者伪经典继承,背后的思路是使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承function Super2(name){this.name = name;this.colors = [‘red’,’blue’,’green’];}Super2.prototype.sayName = function(){console.log(this.name);}function Suber2(name,age){Super2.call(this,name); this.age = age;}Suber2.prototype = new Super2();Suber2.prototype.constructor = Suber2;Suber2.prototype.sayAge = function(){console.log(this.age);}var instance1 = new Suber2(‘chenpeng’,26);instance1.colors.push(‘black’);console.log(instance1.colors);instance1.sayName();instance1.sayAge();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Bootstrap One:table and Form]]></title>
      <url>%2F2017%2F02%2F03%2Fbootstrap-one-table-and-form%2F</url>
      <content type="text"><![CDATA[bootstrap:Sleek, intuitive, and powerful front-end framework for faster and easier web development.(简洁、直观、强悍的前端开发框架，让web开发更迅速、简单。) table.table:defalt property.table.striped:条纹状表格.table-bordered:带边框的表格.table-hover:鼠标悬停.table-condensed:紧缩表格 form 1234567891011121314151617181920212223242526&lt;form action="#" class="form-horizontal"&gt; &lt;div class="form-group"&gt; &lt;label for='exampleInputEamil'class="col-lg-1 control-label"&gt; Email &lt;/label&gt; &lt;div class='col-lg-11'&gt; &lt;input type="text" id="exampleInputEamil" class="form-control" placeholder="email address"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for='exampleInputPassword' class="col-lg-1 control-label"&gt; Password &lt;/label&gt; &lt;div class='col-lg-11'&gt; &lt;input type="text" id="exampleInputPassword" class="form-control" placeholder="Password "&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-lg-1 col-lg-offset-1"&gt; &lt;div class="checkbox"&gt; &lt;label&gt;&lt;input type='checkbox'&gt;Remembe&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-lg-1 col-lg-offset-1"&gt; &lt;button class='btn btn-default'&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; .form-control:表单的宽度.form-group:(纵向)表单上下加距离，为label/input外层加div的class.form-inline:给form添加内联表单.col-lg-offset-1:列偏移，往右移.input-group-addon:与文本框融合]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GIT Two :Learn How to Use Git (二)]]></title>
      <url>%2F2017%2F02%2F02%2FGIT-TWO-learn-how-to-use-git-%E4%BA%8C%2F</url>
      <content type="text"><![CDATA[working Directory :工作区 ；repository 版本库 包含stage/index(暂存区)，master branch; common knowledge change or discard change 管理或者撤销修改 1.git commit 只负责把暂存区的修改提交，如果之前没有用add 命令,git commit 不会提交 2.git checkout – file to discard changes in working directory,撤销修改 3.改乱了内容，还添加到了stage,第一步用命令 git reset HEAD file ,第二步再用git checkout – file 4.版本回退，git log &gt; git reset –hard 版本号 5.command git rm file 用于删除一个文件，如果一个文件已经提交到版本库里，不要担心误删，但是只能恢复到最新版本，会丢失最近一次提交后修改的内容，从版本库里删除需用到git rm,并且git commit remote repository git remote add origin git@github.com:niaogege/works.git git push -u origin master(第一次推送master分支的内容) 每次本地提交后，只要有必要，使用命令git push origin master 从remote repository download ,ues this command:git clone git@github.com:niaogege/works.git 创建、合并、删除分支 git checkout -b dev 相当于git branch dev 并且切换git checkout dev git branch 列出所有分支，当前分支用*表示 git checkout 切换分支 git merge dev 合并dev分支到当前分支 git branch -d 删除分支 git –graph 查看分支合并图 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 git merge –no-ff -m “merge with no-ff” dev:准备合并dev分支，请注意–no-ff参数，表示禁用Fast forward：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Jquery中each()方法的使用指南]]></title>
      <url>%2F2017%2F02%2F01%2Fjquery%E4%B8%AD-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
      <content type="text"><![CDATA[$.each()与$(selector).each()不同, 后者专用于jquery对象的遍历前者可用于遍历任何的集合(无论是数组或对象),如果是数组,回调函数每次传入数组的索引和对应的值(值亦可以通过this 关键字获取,但javascript总会包装this 值作为一个对象—尽管是一个字符串或是一个数字),方法会返回被遍历对象的第一参数.each()方法能使DOM循环结构简洁，不容易出错。each()函数封装了十分强大的遍历功能，使用也很方便，它可以遍历一维数组、多维数组、DOM, JSON 等等在javaScript开发过程中使用$each可以大大的减轻我们的工作量。 下面提一下each的几种常用的用法 each处理一维数组 12345var arr1 = [ "aaa", "bbb", "ccc" ]; $.each(arr1, function(i,val)&#123; alert(i); alert(val);&#125;); each处理二维数组 12345 var arr2 = [['a', 'aa', 'aaa'], ['b', 'bb', 'bbb'], ['c', 'cc', 'ccc']] $.each(arr, function(i, item)&#123; alert(i); alert(item); &#125;); 对此二位数组的处理稍作变更之后 1234567var arr = [['a', 'aa', 'aaa'], ['b', 'bb', 'bbb'], ['c', 'cc', 'ccc']] $.each(arr, function(i, item)&#123; $.each(item,function(j,val)&#123; alert(j); alert(val); &#125;); &#125;); 如果你dom中有一段这样的代码 1234&lt;input name="aaa" type="hidden" value="111" /&gt;&lt;input name="bbb" type="hidden" value="222" /&gt;&lt;input name="ccc" type="hidden" value="333" /&gt;&lt;input name="ddd" type="hidden" value="444"/&gt; 然后你使用each如下 123456$.each($("input:hidden"), function(i,val)&#123; alert(val);alert(i);alert(val.name);alert(val.value); &#125;); 如果将以上面一段代码改变成如下的形式 12345$("input:hidden").each(function(i,val)&#123;alert(i);alert(val.name);alert(val.value); &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[随笔：2017新春快乐！]]></title>
      <url>%2F2017%2F01%2F27%2F2017%E6%96%B0%E6%98%A5%E5%BF%AB%E4%B9%90%EF%BC%81%2F</url>
      <content type="text"><![CDATA[祝贺大家新春快乐，鸡年吉祥，恭喜发财！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[随笔：有时候几件趣事能让你 Recovery]]></title>
      <url>%2F2017%2F01%2F22%2F%E9%9A%8F%E7%AC%94%EF%BC%9A%E6%9C%89%E6%97%B6%E5%80%99%E5%87%A0%E4%BB%B6%E8%B6%A3%E4%BA%8B%E8%83%BD%E8%AE%A9%E4%BD%A0-Recovery%2F</url>
      <content type="text"><![CDATA[最近，身体有些不适，脑袋一直晕乎乎的，周六在家躺了一天，晚上尽量早点休息。大过年的，完全很淡定，心平气和，完全不像还有4天要过年的节奏。 好在今天下午坐车的时候，被逗逼给乐醒了，恍然大悟，头脑也不晕了。这个可以有！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[原生Js打印效果]]></title>
      <url>%2F2017%2F01%2F16%2F%E5%8E%9F%E7%94%9Fjs%E6%89%93%E5%8D%B0%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[原生js打印效果，主要用到以下几个知识点： 1.nbsp;半角的不断行的空白格（推荐使用）2.ensp; 半角的空格 3.emsp; 全角的空格,每个字符前面都加上&amp; 2.string.charAt()返回指定位置的字符 3.indexOf(),array.indexOf(item,start)返回某个指定的字符串在字符串中首次出现的位置 4.substring(),code.substring(0,pos)中的substring()用于提取字符串中介于两个指定下标之间的字符，substring()方法返回的子串包括 开始 处的字符，但不包括 结束 处的字符。 5.classList.add(),classList 属性返回元素的类名，作为 DOMTokenList 对象。该属性用于在元素中添加add，移除remove及切换toggle CSS 类。 源代码如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"/&gt; &lt;meta name="Keywords" content="" /&gt; &lt;meta name="Description" content="" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="viewpoint" content="width=device-width,initial-scale=1,user-scalable= no"/&gt; &lt;title&gt;0116 printer&lt;/title&gt; &lt;style type="text/css"&gt; .typewriter&#123;display:none;width:40em;line-height:1.6;border:1px solid #2dcb70;padding:1em 3em;margin:5em auto;font-family:Microsoft Yahei;font-weight:normal;white-space:normal;-webkit-font-smoothing:antialiased;/*字符反锯齿*/;color:hsla(0,10%,20%,0.9);&#125; .typewriter:after&#123;content:"_";animation:flash .6s steps(2,start) infinite;-webkit-animation:flash .6s steps(2,start) infinite;&#125; .typewriter.gameover:after&#123;display:none;&#125; @keyframes flash&#123; 0%&#123;visibility:visible;&#125; 100%&#123;visibility:hidden;&#125; &#125; @-webkit-keyframes flash&#123; 0%&#123;visibility:visible;&#125; 100%&#123;visibility:hidden;&#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="typewriter"&gt; &lt;!--1.&amp;nbsp; 半角的不断行的空白格（推荐使用）2.&amp;ensp; 半角的空格 3.&amp;emsp; 全角的空格--&gt; 1. Whatever is worth doing is worth doing well.&lt;br /&gt; &amp;emsp;任何值得做的，就把它做好。&lt;br /&gt;&lt;br /&gt; 2. Happiness is a way station between too much and too little.&lt;br /&gt; &amp;emsp;幸福是太多和太少之间的一站。&lt;br /&gt;&lt;br /&gt; 3. In love folly is always sweet.&lt;br /&gt; &amp;emsp;恋爱中，干傻事总是让人感到十分美妙。&lt;br /&gt;&lt;br /&gt; 4. The hard part isn’t making the decision. It’s living with it.&lt;br /&gt; &amp;emsp;做出决定并不困难，困难的是接受决定。&lt;br /&gt;&lt;br /&gt; 5. Your happy passer-by all knows, my distressed there is no place hides.&lt;br /&gt; &amp;emsp;你的幸福路人皆知，我的狼狈无处遁形。&lt;br /&gt;&lt;br /&gt; 6. You may be out of my sight, but never out of my mind.&lt;br /&gt; &amp;emsp;你也许已走出我的视线，但从未走出我的思念。 &lt;/div&gt; &lt;/body&gt; &lt;script&gt; (function()&#123; var typewriter=document.querySelector(".typewriter"), code=typewriter.innerHTML, pos=0, len=code.length; typewriter.innerHTML=""; typewriter.style.display="block"; function typewriting()&#123; pos++; if(pos &lt;= len)&#123; switch(code.charAt(pos)) //charAt()返回指定位置的字符 &#123; case "&lt;": //&lt;&gt;代码开始的字符 pos = code.indexOf("&gt;",pos); //array.indexOf(item,start)返回某个指定的字符串在字符串中首次出现的位置 break; case "&amp;": pos = code.indexOf(";",pos); break; &#125; typewriter.innerHTML=code.substring(0,pos);//substring()用于提取字符串中介于两个指定下标之间的字符，substring() 方法返回的子串包括 开始 处的字符，但不包括 结束 处的字符。 setTimeout(typewriting,100); &#125; else &#123; typewriter.classList.add("gameover");//classList 属性返回元素的类名，作为 DOMTokenList 对象。该属性用于在元素中添加，移除及切换 CSS 类。 &#125; &#125; typewriting(); &#125;)(); &lt;/script&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[随笔：大海我的故乡]]></title>
      <url>%2F2017%2F01%2F15%2F%E9%9A%8F%E7%AC%94%EF%BC%9A%E5%A4%A7%E6%B5%B7%E6%88%91%E7%9A%84%E6%95%85%E4%B9%A1%2F</url>
      <content type="text"><![CDATA[从小习惯了腥鱼烂虾的味道，每次回家都感觉特别温暖！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Goast Button,幽灵按钮特效]]></title>
      <url>%2F2017%2F01%2F15%2Fgoast-button-%E5%B9%BD%E7%81%B5%E6%8C%89%E9%92%AE%E7%89%B9%E6%95%88%2F</url>
      <content type="text"><![CDATA[有时候能看到这种效果的按钮，效果很棒，请看下图 极客学院有专门课程讲解，我们来看一下源代码! Html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang="ZH-CN"&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;meta name="keywords" content=""/&gt;&lt;meta name="description" content=""/&gt;&lt;link rel="shortcut icon" href=""&gt;&lt;title&gt;20170113 goast&lt;/title&gt;&lt;link type="" rel="stylesheet" href="style/0113.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div class="link link-miss"&gt; &lt;span class="icon"&gt;&lt;/span&gt; &lt;a href="#" class="button" data-title="My mission clear"&gt; &lt;span class="line line-top"&gt;&lt;/span&gt; &lt;span class="line line-left"&gt;&lt;/span&gt; &lt;span class="line line-bottom"&gt;&lt;/span&gt; &lt;span class="line line-right"&gt;&lt;/span&gt; MISSION &lt;/a&gt; &lt;/div&gt; &lt;div class="link link-play"&gt; &lt;span class="icon"&gt;&lt;/span&gt; &lt;a href="#" class="button" data-title="This is my palyground"&gt; &lt;span class="line line-top"&gt;&lt;/span&gt; &lt;span class="line line-left"&gt;&lt;/span&gt; &lt;span class="line line-bottom"&gt;&lt;/span&gt; &lt;span class="line line-right"&gt;&lt;/span&gt; PLAY &lt;/a&gt; &lt;/div&gt; &lt;div class="link link-touch"&gt; &lt;span class="icon"&gt;&lt;/span&gt; &lt;a href="#" class="button" data-title="Let's do something together"&gt; &lt;span class="line line-top"&gt;&lt;/span&gt; &lt;span class="line line-left"&gt;&lt;/span&gt; &lt;span class="line line-bottom"&gt;&lt;/span&gt; &lt;span class="line line-right"&gt;&lt;/span&gt; TOUCH &lt;/a&gt; &lt;/div&gt; &lt;div class="tip"&gt; &lt;em&gt;&lt;/em&gt; &lt;!--提示性文字--&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="http://libs.baidu.com/jquery/1.11.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="js/0113.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Css 这里涉及部分css3属性，所以对于低版本的browser的支持效果不是很好 1234567891011121314151617181920212223242526272829303132body&#123;background: #333;font-family: 'Microsoft Yahei';&#125;a&#123;text-decoration:none;cursor:pointer;&#125;.box&#123;width:800px;height:280px;margin: 50px auto;&#125;.box .link&#123;width:205px;height:280px;margin:10px 20px;float:left;position:relative;&#125;.link .icon&#123;width:100%;height:190px;display:block;transition:all 1s linear;-webkit-transition:all 1s linear;-moz-transition:all 1s linear;-ms-transition:all 1s linear;&#125;.link-miss .icon&#123;background: url('../images/mission.png') no-repeat center center;&#125;.link-play .icon&#123;background: url('../images/play.png') no-repeat center center;&#125;.link-touch .icon&#123;background: url('../images/touch.png') no-repeat center center;&#125;.link .icon:hover&#123;-webkit-transform: rotate(360deg) scale(1.1); -o-transform: rotate(360deg) scale(1.1);-moz-transform: rotate(360deg) scale(1.1);-ms-transform: rotate(360deg) scale(1.1);&#125;.button&#123;display:block;font-size:16px;font-weight:bolder;border:2px solid rgba(255,255,255,.8);padding-left:20px;margin: 0 auto;width:180px;height:50px;line-height:50px;color: #2dcb70;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;background: url('../images/allow.png') /*设置背景指示图位移*/ no-repeat 130px 50%;position:relative;transition:all 0.3s ease;-webkit-transition:all 0.3s ease;-moz-transition:all 0.3s ease;-ms-transition:all 0.3s ease;&#125;.button:hover&#123; border:2px solid rgba(255,255,255,1);background-position:140px center;&#125;.button .line&#123;display:block;position:absolute;background:none;transition:all 0.2s ease;-webkit-transition:all 0.2s ease;-moz-transition:all 0.2s ease;-ms-transition:all 0.2s ease;&#125;/*过渡效果必须放在初始值*/.button:hover .line&#123;background:#fff;&#125; /*background:#fff背景色为白色*//*1、高度不变 2宽度在变 3位置在变*/.button .line-top&#123;height:2px;width:0px;left:-110%;top:-2px;&#125;.button:hover .line-top&#123;width:100%;left:-2px;&#125;.button .line-bottom&#123;height:2px;width:0px;right:-110%;bottom:-2px;&#125;.button:hover .line-bottom&#123;width:100%;right:-2px;&#125;/*1、宽度不变 2高度在变 3位置在变*/.button .line-left&#123;width:2px;height:0;left:-2px;bottom:-110%;&#125;.button:hover .line-left&#123;height:100%;bottom:-2px;&#125;.button .line-right&#123;width:2px;height:0;right:-2px;top:-110%;&#125;.button:hover .line-right&#123;height:100%;top:-2px;&#125;.box .tip&#123;position:absolute;padding:0 14px;height:35px;line-height:35px;background: #2dcb70;color:#fff;top:160px;font-size:16px;font-weight:normal;text-transform:none;/*uppercase;capitalize;lowercase转换不同文本的大小写*/margin:0 auto;border-radius:3px;opacity:0;/*透明度为0隐藏*/&#125;.tip em&#123;font-style:normal;&#125;.tip span&#123;width:0;height:0;overflow:hidden;left:50%;margin-left:-3px; position:absolute;top:100%;border:7px solid transparent;border-top-color: #2dcb70;/*倒三角*/&#125; 这里有必要提一下几个知识点： background属性eg:body{background: #00FF00 url(bgimage.gif) no-repeat fixed top;}可能的值：background-position 规定背景图像的位置。background-size 规定背景图片的尺寸。background-repeat 规定如何重复背景图像。background-origin 规定背景图片的定位区域。background-clip 规定背景的绘制区域。background-attachment 规定背景图像是否固定或者随着页面的其余部分滚动。 transition属性eg:div{width:100px;transition: width 2s;-moz-transition: width 2s; / Firefox 4 /-webkit-transition: width 2s; / Safari 和 Chrome /-o-transition: width 2s; / Opera /}语法:transition-property 规定设置过渡效果的 CSS 属性的名称。transition-duration 规定完成过渡效果需要多少秒或毫秒。transition-timing-function 规定速度效果的速度曲线。transition-delay 定义过渡效果何时开始。 注意：transition属性必须设置在代码的初始值里 text-transform属性text-transform:转换不同文本的大小写，值有：uppercase(大写);capitalize(首字母大写);lowercase(小写) Javascript 这里用到jquery12345678910111213$(function()&#123; $('.link .button').hover(function()&#123; var title = $(this).attr('data-title'); $('em').text(title); //em承载的内容就是title var pos = $(this).offset().left; var dis = ($('.tip').outerWidth() - $(this).outerWidth())/2; var f = pos - dis; $('.tip').css(&#123;'left':f+'px'&#125;).animate(&#123;'top':'190','opacity':'1'&#125;,300);; &#125;,function()&#123; $('.tip').animate(&#123;'top':160,"opacity":'0'&#125;,300); &#125;); &#125;); 总结： 1.位移的计算：var pos = $(this).offset().left;var dis = ($(&apos;.tip&apos;).outerWidth() - $(this).outerWidth())/2; var f = pos - dis;&lt;/code&gt; 2.很多css3属性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GIT One :How to Use Git]]></title>
      <url>%2F2017%2F01%2F11%2FGIT-one-how-to-use-git%2F</url>
      <content type="text"><![CDATA[git与github紧密相连，git一定要回使用！git 常用操作以及快捷键，学习来源 廖雪峰老师官方网站，廖老师讲得很是不错的，对于初学者很实用！ 1$ mkdir casework //创建一个名为‘casework’文件夹 1$ cd casework 1$ pwd //显示当前目录 1$ git init //把这个目录变成git可以管理的工具 在当前目录下，新建一个readme.txt 1$ git add readme.txt //把readme.txt增加到暂存区 1$ git commit -m "write a readme file" //把暂存区的readme提交到master分支下 修改当前的readme.txt文件 1$ git status //查看当前仓库的状态 1$ git diff //查看修改的内容 再次修改readme文件 1$ git add readme.txt //把readme.txt增加到暂存区 1$ git commit -m "append GPL" //把暂存区的readme提交到master分支下 1$ git log //用git查看历史版本或者git log --pretty = oneline 1$git reset --hard HEAD^ //HEAD表示当前的版本，回到上一个版本HEAD^ 1$ cat readme.txt //查看内容 1$ git log //查看现在版本库的状态 1$ git reset --hard 382412 //又回到之前的最新版本 1$ git reflog //查看记录每次版本的id In conclusion: HEAD表示当前的版本，回到上一个版本HEAD^,HEAD用于版本之间历史的穿梭 git reset –hard commit_id 穿梭前用git log ，这样能知道会退到哪一个版本 重返未来用git reflog]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图片的一扫而过的闪影]]></title>
      <url>%2F2017%2F01%2F09%2F%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%80%E6%89%AB%E8%80%8C%E8%BF%87%E7%9A%84%E9%97%AA%E5%BD%B1%2F</url>
      <content type="text"><![CDATA[一些网站的logo采用的这种效果 这里用到的依然是伪元素，:before和:after，这里需要注意的一点的是用到了position:absolute，只有设定了位移，幻影才能随之漂浮！ 实例一1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;图片效果&lt;/title&gt;&lt;style type="text/css"&gt; .banner&#123;float:left;width: 250px; padding-top:10px;display:line-block;position:relative;&#125; .banner:before&#123; content:""; position: absolute; left: -600px; top: -600px; width: 300px; height: 15px;outline:px solid red; background-color: rgba(255,255,255,.6); -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); transform: rotate(-45deg); -webkit-animation: searchLights 1s ease-in 0.5s infinite; -o-animation: searchLights 1.s ease-in 0.5s infinite; animation: searchLights 1s ease-in 0.5s infinite;&#125;@-webkit-keyframes searchLights &#123; 0% &#123; left: -200px; top: 0; &#125; to &#123; left: 220px; top: 100px; &#125;&#125;@-o-keyframes searchLights &#123; 0% &#123; left: -200px; top: 0; &#125; to &#123; left: 220px; top: 100px; &#125;&#125;@-moz-keyframes searchLights &#123; 0% &#123; left: -200px; top: 0; &#125; to &#123; left: 220px; top: 100px; &#125;&#125;@keyframes searchLights &#123; 0% &#123; left: -200px; top: 0; &#125; to &#123; left: 220px; top: 100px; &#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="banner"&gt;&lt;img src="http://bbs.zizhuxuexi.cn/static/image/fg_hlximg/logo.png" alt="学习网" /&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 其实，就是一个：before加上css中的animation效果，这里我将animation-duration的时间改为0.8，即完成动画所花费的时间缩短了0.2s,but阴影的宽度加长了15px 示例二123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;图片效果&lt;/title&gt;&lt;style type="text/css"&gt;.banner&#123;float:left;width: 250px; padding-top:10px;display:line-block;&#125;.banner:before&#123; content:""; position: absolute; left: -600px; top: -600px; width: 200px; height: 30px; background-color: rgba(255,255,255,.6); -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); transform: rotate(-45deg);-webkit-animation: searchLights 0.8s ease-in 0.5s infinite; -o-animation: searchLights 0.8.s ease-in 0.5s infinite; animation: searchLights 0.8s ease-in 0.5s infinite;&#125;@-webkit-keyframes searchLights &#123; 0% &#123; left: -200px; top: 0; &#125; to &#123; left: 220px; top: 100px; &#125;&#125;@-o-keyframes searchLights &#123; 0% &#123; left: -200px; top: 0; &#125; to &#123; left: 220px; top: 100px; &#125;&#125;@-moz-keyframes searchLights &#123; 0% &#123; left: -200px; top: 0; &#125; to &#123; left: 220px; top: 100px; &#125;&#125;@keyframes searchLights &#123; 0% &#123; left: -200px; top: 0; &#125; to &#123; left: 220px; top: 100px; &#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="banner"&gt;&lt;img src="http://bbs.zizhuxuexi.cn/static/image/fg_hlximg/logo.png" alt="学习网" /&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 实例三 这里的animation: searchLights 0.8s ease-in 0.5s infinite;中的infinite是无限次播放，把它去掉或者设置1次就能实现只闪一下的效果，并且还把animation: searchLights 0.8s ease-in 0.5s infinite;中的延时播放animation-delay:：0.5s去掉，就是一跳转就实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;图片效果&lt;/title&gt;&lt;style type="text/css"&gt;.banner&#123;float:left;width: 250px; padding-top:10px;display:line-block;&#125;.banner:before&#123; content:""; position: absolute; left: -600px; top: -600px; width: 200px; height: 30px; background-color: rgba(255,255,255,.6); -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); transform: rotate(-45deg);-webkit-animation: searchLights 0.8s ease-in 1; -o-animation: searchLights 0.8.s ease-in .1; animation: searchLights 0.8s ease-in 1;&#125;@-webkit-keyframes searchLights &#123; 0% &#123; left: -200px; top: 0; &#125; to &#123; left: 220px; top: 100px; &#125;&#125;@-o-keyframes searchLights &#123; 0% &#123; left: -200px; top: 0; &#125; to &#123; left: 220px; top: 100px; &#125;&#125;@-moz-keyframes searchLights &#123; 0% &#123; left: -200px; top: 0; &#125; to &#123; left: 220px; top: 100px; &#125;&#125;@keyframes searchLights &#123; 0% &#123; left: -200px; top: 0; &#125; to &#123; left: 220px; top: 100px; &#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="banner"&gt;&lt;img src="http://bbs.zizhuxuexi.cn/static/image/fg_hlximg/logo.png" alt="学习网" /&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[伪元素：：Before和after的梯形效果]]></title>
      <url>%2F2017%2F01%2F08%2F%E4%BC%AA%E5%85%83%E7%B4%A0%EF%BC%9A%EF%BC%9Abefore%E5%92%8Cafter%E7%9A%84%E6%A2%AF%E5%BD%A2%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[伪元素介绍 CSS 伪元素用于向某些选择器设置特殊效果 伪元素的语法： selector:pseudo-element {property:value;} “:before” 伪元素可以在元素的内容前面插入新内容。 “:after” 伪元素可以在元素的内容之后插入新内容。 伪元素的梯形特效实例一：&lt;style&gt; #con_right_tit5{display: block;height:45px;position:absolute;font-size: 18px;line-height: 45px;background: #6e80be;color:white;padding: 0 38px 0 18px;transition:all 0.5s ease-in-out;-webkit-transition:all 0.5s ease-in-out;-moz-transition:all 0.5s ease-in-out;top:70px;} #con_right_tit5 a{color: white;} #con_right_tit5:hover{background: black;} #con_right_tit5::after{content: &quot;&quot;;border-left: solid 22px rgba(0, 0, 0, 0);border-top: rgb(249, 247, 246) 20px solid;position: absolute;right: 0;top: 0;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;con_right_tit5&quot;&gt;教育资讯&lt;/div&gt; &lt;/body&gt; 其实，这里只是一个正方形盖在了div上面，border的边框其中还带有opacity:0,如 实例二：&lt;style&gt; #con_right_tit5{display: block;height:45px;position:absolute;font-size: 18px;line-height: 45px;background: #6e80be;color:white;padding: 0 38px 0 18px;transition:all 0.5s ease-in-out;-webkit-transition:all 0.5s ease-in-out;-moz-transition:all 0.5s ease-in-out;top:70px;} #con_right_tit5 a{color: white;} #con_right_tit5:hover{background: black;} #con_right_tit5::after{content: &quot;&quot;;border-left: solid 22px yellow;border-top: red 20px solid;position: absolute;right: 0;top: 0;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;con_right_tit5&quot;&gt;教育资讯&lt;/div&gt; &lt;/body&gt; 优化与改进 至于为什么：：after里的边框border—left和border-top会是这种两个三角形组成的长方形，我也是搞不明白。不过，这里的三角形可以根据透明度（opacity属性）来调整相应的透明度 实例三：&lt;style&gt; #con_right_tit5{display: block;height:45px;position:absolute;font-size: 18px;line-height: 45px;background: #6e80be;color:white;padding: 0 38px 0 18px;transition:all 0.5s ease-in-out;-webkit-transition:all 0.5s ease-in-out;-moz-transition:all 0.5s ease-in-out;top:70px;} #con_right_tit5 a{color: white;} #con_right_tit5:hover{background: black;} #con_right_tit5::after{content: &quot;&quot;;border-left: solid 22px rgba(0,0,0,0.9);border-top: white 20px solid;position: absolute;right: 0;top: 0;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;con_right_tit5&quot;&gt;教育资讯&lt;/div&gt; &lt;/body&gt; 最近访客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[个人网站 搭建经历]]></title>
      <url>%2F2017%2F01%2F06%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is My very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 建立个人站点经过从去年10月份某天晚上，看过几位前端大牛，比如我非常钦佩的 张雯莉 ，还有 IronPans等，自己的站点建得很棒，心血来潮，也想尝试一下。后来得知有一种搭建个人站点的Hexo框架很方便也很省事。经过2天的深挖，看 技术文档，这里不得不佩服，这位来自厦门的hexo+next主题的创始人 iissnan，年轻有为，好好学习！ 本人主要参考的文章来自 简书 使用Github搭建Hexo技术博客托管在GitHub Pages上–安装教程 Preparation建个人站点前段时间，也有点迷茫，因为自己对于后端、服务器的相关知识一点不了解。现在建起来了，还是对后端有点一无所知，只是对域名、域名解析、git的使用操作有了更深刻的了解吧。关于hexo+github建站的教程网上很多，这里我推荐简书的使用Github搭建Hexo技术博客托管在GitHub Pages上–安装教程 ，这里就不多阐述。这里主要讲讲自己踩过的坑 Git与github的绑定Git是分布式的代码管理工具，远程的代码管理是基于ssh的，所以要使用远程的git则需要ssh的配置。github的ssh配置如下： 设置git的user name和email：$ git config –global user.name “xuhaiyan”$ git config –global user.email “haiyan.xu.vip@gmail.com” 生成SSH密钥过程：1.查看是否已经有了ssh密钥：cd ~/.ssh,如果没有密钥则不会有此文件夹，有则备份删除2.生存密钥：$ ssh-keygen -t rsa -C “your@gmail.com”按3个回车，密码为空。 在github上添加ssh密钥，这要添加的是”id_rsa.pub’里面的公钥。 测试：ssh git@github.com 域名创建和域名解析自己是在自己阿里云买的，很便宜，当然如果顶级域名以.cn或者.com费用还是可以的，域名买好之后，还得去搞个服务器吧，好存储资源，阿里云服务器还是有点小贵的，所以只能把本地代码托管在github上，这也是为什么要用git的原因。 安装Node.js安装地址：nodejs,nodejs是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。妈的，nodejs学问太过深奥，我估计得等到明年在慢慢磨，这里只是借用nodejs的npm安装hexo和 next 安装和部署Hexo 打开git客户端,Git bash Here 1$ npm install -g hexo 1$ hexo init ######注：这个命令会初始化博客的目录，所以，执行这个命令时，在你想创建的目录下执行，就自动生成到对应目录下。 Hexo命令 12345hexo new post "wendang title" #新建,default有三种布局，post、page、draft，后面加文字标题hexo new page "pageName" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHub Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 小结 有些东西看似很复杂，但是如果有毅力坚持去磨的话还是有希望攻破的，加油！niaogege 最近访客]]></content>
    </entry>

    
  
  
</search>
