<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端基础: 设计模式</title>
      <link href="/2021/03/28/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/03/28/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>从架构层面考虑设计，从上往下看，而不是只顾往下看<br>设计模式的定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。<br>设计模式就是一种理念，通过一些设计思维来解决平时编写底层或业务代码时遇到的场景问题。比如早期业务中的一个封装类，同时带有一些封装方法。如果现在该类不能再满足全部业务场景，且不允许修改原方法，此时就需要装饰器或适配器模式来解决；又比如当设计一个场景，在调用一个固定对象时一定要先执行某些方法，比如验证登录、验证身份ID等场景，此时就应该用到代理模式。</p><h2 id="装饰者模式-Decorator"><a href="#装饰者模式-Decorator" class="headerlink" title="装饰者模式 Decorator"></a>装饰者模式 Decorator</h2><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>在原来方法的基础上装饰一些针对特殊场景所适用的方法，即添加一些新功能，主要特征</p><ul><li>为对象添加新功能</li><li>不改变原有的结构和功能，即原本的功能得继续用<h3 id="实现-one"><a href="#实现-one" class="headerlink" title="实现 one"></a>实现 one</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    draw() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'画一个圆'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(circle) &#123;</span><br><span class="line">      <span class="keyword">this</span>.circle = circle</span><br><span class="line">    &#125;</span><br><span class="line">    draw() &#123;</span><br><span class="line">      <span class="keyword">this</span>.circle.draw()</span><br><span class="line">      <span class="keyword">this</span>.setRedBorder()</span><br><span class="line">    &#125;</span><br><span class="line">    setRedBorder() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'画一个红色的边框'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> circle = <span class="keyword">new</span> Circle()</span><br><span class="line">  <span class="keyword">const</span> decorator = <span class="keyword">new</span> Decorator(circle) <span class="comment">// 传入一个实例</span></span><br><span class="line">  decorator.draw()</span><br><span class="line"><span class="comment">// 画一个圆</span></span><br><span class="line"><span class="comment">// 画一个红色的边框</span></span><br></pre></td></tr></table></figure>该例中，我们写了一个Decorator装饰器类，它重写了实例对象的draw方法，给其方法新增了一个setRedBorder()，因此最后为其输出结果进行了装饰。<h3 id="实现-two"><a href="#实现-two" class="headerlink" title="实现 two"></a>实现 two</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装饰器，在当前函数执行前先执行另一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DecoratorBefore</span>(<span class="params">fn, beforeFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = beforeFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">     <span class="comment">// 在前一个函数中判断，不需要执行当前函数</span></span><br><span class="line">    <span class="keyword">if</span>(res !== <span class="literal">false</span>) &#123;</span><br><span class="line">        fn.apply(<span class="keyword">this</span>.arguments)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">learn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'learn 学习'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shufa</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'书法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'run'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> d = DecoratorBefore(shufa, run)</span><br><span class="line">d = DecoratorBefore(d, learn)</span><br><span class="line">d()</span><br><span class="line">VM3126:<span class="number">12</span> learn 学习</span><br><span class="line">VM3126:<span class="number">18</span> run</span><br><span class="line">VM3126:<span class="number">15</span> 书法</span><br></pre></td></tr></table></figure><h3 id="装饰器插件"><a href="#装饰器插件" class="headerlink" title="装饰器插件"></a>装饰器插件</h3>ES7 中就存在了装饰器语法，需要安装相应的babel插件，一起看一下该插件如何用，首先安装一下插件，并做相关的语法配置：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-plugin-transform-decorators-legacy </span><br><span class="line"></span><br><span class="line"><span class="comment">//.babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>: [<span class="string">"es2015"</span>, <span class="string">"latest"</span>],</span><br><span class="line">    <span class="string">"plugins"</span>: [<span class="string">"transform-decorators-legacy"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>给一个Demo类上添加一个装饰器 testDec，此时 Demo类就具有了 装饰器赋予的属性：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@testDec</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testDec</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">   target.isDec = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(Demo.isDec) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>得出结论<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@decorator </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line">A = decorator(A) || A;</span><br></pre></td></tr></table></figure></li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li>Vue项目里的 vue-property-decorator <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Vue &#125; <span class="keyword">from</span> <span class="string">'vue-property-decorator'</span></span><br><span class="line"><span class="meta">@Component</span>(&#123;&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> MaskLayer <span class="keyword">extends</span> Vue &#123;&#125;</span><br></pre></td></tr></table></figure></li><li>mixin 示例<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">Object</span>.assign(target.prototype, ...list)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">    foo() &#123;</span><br><span class="line">        alert(<span class="string">'foo'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure>上例中，Foo作为target的实参，MyClass作为 list的实参，最终实现将Foo的所有原型方法（foo）装饰到 MyClass类上，成为了MyClass的方法。最终代码的运行结果是执行了foo()</li></ul><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p><a href="http://niaogege.cn/2020/12/13/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E8%A3%85%E9%A5%B0%E5%99%A8/">ts里的装饰器, 更新中</a></p><h2 id="发布-订阅模式（Observer-Pattern）"><a href="#发布-订阅模式（Observer-Pattern）" class="headerlink" title="发布-订阅模式（Observer Pattern）"></a>发布-订阅模式（Observer Pattern）</h2><p>发布-订阅模式又叫观察者模式，也称作观察者模式，定义了对象间的一种一对多的依赖关系，当一个对象的状态发 生改变时，所有依赖于它的对象都将得到通知。JavaScript 本身也是一门基于事件驱动的语言，也利用了发布订阅模式</p><p>它的作用是当一个对象的状态发生变化时，能够自动通知其他关联对象，自动刷新对象状态，或者说执行对应对象的方法。<br>这种设计模式可以大大降低程序模块之间的耦合度，便于更加灵活的扩展和维护。</p><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>观察者模式包含两种角色：</p><p>观察者（订阅者）<br>被观察者（发布者）</p><p>核心思想：订阅者只要订阅了发布者的事件，那么当发布者的状态改变时，发布者会主动去通知观察者，而无需关心订阅者得到事件后要去做什么，实际程序中可能是执行订阅者中的回调函数。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>支持简单的广播通信，当对象状态发生改变时，会自动通知已经订阅过的对象。</li><li>解耦, 发布者与订阅者耦合性降低，发布者只管发布一条消息出去，它不关心这条消息如何被订阅者使用，同时，订阅者只监听发布者的事件名，只要发布者的事件名不变，它不管发布者如何改变</li><li>缺点：创建订阅者本身要消耗一定的时间和内存，订阅的处理函数不一定会被执行，驻留内存有性能开销，弱化了对象之间的联系，复杂的情况下可能会导致程序难以跟踪维护和理解(如果过多的使用发布订阅模式, 会增加维护的难度)</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.watchers = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 订阅主题和回调函数</span></span><br><span class="line">  subscribe(key, fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.watchers[key] = <span class="keyword">this</span>.watchers[key] || []</span><br><span class="line">    <span class="keyword">this</span>.watchers[key].push(fn)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 主题发布以及传参</span></span><br><span class="line">  publish(key, data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.watchers[key] &amp;&amp; <span class="keyword">this</span>.watchers[key].length) &#123;</span><br><span class="line">      <span class="keyword">this</span>.watchers[key].forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">        fn(data);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取消主题或者指定事件退订</span></span><br><span class="line">  unsubscribe (key = <span class="string">''</span>, fn = <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fn) &#123;</span><br><span class="line">      <span class="comment">// 如果只取消</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.watchers[key] &amp;&amp; <span class="keyword">this</span>.watchers[key].length) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = <span class="keyword">this</span>.watchers[key].findIndex(<span class="function"><span class="params">cb</span> =&gt;</span> <span class="built_in">Object</span>.is(cb, fn))</span><br><span class="line">        <span class="keyword">this</span>.watchers[key].splice(index, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key) &#123;</span><br><span class="line">       <span class="keyword">this</span>.watchers[key] = []</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.watchers = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> event = <span class="keyword">new</span> Event();</span><br><span class="line"><span class="keyword">const</span> eatFn = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data, <span class="string">'eat'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> studyFn = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data, <span class="string">'come on 加油'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据主题 订阅</span></span><br><span class="line">event.subscribe(<span class="string">'eat'</span>, eatFn);</span><br><span class="line">event.subscribe(<span class="string">'study'</span>,studyFn);</span><br><span class="line"><span class="comment">// 根据主题进行发布</span></span><br><span class="line">event.publish(<span class="string">'study'</span>, <span class="string">'study PUBLISH'</span>);</span><br><span class="line">event.publish(<span class="string">'eat'</span>, <span class="string">'eat PUBLISH'</span>);</span><br></pre></td></tr></table></figure><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><ul><li>JS中的事件就是经典的发布-订阅模式的实现<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们向某dom文档订阅了点击事件，当点击发生时，他会执行我们传入的callback</span></span><br><span class="line">element.addEventListener(‘click’, callback2, <span class="literal">false</span>)</span><br><span class="line">element.addEventListener(‘click’, callback2, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>或者Vue<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">事件发布者使用<span class="string">'vm.$emit、vm.$dispatch(vue1.0)、vm.$broadcast(vue1.0)发布事件</span></span><br><span class="line"><span class="string">// 接受方使用$on方法或组件监听器订阅事件，传递一个回调函数</span></span><br><span class="line"><span class="string">vm.$emit(event, […args]) // publish</span></span><br><span class="line"><span class="string">vm.$on(event, callback) // subscribe</span></span><br><span class="line"><span class="string">vm.$off([event, callback]) // unsubscribe</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="外观模式（Facade-Pattern）"><a href="#外观模式（Facade-Pattern）" class="headerlink" title="外观模式（Facade Pattern）"></a>外观模式（Facade Pattern）</h2><p>也叫门面模式，外观模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用<br>实现:<br>外观设计模式就是把多个子系统中复杂逻辑进行抽象，从而提供一个更统一、更简洁、更易用的API。很多我们常用的框架和库基本都遵循了外观设计模式，比如JQuery就把复杂的原生DOM操作进行了抽象和封装，并消除了浏览器之间的兼容问题，从而提供了一个更高级更易用的版本。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三个处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'doing'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外观函数，将一些处理统一起来，方便调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    start();</span><br><span class="line">    doing();</span><br><span class="line">    end();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用init开始执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 此处直接调用了高层函数，也可以选择越过它直接调用相关的函数</span></span><br><span class="line">    execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init(); <span class="comment">// start doing end</span></span><br></pre></td></tr></table></figure><h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><p>我们可以应用外观模式封装一个统一的DOM元素事件绑定/取消方法，用于兼容不同版本的浏览器和更方便的调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">    element.addEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">    element.attachEvent(<span class="string">'on'</span> + event, handler);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    element[<span class="string">'on'</span> + event] = fn;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取消绑定</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeEvent</span>(<span class="params">element, event, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">    element.removeEventListener(event, handler, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">    element.detachEvent(<span class="string">'on'</span> + event, handler);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    element[<span class="string">'on'</span> + event] = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代理模式（Proxy-Pattern）"><a href="#代理模式（Proxy-Pattern）" class="headerlink" title="代理模式（Proxy Pattern）"></a>代理模式（Proxy Pattern）</h2><h3 id="核心-1"><a href="#核心-1" class="headerlink" title="核心"></a>核心</h3><p>为一个对象提供一个代用品或占位符，以便控制对它的访问。<br>使用者、目标对象和代理者，使用者的目的是直接访问目标对象，但却不能直接访问，而是要先通过代理者。因此该模式非常像明星代理人的场景。其特征为：</p><ul><li>使用者无权访问目标对象；</li><li>中间加代理，通过代理做授权和控制。</li></ul><p>代理模式确实很方便，通常如果面临一些很大开销的操作，就可以并采用虚拟代理的方式延迟到需要它的时候再去创建，比如懒加载操作。或者一些前置条件较多的操作，比如目标操作实现的前提必须是已登录，且Id符合一定特征，此时也可以将这些前置判断写到代理器中。举个加载图片的例子：</p><h3 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h3><ul><li><p>事件冒泡与事件捕获应用:事件代理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">"color_list"</span>&gt;        </span><br><span class="line">      &lt;li&gt;red&lt;<span class="regexp">/li&gt;        </span></span><br><span class="line"><span class="regexp">      &lt;li&gt;orange&lt;/</span>li&gt;        </span><br><span class="line">      &lt;li&gt;yellow&lt;<span class="regexp">/li&gt;        </span></span><br><span class="line"><span class="regexp">      &lt;li&gt;green&lt;/</span>li&gt;        </span><br><span class="line">      &lt;li&gt;blue&lt;<span class="regexp">/li&gt;        </span></span><br><span class="line"><span class="regexp">      &lt;li&gt;purple&lt;/</span>li&gt;    </span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">      function colorChange(e) &#123;</span></span><br><span class="line"><span class="regexp">        var e = e || window.event;</span></span><br><span class="line"><span class="regexp">        if (e.target.nodeName.toLowerCase === 'li') &#123;</span></span><br><span class="line"><span class="regexp">          box.innerHTML="该颜色为 "+e.target.innerHTML;         </span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">      color_list.addEventListener("click", colorChange, false)</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure><p>我们并未直接在元素上定义点击事件，而是通过监听元素点击事件，并通过定位元素节点名称来代理到<li>标签的点击，最终利用捕获事件来实现相应的点击效果。</p></li><li><p>缓存代理 可以为一些开销大的运算结果提供暂时的缓存，提升效率</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memo</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> key = [].join.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span>(cache.has(key))&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    cache.set(key, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getMemor = memo(<span class="function"><span class="keyword">function</span> <span class="title">slow</span>(<span class="params">x,y,z</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x + y + z, <span class="string">'total'</span>)</span><br><span class="line">  <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> test1 = getMemor(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> test2 = getMemor(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(test1)</span><br><span class="line"><span class="built_in">console</span>.log(test2)</span><br><span class="line"><span class="comment">// 6 "total" 只会执行一次</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure></li><li><p>ES6 proxy<br>ES6的 Proxy 相信大家都不会陌生，Vue 3.0 的双向绑定原理就是依赖 ES6 的 Proxy 来实现，给一个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proxy</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'cpp'</span>,</span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  obj,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">get</span>(target,key) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, key, val) &#123;</span><br><span class="line">      target[key] = val;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h2 id="工厂模式（Factory-Pattern）"><a href="#工厂模式（Factory-Pattern）" class="headerlink" title="工厂模式（Factory Pattern）"></a>工厂模式（Factory Pattern）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>当构造函数过多不方便管理，且需要创建的对象之间存在某些关联（有同一个父类、实现同一个接口,有同一个属性等）时，不妨使用工厂模式。工厂模式提供一种集中化、统一化的方式，避免了分散创建对象导致的代码重复、灵活性差/实例化重复的问题。</p><h3 id="核心-2"><a href="#核心-2" class="headerlink" title="核心"></a>核心</h3><ul><li>主要用于隐藏创建实例的复杂度，只需对外提供一个接口；</li><li>实现构造函数和创建者的分离，满足开放封闭的原则；</li></ul><p>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Suzuki汽车构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuzukiCar</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">  <span class="keyword">this</span>.brand = <span class="string">'Suzuki'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// BMW汽车构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BMWCar</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = color;</span><br><span class="line">  <span class="keyword">this</span>.brand = <span class="string">'BMW'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 汽车品牌枚举</span></span><br><span class="line"><span class="keyword">const</span> BRANDS = &#123;</span><br><span class="line">  suzuki: <span class="number">1</span>,</span><br><span class="line">  honda: <span class="number">2</span>,</span><br><span class="line">  bmw: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 汽车工厂 颜色一致 brand不一样</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CarFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">brand, color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (brand) &#123;</span><br><span class="line">      <span class="keyword">case</span> BRANDS.suzuki:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SuzukiCar(color);</span><br><span class="line">      <span class="keyword">case</span> BRANDS.bmw:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BMWCar(color);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> carFactory = <span class="keyword">new</span> CarFactory();</span><br><span class="line"><span class="keyword">const</span> cars = [];</span><br><span class="line">cars.push(carFactory.create(BRANDS.suzuki, <span class="string">'brown'</span>));</span><br><span class="line">cars.push(carFactory.create(BRANDS.bmw, <span class="string">'red'</span>));</span><br><span class="line"><span class="comment">// SuzukiCar &#123;color: "brown", brand: "Suzuki"&#125;</span></span><br><span class="line"><span class="comment">// BMWCar &#123;color: "red", brand: "BMW"&#125;</span></span><br></pre></td></tr></table></figure><p>使用工厂模式之后，不再需要重复引入一个个构造函数，只需要引入工厂对象就可以方便的创建各类对象。</p><h3 id="场景-4"><a href="#场景-4" class="headerlink" title="场景"></a>场景</h3><ul><li>jQuery的选择器$(selector)，$内置的实现机制是工厂模式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">jQuery</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(selector) &#123;</span><br><span class="line">        <span class="keyword">super</span>(selector)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.$ = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> jQuery(selector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Vue 异步组件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-example'</span> , (resolve , reject) =&gt; &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(&#123;</span><br><span class="line">            template: <span class="string">`&lt;div&gt;I am async!&lt;/div&gt;`</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="单例模式（Singleton-Pattern）"><a href="#单例模式（Singleton-Pattern）" class="headerlink" title="单例模式（Singleton Pattern）"></a>单例模式（Singleton Pattern）</h2><p>顾名思义，单例模式中Class的实例个数最多为1。当需要一个对象去贯穿整个系统执行某些任务时，单例模式就派上了用场。而除此之外的场景尽量避免单例模式的使用，因为单例模式会引入全局状态，而一个健康的系统应该避免引入过多的全局状态。</p><ul><li>确保只有一个实例</li><li>可以全局访问</li></ul><p>我们一般通过实现以下两点来解决上述问题：</p><ul><li>隐藏Class的构造函数，避免多次实例化</li><li>通过暴露一个 getInstance() 方法来创建/获取唯一实例<h3 id="实现-one-1"><a href="#实现-one-1" class="headerlink" title="实现 one"></a>实现 one</h3>Javascript中单例模式可以通过以下方式实现：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例构造器</span></span><br><span class="line"><span class="keyword">const</span> FooServiceSingleton = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 隐藏的Class的构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">FooService</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 未初始化的单例对象</span></span><br><span class="line">  <span class="keyword">let</span> fooService;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 创建/获取单例对象的函数</span></span><br><span class="line">    getInstance: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!fooService) &#123;</span><br><span class="line">        fooService = <span class="keyword">new</span> FooService();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> fooService;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>实现的关键点有：</li></ul><ol><li>使用 IIFE 创建局部作用域并即时执行；</li><li>getInstance() 为一个 闭包 ，使用闭包保存局部作用域中的单例对象并返回</li></ol><p>测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fooService1 = FooServiceSingleton.getInstance();</span><br><span class="line"><span class="keyword">const</span> fooService2 = FooServiceSingleton.getInstance();</span><br><span class="line"><span class="built_in">console</span>.log(fooService1 === fooService2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="实现-two-1"><a href="#实现-two-1" class="headerlink" title="实现 two"></a>实现 two</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result || (result = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getScript = singleton(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> script1 = getScript();</span><br><span class="line"><span class="keyword">const</span> script2 = getScript();</span><br><span class="line"><span class="built_in">console</span>.log(script1 === script2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="场景-5"><a href="#场景-5" class="headerlink" title="场景"></a>场景</h3><ul><li>因为 JavaScript 是无类的语言, 而且 JS 中的全局对象符合单例模式两个条件。很多时候我们把全局对象当成单例模式来使用,</li><li>Vue和React中的store</li></ul><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>解释: 对象有某个行为，但是在不同的场景中，该行为有不同的实现策略(根据不同参数可以命中不同的策略)<br>案例: 模式的场景如登录鉴权，鉴权算法取决于用户的登录方式是手机、邮箱或者第三方的微信登录等等，而且登录方式也只有在运行时才能获取，获取到登录方式后再动态的配置鉴权策略。所有这些策略应该实现统一的接口，或者说有统一的行为模式。<br>示例:<br>登录鉴权的例子我们仿照 passport.js 的思路通过代码来理解策略模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoginController</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.strategy = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">this</span>.setStrategy = <span class="function"><span class="keyword">function</span> (<span class="params">strategy</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    <span class="keyword">this</span>.login = <span class="keyword">this</span>.strategy.login;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户名、密码登录策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LocalStragegy</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.login = <span class="function">(<span class="params">&#123; username, password &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(username, password);</span><br><span class="line">    <span class="comment">// authenticating with username and password... </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 手机号、验证码登录策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PhoneStragety</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.login = <span class="function">(<span class="params">&#123; phone, verifyCode &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(phone, verifyCode);</span><br><span class="line">    <span class="comment">// authenticating with hone and verifyCode... </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第三方社交登录策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SocialStragety</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.login = <span class="function">(<span class="params">&#123; id, secret &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(id, secret);</span><br><span class="line">    <span class="comment">// authenticating with id and secret... </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loginController = <span class="keyword">new</span> LoginController();</span><br><span class="line"><span class="comment">// 调用用户名、密码登录接口，使用LocalStrategy</span></span><br><span class="line">app.use(<span class="string">'/login/local'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  loginController.setStrategy(<span class="keyword">new</span> LocalStragegy());</span><br><span class="line">  loginController.login(req.body);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用手机、验证码登录接口，使用PhoneStrategy</span></span><br><span class="line">app.use(<span class="string">'/login/phone'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  loginController.setStrategy(<span class="keyword">new</span> PhoneStragety());</span><br><span class="line">  loginController.login(req.body);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用社交登录接口，使用SocialStrategy</span></span><br><span class="line">app.use(<span class="string">'/login/social'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  loginController.setStrategy(<span class="keyword">new</span> SocialStragety());</span><br><span class="line">  loginController.login(req.body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>特点:</p><ul><li>在运行时切换算法和策略</li><li>更简洁，避免使用大量的条件判断</li><li>分离，每个strategy类控制自己的算法逻辑，strategy和其使用者之间也相互独立</li></ul><h2 id="迭代-遍历器Iterator-pattern）"><a href="#迭代-遍历器Iterator-pattern）" class="headerlink" title="迭代(遍历器Iterator pattern）"></a>迭代(遍历器Iterator pattern）</h2><p>ES6中的迭代器 Iterator 相信大家都不陌生，迭代器用于遍历容器（集合）并访问容器中的元素，而且无论容器的数据结构是什么（Array、Set、Map等），迭代器的接口都应该是一样的，都需要遵循 迭代器协议。<br>迭代器模式解决了以下问题：<br>一种机制,各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p><p>ES6提供了更简单的迭代循环语法 for…of，使用该语法的前提是操作对象需要实现 可迭代协议（The iterable protocol），简单说就是该对象有个Key为 Symbol.iterator 的方法，该方法返回一个iterator对象。<br>比如我们实现一个 Range 类用于在某个数字区间进行迭代</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Range</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        next() &#123;</span><br><span class="line">          <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">value</span>: start++, <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: end &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (num <span class="keyword">of</span> Range(<span class="number">1</span>, <span class="number">5</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num); <span class="comment">//1 2 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://juejin.cn/post/6844903918330347533" target="_blank" rel="noopener">深入 JavaScript 设计模式，从此有了优化代码的理论依据</a></li><li><a href="https://zhuanlan.zhihu.com/p/133263261" target="_blank" rel="noopener">前端设计模式</a></li><li><a href="https://juejin.cn/post/6844903474535071752#heading-0" target="_blank" rel="noopener">JavaScript 常见设计模式解析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> v设计模式 </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础:js原型链与继承</title>
      <link href="/2021/03/28/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-js%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
      <url>/2021/03/28/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-js%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>继承是OO语言中的一个最为人津津乐道的概念.许多OO语言都支持两种继承方式: 接口继承 和 实现继承 .接口继承只继承方法签名,而实现继承则继承实际的方法.由于js中方法没有签名,在ECMAScript中无法实现接口继承.ECMAScript只支持实现继承,而且其 实现继承 主要是依靠原型链来实现的. </p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>简单回顾下构造函数,原型和实例的关系:<br>每个构造函数(constructor)都有一个原型对象(prototype),原型对象都包含一个指向构造函数的指针(constructor),而实例(instance)都包含一个指向原型对象的内部指针(<strong>proto</strong>)</p><blockquote><p><strong>proto</strong>是隐式原型，prototype是显式原型</p></blockquote><p>每个对象都有一个隐式原型，指向该对象的原型。实例化后通过<strong>proto</strong>属性指向构造函数的显式原型prototype,<br>原型链是由各个原型对象组成，每个对象都有<strong>proto</strong>属性，指向创建该对象的构造函数的原型，通过隐式原型<strong>proto</strong>属性将对象链起来，组成原型链，用来实现属性方法继承和共享</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.names = [<span class="string">'cpp'</span>, <span class="string">'wmh'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.names)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child()</span><br><span class="line">child1.names.push(<span class="string">'James'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child1.names) <span class="comment">// ["cpp", "wmh", "James"]</span></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="built_in">console</span>.log(child2.names) <span class="comment">// ["cpp", "wmh", "James"]</span></span><br><span class="line"><span class="built_in">console</span>.log(Parent.prototype.constructor === Parent)</span><br></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>当原型链中包含引用类型属性的时候，引用类型的属性会被所有实例共享</li><li>当创建Child子类的时候，不能向父类构造函数Parent传参<br>为此,下面将有一些尝试以弥补原型链的不足!</li></ul><h2 id="构造函数继承-constructor-stealing-经典继承"><a href="#构造函数继承-constructor-stealing-经典继承" class="headerlink" title="构造函数继承 constructor stealing (经典继承)"></a>构造函数继承 constructor stealing (经典继承)</h2><p>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.names = [<span class="string">'cpp'</span>, <span class="string">'wmh'</span>]</span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.names)</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="keyword">this</span>.getName()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="built_in">console</span>.log(child1)</span><br><span class="line"><span class="built_in">console</span>.log(child2)</span><br><span class="line"></span><br><span class="line">VM911:<span class="number">4</span> (<span class="number">2</span>) [<span class="string">"cpp"</span>, <span class="string">"wmh"</span>]</span><br><span class="line">VM911:<span class="number">4</span> (<span class="number">2</span>) [<span class="string">"cpp"</span>, <span class="string">"wmh"</span>]</span><br><span class="line">Child &#123;<span class="attr">names</span>: <span class="built_in">Array</span>(<span class="number">2</span>), <span class="attr">getName</span>: ƒ&#125; <span class="comment">// getName 调用1次</span></span><br><span class="line">Child &#123;<span class="attr">names</span>: <span class="built_in">Array</span>(<span class="number">2</span>), <span class="attr">getName</span>: ƒ&#125; <span class="comment">// getName 调用2次</span></span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>避免了引用类型的属性被所有实例共享</li><li>可以在 Child 中向 Parent 传参<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3>方法都在构造函数中定义，导致每次创建实例都会执行constructor方法</li></ul><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><h3 id="组合继承-有时候也叫做伪经典继承-指的是将原型链和借用构造函数的技术组合到一块-从而发挥两者之长的一种继承模式。即原型链继承-构造函数继承"><a href="#组合继承-有时候也叫做伪经典继承-指的是将原型链和借用构造函数的技术组合到一块-从而发挥两者之长的一种继承模式。即原型链继承-构造函数继承" class="headerlink" title="组合继承, 有时候也叫做伪经典继承,指的是将原型链和借用构造函数的技术组合到一块,从而发挥两者之长的一种继承模式。即原型链继承 + 构造函数继承"></a>组合继承, 有时候也叫做伪经典继承,指的是将原型链和借用构造函数的技术组合到一块,从而发挥两者之长的一种继承模式。即原型链继承 + 构造函数继承</h3><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路:"></a>基本思路:</h3><p>原型链实现对原型属性和方法的继承<br>构造函数实现对实例属性和方法的继承</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Parent const'</span>)</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'cpp'</span>)</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">'wmh'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child1)</span><br><span class="line"><span class="built_in">console</span>.log(child2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parent const</span></span><br><span class="line"><span class="comment">// Parent const</span></span><br><span class="line"><span class="comment">// Parent const</span></span><br><span class="line">VM1202:<span class="number">14</span> Child &#123;<span class="attr">name</span>: <span class="string">"cpp"</span>&#125;</span><br><span class="line">VM1202:<span class="number">15</span> Child &#123;<span class="attr">name</span>: <span class="string">"wmh"</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>融合原型链继承 + 构造函数继承两者优点，js常用的继承模式</p><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>创建实例会调用两次父类构造函数</li></ul><h2 id="原型式继承Object-create"><a href="#原型式继承Object-create" class="headerlink" title="原型式继承Object.create"></a>原型式继承Object.create</h2><p>ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型(对象的<strong>proto</strong>)。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockCreate</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  Fn.protptype = obj</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Fn()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'kevin'</span>,</span><br><span class="line">    friends: [<span class="string">'daisy'</span>, <span class="string">'kelly'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = mockCreate(person);</span><br><span class="line"><span class="keyword">var</span> person2 = mockCreate(person);</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">'person1'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line">person1.firends.push(<span class="string">'taylor'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// ["daisy", "kelly", "taylor"]</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：修改person1.name的值，person2.name的值并未发生改变，并不是因为person1和person2有独立的 name 值，而是因为person1.name = ‘person1’，给person1添加了 name 值，并非修改了原型上的 name 值。</p></blockquote><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>包含引用类型的属性值始终都会被实例共享，这点跟原型链继承缺点一样。</p><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>创建一个<strong>仅用于封装继承过程的函数</strong>,该函数在内部以某种方式来<strong>增强对象</strong>,最后再返回对象. 如下.</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(o); <span class="comment">// 原型式继承</span></span><br><span class="line">    clone.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 增强对象</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone; <span class="comment">// 记得返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> parent = &#123;<span class="attr">name</span>: <span class="string">'cpp'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> child = createObj(parent)</span><br><span class="line"><span class="built_in">console</span>.log(child)</span><br></pre></td></tr></table></figure><p>这个例子中的代码基于parent返回了一个新对象child. 新对象不仅具有parent的所有属性和方法, 而且还被增强了, 拥有了sayName()方法.<br>缺点也是 父类包含引用类型的属性值会被实例继承</p><h2 id="寄生组合-继承"><a href="#寄生组合-继承" class="headerlink" title="寄生组合 继承"></a>寄生组合 继承</h2><p>组合继承最大的缺点就是会两次调用父类构造函数,先回顾下组合继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1)<span class="string">`</span></span><br></pre></td></tr></table></figure><p>一次是<strong>设置子类型实例的原型</strong>的时候：<br><code>Child.prototype = new Parent();</code><br>一次在<strong>创建子类型实例</strong>的时候：<br><code>var child1 = new Child(&#39;kevin&#39;, &#39;18&#39;);</code><br>寄生组合式继承就是为了降低调用父类构造函数的开销而出现的</p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">foo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.foo = foo</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.printFoo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">bar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.bar = bar</span><br><span class="line">  Parent.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype)</span><br><span class="line">Child.prototype.constructor = Child <span class="comment">// 重新指标指向自己</span></span><br></pre></td></tr></table></figure><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockObject</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototype</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    child.prototype = mockObject(parent.prototype);</span><br><span class="line">    child.prototype.constructor = child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当我们使用的时候：</span></span><br><span class="line">prototype(Child, Parent);</span><br></pre></td></tr></table></figure><h2 id="es6版继承"><a href="#es6版继承" class="headerlink" title="es6版继承"></a>es6版继承</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(foo) &#123;</span><br><span class="line">    <span class="keyword">this</span>.foo = foo</span><br><span class="line">  &#125;</span><br><span class="line">  printInfo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(foo, bar) &#123;</span><br><span class="line">    <span class="keyword">super</span>(foo)</span><br><span class="line">    <span class="keyword">this</span>.bar = bar</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES5的继承，实质是先创造子类的实例对象，然后将再将父类的方法添加到this上。<br>ES6的继承，先创造父类的实例对象（所以必须先调用super方法，然后再用子类的构造函数修改this)</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://segmentfault.com/a/1190000009389979" target="_blank" rel="noopener">JavaScript深入之继承的多种方式和优缺点</a></li><li><a href="http://louiszhai.github.io/2015/12/15/prototypeChain/#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">详解JS原型链与继承</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> prototype </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-handWritng-series-updating</title>
      <link href="/2021/03/27/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-handWritng-series-updating/"/>
      <url>/2021/03/27/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-handWritng-series-updating/</url>
      
        <content type="html"><![CDATA[<h1 id="js基础"><a href="#js基础" class="headerlink" title="js基础"></a>js基础</h1><h2 id="手写const"><a href="#手写const" class="headerlink" title="手写const"></a>手写const</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_const</span>(<span class="params">obj, key, value</span>) </span>&#123;    </span><br><span class="line">  <span class="keyword">const</span> desc = &#123;        </span><br><span class="line">    value,        </span><br><span class="line">    writable: <span class="literal">false</span>    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, desc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_const(&#123;&#125;, <span class="string">'obj'</span>, &#123;<span class="attr">i</span>: <span class="number">1</span>&#125;)   <span class="comment">//定义obj</span></span><br><span class="line">obj.b = <span class="number">3</span>               <span class="comment">//可以正常给obj的属性赋值</span></span><br><span class="line">obj = &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="mock-Promise-精简，重点是明白其中异步调用原理）"><a href="#mock-Promise-精简，重点是明白其中异步调用原理）" class="headerlink" title="mock Promise(精简，重点是明白其中异步调用原理）"></a>mock Promise(精简，重点是明白其中异步调用原理）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line"><span class="keyword">this</span>.cbs = [];</span><br><span class="line"><span class="keyword">this</span>.data = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">var</span> resolve = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.data = data</span><br><span class="line"><span class="keyword">this</span>.cbs.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(data))</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">executor(resolve)</span><br><span class="line">&#125;</span><br><span class="line">then(onResolved, onReject) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.cbs.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> data = onResolved(<span class="keyword">this</span>.data)</span><br><span class="line">        <span class="keyword">if</span> (data <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            data.then(resolve)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试案例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="built_in">console</span>.log);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end line'</span>)</span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">//  end line</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure><h2 id="mock-async"><a href="#mock-async" class="headerlink" title="mock async"></a>mock async</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getData = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">"data"</span>), <span class="number">1000</span>))</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> getData()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'data: '</span>, data);</span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">await</span> getData()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'data2: '</span>, data2);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'success'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样的一个函数 应该再1秒后打印data 再过一秒打印data2 最后打印success</span></span><br><span class="line">test().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure><p>手写async(22行)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn 传入的generator生成器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncGenerator</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> gen = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">key, arg</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">let</span> generatorResult</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                generatorResult = gen[key](arg)</span><br><span class="line">              &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                reject(e)</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">const</span> &#123;value, done&#125; = generatorResult;</span><br><span class="line">              <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                <span class="keyword">return</span> resolve(value)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(value).then(</span><br><span class="line">                  val =&gt; step(<span class="string">'next'</span>, val),</span><br><span class="line">                  err =&gt; step(<span class="string">'throw'</span>, err)</span><br><span class="line">                )</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step(<span class="string">'next'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getData = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'data'</span>), <span class="number">1000</span>))</span><br><span class="line"><span class="keyword">var</span> test = asyncGenerator(</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">testG</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">yield</span> getData()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'data1: '</span>, data);</span><br><span class="line">    <span class="keyword">const</span> data2 = <span class="keyword">yield</span> getData()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'data2: '</span>, data2);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'success'</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">test().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res, <span class="string">'cpp'</span>))</span><br></pre></td></tr></table></figure><h2 id="封装一个类使对象可以被for-of遍历"><a href="#封装一个类使对象可以被for-of遍历" class="headerlink" title="封装一个类使对象可以被for of遍历"></a>封装一个类使对象可以被for of遍历</h2><p>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MakeIterator</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(obj) &#123;</span><br><span class="line"><span class="keyword">this</span>.obj = obj;</span><br><span class="line"><span class="keyword">this</span>.len = <span class="built_in">Object</span>.keys(obj).length;</span><br><span class="line"><span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="built_in">Symbol</span>.iterator]() &#123;<span class="keyword">return</span> <span class="keyword">this</span>;&#125;</span><br><span class="line">next() &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.index &lt; <span class="keyword">this</span>.len) &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">value: <span class="keyword">this</span>.obj[<span class="keyword">this</span>.index ++],</span><br><span class="line">done: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">value: <span class="literal">undefined</span>,</span><br><span class="line">done: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意对象的格式 类数组</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'wmh'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'cpp'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'chendap'</span>,</span><br><span class="line">length: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">of</span> <span class="keyword">new</span> MakeIterator(obj)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h2><p>难点主要是在于：一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。<br>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockBind</span>(<span class="params">context, ...rest</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> fbound =  <span class="function"><span class="keyword">function</span>(<span class="params">...rest2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [...rest, ...rest2];</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'——————self 绑定的函数'</span>, self)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'——————conetxt 绑定的对象'</span>, context)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'——————this 普通函数指向window 构造函数指向当前的 new 实例'</span>, <span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 当结果为 true 的时候，this 指向实例 也就是通过new方式调用</span></span><br><span class="line">    self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> self ? <span class="keyword">this</span> : context, args)</span><br><span class="line">  &#125;</span><br><span class="line">  fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">  fbound.prototype = <span class="keyword">new</span> fNOP()</span><br><span class="line">  <span class="keyword">return</span> fbound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.value); <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.mockBind = mockBind;</span><br><span class="line"><span class="keyword">var</span> sayFnMock = sayName.mockBind(obj2, <span class="string">'wmh'</span>)</span><br><span class="line"><span class="keyword">var</span> resMock = <span class="keyword">new</span> sayFnMock(<span class="string">'菜鸟Mock'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(resMock, <span class="string">'Mock的bind返回的值'</span>)</span><br></pre></td></tr></table></figure><h2 id="Apply"><a href="#Apply" class="headerlink" title="Apply"></a>Apply</h2><p>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockApply</span>(<span class="params">con, arr</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(con) || <span class="built_in">window</span>;</span><br><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(); <span class="comment">// 独一无二的值</span></span><br><span class="line">obj[sym] = <span class="keyword">this</span>;</span><br><span class="line"><span class="comment">// 执行函数;</span></span><br><span class="line"><span class="keyword">const</span> target = obj[sym](...arr);</span><br><span class="line"><span class="keyword">delete</span> obj[sym]</span><br><span class="line"><span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'cpp'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  alert(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.mockApply = mockApply</span><br><span class="line">sayName.mockApply(obj, [<span class="string">'菜鸟'</span>])</span><br></pre></td></tr></table></figure><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>step one: 创建一个空对象 obj;<br>step two: 将空对象的隐式原型（proto）指向构造函数的prototype。<br>step three: 使用 apply 改变 this 的指向<br>step four: 如果无返回值或者返回一个非对象值，则将 obj 返回作为新对象；如果返回值是一个新对象的话那么直接返回该对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockNew</span>(<span class="params">con, ...rest</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(con.prototype) || <span class="built_in">window</span>; <span class="comment">// step one two</span></span><br><span class="line"><span class="keyword">let</span> res = con.apply(obj, rest) <span class="comment">// step three</span></span><br><span class="line"><span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? res : obj; <span class="comment">// step four</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SayName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">SayName.prototype.emit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> SayName(<span class="string">'cpp'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(test)</span><br><span class="line"><span class="keyword">var</span> test1 = mockNew(SayName, <span class="string">'cpp'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(test1)</span><br></pre></td></tr></table></figure><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>判断一个实例是否是其父类或者祖先类型的实例。<br>instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype查找失败，返回 false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockInstanceof</span>(<span class="params">target, origin</span>) </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(target) &#123;</span><br><span class="line"><span class="keyword">if</span>(target.__proto__ === origin.prototype) &#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;</span><br><span class="line">target = target.__proto__</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// true</span></span><br><span class="line">mockInstanceof([<span class="number">1</span>,<span class="number">2</span>], <span class="built_in">Array</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="curry-函数柯里化"><a href="#curry-函数柯里化" class="headerlink" title="curry 函数柯里化"></a>curry 函数柯里化</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = []</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">temp</span>(<span class="params">...rest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rest.length) &#123;</span><br><span class="line">      arr.push(...rest);</span><br><span class="line">      <span class="keyword">return</span> temp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> val = fn.apply(<span class="keyword">this</span>, arr)</span><br><span class="line">      arr = []</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> addFn = curry(add)</span><br><span class="line"><span class="keyword">var</span> test = addFn(<span class="number">3</span>)(<span class="number">1</span>)(<span class="number">5</span>)() <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h2 id="Mock-webpack-模拟webpack打包构建过程"><a href="#Mock-webpack-模拟webpack打包构建过程" class="headerlink" title="Mock webpack,模拟webpack打包构建过程"></a>Mock webpack,模拟webpack打包构建过程</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="comment">// es6 code transform ast</span></span><br><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">'@babel/parser'</span>)</span><br><span class="line"><span class="comment">// traverse 依赖路径</span></span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">'@babel/traverse'</span>)</span><br><span class="line"><span class="comment">// paser transformFromAst es5代码</span></span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'@babel/core'</span>)</span><br><span class="line"><span class="keyword">const</span> getModuleInfo = <span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> body = fs.readFileSync(file, <span class="string">'utf-8'</span>)</span><br><span class="line">  <span class="keyword">const</span> ast = parser.parse(body, &#123;</span><br><span class="line">    sourceType: <span class="string">'module'</span> <span class="comment">// 解析的是es模块 default sourceType: 'script'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 收集依赖路径 win10系统下</span></span><br><span class="line">  <span class="keyword">const</span> deps = &#123;&#125;</span><br><span class="line">  traverse.default(ast, &#123;</span><br><span class="line">    ImportDeclaration(&#123;node&#125;) &#123;</span><br><span class="line">      <span class="keyword">const</span> dirname = path.dirname(file)</span><br><span class="line">      <span class="keyword">const</span> depsPath = node.source.value</span><br><span class="line">      <span class="keyword">const</span> abspath = <span class="string">'./'</span> + path.join(dirname, depsPath)</span><br><span class="line">      deps[depsPath] = abspath;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> &#123;code&#125; = babel.transformFromAst(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">    presets: [<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    file,</span><br><span class="line">    deps,</span><br><span class="line">    code,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解析模块深层次遍历模块 输出字符串</span></span><br><span class="line"><span class="keyword">const</span> parseModules = <span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> entry = getModuleInfo(file);</span><br><span class="line">  <span class="keyword">const</span> temp = [entry]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; temp.length; i ++) &#123;</span><br><span class="line">    <span class="keyword">const</span> deps = temp[i].deps;</span><br><span class="line">    <span class="keyword">if</span> (deps) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> deps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deps.hasOwnProperty(key)) &#123;</span><br><span class="line">          temp.push(getModuleInfo(deps[key]))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存储格式 add.js: &#123;deps: '', code: ''&#125;</span></span><br><span class="line">  <span class="keyword">const</span> depsGraph = &#123;&#125;</span><br><span class="line">  temp.forEach(<span class="function">(<span class="params">moduleInfo</span>) =&gt;</span> &#123;</span><br><span class="line">    depsGraph[moduleInfo.file] = &#123;</span><br><span class="line">      deps: moduleInfo.deps,</span><br><span class="line">      code: moduleInfo.code,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> depsGraph</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出bundle</span></span><br><span class="line"><span class="keyword">const</span> bundle = <span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> depsGraph = <span class="built_in">JSON</span>.stringify(parseModules(file));</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`(function (graph) &#123;</span></span><br><span class="line"><span class="string">    function require(file) &#123;</span></span><br><span class="line"><span class="string">      var exports = &#123;&#125;;</span></span><br><span class="line"><span class="string">      function absRequire(relPath) &#123;</span></span><br><span class="line"><span class="string">        console.log(relPath, 'relPath')</span></span><br><span class="line"><span class="string">        return require(graph[file].deps[relPath])</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      (function(require, exports, code)&#123;</span></span><br><span class="line"><span class="string">        console.log(code)</span></span><br><span class="line"><span class="string">        eval(code)</span></span><br><span class="line"><span class="string">      &#125;)(absRequire, exports, graph[file].code)</span></span><br><span class="line"><span class="string">      return exports</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    require('<span class="subst">$&#123;file&#125;</span>')</span></span><br><span class="line"><span class="string">  &#125;)(<span class="subst">$&#123;depsGraph&#125;</span>)`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照路径生成文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">emit</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> content = bundle(path)</span><br><span class="line">  <span class="keyword">const</span> distPath = <span class="string">'./dist'</span>;</span><br><span class="line">  <span class="keyword">const</span> bundlePath = <span class="string">'./dist/bundle.js'</span></span><br><span class="line">  fs.unlinkSync(bundlePath);</span><br><span class="line">  fs.rmdirSync(distPath);</span><br><span class="line">  fs.mkdirSync(distPath)</span><br><span class="line">  fs.writeFileSync(bundlePath, content)</span><br><span class="line">&#125;;</span><br><span class="line">emit(<span class="string">'./src/index.js'</span>)</span><br></pre></td></tr></table></figure><h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><p>手写一个给打包文件头部注入作者和描述信息的webpack plugin<br>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInfoPlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options = &#123;</span><br><span class="line">    author: <span class="string">'cpp'</span>,</span><br><span class="line">    description: <span class="string">'plugin name'</span></span><br><span class="line">  &#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.options = options</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> pluginName() &#123;</span><br><span class="line">    <span class="keyword">return</span> MyInfoPlugin.name</span><br><span class="line">  &#125;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    compiler.hooks.emit.tapPromise(</span><br><span class="line">      <span class="keyword">this</span>.pluginName,</span><br><span class="line">      <span class="keyword">async</span> (compilation) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> options = <span class="keyword">this</span>.options;</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> assets = compilation.assets;</span><br><span class="line">          <span class="built_in">Object</span>.keys(assets).forEach(<span class="function">(<span class="params">asset</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> source = assets[asset].source();</span><br><span class="line">            <span class="keyword">let</span> info = []</span><br><span class="line">            <span class="keyword">if</span> (options.author) &#123;</span><br><span class="line">              info.push(<span class="string">`@Author: <span class="subst">$&#123;options.author&#125;</span>`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (options.description) &#123;</span><br><span class="line">              info.push(<span class="string">`@Description: <span class="subst">$&#123;options.description&#125;</span>`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (info.length) &#123;</span><br><span class="line">              info.push(<span class="string">`@Date: <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span>`</span>)</span><br><span class="line">              source = <span class="string">`/*\n  <span class="subst">$&#123;info.join(<span class="string">'\n  '</span>)&#125;</span>\n*/\n <span class="subst">$&#123;source&#125;</span>`</span></span><br><span class="line">            &#125;</span><br><span class="line">            compilation.assets[asset].source = <span class="function"><span class="params">()</span> =&gt;</span> source;</span><br><span class="line">            compilation.assets[asset].size = <span class="function"><span class="params">()</span> =&gt;</span> source.size;</span><br><span class="line">          &#125;)</span><br><span class="line">          resolve(<span class="string">'Success'</span>)</span><br><span class="line">          reject(<span class="string">'MyInfoPlugin 插件出问题咯'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = MyInfoPlugin</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build\webpack.common.js</span></span><br><span class="line"><span class="keyword">const</span> MyInfoPlugin = <span class="built_in">require</span>(<span class="string">'../plugin/MyInfoPlugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MyInfoPlugin(&#123;</span><br><span class="line">      author: <span class="string">'chendapeng'</span>,</span><br><span class="line">      description: <span class="string">'Test test description'</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</span><br><span class="line"><span class="keyword">const</span> validateOptions = <span class="built_in">require</span>(<span class="string">'schema-utils'</span>);</span><br><span class="line"><span class="comment">// 定义loader里的options选项数据结构</span></span><br><span class="line"><span class="keyword">const</span> schema = &#123;</span><br><span class="line">  type: <span class="string">'object'</span>,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">      type: <span class="string">'string'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this指向当前的Loader Context,不是webpack实例也不是compilation</span></span><br><span class="line">  <span class="keyword">const</span> options = loaderUtils.getOptions(<span class="keyword">this</span>)</span><br><span class="line">  validateOptions(schema, options, <span class="string">'Example Loader'</span>)</span><br><span class="line">  <span class="keyword">return</span> source</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试<br>三种使用方式，推荐resolveLoader种的alias模式以及匹配(test)单个 loader还有常用的npm link软连接的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    resolveLoader: &#123;</span><br><span class="line">      alias: &#123;</span><br><span class="line">        <span class="string">'async-loader'</span>: path.resolve(__dirname, <span class="string">'../loader/async-loader.js'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">          exclude: <span class="string">'/node_modules/'</span>,</span><br><span class="line">          use: [</span><br><span class="line">            &#123;</span><br><span class="line">              loader: <span class="string">'async-loader'</span>,</span><br><span class="line">              options: &#123;</span><br><span class="line">                name: <span class="string">'test my loader cpp'</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h2 id="vue-instance"><a href="#vue-instance" class="headerlink" title="vue instance"></a>vue instance</h2><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><h1 id="tool"><a href="#tool" class="headerlink" title="tool"></a>tool</h1><h2 id="Array-prototype-Map"><a href="#Array-prototype-Map" class="headerlink" title="Array.prototype.Map()"></a>Array.prototype.Map()</h2><h2 id="Array-prototype-flat"><a href="#Array-prototype-flat" class="headerlink" title="Array.prototype.flat()"></a>Array.prototype.flat()</h2><p>多维数组降到一维数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [...arr]</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> next = stack.pop() <span class="comment">// 栈尾</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(next)) &#123;</span><br><span class="line">      stack.push(...next)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.push(next)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.reverse()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">flatten([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>,<span class="number">5</span>], <span class="number">6</span>])</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">00</span>, <span class="number">99</span>,<span class="number">99</span>]</span><br><span class="line"><span class="keyword">var</span> test = arr.reduce(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!prev.includes(cur)) &#123;</span><br><span class="line">prev.push(cur)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> prev</span><br><span class="line">&#125;, [])</span><br><span class="line"><span class="built_in">console</span>.log(tes) <span class="comment">// [1, 2, 3, 4, 00, 99]</span></span><br></pre></td></tr></table></figure><h2 id="URLSearchParams-url参数解析"><a href="#URLSearchParams-url参数解析" class="headerlink" title="URLSearchParams url参数解析"></a>URLSearchParams url参数解析</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> URL(<span class="string">'http://ccing.com/develop.html?systemId=111&amp;idc=cc'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParams</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams(url.search); <span class="comment">// 主要是url里的search属性</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> ([k, v] <span class="keyword">of</span> params.entries()) &#123;</span><br><span class="line">obj[k] = v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test = getParams(str)</span><br><span class="line"><span class="built_in">console</span>.log(test)<span class="comment">// &#123;systemId: '', idc:''&#125;</span></span><br></pre></td></tr></table></figure><p>存在缺陷，如果url里含有hash值，会优先解析hash参数，第二种</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'http://ccuning.com/d.html#/dashboard?reportId=1118&amp;versionId=1.0&amp;systemId=111'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getParams</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> params = url.split(<span class="string">'?'</span>).pop().split(<span class="string">'#'</span>).shift().split(<span class="string">'&amp;'</span>);</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> ([k, v] <span class="keyword">of</span> params.entries()) &#123;</span><br><span class="line"><span class="keyword">const</span> [key, val] = v.split(<span class="string">'='</span>)</span><br><span class="line">obj[key] = val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> test = getParams(str)</span><br><span class="line"><span class="built_in">console</span>.log(test)</span><br></pre></td></tr></table></figure><h2 id="LRU-Cache"><a href="#LRU-Cache" class="headerlink" title="LRU Cache"></a>LRU Cache</h2><h2 id="手写原始AJAX"><a href="#手写原始AJAX" class="headerlink" title="手写原始AJAX"></a>手写原始AJAX</h2><p>使用AJAX最主要的两个特性做下列事：</p><ul><li>在不重新加载页面的情况下发送请求给服务器。</li><li>接受并使用从服务器发来的数据。<br>具体步骤:<br>step one: 创建 XMLHttpRequest 实例<br>step two: 声明接到响应后要做啥事<br>step three: 发送一个实际的请求，通过调用HTTP请求对象的 open() 和 send() 方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeGetRequest</span>(<span class="params">url, cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// step one</span></span><br><span class="line">  <span class="keyword">let</span> httpRequst = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  <span class="comment">// step two</span></span><br><span class="line">  httpRequest.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 检查请求的状态 4</span></span><br><span class="line">    <span class="keyword">if</span> (httpRequest.readyState === XMLHttpRequest.done) &#123;</span><br><span class="line">      <span class="comment">// 检查请求状态码</span></span><br><span class="line">      <span class="keyword">if</span> (httpRequest.status === <span class="number">200</span>) &#123;</span><br><span class="line">        cb(httpRequest.responsText)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// step two</span></span><br><span class="line">  httpRequest.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>) </span><br><span class="line">  <span class="comment">// 第三个参数可选，用于设置请求是否是异步的。如果设为 true (默认值)，即开启异步，JavaScript就不会在此语句阻塞，使得用户能在服务器还没有响应的情况下与页面进行交互。</span></span><br><span class="line">  httpRequest.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>如果你使用 POST 数据，那就需要设置请求的MIME类型。比如，在调用 send() 方法获取表单数据前要有下面这个：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makePostRequest</span>(<span class="params">url, cb, userName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> httpRequst = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  httpRequest.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (httpRequest.readyState === XMLHttpRequest.done) &#123;</span><br><span class="line">      <span class="keyword">if</span> (httpRequest.status === <span class="number">200</span>) &#123;</span><br><span class="line">        cb(httpRequest.responsText)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  httpRequest.open(<span class="string">'Post'</span>, url, <span class="literal">true</span>);</span><br><span class="line">  httpRequest.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">  httpRequest.send(<span class="string">'userName='</span> + <span class="built_in">encodeURIComponent</span>(userName));</span><br></pre></td></tr></table></figure></li></ul><h2 id="手写jsonp"><a href="#手写jsonp" class="headerlink" title="手写jsonp"></a>手写jsonp</h2><p>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, callBack</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> funcName = <span class="string">'jsonp_'</span> + <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">  script.src = url</span><br><span class="line">  script.async = <span class="literal">true</span></span><br><span class="line">  script.type = <span class="string">'text/javascript'</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">  <span class="built_in">window</span>[funcName] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    callBack &amp;&amp; callBack(data)</span><br><span class="line">    <span class="comment">// 重点清除全局函数和script标签</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">window</span>[funcName]</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(script)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jsonp(<span class="string">'http://127.0.0.1:8080/api'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><blockquote><p>感谢各位大佬的倾情奉献，小弟只是代码搬运工！</p></blockquote><ul><li><a href="https://segmentfault.com/a/1190000009271416" target="_blank" rel="noopener">JavaScript深入之bind的模拟实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/345232890" target="_blank" rel="noopener">前端JavaScript高频手写面试大全，助你查漏补缺</a></li><li><a href="https://segmentfault.com/a/1190000022110467" target="_blank" rel="noopener">还得学习css</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端框架:vue-cli-service使用中遇到的问题 npm run build -- --report</title>
      <link href="/2021/03/27/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-vue-cli-service%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98-npm-run-build-report/"/>
      <url>/2021/03/27/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-vue-cli-service%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98-npm-run-build-report/</url>
      
        <content type="html"><![CDATA[<h2 id="vue-cli3执行打包命令时候的–report参数无效"><a href="#vue-cli3执行打包命令时候的–report参数无效" class="headerlink" title="vue-cli3执行打包命令时候的–report参数无效"></a>vue-cli3执行打包命令时候的–report参数无效</h2><p>项目里的scripts脚本</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scripts: &#123;</span><br><span class="line">  "build": "vue-cli-service build &amp;&amp; npm run test",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>npm 执行打包命令的时候 npm run build –report 却没有生成我想要的webpack-bundle-analyzer 分析报告，官网里明确写了支持的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--report 和 --report-json 会根据构建统计生成报告，它会帮助你分析包中包含的模块们的大小</span><br></pre></td></tr></table></figure><p><a href="https://cli.vuejs.org/zh/guide/cli-service.html#vue-cli-service-serve" target="_blank" rel="noopener">vue-cli-service build</a><br>刚开始找不到方向直到有一天看到大佬的文章才明白，(后面得学习从源码的角度思考问题)<br>找到打包命令的文件，打印args入参看下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node_modules\@vue\cli-service\lib\commands\build\index.js</span></span><br><span class="line"> <span class="built_in">console</span>.log(args, <span class="string">'——————args'</span>)</span><br><span class="line"> <span class="keyword">if</span> (args.report || args[<span class="string">'report-json'</span>]) &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; BundleAnalyzerPlugin &#125; = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>)</span><br><span class="line">   <span class="built_in">console</span>.log(config)</span><br><span class="line">   modifyConfig(webpackConfig, config =&gt; &#123;</span><br><span class="line">     <span class="keyword">const</span> bundleName = args.target !== <span class="string">'app'</span></span><br><span class="line">       ? config.output.filename.replace(<span class="regexp">/\.js$/</span>, <span class="string">'-'</span>)</span><br><span class="line">       : isLegacyBuild ? <span class="string">'legacy-'</span> : <span class="string">''</span></span><br><span class="line">     config.plugins.push(<span class="keyword">new</span> BundleAnalyzerPlugin(&#123;</span><br><span class="line">       logLevel: <span class="string">'warn'</span>,</span><br><span class="line">       openAnalyzer: <span class="literal">false</span>,</span><br><span class="line">       analyzerMode: args.report ? <span class="string">'static'</span> : <span class="string">'disabled'</span>,</span><br><span class="line">       reportFilename: <span class="string">`<span class="subst">$&#123;bundleName&#125;</span>report.html`</span>,</span><br><span class="line">       statsFilename: <span class="string">`<span class="subst">$&#123;bundleName&#125;</span>report.json`</span>,</span><br><span class="line">       generateStatsFile: !!args[<span class="string">'report-json'</span>]</span><br><span class="line">     &#125;))</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>观察到打印的args携带的参数report: false，我发现俩个问题</p><ul><li>第一点：如果打包脚本是官方原本的命令行打包参数，即<code>vue-cli-service build</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scripts: &#123;</span><br><span class="line">  "buildReport": "vue-cli-service build",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二点：同时npm执行的时候，需要在–report前面加上–，也就是要这样: <code>npm run build -- --report</code><br>然后我们在看打印参数<br>args打印出<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  _: [],</span><br><span class="line">  modern: <span class="literal">false</span>,</span><br><span class="line">  report: <span class="literal">true</span>, <span class="comment">// 可行 </span></span><br><span class="line">  <span class="string">'report-json'</span>: <span class="literal">false</span>,</span><br><span class="line">  watch: <span class="literal">false</span>,</span><br><span class="line">  open: <span class="literal">false</span>,</span><br><span class="line">  copy: <span class="literal">false</span>,</span><br><span class="line">  https: <span class="literal">false</span>,</span><br><span class="line">  verbose: <span class="literal">false</span>,</span><br><span class="line">  clean: <span class="literal">true</span>,</span><br><span class="line">  target: <span class="string">'app'</span>,</span><br><span class="line">  entry: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>参考npm官网 <a href="https://docs.npmjs.com/cli/v7/commands/npm-run-script" target="_blank" rel="noopener">npm-run-script</a></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1.npm run build – –report 可行<br>2.1.npm run build &amp;&amp; run build test – –report 不可行<br>3.yarn run build  –report 可行<br>4.yarn run build &amp;&amp; run build test –report 不可行</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.npmjs.com/cli/v7/commands/npm-run-script" target="_blank" rel="noopener">npm-run-script</a></li><li><a href="https://blog.csdn.net/sanchuanhi/article/details/105259027" target="_blank" rel="noopener">vue-cli利用webpack-bundle-analyzer分析构建产物</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法基础: 简单和中等</title>
      <link href="/2021/03/27/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E7%AE%80%E5%8D%95%E5%92%8C%E4%B8%AD%E7%AD%89/"/>
      <url>/2021/03/27/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E7%AE%80%E5%8D%95%E5%92%8C%E4%B8%AD%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first one</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; nums.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">let</span> item = nums[i];</span><br><span class="line">        <span class="keyword">let</span> diff = target - item;</span><br><span class="line">        j = nums.indexOf(diff)</span><br><span class="line">        <span class="keyword">if</span>(j &gt; <span class="number">-1</span> &amp;&amp; j != i) &#123;</span><br><span class="line">            <span class="keyword">return</span> [i,j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// second</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; nums.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.has(nums[i])) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(map)</span><br><span class="line">          <span class="keyword">return</span> [</span><br><span class="line">            map.get(nums[i]), i</span><br><span class="line">          ]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          map.set(target - nums[i], i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line">twoSum([<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], <span class="number">17</span>)</span><br></pre></td></tr></table></figure><h3 id="三数最接近之和"><a href="#三数最接近之和" class="headerlink" title="三数最接近之和"></a>三数最接近之和</h3>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络基础: tcp/udp/http</title>
      <link href="/2021/03/24/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80-tcp-udp-http/"/>
      <url>/2021/03/24/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80-tcp-udp-http/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/4/13/1717297c7324a8f0?imageslim" alt=""></p><h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><p>OSI（Open System Interconnect），即开放式系统互联。一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互连模型。ISO为了更好的使网络应用更为普及，推出了OSI参考模型，这样所有的公司都按照统一的标准来指定自己的网络，就可以互通互联了。<br>OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）。</p><h3 id="TCP-IP四层协议"><a href="#TCP-IP四层协议" class="headerlink" title="TCP/IP四层协议"></a>TCP/IP四层协议</h3><p>（数据链路层、网络层、传输层、应用层）</p><ul><li>应用层<br>应用层最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，TELNET等。</li><li>传输层<br>建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。</li><li>网络层<br>本层通过IP寻址来建立两个节点之间的连接。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</li><li>数据链路层<br>通过一些规程或协议来控制这些数据的传输，以保证被传输数据的正确性。实现这些规程或协议的硬件和软件加到物理线路，这样就构成了数据链路</li></ul><h3 id="什么是TCP-IP和UDP"><a href="#什么是TCP-IP和UDP" class="headerlink" title="什么是TCP/IP和UDP"></a>什么是TCP/IP和UDP</h3><h4 id="TCP-IP即传输控制-网络协议"><a href="#TCP-IP即传输控制-网络协议" class="headerlink" title="TCP/IP即传输控制/网络协议"></a>TCP/IP即传输控制/网络协议</h4><p>是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达</p><h4 id="UDP它是属于TCP-IP协议族中的一种。"><a href="#UDP它是属于TCP-IP协议族中的一种。" class="headerlink" title="UDP它是属于TCP/IP协议族中的一种。"></a>UDP它是属于TCP/IP协议族中的一种。</h4><p>是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。</p><h3 id="TCP与UDP区别："><a href="#TCP与UDP区别：" class="headerlink" title="TCP与UDP区别："></a>TCP与UDP区别：</h3><ul><li><p>TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达；<br>UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；</p></li><li><p>TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；<br>UDP通信类似于学校广播，靠着广播播报直接进行通信。</p></li><li><p>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；</p></li><li><p>TCP是面向字节流的，UDP是面向报文的；面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。</p></li><li><p>TCP首部开销（20字节）比UDP首部开销（8字节）要大</p></li></ul><h3 id="形容一下TCP和UDP"><a href="#形容一下TCP和UDP" class="headerlink" title="形容一下TCP和UDP"></a>形容一下TCP和UDP</h3><p>TCP通信可看作打电话：<br>    李三(拨了个号码)：喂，是王五吗？<br>    王五：哎，您谁啊？<br>    李三：我是李三，我想给你说点事儿，你现在方便吗？<br>    王五：哦，我现在方便，你说吧。<br>    甲：那我说了啊？<br>    乙：你说吧。<br>    (连接建立了，接下来就是说正事了…)</p><p>UDP通信可看为学校里的广播：<br>    播音室：喂喂喂！全体操场集合</p><h3 id="运行在TCP-或UDP的应用层协议分析"><a href="#运行在TCP-或UDP的应用层协议分析" class="headerlink" title="运行在TCP 或UDP的应用层协议分析"></a>运行在TCP 或UDP的应用层协议分析</h3><p>运行在TCP协议上的协议：</p><p>HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。<br>HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。<br>FTP（File Transfer Protocol，文件传输协议），用于文件传输。<br>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。<br>SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。</p><p>运行在UDP协议上的协议：</p><p>NTP（Network Time Protocol，网络时间协议），用于网络同步。<br>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。</p><p>运行在TCP和UDP协议上：</p><p>DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。<br>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。</p><h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><p>什么是TCP的三次握手<br>在网络数据传输中，传输层协议TCP是要建立连接的可靠传输，TCP建立连接的过程，我们称为三次握手。</p><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/4/13/1717297c73467e00?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="三次握手"></p><ul><li><p>第一次握手：Client将SYN置1，随机产生一个通讯初始序列号seq发送给Server，进入SYN_SENT状态</p></li><li><p>第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=sequence number+1，并随机产生一个自己的通讯初始序列号，发送给客户端；进入SYN_RCVD状态；</p></li><li><p>第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=服务器发的序列号+1，发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。</p></li></ul><p>简单来说就是 ：</p><ul><li>客户端向服务端发送SYN</li><li>服务端返回SYN,ACK</li><li>客户端发送ACK</li></ul><h3 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h3><p>什么是TCP的四次挥手<br>在网络数据传输中，传输层协议断开连接的过程我们称为四次挥手</p><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2020/4/13/1717297c746f6ee2?imageslim" alt="四次挥手"></p><ul><li><p>第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入FIN_WAIT_1状态；</p></li><li><p>第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。</p></li><li><p>第三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态；</p></li><li><p>第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。</p></li></ul><p>简单来说</p><ul><li>客户端向服务端发送FIN</li><li>服务端向客户端返回ACK</li><li>服务端向客户端返回FIN</li><li>客户端向服务端发送ACK</li></ul><h4 id="客户端TIME-WAIT状态的意义是什么？"><a href="#客户端TIME-WAIT状态的意义是什么？" class="headerlink" title="客户端TIME_WAIT状态的意义是什么？"></a>客户端TIME_WAIT状态的意义是什么？</h4><p>第四次挥手时，客户端发送给服务器的ACK有可能丢失，<em>TIME_WAIT</em>状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2<em>MSL</em>的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。 MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><ul><li><p>网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个Socket。Socket通常用来实现客户方和服务方的连接。Socket是TCP/IP协议的一个十分流行的编程界面，一个Socket由一个IP地址和一个端口号唯一确定。</p></li><li><p>但是，Socket所支持的协议种类也不光TCP/IP、UDP，因此两者之间是没有必然联系的。在Java环境下，Socket编程主要是指基于TCP/IP协议的网络编程。</p></li><li><p>socket连接就是所谓的长连接，客户端和服务器需要互相连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉的，但是有时候网络波动还是有可能的</p></li><li><p>Socket偏向于底层。一般很少直接使用Socket来编程，框架底层使用Socket比较多，</p></li><li><p>位于应用层和传输层之间，我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。</p></li></ul><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>Http协议是对客户端和服务器端之间数据之间实现可靠性的传输文字、图片、音频、视频等超文本数据的规范，格式简称为“超文本传输协议”</p><p>Http协议属于应用层，及用户访问的第一层就是http</p><h3 id="Socket和http的区别和应用场景"><a href="#Socket和http的区别和应用场景" class="headerlink" title="Socket和http的区别和应用场景"></a>Socket和http的区别和应用场景</h3><ul><li><p>Socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；</p></li><li><p>Socket适用场景：网络游戏，银行持续交互，直播，在线视屏等。</p></li><li><p>http连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断开等待下次连接</p></li><li><p>http适用场景：公司OA服务，互联网服务，电商，办公，网站等等等等</p></li></ul><h3 id="什么是http的请求体？"><a href="#什么是http的请求体？" class="headerlink" title="什么是http的请求体？"></a>什么是http的请求体？</h3><p>HTTP请求体由：请求行 、请求头、请求数据组成的</p><h3 id="http的响应报文有哪些？"><a href="#http的响应报文有哪些？" class="headerlink" title="http的响应报文有哪些？"></a>http的响应报文有哪些？</h3><p>http的响应报是服务器返回给我们的数据，必须先有请求体再有响应报文</p><p>响应报文包含三部分 状态行、响应首部字段、响应内容实体实现</p><h3 id="http和https的区别？"><a href="#http和https的区别？" class="headerlink" title="http和https的区别？"></a>http和https的区别？</h3><p>其实HTTPS就是从HTTP加上加密处理（一般是SSL安全通信线路）+认证+完整性保护</p><p>区别：<br>HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。<br>HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页;<br>HTTPS需要用到SSL证书，而HTTP不用;<br>Https默认端口号是443.而http默认端口号是80<br>HTTPS基于传输层(介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议)，HTTP基于应用层<br>HTTPS在浏览器显示安全锁，HTTP没有显示;</p><h3 id="https工作流程"><a href="#https工作流程" class="headerlink" title="https工作流程"></a>https工作流程</h3><p>1.Client发起一个HTTPS的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。<br>2.Server把事先配置好的公钥证书（public key certificate）返回给客户端。<br>3.Client验证公钥（RSA加密）证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。<br>4.Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密（RSA加密）这个对称密钥，发给Server。<br>5.Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。<br>6.Server使用对称密钥加密“明文内容A”，发送给Client。<br>7.Client使用对称密钥解密响应的密文，得到“明文内容A”。<br>8.Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”</p><h3 id="常用HTTP状态码是怎么分类的，有哪些常见的状态码？"><a href="#常用HTTP状态码是怎么分类的，有哪些常见的状态码？" class="headerlink" title="常用HTTP状态码是怎么分类的，有哪些常见的状态码？"></a>常用HTTP状态码是怎么分类的，有哪些常见的状态码？</h3><p>HTTP状态码表示客户端HTTP请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。<br>1xx：<br>指示信息–表示请求已接收，正在处理</p><p>2xx：<br>成功–表示请求已被成功接收、理解、接受</p><p>3xx：<br>重定向–要完成请求必须进行更进一步的操作</p><p>4xx：<br>客户端错误–请求有语法错误或请求无法实现</p><p>5xx：<br>服务器端错误–服务器未能实现合法的请求</p><h3 id="Http协议中有那些请求方式"><a href="#Http协议中有那些请求方式" class="headerlink" title="Http协议中有那些请求方式"></a>Http协议中有那些请求方式</h3><p>PUT：    传输文件，报文主体中包含文件内容，保存到对应URI位置。<br>HEAD：    获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有 &gt; 效。<br>DELETE：    删除文件，与PUT方法相反，删除对应URI位置的文件。</p><h3 id="GET方法与POST方法的区别"><a href="#GET方法与POST方法的区别" class="headerlink" title="GET方法与POST方法的区别"></a>GET方法与POST方法的区别</h3><p>区别一：<br>get重点在从服务器上获取资源，post重点在向服务器发送数据；</p><p>区别二：<br>Get传输的数据量小，因为受URL长度限制，但效率较高；<br>Post可以传输大量数据，所以上传文件时只能用Post方式；</p><p>区别三：<br>get是不安全的，因为get请求发送数据是在URL上，是可见的，可能会泄露私密信息，如密码等；<br>post是放在请求头部的，是安全的</p><h3 id="http版本的对比"><a href="#http版本的对比" class="headerlink" title="http版本的对比"></a>http版本的对比</h3><p>HTTP1.0版本的特性：</p><ul><li>早先1.0的HTTP版本，是一种无状态、无连接的应用层协议。</li><li>HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。</li></ul><p>HTTP1.1版本新特性</p><ul><li>默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求</li><li>管线化 HTTP Pipelining，客户端可以同时发出多个HTTP请求，而不用一个个等待响应(断点续传原理)</li></ul><p>HTTP2.0版本的特性</p><ul><li>二进制分帧（采用二进制格式的编码将其封装）</li><li>头部采用HPACK压缩（设置了专门的首部压缩设计的HPACK算法。）</li><li>流量控制（设置了接收某个数据流的多少字节一些流量控制）</li><li>多路复用（可以在共享TCP链接的基础上同时发送请求和响应）</li><li>请求优先级（可以通过优化这些帧的交错和传输顺序进一步优化性能）</li><li>服务器推送（就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资 源无需客户端明确的请求。（重大更新））</li></ul><h3 id="什么是对称加密与非对称加密"><a href="#什么是对称加密与非对称加密" class="headerlink" title="什么是对称加密与非对称加密"></a>什么是对称加密与非对称加密</h3><ul><li><p>对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；</p></li><li><p>而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢</p></li></ul><h3 id="cookie和session对于HTTP有什么用？"><a href="#cookie和session对于HTTP有什么用？" class="headerlink" title="cookie和session对于HTTP有什么用？"></a>cookie和session对于HTTP有什么用？</h3><p>HTTP协议本身是无法判断用户身份。所以需要cookie或者session</p><h4 id="什么是cookie"><a href="#什么是cookie" class="headerlink" title="什么是cookie"></a>什么是cookie</h4><p>cookie是由Web服务器保存在用户浏览器上的文件（key-value格式），可以包含用户相关的信息。客户端向服务器发起请求，就提取浏览器中的用户信息由http发送给服务器</p><h4 id="什么是session"><a href="#什么是session" class="headerlink" title="什么是session"></a>什么是session</h4><p>session 是浏览器和服务器会话过程中，服务器会分配的一块储存空间给session。</p><p>服务器默认为客户浏览器的cookie中设置 sessionid，这个sessionid就和cookie对应，浏览器在向服务器请求过程中传输的cookie 包含 sessionid ，服务器根据传输cookie 中的 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。</p><h4 id="cookie与session区别"><a href="#cookie与session区别" class="headerlink" title="cookie与session区别"></a>cookie与session区别</h4><ul><li>cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高</li><li>单个cookie保存的数据不能超过4K，session无此限制</li><li>session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.jianshu.com/p/88d69454bdde" target="_blank" rel="noopener">tcp、http和socket的区别</a></li><li><a href="https://juejin.cn/post/6844903889146216456" target="_blank" rel="noopener">TCP/UDP协议详解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
          <category> https </category>
          
          <category> http2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> https </tag>
            
            <tag> http2 </tag>
            
            <tag> tcp/udp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chrome: 并行配置不正确导致无法启动</title>
      <link href="/2021/03/21/chrome-%E5%B9%B6%E8%A1%8C%E9%85%8D%E7%BD%AE%E4%B8%8D%E6%AD%A3%E7%A1%AE%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/"/>
      <url>/2021/03/21/chrome-%E5%B9%B6%E8%A1%8C%E9%85%8D%E7%BD%AE%E4%B8%8D%E6%AD%A3%E7%A1%AE%E5%AF%BC%E8%87%B4%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>启动chrome.exe突然提示: 应用程序无法打开，因为应用查询的并行配置错误，然后上网百度了下，记录了下，三个步骤</p><h3 id="右击自己的chrome快捷键，找到chrome的安装位置"><a href="#右击自己的chrome快捷键，找到chrome的安装位置" class="headerlink" title="右击自己的chrome快捷键，找到chrome的安装位置"></a>右击自己的chrome快捷键，找到chrome的安装位置</h3><h3 id="然后会看到两个ip地址类型的文件夹-找到两个文件夹的区别，然后把一个少manifest的文件从另一个ip地址的文件夹拷贝过去，并改成-当前ip地址的文件名"><a href="#然后会看到两个ip地址类型的文件夹-找到两个文件夹的区别，然后把一个少manifest的文件从另一个ip地址的文件夹拷贝过去，并改成-当前ip地址的文件名" class="headerlink" title="然后会看到两个ip地址类型的文件夹,找到两个文件夹的区别，然后把一个少manifest的文件从另一个ip地址的文件夹拷贝过去，并改成 当前ip地址的文件名"></a>然后会看到两个ip地址类型的文件夹,找到两个文件夹的区别，然后把一个少manifest的文件从另一个ip地址的文件夹拷贝过去，并改成 当前ip地址的文件名</h3><p><img src= "/img/loading.gif" data-src="/images/chrome/1.png" alt="chrome"><br><img src= "/img/loading.gif" data-src="/images/chrome/2.png" alt="chrome"></p><h3 id="编辑下文件mainfest-里面涉及到的ip地址也对应改下即可"><a href="#编辑下文件mainfest-里面涉及到的ip地址也对应改下即可" class="headerlink" title="编辑下文件mainfest,里面涉及到的ip地址也对应改下即可"></a>编辑下文件mainfest,里面涉及到的ip地址也对应改下即可</h3><p><img src= "/img/loading.gif" data-src="/images/chrome/3.png" alt="chrome"></p>]]></content>
      
      
      <categories>
          
          <category> chrome </category>
          
          <category> manifest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome </tag>
            
            <tag> manifest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收机制: 标记清除和引用计数</title>
      <link href="/2021/03/20/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E5%92%8C%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
      <url>/2021/03/20/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E5%92%8C%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>像C语言这样的底层语言一般都有底层的内存管理接口，比如 malloc()和free()用于分配内存和释放内存。<br>而对于JavaScript来说，会在创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放内存，这个自动释放内存的过程称为垃圾回收。<br>因为自动垃圾回收机制的存在，让大多Javascript开发者感觉他们可以不关心内存管理，所以会在一些情况下导致内存泄漏。</p><p>JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p><h2 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h2><p>JS 环境中分配的内存有如下声明周期：<br><img src= "/img/loading.gif" data-src="/images/gc/memory.png" alt="内存生命周期"><br>内存分配：当我们申明变量、函数、对象的时候，系统会自动为他们分配内存<br>内存使用：即读写内存，也就是使用变量、函数等<br>内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存</p><h3 id="JS-的内存分配"><a href="#JS-的内存分配" class="headerlink" title="JS 的内存分配"></a>JS 的内存分配</h3><p>JavaScript 在定义变量时就完成了内存分配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span>; <span class="comment">// 给数值变量分配内存</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"azerty"</span>; <span class="comment">// 给字符串分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">null</span></span><br><span class="line">&#125;; <span class="comment">// 给对象及其包含的值分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给数组及其包含的值分配内存（就像对象一样）</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">null</span>, <span class="string">"abra"</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">2</span>;</span><br><span class="line">&#125; <span class="comment">// 给函数（可调用的对象）分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式也能分配一个对象</span></span><br><span class="line">someElement.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  someElement.style.backgroundColor = <span class="string">'blue'</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="JS-的内存使用"><a href="#JS-的内存使用" class="headerlink" title="JS 的内存使用"></a>JS 的内存使用</h3><p>使用值的过程实际上是对分配内存进行读取与写入的操作。 读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">// 分配内存</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 对内存的使用</span></span><br></pre></td></tr></table></figure><h3 id="JS的内存回收"><a href="#JS的内存回收" class="headerlink" title="JS的内存回收"></a>JS的内存回收</h3><p>JS 有自动垃圾回收机制，那么这个自动垃圾回收机制的原理是什么呢？<br>其实很简单，就是找出那些不再继续使用的值，然后释放其占用的内存。<br>大多数内存管理的问题都在这个阶段。<br>在这里最艰难的任务是<strong>找到不再需要使用的变量</strong>。<br>不再需要使用的变量也就是生命周期结束的变量，是局部变量，局部变量只在函数的执行过程中存在，<br>当函数运行结束，没有其他引用(闭包)，那么该变量会被标记回收。<br>全局变量的生命周期直至浏览器卸载页面才会结束，也就是说<em>全局变量</em>不会被当成垃圾回收。<br>因为自动垃圾回收机制的存在，开发人员可以不关心也不注意内存释放的有关问题，但对无用内存的释放这件事是客观存在的。<br>不幸的是，即使不考虑垃圾回收对性能的影响，目前最新的垃圾回收算法，也无法智能回收所有的极端情况</p><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>标记-清除算法包含三个步骤：</p><ul><li>根：一般来说，根指的是代码中引用的全局变量。就拿 JavaScript 来说，window 对象即是根的全局变量。Node.js 中相对应的变量为 “global”。垃圾回收器会构建出一份所有根变量的完整列表。</li><li>随后，算法会检测所有的根变量及他们的后代变量并标记它们为激活状态(表示它们不可回收)。任何根变量所到达不了的变量(或者对象等等)都会被标记为内存垃圾。</li><li>最后，垃圾回收器会释放所有非激活状态的内存片段然后返还给操作系统。<br><img src= "/img/loading.gif" data-src="https://user-images.githubusercontent.com/1475173/40289792-0436a5be-5ced-11e8-9471-37f13d00966b.gif" alt="sweep"></li></ul><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>这是最初级的垃圾回收算法。</p><p>引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。 如果没有其他对象指向它了，说明该对象已经不再需了。<br>统计引用类型变量声明后被引用的次数，当次数为 0 时，该变量将被回收。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func4</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> c = &#123;&#125; <span class="comment">// 引用类型变量 c的引用计数为 0</span></span><br><span class="line">      <span class="keyword">let</span> d = c <span class="comment">// c 被 d 引用 c的引用计数为 1</span></span><br><span class="line">      <span class="keyword">let</span> e = c <span class="comment">// c 被 e 引用 c的引用计数为 2</span></span><br><span class="line">      d = &#123;&#125; <span class="comment">// d 不再引用c c的引用计数减为 1</span></span><br><span class="line">      e = <span class="literal">null</span> <span class="comment">// e 不再引用 c c的引用计数减为 0 将被回收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o</span></span><br><span class="line"><span class="comment">// 很显然，没有一个可以被垃圾收集</span></span><br><span class="line"><span class="keyword">var</span> o = &#123; </span><br><span class="line">  a: &#123;</span><br><span class="line">    b:<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = o; <span class="comment">// o2变量是第二个对“这个对象”的引用</span></span><br><span class="line"></span><br><span class="line">o = <span class="number">1</span>;      <span class="comment">// 现在，“这个对象”的原始引用o被o2替换了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oa = o2.a; <span class="comment">// 引用“这个对象”的a属性</span></span><br><span class="line"><span class="comment">// 现在，“这个对象”有两个引用了，一个是o2，一个是oa</span></span><br><span class="line"></span><br><span class="line">o2 = <span class="string">"yo"</span>; <span class="comment">// 最初的对象现在已经是零引用了</span></span><br><span class="line">           <span class="comment">// 他可以被垃圾回收了</span></span><br><span class="line">           <span class="comment">// 然而它的属性a的对象还在被oa引用，所以还不能回收</span></span><br><span class="line"></span><br><span class="line">oa = <span class="literal">null</span>; <span class="comment">// a属性的那个对象现在也是零引用了</span></span><br><span class="line">           <span class="comment">// 它可以被垃圾回收了</span></span><br></pre></td></tr></table></figure><p>但这种方式存在缺陷，就是互相引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func5</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> f = &#123;&#125;</span><br><span class="line">      <span class="keyword">let</span> g = &#123;&#125;</span><br><span class="line">      f.prop = g</span><br><span class="line">      g.prop = f</span><br><span class="line">      <span class="comment">// 由于 f 和 g 互相引用，计数永远不可能为 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能手动清除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.prop = <span class="literal">null</span></span><br><span class="line">g.prop = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>在现代浏览器中，Javascript 使用的方式是标记清除，所以我们无需担心循环引用的问题</p><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露?"></a>内存泄露?</h2><p>内存泄露就是不再被需要的内存, 由于某种原因, 无法被释放.</p><h3 id="意外的全局变量造成内存泄漏"><a href="#意外的全局变量造成内存泄漏" class="headerlink" title="意外的全局变量造成内存泄漏"></a>意外的全局变量造成内存泄漏</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"你我贷"</span> <span class="comment">// 全局变量 =&gt; window.name</span></span><br><span class="line">    bar = <span class="string">'come on'</span> <span class="comment">// 没有声明变量 实际上是全局变量 =&gt; window.bar</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br></pre></td></tr></table></figure><p>在这种情况下this指向了全局变量window对象，意外的创建了全局变量. 我们谈到了一些意外情况下定义的全局变量, 代码中也有一些我们明确定义的全局变量. 如果使用这些全局变量用来暂存大量的数据, 记得在使用后, 对其重新赋值为 null.</p><h3 id="未销毁的定时器和回调函数造成内存泄露"><a href="#未销毁的定时器和回调函数造成内存泄露" class="headerlink" title="未销毁的定时器和回调函数造成内存泄露"></a>未销毁的定时器和回调函数造成内存泄露</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">poll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        timer &amp;&amp; clearTimeout(timer)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'11'</span>)</span><br><span class="line">        poll()</span><br><span class="line">    &#125;, <span class="number">400</span>);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroyer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    timer &amp;&amp; clearTimeout(timer) <span class="comment">// 一定要记得销毁定时器，不能只销毁定时器的引用</span></span><br><span class="line">    timer = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">poll()</span><br><span class="line"><span class="built_in">console</span>.log(timer)</span><br></pre></td></tr></table></figure><h3 id="闭包造成内存泄露"><a href="#闭包造成内存泄露" class="headerlink" title="闭包造成内存泄露"></a>闭包造成内存泄露</h3><h3 id="dom引用造成内存泄漏"><a href="#dom引用造成内存泄漏" class="headerlink" title="dom引用造成内存泄漏"></a>dom引用造成内存泄漏</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> elements = &#123;</span><br><span class="line">    txt: <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    elements.txt.innerHTML = <span class="string">"1111"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeTxt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'test'</span>));</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">removeTxt()</span><br><span class="line"><span class="built_in">console</span>.log(elements.txt)</span><br></pre></td></tr></table></figure><p>我们对 Dom 的操作, 会把 Dom 的引用保存在一个数组或者 对象 中。上述案例中, 即使我们对于 test 元素进行了移除, 但是仍然有对 test 元素的引用, 依然无法对其进行内存回收。</p><p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>);</span><br><span class="line"></span><br><span class="line">wm.set(element, <span class="string">'some information'</span>);</span><br><span class="line">wm.get(element) <span class="comment">// "some information"</span></span><br></pre></td></tr></table></figure><p>上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。</p><p>也就是说，上面的 DOM 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。</p><p>总之，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。<br>注意，WeakMap 弱引用的只是<strong>键名</strong>，而不是键值。键值依然是正常引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> key = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">wm.set(key, obj);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br><span class="line">wm.get(key)</span><br><span class="line"><span class="comment">// Object &#123;foo: 1&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，键值obj是正常引用。所以，即使在 WeakMap 外部消除了obj的引用，WeakMap 内部的引用依然存在。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><ul><li>echarts 造成内存泄漏<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">destroyed () &#123;</span><br><span class="line">    <span class="keyword">this</span>.chart.destroy()</span><br><span class="line">    <span class="keyword">this</span>.chart = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>g2造成内存泄漏</li><li>WeakMap 应用的典型场合就是 DOM 节点作为键名<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">myWeakmap.set(</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>),</span><br><span class="line">  &#123;<span class="attr">timesClicked</span>: <span class="number">0</span>&#125;)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> logoData = myWeakmap.get(<span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>));</span><br><span class="line">  logoData.timesClicked++;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>document.getElementById(‘logo’)是一个 DOM 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是这个节点对象。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。</li></ul><h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><ul><li><p>尽可能避免创建对象，非必要情况下避免调用会创建对象的方法，如 Array.slice、Array.map、Array.filter、字符串相加、$(‘div’)、ArrayBuffer.slice 等。</p></li><li><p>不再使用的对象，手动赋为 null，可避免循环引用等问题。</p></li><li><p>使用 Weakmap</p></li><li><p>生产环境勿用 console.log 大对象，包括 DOM、大数组、ImageData、ArrayBuffer 等。因为 console.log 的对象不会被垃圾回收。详见Will console.log prevent garbage collection?。</p></li><li><p>合理设计页面，按需创建对象/渲染页面/加载图片等。</p></li></ul><p>避免如下问题：</p><p>为了省事儿，一次性请求全部数据。<br>为了省事儿，一次性渲染全部数据，再做隐藏。<br>为了省事儿，一次性加载/渲染全部图片。<br>使用重复 DOM 等，如重复使用同一个弹窗而非创建多个。</p><p>如 Vue-Element 框架中，PopOver/Tooltip 等组件用于表格内时会创建 m * n 个实例，可优化为只创建一个实例，动态设置位置及数据。</p><ul><li><p>ImageData 对象是 JS 内存杀手，避免重复创建 ImageData 对象。</p></li><li><p>重复使用 ArrayBuffer(前端的一个通用的二进制缓冲区，类似数组，但在API和特性上却有诸多不同)</p></li><li><p>压缩图片、按需加载图片、按需渲染图片，使用恰当的图片尺寸、图片格式，如 WebP 格式。</p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://hub.fastgit.org/Troland/how-javascript-works/blob/master/memory-management.md" target="_blank" rel="noopener">Javascript 的垃圾回收机制</a></li><li><a href="https://juejin.cn/post/6844903943722500110" target="_blank" rel="noopener">记录一次定时器及闭包问题造成的内存泄漏</a></li><li><a href="https://zhuanlan.zhihu.com/p/97768916" target="_blank" rel="noopener">ArrayBuffer</a></li><li><a href="https://juejin.cn/post/6877353084519972878" target="_blank" rel="noopener">一文搞懂JS系列（三）之垃圾回收机制，内存泄漏，闭包</a></li><li><a href="https://juejin.cn/post/6844903869525262349" target="_blank" rel="noopener">「前端进阶」JS中的内存管理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> Gc </category>
          
          <category> closure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> Gc </tag>
            
            <tag> closure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具进阶: 初识webpack原理</title>
      <link href="/2021/03/14/%E5%B7%A5%E5%85%B7%E8%BF%9B%E9%98%B6-%E5%88%9D%E8%AF%86webpack%E5%8E%9F%E7%90%86/"/>
      <url>/2021/03/14/%E5%B7%A5%E5%85%B7%E8%BF%9B%E9%98%B6-%E5%88%9D%E8%AF%86webpack%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>目前本文介绍的是webpack的打包原理，还会有涉及到的</p><ol><li>webpack 构建流程(编译原理？)是怎样的？(本文)</li><li>webpack loader 和 plugin 的原理和区别？(更新中)</li><li>plugin 中有异步请求会阻塞后面的 plugin 吗？</li><li>webpack 热更新原理？</li><li>你webpack 是怎么做拆包(分包)的？</li><li>做过webpack 性能优化吗？</li></ol><p>webpack是高度复杂抽象的插件集合，理解webpack的运行机制，对于我们日常定位构建错误以及写一些插件处理构建任务有很大的帮助。<br>webpack 的作用是根据入口文件将源代码编译（构建、打包）成最终代码。中间经过webpack打包，打包的过程就是编译</p><h2 id="核心打包原理"><a href="#核心打包原理" class="headerlink" title="核心打包原理"></a>核心打包原理</h2><h3 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h3><p>  初始化 -&gt; 编译 -&gt; 输出</p><ul><li>初始化这个阶段,webpack会将CLI参数、配置文件、默认配置进行融合，形成一个最终的配置对象</li><li>编译阶段，1.创建chunk 2.构建所有依赖模块 3.产生 chunk assets 4.合并 chunk assets，</li><li>输出阶段，利用node模块里的fs模块，根据编译产生总的asset以及结合output输出文件</li></ul><h3 id="具体webpack细节"><a href="#具体webpack细节" class="headerlink" title="具体webpack细节"></a>具体webpack细节</h3><ul><li>获取主模块内容</li><li>分析模块<br>安装@babel/parser包（转AST）</li><li>对模块内容进行处理<br>安装@babel/traverse包（遍历AST收集依赖）<br>安装@babel/core和@babel/preset-env包（es6转ES5）</li><li>递归所有模块生成最终代码</li></ul><h3 id="重要的构建节点"><a href="#重要的构建节点" class="headerlink" title="重要的构建节点"></a>重要的构建节点</h3><p>webpack的构建中总会经历如下几个事件节点。<br>  before-run 清除缓存<br>  run 注册缓存数据钩子<br>  compile 开始编译<br>  make 从入口分析依赖以及间接依赖模块，创建模块对象<br>  build-module 模块构建<br>  seal 构建结果封装， 不可再更改<br>  after-compile 完成构建，缓存数据<br>  emit 输出到dist目录</p><p>其中make是整个构建中最核心的部分编译，通过模块工厂函数创建模块，然后对模块进行编译。</p><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2018/4/3/162891e3306cf41e?imageslim" alt="在make钩子的编译"></p><h2 id="构建封装seal"><a href="#构建封装seal" class="headerlink" title="构建封装seal"></a>构建封装seal</h2><p>到构建封装阶段时候，代码构建已经完毕，但是如何将这些代码按照依赖引用逻辑组织起来，当浏览器将你构建出来的代码加载到浏览器的时候，仍然能够正确执行。在webpack中通过Manifest记录各个模块的详细要点，通过Runtime来引导，加载执行模块代码，特别是异步加载。</p><h2 id="参考文件"><a href="#参考文件" class="headerlink" title="参考文件"></a>参考文件</h2><ul><li><a href="https://juejin.cn/post/6844903586942451726" target="_blank" rel="noopener">webpack的编译&amp;构建</a></li><li><a href="https://juejin.cn/post/6854818576470933512#heading-4" target="_blank" rel="noopener">Webpack 原理浅析</a></li><li><a href="https://juejin.cn/post/6854573217336541192#heading-7" target="_blank" rel="noopener">手写webpack核心原理，再也不怕面试官问我webpack原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/58151131?utm_source=com.daimajia.gold&utm_medium=social&utm_oi=631273285770547200" target="_blank" rel="noopener">理解webpack原理，手写一个100行的webpack</a></li><li><a href="https://juejin.cn/post/6935217623487643656#comment" target="_blank" rel="noopener">为女朋友解梦之——webpack编译原理</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端框架Vue: 面试相关1</title>
      <link href="/2021/03/06/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6Vue-%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B31/"/>
      <url>/2021/03/06/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6Vue-%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B31/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue响应式原理"><a href="#Vue响应式原理" class="headerlink" title="Vue响应式原理"></a>Vue响应式原理</h3><h3 id="computed实现原理"><a href="#computed实现原理" class="headerlink" title="computed实现原理"></a>computed实现原理</h3><h3 id="nextTick原理"><a href="#nextTick原理" class="headerlink" title="$nextTick原理"></a>$nextTick原理</h3><p>(Vue的数据为什么频繁变化但只会更新一次)</p><h3 id="virtual-Dom-实现原理"><a href="#virtual-Dom-实现原理" class="headerlink" title="virtual Dom 实现原理"></a>virtual Dom 实现原理</h3><h3 id="Vue-生命周期过程"><a href="#Vue-生命周期过程" class="headerlink" title="Vue 生命周期过程"></a>Vue 生命周期过程</h3><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>-<a href="https://juejin.cn/post/6844904116339261447#heading-13" target="_blank" rel="noopener">2021年前端面试必读文章【超三百篇文章/赠复习导图】</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端基础: 网络-1</title>
      <link href="/2021/03/06/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80-%E7%BD%91%E7%BB%9C-1/"/>
      <url>/2021/03/06/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80-%E7%BD%91%E7%BB%9C-1/</url>
      
        <content type="html"><![CDATA[<h3 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h3><p>HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。<br>HTTPS主要作用是：<br>（1）对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;<br>（2）对网站服务器进行真实身份认证。</p><h4 id="http存在的问题"><a href="#http存在的问题" class="headerlink" title="http存在的问题"></a>http存在的问题</h4><ul><li>通信使用明文，内容可能被窃听</li><li>无法证明报文的完整性，所以可能遭篡改</li><li>不验证通信方的身份，因此有可能遭遇伪装</li></ul><p>反观Https，相比http多了一下优势</p><ul><li>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</li><li>数据完整性：内容传输经过完整性校验</li><li>身份认证：第三方无法伪造服务端（客户端）身份</li></ul><h4 id="HTTPS如何解决HTTP上述问题"><a href="#HTTPS如何解决HTTP上述问题" class="headerlink" title="HTTPS如何解决HTTP上述问题?"></a>HTTPS如何解决HTTP上述问题?</h4><p>在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。也就是说HTTP加上加密处理和认证以及完整性保护后即是HTTPS。<br>1.解决内容可能被窃听的问题——加密 方法3.对称加密+非对称加密(HTTPS采用这种方式)<br>2.解决报文可能遭篡改问题——数字签名<br>3.解决通信方身份可能被伪装的问题——数字证书</p><h4 id="https工作流程"><a href="#https工作流程" class="headerlink" title="https工作流程"></a>https工作流程</h4><p><img src= "/img/loading.gif" data-src="/images/network/https1.png" alt="https工作流程"><br>1.Client发起一个HTTPS的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。<br>2.Server把事先配置好的公钥证书（public key certificate）返回给客户端。<br>3.Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。<br>4.Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。<br>5.Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。<br>6.Server使用对称密钥加密“明文内容A”，发送给Client。<br>7.Client使用对称密钥解密响应的密文，得到“明文内容A”。<br>8.Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。</p><h4 id="https和http区别"><a href="#https和http区别" class="headerlink" title="https和http区别"></a>https和http区别</h4><ul><li>HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li><li>HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页;</li><li>HTTPS需要用到SSL证书，而HTTP不用;</li><li>Https默认端口号是443.而http默认端口号是80</li><li>HTTPS基于传输层，HTTP基于应用层;</li><li>HTTPS在浏览器显示安全锁，HTTP没有显示;</li></ul><h3 id="https做什么用的，以及https握手过程"><a href="#https做什么用的，以及https握手过程" class="headerlink" title="https做什么用的，以及https握手过程"></a>https做什么用的，以及https握手过程</h3><h3 id="tcp的握手过程"><a href="#tcp的握手过程" class="headerlink" title="tcp的握手过程"></a>tcp的握手过程</h3><p>TCP是什么？<br>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><p><img src= "/img/loading.gif" data-src="/images/network/tcp1.jpg" alt="https工作流程"></p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；<br>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。<br>完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。</p><p>另一个版本的三次握手<br>第一次握手<br>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。<br>第二次握手<br>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。<br>第三次握手<br>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。<br>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；<br>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；<br>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；<br>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><p>另一个版本的四次挥手<br>TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。<br>第一次握手<br>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。<br>第二次握手<br>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。<br>第三次握手<br>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。<br>第四次握手<br>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p><h3 id="tcp-udp的区别"><a href="#tcp-udp的区别" class="headerlink" title="tcp/udp的区别"></a>tcp/udp的区别</h3><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>UDP协议全称是 用户数据报协议 USER DATA Protocol，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>1.面向无连接<br>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。<br>2.有单播，多播，广播的功能<br>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。<br>3.UDP是面向报文的<br>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文<br>4.不可靠性<br>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p><p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。<br>5.头部开销小，传输数据报文时是很高效的。</p><h3 id="TCp"><a href="#TCp" class="headerlink" title="TCp"></a>TCp</h3><p>TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li>面向连接</li></ul><p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p><ul><li>仅支持单播传输</li></ul><p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p><ul><li>面向字节流</li></ul><p>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p><ul><li>可靠传输</li></ul><p>对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p><ul><li>提供拥塞控制</li></ul><p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞</p><ul><li>TCP提供全双工通信</li></ul><p>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p><h3 id="TCP-UDP区别"><a href="#TCP-UDP区别" class="headerlink" title="TCP/UDP区别"></a>TCP/UDP区别</h3><table><thead><tr><th>特点</th><th>UDP</th><th>TCP</th></tr></thead><tbody><tr><td>是否连接</td><td>无连接</td><td>面向连接</td></tr><tr><td>是否可靠</td><td>不可靠传输 不使用流量控制和拥塞控制</td><td>可靠传输</td></tr><tr><td>连接对象个数</td><td>支持一对一，一对多，多对一和多对多交互通信</td><td>只能是一对一通信</td></tr><tr><td>传输方式</td><td>面向报文</td><td>面向字节流</td></tr><tr><td>首部开销</td><td>首部开销小 仅8字节</td><td>首部最小20字节，最大60字节</td></tr><tr><td>适用场景</td><td>适用实时应用(视频会议/直播)</td><td>适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.cn/post/6844903830916694030" target="_blank" rel="noopener">深入理解HTTPS工作原理</a></li><li><a href="https://juejin.cn/post/6844903521272201223#heading-18" target="_blank" rel="noopener">九个问题从入门到熟悉HTTPS</a></li><li><a href="https://juejin.cn/post/6884813913259524104#heading-10" target="_blank" rel="noopener">HTTPS 工作原理详解 | TLS握手过程</a></li><li><a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="noopener">通俗大白话来理解TCP协议的三次握手和四次分手 </a></li><li><a href="https://juejin.cn/post/6844903800336023560" target="_blank" rel="noopener">TCP和UDP比较</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
          <category> https </category>
          
          <category> http2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> https </tag>
            
            <tag> http2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础-前端重学-7</title>
      <link href="/2021/03/03/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-7/"/>
      <url>/2021/03/03/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-7/</url>
      
        <content type="html"><![CDATA[<h2 id="事件冒泡和事件捕获"><a href="#事件冒泡和事件捕获" class="headerlink" title="事件冒泡和事件捕获"></a>事件冒泡和事件捕获</h2><h3 id="事件冒泡和事件捕获的区别"><a href="#事件冒泡和事件捕获的区别" class="headerlink" title="事件冒泡和事件捕获的区别"></a>事件冒泡和事件捕获的区别</h3>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"outer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  事件冒泡: 事件从最内层的元素开始，一直向上传播，直到document。则在事件冒泡的概念上，应该是p -&gt; div -&gt; body -&gt; html -&gt; document<br>  事件捕获: 与事件冒泡相反，从最外层开始，直到具体元素</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(event, <span class="function"><span class="keyword">function</span>, <span class="title">useCapture</span>)</span></span><br></pre></td></tr></table></figure><p>  第一个参数是需要绑定的元素<br>  第二个参数是触发事件后要执行的函数<br>  第三个元素就是为事件冒泡还是捕获准备的<br>  默认是false,表示在事件冒泡阶段处理函数，<br>  true 则表示在事件捕获阶段处理函数</p><p>addEventListener方法用来为一个特定的元素绑定一个事件处理函数，</p><h3 id="事件冒泡与事件捕获应用"><a href="#事件冒泡与事件捕获应用" class="headerlink" title="事件冒泡与事件捕获应用:"></a>事件冒泡与事件捕获应用:</h3><p>  在实际开发中，利用事件流的特性，事件代理<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">"color_list"</span>&gt;        </span><br><span class="line">    &lt;li&gt;red&lt;<span class="regexp">/li&gt;        </span></span><br><span class="line"><span class="regexp">    &lt;li&gt;orange&lt;/</span>li&gt;        </span><br><span class="line">    &lt;li&gt;yellow&lt;<span class="regexp">/li&gt;        </span></span><br><span class="line"><span class="regexp">    &lt;li&gt;green&lt;/</span>li&gt;        </span><br><span class="line">    &lt;li&gt;blue&lt;<span class="regexp">/li&gt;        </span></span><br><span class="line"><span class="regexp">    &lt;li&gt;purple&lt;/</span>li&gt;    </span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="box"&gt;&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><br>这时就需要事件代理出场了，利用事件流的特性，我们只绑定一个事件处理函数也可以完成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">colorChange</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> e = e || <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="keyword">if</span> (e.target.nodeName.toLowerCase === <span class="string">'li'</span>) &#123;</span><br><span class="line">     box.innerHTML=<span class="string">"该颜色为 "</span>+e.target.innerHTML;         </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">color_list.addEventListener(<span class="string">"click"</span>, colorChange, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h2 id="Cors中的简单请求和复杂请求"><a href="#Cors中的简单请求和复杂请求" class="headerlink" title="Cors中的简单请求和复杂请求"></a>Cors中的简单请求和复杂请求</h2><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>cors: cross origin resource share 跨域资源共享<br>允许浏览器向跨域服务器发出xhr,从而克服跨域问题，需要浏览器和服务器同时支持。</p><ul><li>浏览器会自动往请求header里添加origin字段表明当前请求来源</li><li>服务器端需要设置响应头的Access-Control-Allow-origin/Methods/Headers 源 方法 头部信息等</li><li>请求分为简单请求和复杂请求，复杂请求发之前会发生Options类型的预检请求，看是否允许当前跨域请求<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3>简单请求<br>请求方法是以下三种方法之一：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HEAD</span><br><span class="line">GET</span><br><span class="line">POST</span><br><span class="line"></span><br><span class="line">HTTP的请求头信息不超出以下几种字段：</span><br><span class="line"></span><br><span class="line">Accept</span><br><span class="line">Accept-Language</span><br><span class="line">Content-Language</span><br><span class="line">Last-Event-ID</span><br><span class="line">Content-Type：只限于三个值application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain</span><br></pre></td></tr></table></figure><h4 id="后端的头部响应设置"><a href="#后端的头部响应设置" class="headerlink" title="后端的头部响应设置"></a>后端的头部响应设置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin：该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个&lt;code&gt;*&lt;<span class="regexp">/code&gt;，表示接受任意域名的请求。</span></span><br><span class="line"><span class="regexp">Access-Control-Allow-Credentials：该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。</span></span><br><span class="line"><span class="regexp">Access-Control-Expose-Headers：该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。</span></span><br></pre></td></tr></table></figure><h3 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h3>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是<strong>application/json</strong>。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求<em>（preflight）</em>。<br>Access-Control-Request-Method: Put/Delete 必须，表示当前请求会用到哪些Http方法<br>Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。<br>如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。</li></ul><h3 id="和JSONP请求对比"><a href="#和JSONP请求对比" class="headerlink" title="和JSONP请求对比"></a>和JSONP请求对比</h3><ul><li>Jsonp只能支持get请求，而cors支持所有http请求方法</li><li>JSONP优势在于支持老是浏览器，以及可以向不支持CORS的网站请求数据</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.cn/post/6844903928442667015#heading-25" target="_blank" rel="noopener">面试分享：两年工作经验成功面试阿里P6总结</a></li><li><a href="https://juejin.cn/post/6844904150459908103" target="_blank" rel="noopener">CORS跨域请求[简单请求与复杂请求]</a></li></ul><h2 id="Set和Map的区别"><a href="#Set和Map的区别" class="headerlink" title="Set和Map的区别"></a>Set和Map的区别</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Es6新的数据结构。类似于数组，成员唯一，没有重复的值<br>Set本身是构造函数，用来生成Set数据结构.</p><h3 id="WeakSet-与-Set区别"><a href="#WeakSet-与-Set区别" class="headerlink" title="WeakSet 与 Set区别"></a>WeakSet 与 Set区别</h3><ul><li>WeakSet成员只能是对象，不能是其他类型的值</li><li>WeakSet的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。<br>因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</li></ul><p>由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。</p><h3 id="WeakSet应用"><a href="#WeakSet应用" class="headerlink" title="WeakSet应用"></a>WeakSet应用</h3><ul><li>WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</li><li>确保实例方法只能在实例上调用，<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foos = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    foos.add(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  method () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!foos.has(<span class="keyword">this</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Foo.prototype.method 只能在Foo的实例上调用！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>上面代码保证了Foo的实例方法，只能在Foo的实例上调用。这里使用 WeakSet 的好处是，foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑foos，也不会出现内存泄漏。</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>js对象，本质上是键值对的集合<em>（hash结构）<em>。<br>以前对象里的key只能是字符串，Map里阔以用对象当作key，Object结构提供了</em>字符串-值<em>的对应结构，Map结构提供了</em>值-值</em> 的数据结构，是一种更完善的hash结构实现。</p><ul><li>Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</li><li>如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。</li></ul><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>WeakMap结构与Map结构类似，也是用于生成键值对的集合。</p><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p>weakMap只接受对象作为键名（null 除外），不接受其他类型的值作为键名key。<br>weakMap它的键名所指向的对象都是弱引用，即垃圾回收机制不会将该引用考虑在内。<br>因此只要所引用对象的<strong>其他引用</strong>都被清除，GC就会释放该引用对象所占的内存，也就是说，一旦不需要，weakMap里的键名对象和对应的键值对会自动消失，不用手动删除引用。</p><p>WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有keys()、values()和entries()方法），也没有size属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>);</span><br><span class="line"></span><br><span class="line">wm.set(element, <span class="string">'some information'</span>);</span><br><span class="line">wm.get(element) <span class="comment">// "some information"</span></span><br></pre></td></tr></table></figure><p>WeakMap对element就是弱引用，不会被计入垃圾回收机制。也就是说，上面dom节点引用计数是1，一旦消除该节点的引用，所占用的内存即会被释放，WeakMap里保存的键值对也会自动消失</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ol><li>DOM节点作为键名 注意是键名<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myWeakmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">myWeakmap.set(</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>),</span><br><span class="line">  &#123;<span class="attr">timesClicked</span>: <span class="number">0</span>&#125;)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> logoData = myWeakmap.get(<span class="built_in">document</span>.getElementById(<span class="string">'logo'</span>));</span><br><span class="line">  logoData.timesClicked++;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>上面代码中，document.getElementById(‘logo’)是一个 DOM 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的<em>键名</em>就是这个节点对象。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。</li></ol><p>2.WeakMap 部署私有属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SimCard = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> _private = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">SimCard</span> </span>&#123;</span><br><span class="line">   <span class="keyword">constructor</span>(number, type, p1, p2) &#123;</span><br><span class="line">        _private.set(<span class="string">'p1'</span>, p1)</span><br><span class="line">        _private.set(<span class="string">'p2'</span>, p2)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> p1() &#123;</span><br><span class="line">        <span class="keyword">return</span> _private.get(<span class="string">'p1'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> p2() &#123;</span><br><span class="line">        <span class="keyword">return</span> _private.get(<span class="string">'p2'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> SimCard</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> SimCard(<span class="string">'one'</span>, <span class="string">'two'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(test.p1) <span class="comment">// 'one'</span></span><br><span class="line"><span class="built_in">console</span>.log(test.p2) <span class="comment">// 'two'</span></span><br><span class="line"><span class="built_in">console</span>.log(test._private) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.cn/post/6844903863921672200#heading-1" target="_blank" rel="noopener">ECMAScript 类 —— 定义私有属性</a></li><li><a href="https://es6.ruanyifeng.com/#docs/set-map#Map" target="_blank" rel="noopener">map</a></li></ul><h2 id="vue-slot是做什么的"><a href="#vue-slot是做什么的" class="headerlink" title="vue slot是做什么的"></a>vue slot是做什么的</h2><h2 id="实现bind函数"><a href="#实现bind函数" class="headerlink" title="实现bind函数"></a>实现bind函数</h2><h2 id="实现一个并发请求控制函数"><a href="#实现一个并发请求控制函数" class="headerlink" title="实现一个并发请求控制函数"></a>实现一个并发请求控制函数</h2><h2 id="参考链接-2"><a href="#参考链接-2" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://juejin.cn/post/6844903834075021326" target="_blank" rel="noopener">你真的理解 事件冒泡 和 事件捕获 吗？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 重新认识this</title>
      <link href="/2021/02/28/%E5%9F%BA%E7%A1%80-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86this/"/>
      <url>/2021/02/28/%E5%9F%BA%E7%A1%80-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86this/</url>
      
        <content type="html"><![CDATA[<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p><img src= "/img/loading.gif" data-src="/images/this/executable.png" alt="执行上下文生命周期"><br>当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p><p>可执行代码<br>这就要说到 JavaScript 的可执行代码(executable code)的类型有哪些了？<br>其实很简单，就三种，全局代码、函数代码、eval代码。<br>举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做”执行上下文(execution contexts)”。</p><p>对于每个执行上下文，都有三个重要属性：</p><ul><li>变量对象(Variable object，VO)</li><li>作用域链(Scope chain)</li><li>this</li></ul><p>执行上下文的创建阶段，会分别生成变量对象，建立作用域链，确定this指向，谨记this的指向，是在<em>函数被调用<em>的时候确定的。也就是</em>执行上下文被创建时<em>确定的。且在函数执行过程中，</em>this一旦被确定，就不可更改了</em></p><p>this 并不是取决于他所在的位置，而是取决于他所在的Function是如何调用的<br>构造函数中的 this ，就是指向即将实例化的那个对象。谨记！</p><h2 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h2><p>在全局执行上下文中this都指代全局对象。<br>在浏览器里面this等价于window对象，如果你声明一些全局变量，这些变量都会作为this的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过this绑定到全局对象</span></span><br><span class="line"><span class="keyword">this</span>.a2 = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 通过声明绑定到变量对象，但在全局环境中，变量对象就是它自身</span></span><br><span class="line"><span class="keyword">var</span> a1 = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 仅仅只有赋值操作，标识符会隐式绑定到全局对象</span></span><br><span class="line">a3 = <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 输出结果会全部符合预期</span></span><br><span class="line"><span class="built_in">console</span>.log(a1);</span><br><span class="line"><span class="built_in">console</span>.log(a2);</span><br><span class="line"><span class="built_in">console</span>.log(a3);</span><br></pre></td></tr></table></figure><h2 id="函数上下文-函数中的this"><a href="#函数上下文-函数中的this" class="headerlink" title="函数上下文,函数中的this"></a>函数上下文,函数中的this</h2><ul><li>demo<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  c: <span class="keyword">this</span>.a + <span class="number">20</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.c); </span><br><span class="line"><span class="built_in">console</span>.log(obj.fn());</span><br></pre></td></tr></table></figure>注意这里的<br>obj: {<br>c: this.a + 20<br>} <blockquote><p>单独的{}不会形成新的作用域，因此这里的this.a，由于并没有作用域的限制，它仍然处于全局作用域之中。所以这里的this其实是指向的window对象。</p></blockquote></li></ul><h3 id="直接调用"><a href="#直接调用" class="headerlink" title="直接调用"></a>直接调用</h3><p>this指向全局变量, this === window </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo() === <span class="built_in">window</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="作为对象的一个方法"><a href="#作为对象的一个方法" class="headerlink" title="作为对象的一个方法"></a>作为对象的一个方法</h3><p>this指向调用函数的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"cpp"</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// cpp</span></span><br></pre></td></tr></table></figure><p>稍不留心写成了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"cpp"</span>,</span><br><span class="line">  getName: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// '' 返回空字符串</span></span><br></pre></td></tr></table></figure><p>这是因为下面要说的箭头函数</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>所有的箭头函数都没有自己的this，都指向外层,<br>1.没有自己的this、super、arguments和new.target绑定。<br>2.不能使用new来调用。<br>3.没有原型对象。<br>4.不可以改变this的绑定。<br>5.形参名称不能重复。<br>MDN中的解释</p><blockquote><p>An arrow function does not create its own this, the this value of the enclosing execution context is used.<br>箭头函数会捕获其所在上下文的this值，作为自己的this值。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"xb"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"sb"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.say()); <span class="comment">// sb</span></span><br></pre></td></tr></table></figure><h4 id="哪些场景下不能使用箭头函数"><a href="#哪些场景下不能使用箭头函数" class="headerlink" title="哪些场景下不能使用箭头函数"></a>哪些场景下不能使用箭头函数</h4><p>1.在一个对象上，定义一个指向函数的属性，当方法被调用时，方法内的this指向方法所属的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calculator = &#123;</span><br><span class="line">  array: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  sum: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// =&gt; true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.array.reduce(<span class="function">(<span class="params">result, item</span>) =&gt;</span> result + item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="comment">// Throws "TypeError: Cannot read property 'reduce' of undefined"</span></span><br><span class="line">calculator.sum();</span><br></pre></td></tr></table></figure><p>2.定义原型方法<br>3.定义事件回调函数<br>4.定义构造函数</p><h3 id="作为一个构造函数"><a href="#作为一个构造函数" class="headerlink" title="作为一个构造函数"></a>作为一个构造函数</h3><p>this被绑定到正在构造的实例中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">30</span>;</span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">":"</span> + <span class="keyword">this</span>.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"cpp"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// cpp</span></span><br><span class="line">person.say(); <span class="comment">// cpp:30</span></span><br></pre></td></tr></table></figure><h2 id="this绑定优先级"><a href="#this绑定优先级" class="headerlink" title="this绑定优先级"></a>this绑定优先级</h2><p>优先级是new 调用 &gt; call、apply、bind 调用 &gt; 对象上的函数调用 &gt; 普通函数调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'person'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> doSth = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'return:'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Student = &#123;</span><br><span class="line">    name: <span class="string">'若川'</span>,</span><br><span class="line">    doSth: doSth</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通函数调用</span></span><br><span class="line">doSth(); <span class="comment">// window</span></span><br><span class="line"><span class="comment">// 对象上的函数调用</span></span><br><span class="line">Student.doSth(); <span class="comment">// '若川'</span></span><br><span class="line"><span class="comment">// call、apply 调用</span></span><br><span class="line">Student.doSth.call(person); <span class="comment">// 'person'</span></span><br><span class="line"><span class="keyword">new</span> Student.doSth.call(person) <span class="comment">//  VM36:21 Uncaught TypeError: Student.doSth.call is not a constructor</span></span><br></pre></td></tr></table></figure><p>最后一个执行报错<br>这是因为函数内部有两个不同的方法：[[Call]]和[[Constructor]]。<br>当使用普通函数调用时，[[Call]]会被执行。当使用构造函数调用时，[[Constructor]]会被执行。call、apply、bind和箭头函数内部没有[[Constructor]]方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>new 调用：绑定到新创建的对象，注意：显示return函数或对象，返回值不是新创建的对象，而是显式返回的函数或对象。</li><li>call 或者 apply（ 或者 bind） 调用：严格模式下，绑定到指定的第一个参数。非严格模式下，null和undefined，指向全局对象（浏览器中是window），其余值指向被new Object()包装的对象。</li><li>对象上的函数调用：绑定到那个对象。</li><li>普通函数调用： 在严格模式下绑定到 undefined，否则绑定到全局对象。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/axuebin/articles/issues/6" target="_blank" rel="noopener">JavaScript基础心法——this </a></li><li><a href="https://juejin.cn/post/6844903746984476686#heading-8" target="_blank" rel="noopener">面试官问：JS的this指向</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> this </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端安全-xss和csrf</title>
      <link href="/2021/02/28/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8-xss%E5%92%8Ccsrf/"/>
      <url>/2021/02/28/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8-xss%E5%92%8Ccsrf/</url>
      
        <content type="html"><![CDATA[<h2 id="csrf"><a href="#csrf" class="headerlink" title="csrf"></a>csrf</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>csrf: 跨站请求伪造 cross site Request <strong>forgery</strong> 或者简称xsrf。是指在挟持用户当前已经登录的web应用程序当中执行非本意操作的攻击方法。<br>另一个是xss cross site script 跨站脚本攻击，两者区别是 xss利用用户对网站的信任，csrf利用的则是网站对用户网页浏览器的信任</p><blockquote><p>简单来说就是利用用户的登录态发起恶意请求</p></blockquote><h3 id="如何攻击的"><a href="#如何攻击的" class="headerlink" title="如何攻击的"></a>如何攻击的</h3><p><img src= "/img/loading.gif" data-src="https://user-gold-cdn.xitu.io/2018/8/8/1651a22ce6858fd9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="csrf"></p><h3 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h3><p>遵循以下几种原则:<br>1.get请求不对数据进行修改<br>2.禁止第三方网站访问到用户cookie<br>3.阻止第三方网站请求接口<br>4.请求时附带验证信息，比如tocken或者验证码</p><p>具体措施</p><h4 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h4><p>对cookie设置SameSite属性，设置之后cookie信息不会随着跨域请求发送，很大程度上减少CSRF攻击</p><h4 id="验证referer"><a href="#验证referer" class="headerlink" title="验证referer"></a>验证referer</h4><p>在对需要防范csrf的请求中，我们阔以根据请求头中的referer属性来判断请求来源</p><h4 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h4><p>服务器下发随机token，前端每次发请求携带token，后端验证token的有效性</p><h4 id="防抓包"><a href="#防抓包" class="headerlink" title="防抓包"></a>防抓包</h4><p>使用https替换http(https还是通过http进行传输，只是信息经过tls协议加密，对传输的数据进行加密，当请求的信息被抓包工具抓包时，无法修改提交的数据)</p><h2 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h2><p>xss cross site script 跨站脚本攻击<br>通过在客户端注入可执行脚本的方式实行攻击</p><h3 id="主要方式"><a href="#主要方式" class="headerlink" title="主要方式"></a>主要方式</h3><ul><li><p>劫持Html ,通过script标签进行注入</p></li><li><p>在可执行的js中，通过拼接数据来执行恶意脚本 </p></li><li><p>在页面可执行的dom元素，添加可执行代码，比如javascript:xx</p></li><li><p>在onload/onClick事件中注入不受控制的代码</p></li></ul><h3 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h3><p>有存储型Xss 反射型Xss 以及DOM型Xss,跟前端有关的是DOM型Xss,其他防范主要在后端</p><h4 id="存储型Xss"><a href="#存储型Xss" class="headerlink" title="存储型Xss"></a>存储型Xss</h4><p>恶意脚本存储在后端数据库，然后又传输到前台页面，从而发生攻击。防范主要是通过文本转义</p><h4 id="反射型Xss"><a href="#反射型Xss" class="headerlink" title="反射型Xss"></a>反射型Xss</h4><p>恶意脚本不是存储在后端，而是出现在url里，防范主要是<br>区分两者主要看恶意代码的存储位置</p><h4 id="Dom型Xss"><a href="#Dom型Xss" class="headerlink" title="Dom型Xss"></a>Dom型Xss</h4><p>不需要跟后端交互，主要是通过劫持Html文件进行修改实现恶意代码的注入<br>在DOM api中通过 textContext/setAttribute来代替.innerHtml/docuemnt.write Vue中不建议用v-html</p><h3 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h3><h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><p>在存储型XSS和反射型XSS攻击中，这个是一个关键的防范方式，通过对不同类型的<strong>文本和数据</strong>做对应的转义和很好的防止大部分的XSS攻击</p><h4 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h4><p>通过在脚本增加 <em>Content-security-Policy</em> 字段来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content-security-policy: <span class="keyword">default</span>-src <span class="string">'self'</span></span><br></pre></td></tr></table></figure><p>在较严格的CSP模式下，具有以下作用<br>1.禁止加载外域代码<br>2.禁止内联脚本执行<br>3.禁止外域提交<br>4.禁止未授权的脚本执行<br>5.通过csp上报 便于修复</p><h4 id="httponly"><a href="#httponly" class="headerlink" title="httponly"></a>httponly</h4><p>cookie里的一个属性，主要防止cookie属性被改写，该属性主要是防止cookie被js获取，只能通过http传输和访问<br>httpOnly本质上不能防止xss攻击，主要是起到缓解作用，在恶意脚本执行之后无法获取cookie,防止下一步的攻击和用户数据泄露</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://juejin.cn/post/6892938793901359112" target="_blank" rel="noopener">前端安全-XSS</a></li><li><a href="https://juejin.cn/post/6844903653757698062" target="_blank" rel="noopener">关于csrf,什么是csrf,怎么防范它?</a></li><li><a href="https://yuchengkai.cn/docs/frontend/#%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">前端面试</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> xss </category>
          
          <category> csrf </category>
          
          <category> csp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
            <tag> csrf </tag>
            
            <tag> csp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法基础: BFS和DFS</title>
      <link href="/2021/02/21/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-BFS%E5%92%8CDFS/"/>
      <url>/2021/02/21/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-BFS%E5%92%8CDFS/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue进阶: 依赖收集原理</title>
      <link href="/2021/02/15/vue%E8%BF%9B%E9%98%B6-%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%E5%8E%9F%E7%90%86/"/>
      <url>/2021/02/15/vue%E8%BF%9B%E9%98%B6-%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>一对多关系解耦的行为设计模式，主要涉及两个角色，观察者和观察目标<br> 观察者直接订阅观察目标，观察目标(订阅中心)做出通知，观察者就要进行处理</p><h3 id="vue依赖收集"><a href="#vue依赖收集" class="headerlink" title="vue依赖收集"></a>vue依赖收集</h3><p>  <img src= "/img/loading.gif" data-src="/images/vue/depend.png" alt="vue依赖收集"><br>  每个组件实例都会有相应的Watcher实,渲染组件的过程，会把属性记录为依赖，当我们操作数据的时候，依赖项的setter会被调用，从而通知Watcher重新计算，从而使得相关的组件得以更新。</p><p>  Getter里进行依赖收集，当依赖的数据被更新时，会触发该数据的setter,setter里会触发render函数重新计算</p><h3 id="依赖收集与观察者模式"><a href="#依赖收集与观察者模式" class="headerlink" title="依赖收集与观察者模式"></a>依赖收集与观察者模式</h3><p>vue依赖收集的场景既是一对多，一个数据发生变更，多处用到该数据的地方都得处理。而且依赖的数据变了，即必须要做出处理。<br>vue里，<strong>依赖</strong>的数据是观察目标(Dep, 订阅中心)，依赖就是Dep<br>视图、计算属性、侦听器等算是观察者(watcher),用到该数据的就是观察者(Watcher)</p><h3 id="源码解析vue依赖收集"><a href="#源码解析vue依赖收集" class="headerlink" title="源码解析vue依赖收集"></a>源码解析vue依赖收集</h3><h4 id="三个角色"><a href="#三个角色" class="headerlink" title="三个角色"></a>三个角色</h4><p>Dep: 扮演观察目标的角色，每一个数据都会有一个Dep类的实例，内部有subs队列，保存着依赖本数据的观察者Watcher,当本数据变更时，调用实例dep.notify()通知观察者Watcher</p><p>Watcher: 扮演观察者的角色，进行观察者函数 的包装处理，render函数会被包装成一个Watcher实例</p><p>Observer: 辅助的可观测类，数组和对象通过其转化，可成为可观测数据</p><h4 id="每一个数据都会有一个Dep类的实例：-观察目标"><a href="#每一个数据都会有一个Dep类的实例：-观察目标" class="headerlink" title="每一个数据都会有一个Dep类的实例： 观察目标"></a>每一个数据都会有一个Dep类的实例： 观察目标</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> target = <span class="literal">null</span> <span class="comment">// 指向对应的Watcher实例</span></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.uid ++;</span><br><span class="line">    <span class="keyword">this</span>.subs = []; <span class="comment">// 管理watcher实例</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加watcher实例</span></span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 依赖</span></span><br><span class="line">  depend() &#123;</span><br><span class="line">    <span class="comment">// Dep.target指向对应的watcher实例 </span></span><br><span class="line">    <span class="comment">// this 指向Dep实例</span></span><br><span class="line">    Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// setter触发watcher更新</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">var</span> subs = <span class="keyword">this</span>.subs.slice();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于JavaScript是单线程模型，所以虽然有多个观察者函数，但是一个时刻内，就只会有一个观察者函数在执行，那么此刻正在执行的那个观察者函数，所对应的Watcher实例，便会被赋给Dep.target这一类变量，从而只要访问Dep.target就能知道当前的观察者是谁。 在后续的依赖收集工作里，getter里会调用dep.depend()，而setter里则会调用dep.notify();</p><h4 id="配置观测数据"><a href="#配置观测数据" class="headerlink" title="配置观测数据"></a>配置观测数据</h4><p>observe主要是给每层数据加一个私有属性<strong><strong>ob</strong></strong>，同时这个<strong>ob</strong>是 Observer类的一个实例，总结来说就是给对象和数组实例化一个Observer实例，且在依赖的数据是可配置的时候才会实例化。<br>在<strong>ob</strong>上挂载dep实例，用来处理改变内容的情况，以便能够形成追踪链路。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value, asRootData</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果不是Object类型则不能观测 </span></span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> ob;</span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Observer类代码: 辅助的可观测类，数组和对象通过其转化，可成为可观测数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Observer = <span class="function"><span class="keyword">function</span> <span class="title">Observer</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = value;</span><br><span class="line">  <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep(); <span class="comment">// 实例化一个观察目标对象</span></span><br><span class="line">  <span class="keyword">this</span>.vmCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// def(value, '__ob__', this);</span></span><br><span class="line">  <span class="comment">// this 既是当前实例化的Observer实例</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(value, <span class="string">'__ob__'</span>, &#123;</span><br><span class="line">    value: <span class="keyword">this</span>,</span><br><span class="line">    enumerable: !!enumerable,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observeArray(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 对象处理</span></span><br><span class="line">    <span class="keyword">this</span>.walk(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Observer.prototype.walk = <span class="function"><span class="keyword">function</span> <span class="title">walk</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    defineReactive$$<span class="number">1</span>(obj, keys[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">Observer.prototype.observeArray = <span class="function"><span class="keyword">function</span> <span class="title">observeArray</span> (<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">    observe(items[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结Observer类就是: 将Observer实例挂载在<strong><em>ob</em></strong>属性上，提供后续观测数据使用。同时实例化一个Dep(观察目标)类实例。同时将对象、数组绑定在value对象上，即</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原数据</span></span><br><span class="line">data: &#123;</span><br><span class="line">  name: <span class="string">'cpp'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改造后</span></span><br><span class="line">data: &#123;</span><br><span class="line">  name: <span class="string">'cpp'</span>,</span><br><span class="line">  __ob__: &#123; <span class="comment">// Observer实例</span></span><br><span class="line">    dep: <span class="keyword">new</span> Dep(), <span class="comment">// dep依赖收集器 观察目标 订阅器 信息中心 各种叫法</span></span><br><span class="line">    value: data, <span class="comment">// 数据本身data</span></span><br><span class="line">    vmCount: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> name: ƒ reactiveGetter(),</span><br><span class="line">  <span class="keyword">get</span> name: ƒ reactiveSetter(newVal),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如果value是个对象，就执行walk-过程，遍历对象把每一项数据都变为可观测数据（调用defineReactive方法处理）"><a href="#如果value是个对象，就执行walk-过程，遍历对象把每一项数据都变为可观测数据（调用defineReactive方法处理）" class="headerlink" title="如果value是个对象，就执行walk()过程，遍历对象把每一项数据都变为可观测数据（调用defineReactive方法处理）"></a>如果value是个对象，就执行<em>walk()</em>过程，遍历对象把每一项数据都变为可观测数据（调用defineReactive方法处理）</h4><p>Observer里依赖收集：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据改造成属性getter/setter</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive$$1</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj,</span></span></span><br><span class="line"><span class="function"><span class="params">  key,</span></span></span><br><span class="line"><span class="function"><span class="params">  val,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 每个引用类型的属性都有自己的dep，用于收集该引用类型自动的依赖</span></span><br><span class="line">  <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  <span class="keyword">var</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">  <span class="keyword">var</span> getter = property &amp;&amp; property.get;</span><br><span class="line">  <span class="keyword">var</span> setter = property &amp;&amp; property.set;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">      <span class="comment">// Watcher 依赖收集</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal;</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">      <span class="comment">// 数据变更 观察目标通知观察者</span></span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>defineReactive</em>方法做了下面几件事</p><ul><li>为每个属性实例化一个dep依赖收集器，用于收集该属性的相关依赖</li><li>缓存属性原有的get和set方法，保证后面重写get、set方法时行为正常</li><li>对子属性进行observer递归</li><li>将对象中的每一个属性都加上<strong>getter、setter</strong>方法</li></ul><p>经过defineReactive处理的数据变化如下, 每个属性都有自己的dep、childOb、getter、setter，并且每个object类型的属性都有<strong>ob</strong></p><p>getter方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line"><span class="comment">//调用原属性的get方法返回值</span></span><br><span class="line"><span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">    <span class="comment">//如果存在需要被收集的依赖 Dep.target执行当前的Watcher</span></span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        <span class="comment">/* 将依赖收集到该属性的dep中 */</span></span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          <span class="comment">//每个对象的childOb.__ob__.dep中也收集该依赖</span></span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="comment">//如果属性是array类型，进行dependArray操作</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>做了2件事<br>1.调用属性的get方法返回值<br>2.收集依赖<br>  a.Dep.target表示一个依赖，即观察者Watcher，大部分情况下是一个依赖函数。<br>  b.如果存在需要被收集的依赖，则收集依赖的数据到该属性的dep依赖收集器中,每个属性都有一个dep(实例化的Dep)<br>  c.如果存在childOb,则依赖收集到value.<strong>ob</strong>.dep.depend();<br>  d.如果属性的值是数组，调用dependArray函数，将依赖收集到数组中的每一个对象元素的<strong>ob</strong>.dep中。确保在使用$set 或 Vue.set时，数组中嵌套的对象能正常响应。代码如下：<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  user: [</span><br><span class="line">    name: <span class="string">'cpp'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 页面显示</span></span><br><span class="line">&#123;&#123;user&#125;&#125;</span><br><span class="line">&lt;Button @click=<span class="string">"addAge()"</span>&gt;addAge&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/addAge方法,为数组中的嵌套对象添加age属性</span></span><br><span class="line"><span class="regexp">addAge: function()&#123;</span></span><br><span class="line"><span class="regexp">this.$set(this.user[0], 'age', 18)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><br>dependArray函数如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dependArray</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> e = (<span class="keyword">void</span> <span class="number">0</span>), i = <span class="number">0</span>, l = value.length; i &lt; l; i++) &#123;</span><br><span class="line">    e = value[i];</span><br><span class="line">     <span class="comment">//将依赖收集到每一个子对象/数组中</span></span><br><span class="line">    e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(e)) &#123;</span><br><span class="line">      dependArray(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化后的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//转化后数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  user: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">'summer'</span>,</span><br><span class="line">      __ob__: &#123;user[<span class="number">0</span>], dep, vmCount&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    __ob__: &#123;user, dep, vmCount&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>（所谓依赖，就是这个组件所需要依赖到的数据）</strong></p></blockquote><h4 id="总结一句话就是在getter方法中，将存在的观察者收集到Dep中，由Dep中的subs统一管理，集中维护"><a href="#总结一句话就是在getter方法中，将存在的观察者收集到Dep中，由Dep中的subs统一管理，集中维护" class="headerlink" title="总结一句话就是在getter方法中，将存在的观察者收集到Dep中，由Dep中的subs统一管理，集中维护"></a>总结一句话就是在getter方法中，将存在的观察者收集到Dep中，由Dep中的subs统一管理，集中维护</h4><h4 id="如果value是个数组，就执行observeArray-过程，递归地对数组元素调用observe-，以便能够对元素还是数组的情况进行处理"><a href="#如果value是个数组，就执行observeArray-过程，递归地对数组元素调用observe-，以便能够对元素还是数组的情况进行处理" class="headerlink" title="如果value是个数组，就执行observeArray()过程，递归地对数组元素调用observe()，以便能够对元素还是数组的情况进行处理."></a>如果value是个数组，就执行observeArray()过程，递归地对数组元素调用observe()，以便能够对元素还是数组的情况进行处理.</h4><p>相关代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">    <span class="comment">// protoAugment(value, arrayMethods);</span></span><br><span class="line">    value.__proto__ = arrayMethods</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    copyAugment(value, arrayMethods, arrayKeys);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 递归观测数组中的每一个值</span></span><br><span class="line">  <span class="keyword">this</span>.observeArray(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Observer原型上的observeArray方法</span></span><br><span class="line">Observer.prototype.observeArray = <span class="function"><span class="keyword">function</span> <span class="title">observeArray</span> (<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">    observe(items[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>1.使用protoAugment方法指定value值的原型链为arrayMethods函数，<br>2.遍历数组中的每一个值，调用observer方法，使其观测</p><h4 id="arrayMethods-拦截修改数组方法"><a href="#arrayMethods-拦截修改数组方法" class="headerlink" title="arrayMethods 拦截修改数组方法"></a>arrayMethods 拦截修改数组方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayProto = <span class="built_in">Array</span>.prototype;</span><br><span class="line"><span class="keyword">var</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">var</span> original = arrayProto[method];</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [], len = <span class="built_in">arguments</span>.length;</span><br><span class="line">    <span class="keyword">while</span> ( len-- ) args[ len ] = <span class="built_in">arguments</span>[ len ];</span><br><span class="line">    <span class="keyword">var</span> result = original.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    <span class="keyword">var</span> ob = <span class="keyword">this</span>.__ob__;</span><br><span class="line">    <span class="keyword">var</span> inserted;</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对新增元素使用observerArray方法进行观测</span></span><br><span class="line">    <span class="keyword">if</span> (inserted) &#123; ob.observeArray(inserted); &#125;</span><br><span class="line">    <span class="comment">// notify change 触发__ob__.dep中的所有依赖</span></span><br><span class="line">    ob.dep.notify();</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>arrayMethods做了几件事</p><p>1.需要拦截的修改数组的方法有：push、pop、shift、unshift、splice、sort、reverse<br>2.当数组有新增元素时，使用observeArray对新增的元素进行观测<br>3.拦截了修改数组的方法，当修改数组方法被调用时触发数组中的<strong>ob</strong>.dep的所有依赖(ob.dep.notify();)</p><h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4><p>只关心数据，数据发生变化的时候，Dep.notify() =&gt; Watcher.update()</p><p>Watcher扮演的角色是观察者，它关心数据，在数据变化后能够获得通知，并作出处理。一个组件里可以有多个Watcher类实例，Watcher类包装观察者函数，而观察者函数使用数据。 观察者函数经过Watcher是这么被包装的： </p><ul><li>模板渲染：<br><code>this._watcher = new Watcher(this, render, this._update)</code></li><li>计算属性：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    name() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">会形成</span></span><br><span class="line"><span class="comment">new Watcher(this, function name() &#123;</span></span><br><span class="line"><span class="comment">    return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;`</span></span><br><span class="line"><span class="comment">&#125;, callback);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>Watcher主要代码如下<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    vm: Component, // 组件实例</span><br><span class="line">    expOrFn: string | Function, // 观察者函数 即上述的function name函数</span><br><span class="line">    cb: Function, // 回调函数</span><br><span class="line">    options?: ?Object, // 选项</span><br><span class="line">    isRenderWatcher?: boolean</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = !!options.deep</span><br><span class="line">      <span class="keyword">this</span>.user = !!options.user</span><br><span class="line">      <span class="keyword">this</span>.lazy = !!options.lazy</span><br><span class="line">      <span class="keyword">this</span>.sync = !!options.sync</span><br><span class="line">      <span class="keyword">this</span>.before = options.before</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = <span class="keyword">this</span>.user = <span class="keyword">this</span>.lazy = <span class="keyword">this</span>.sync = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.deps = [] <span class="comment">// 缓存上一轮执行观察者函数用到的dep实例</span></span><br><span class="line">    <span class="keyword">this</span>.newDeps = [] <span class="comment">// 存储本轮执行观察者函数用到的dep实例</span></span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>() <span class="comment">// Hash表，用于快速查找</span></span><br><span class="line">    <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>() <span class="comment">// Hash表，用于快速查找</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 视图更新</span></span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">      <span class="keyword">this</span>.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 订阅观察目标</span></span><br><span class="line">  addDep(dep) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.id</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">      <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">        dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/45081605" target="_blank" rel="noopener">深入解析Vue依赖收集原理</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> vue源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 观察者模式 </tag>
            
            <tag> 依赖收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法基础: 树和二叉搜索树</title>
      <link href="/2021/02/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2021/02/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><img src= "/img/loading.gif" data-src="/images/tree/tree.jpg" alt="树"></p><h2 id="二叉树和二叉搜索树"><a href="#二叉树和二叉搜索树" class="headerlink" title="二叉树和二叉搜索树"></a>二叉树和二叉搜索树</h2><p>二叉树: 书中的节点最多只能有2个节点，一个是左侧子节点，一个是右侧子节点<br>二叉搜索树(BST): 二叉树种的一种，但是只允许你在左侧存储比父节点小的值，右侧存储比父节点大的值 </p><h3 id="两颗相同的树"><a href="#两颗相同的树" class="headerlink" title="两颗相同的树"></a>两颗相同的树</h3><p>题目:<br>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>答案:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">p</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">q</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSameTree = <span class="function"><span class="keyword">function</span>(<span class="params">p, q</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span> || q == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  p.val === q.val &amp;&amp; isSameTree(p.right, q.right) &amp;&amp; isSameTree(p.left, q.left)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>链接: <a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">100. 相同的树</a></p><h3 id="二叉搜索树的中序遍历"><a href="#二叉搜索树的中序遍历" class="headerlink" title="二叉搜索树的中序遍历"></a>二叉搜索树的中序遍历</h3><p>题目: 给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p><p>递归遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = []</span><br><span class="line">    <span class="keyword">const</span> inOder = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node !== <span class="literal">null</span>) &#123;</span><br><span class="line">            inOder(node.left)</span><br><span class="line">            arr.push(node.val)</span><br><span class="line">            inOder(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    inOder(root)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">inOrderTravserseIterator(root) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = []; <span class="comment">// 最终的结果</span></span><br><span class="line">  <span class="keyword">const</span> stack = []</span><br><span class="line">  <span class="keyword">while</span>(root) &#123;</span><br><span class="line">    stack.push(root)</span><br><span class="line">    root= root.left</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(stack.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = stack.pop(); <span class="comment">// 栈顶的节点出栈</span></span><br><span class="line">    res.push(current.val)</span><br><span class="line">    current = current.right; <span class="comment">// 获取右子树</span></span><br><span class="line">    <span class="keyword">while</span>(current) &#123;</span><br><span class="line">      stack.push(current)</span><br><span class="line">      current = current.left</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/images/tree/inOrder.png" alt="迭代遍历"><br>链接：</p><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/submissions/" target="_blank" rel="noopener">二叉搜索树的中序遍历</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/shou-hua-tu-jie-yong-zhan-mo-ni-zhong-xu-bian-li-z/" target="_blank" rel="noopener">「手画图解」用栈模拟中序遍历，怎么做以及为什么 | 递归与迭代</a></li></ul><h3 id="二叉树先序遍历"><a href="#二叉树先序遍历" class="headerlink" title="二叉树先序遍历"></a>二叉树先序遍历</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = []</span><br><span class="line">    <span class="keyword">const</span> inOder = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node !== <span class="literal">null</span>) &#123;</span><br><span class="line">            arr.push(node.val)</span><br><span class="line">            inOder(node.left)</span><br><span class="line">            inOder(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    inOder(root)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = []</span><br><span class="line">    <span class="keyword">const</span> postOrder = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">            postOrder(node.left)</span><br><span class="line">            postOrder(node.right)</span><br><span class="line">            arr.push(node.val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrder(root)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。<br>示例：<br>二叉树：[3,9,20,null,null,15,7],<br>得到:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="广度遍历bfs"><a href="#广度遍历bfs" class="headerlink" title="广度遍历bfs"></a>广度遍历bfs</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;<span class="keyword">return</span> []&#125;;</span><br><span class="line">    <span class="comment">// bfs</span></span><br><span class="line">    <span class="comment">// 根节点放入队列</span></span><br><span class="line">    <span class="keyword">let</span> queue = [root]</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">while</span>(queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> len = queue.length;</span><br><span class="line">        <span class="keyword">let</span> arr = []</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="comment">// 依次取出队列中的中塞到每一层的arr</span></span><br><span class="line">            <span class="keyword">let</span> node = queue.shift()</span><br><span class="line">            arr.push(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left) &#123;</span><br><span class="line">                queue.push(node.left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right) &#123;</span><br><span class="line">                queue.push(node.right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(arr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="dfs深度遍历"><a href="#dfs深度遍历" class="headerlink" title="dfs深度遍历"></a>dfs深度遍历</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">levelOrderdfs() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.root) &#123;<span class="keyword">return</span> []&#125;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">node, step, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!res[step]) &#123;</span><br><span class="line">        res[step] = []</span><br><span class="line">      &#125;</span><br><span class="line">      res[step].push(node.key)</span><br><span class="line">      dfs(node.left, step + <span class="number">1</span>, res);</span><br><span class="line">      dfs(node.right, step + <span class="number">1</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(<span class="keyword">this</span>.root, <span class="number">0</span>, res)</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><p>递归的结束条件：当遍历到 null 节点，它们的高度是 0，返回 0。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> leftMaxDepth = maxDepth(root.left);</span><br><span class="line">      <span class="keyword">const</span> rightMaxDepth = maxDepth(root.right);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">Math</span>.max(leftMaxDepth, rightMaxDepth)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最小深度"><a href="#最小深度" class="headerlink" title="最小深度"></a>最小深度</h3><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明：叶子节点是指没有子节点的节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span>  <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">Math</span>.min(minDepth(root.right), minDepth(root.left))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树所有路径"><a href="#二叉树所有路径" class="headerlink" title="二叉树所有路径"></a>二叉树所有路径</h3><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p>说明: 叶子节点是指没有子节点的节点。<br>实例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输入:</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span></span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">5</span></span><br><span class="line"></span><br><span class="line">输出: [<span class="string">"1-&gt;2-&gt;5"</span>, <span class="string">"1-&gt;3"</span>]</span><br><span class="line"></span><br><span class="line">解释: 所有根节点到叶子节点的路径为: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>, <span class="number">1</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-paths" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-paths</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 树 </category>
          
          <category> 二叉搜索树 </category>
          
          <category> 中序、先序、后序、层序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉搜索树 </tag>
            
            <tag> 中序、先序、后序、层序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构进阶: 链表</title>
      <link href="/2021/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6-%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/02/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%BF%9B%E9%98%B6-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>链表还是没啥数据概念，多做做点题目，理解理解链表</p><h2 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><p><img src= "/img/loading.gif" data-src="/images/linkedList/swap_ex1.jpg" alt="两两交换"></p><p>输入：head = [1,2,3,4]<br>输出：[2,1,4,3]</p><h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a>示例 1</h4><p>输入：head = [1]<br>输出：[1]</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>对于不熟悉链表数据结构的同学还是画画流程图，图画好了基本能明白大概了</p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两两交换</span></span><br><span class="line">swapPairs() &#123;</span><br><span class="line">  <span class="keyword">const</span> head = <span class="keyword">this</span>.head</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> helper = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> tempNext = node.next</span><br><span class="line">    <span class="keyword">if</span> (tempNext) &#123;</span><br><span class="line">      <span class="keyword">const</span> tempNextNext = node.next.next</span><br><span class="line">      node.next.next = node</span><br><span class="line">      <span class="keyword">if</span> (tempNextNext) &#123;</span><br><span class="line">        node.next = helper(tempNextNext)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.next = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tempNext || node</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.head = helper(head);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'head'</span>, <span class="keyword">this</span>.head);</span><br><span class="line">  <span class="comment">// return res</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代码位置 <a href="https://github.com/niaogege/webpack-learn/blob/linkedList/src/linkedList/main.js" target="_blank" rel="noopener">链表问题1</a></p></blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/submissions/" target="_blank" rel="noopener">两两交换链表中的节点</a></li><li><a href="https://juejin.cn/post/6847009772500156429#heading-8" target="_blank" rel="noopener">链表问题</a></li></ul><h2 id="环形链表一"><a href="#环形链表一" class="headerlink" title="环形链表一"></a>环形链表一</h2><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p><img src= "/img/loading.gif" data-src="/images/linkedList/circularlinkedlist.png" alt="两两交换"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><h3 id="解法1-hash表"><a href="#解法1-hash表" class="headerlink" title="解法1 hash表"></a>解法1 hash表</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hasCycle() &#123;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">  <span class="keyword">if</span> (!current || !current.next) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">while</span>(current.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.has(current)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    map.set(current, <span class="literal">true</span>)</span><br><span class="line">    current = current.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法2-数组"><a href="#解法2-数组" class="headerlink" title="解法2 数组"></a>解法2 数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = head</span><br><span class="line">    <span class="keyword">const</span> arr = [];</span><br><span class="line">    <span class="keyword">while</span>(current !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr.includes(current)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arr.push(current)</span><br><span class="line">      &#125;</span><br><span class="line">      current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解法3-快慢指针"><a href="#解法3-快慢指针" class="headerlink" title="解法3 快慢指针"></a>解法3 快慢指针</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fast = head;</span><br><span class="line">    <span class="keyword">let</span> slow = head;</span><br><span class="line">    <span class="keyword">while</span>(slow &amp;&amp; fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        slow = slow.next</span><br><span class="line">        <span class="keyword">if</span> (slow === fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://leetcode-cn.com/problems/linked-list-cycle" target="_blank" rel="noopener">判圈算法</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle/solution/shuang-jie-fa-floydsuan-fa-ha-xi-biao-javascriptsh/" target="_blank" rel="noopener">哈希表</a></li></ul><h2 id="环形链表二"><a href="#环形链表二" class="headerlink" title="环形链表二"></a>环形链表二</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：返回索引为 <span class="number">1</span> 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><h3 id="解法1-hash"><a href="#解法1-hash" class="headerlink" title="解法1 hash"></a>解法1 hash</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> detectCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = head</span><br><span class="line">    <span class="keyword">if</span> (!current || !current.next) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">while</span>(current !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (map.has(current)) &#123;</span><br><span class="line">        <span class="keyword">return</span> current</span><br><span class="line">      &#125;</span><br><span class="line">      map.set(current, <span class="literal">true</span>)</span><br><span class="line">      current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解法2快慢指针"><a href="#解法2快慢指针" class="headerlink" title="解法2快慢指针"></a>解法2快慢指针</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fast = head,</span><br><span class="line">        slow = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针确定有环</span></span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast.next) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确定有环，开始找环的第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (fast === slow) &#123;</span><br><span class="line">            slow = head;</span><br><span class="line">            <span class="keyword">while</span> (slow !== fast) &#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/submissions/" target="_blank" rel="noopener">环形链表二</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/142huan-xing-lian-biao-iishuang-zhi-zhen-ha-xi-bia/" target="_blank" rel="noopener">142.环形链表 II【双指针、哈希表】</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
            <tag> leetCode </tag>
            
            <tag> 排序链表 </tag>
            
            <tag> 两两反向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔: 35岁该何去何从</title>
      <link href="/2021/02/06/%E9%9A%8F%E7%AC%94-35%E5%B2%81%E8%AF%A5%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E/"/>
      <url>/2021/02/06/%E9%9A%8F%E7%AC%94-35%E5%B2%81%E8%AF%A5%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E/</url>
      
        <content type="html"><![CDATA[<p>马上就到了35岁，还有五年的光阴，想抓住最后的年轻红利，大声喊出我们的口号:<br>Formulation for decade, freedom forever.<br>五年布局，百年自由</p><p>接下来的时间(3月底)，重点关注</p><ul><li>webpack编译相关</li><li>vue源码级别的面试题</li><li>栈和队列<br>聚焦上面两项，为自由奋斗！！！</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 中年油腻大叔 </tag>
            
            <tag> 三十而立 </tag>
            
            <tag> 闲笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: Promise.all/any/race/allSettled手写</title>
      <link href="/2021/01/16/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-Promise-all-race-any-allSettled%E6%89%8B%E5%86%99/"/>
      <url>/2021/01/16/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-Promise-all-race-any-allSettled%E6%89%8B%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>Promise以下几个api，直接手写，便于理解。<br>学习就是一个渐进的过程，第一遍看不懂，第二遍只能领略皮毛，后面再看，仔细品味，感觉还是不错的</p><h3 id="Promise-all-Iterator"><a href="#Promise-all-Iterator" class="headerlink" title="Promise.all(Iterator)"></a>Promise.all(Iterator)</h3><p>Promise.all() 方法会将多个 Promise 实例组合成一个新的 Promise 实例<br>1.传入的参数必须可迭代<br>2.传入的实例不一定是Promise,必须再用Promise.resolve()包装下<br>3.组合后的Promise实例，只有当每个包含的Promise实例都解决才去解决（fulFilled）,当然如果有一个Promise实例被拒绝的话,则合成的Promise会拒绝(rejected)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写all</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve( <span class="number">1</span> );</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve( <span class="built_in">Promise</span>.resolve( <span class="string">'111'</span> ) );</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="built_in">Promise</span>.reject(<span class="string">'error'</span>)</span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(</span><br><span class="line">res =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;,</span><br><span class="line">err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(err)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">Promise</span>.myAll = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;    </span><br><span class="line">        <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> res = [];</span><br><span class="line">        <span class="keyword">var</span> len = arr.length</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> [i, p] <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(</span><br><span class="line">                data =&gt; &#123;</span><br><span class="line">                    res[i] = data;</span><br><span class="line">                    index ++</span><br><span class="line">                    <span class="keyword">if</span> (index === len) &#123;</span><br><span class="line">                        resolve(res)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                err =&gt; &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Promise</span>.myAll([p1, p2, p3]).then(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res, <span class="string">'res success'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(err, <span class="string">'err'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="comment">// error err</span></span><br></pre></td></tr></table></figure><h3 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any"></a>Promise.any</h3><p>Promise.all的反向操作，只有当每个包含的Promise实例都拒绝了，合成的promise才会拒绝rejected</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.reject( <span class="number">1</span> );</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.reject(<span class="built_in">Promise</span>.resolve( <span class="string">'222'</span> ));</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="built_in">Promise</span>.reject(<span class="string">'my error'</span>)</span><br><span class="line"><span class="built_in">Promise</span>.any([p1, p2, p3]).then(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(err)</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">Promise</span>.myAny = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> index= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> res = [];</span><br><span class="line">        <span class="keyword">var</span> len = arr.length</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> [i, p] <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(</span><br><span class="line">                data =&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> resolve(data)</span><br><span class="line">                &#125;,</span><br><span class="line">                err =&gt; &#123;</span><br><span class="line">                    res[i] = err;</span><br><span class="line">                    index ++</span><br><span class="line">                    <span class="keyword">if</span> (index === len) &#123;</span><br><span class="line">                        reject(<span class="string">'this is end'</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.myAny([p1, p2, p3]).then(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(err)</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// AggregateError: All promises were rejecte</span></span><br><span class="line"><span class="comment">// this is end</span></span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>只要有一个请求有响应值，请求就会结束，返回有响应的那个promise结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写race</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve( <span class="number">1</span> );</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="built_in">Promise</span>.resolve( <span class="string">'222'</span> ));</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="built_in">Promise</span>.reject(<span class="string">'my error'</span>)</span><br><span class="line"><span class="built_in">Promise</span>.race([p3, p2, p1]).then(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(err)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">Promise</span>.myRace = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> p <span class="keyword">of</span> arr) &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(</span><br><span class="line">              data =&gt; &#123;</span><br><span class="line">                  <span class="keyword">return</span> resolve(data)</span><br><span class="line">              &#125;,</span><br><span class="line">              err =&gt; &#123;</span><br><span class="line">                  reject(err, <span class="string">'myRace err'</span>)</span><br><span class="line">              &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.myRace([p3, p2, p1]).then(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(err)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// my error</span></span><br><span class="line"><span class="comment">// my error</span></span><br></pre></td></tr></table></figure><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p>Promise.allSettled() 方法也是返回一个合成的 Promise，不过只有等到所有 Promise 实例都返回结果落定时，不管是解决(fulfilled)还是拒绝(rejected)，合成的 Promise 才会结束。一旦结束，状态总是 fulfilled。</p><p>等所有的成功和失败的结果都有了才会返回promise结果,失败的时候返回{}成功的时候返回，组成一个失败和成功的组合的promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写allSettled</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve( <span class="number">1</span> );</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve( <span class="built_in">Promise</span>.resolve( <span class="string">'111'</span> ) );</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="built_in">Promise</span>.reject(<span class="string">'error'</span>)</span><br><span class="line"><span class="built_in">Promise</span>.allSettled([p1, p2, p3]).then(</span><br><span class="line">  res =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 第一种实现</span></span><br><span class="line"><span class="built_in">Promise</span>.myAllSettled = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;    </span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> res = [];</span><br><span class="line">        <span class="keyword">const</span> len = arr.length</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> [i, p] <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(p).then(</span><br><span class="line">                data =&gt; &#123;</span><br><span class="line">                    res[i] = &#123;<span class="attr">status</span>: <span class="string">'fifilled'</span>, <span class="attr">value</span>: data&#125;;</span><br><span class="line">                    index ++</span><br><span class="line">                    <span class="keyword">if</span> (index === len) &#123;</span><br><span class="line">                        <span class="keyword">return</span> resolve(res)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                err =&gt; &#123;</span><br><span class="line">                    res[i] = &#123;<span class="attr">status</span>: <span class="string">'rejected'</span>, <span class="attr">reason</span>: err&#125;;</span><br><span class="line">                    index ++</span><br><span class="line">                    <span class="keyword">if</span> (index === len) &#123;</span><br><span class="line">                        <span class="keyword">return</span> resolve(res)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Promise</span>.myAllSettled([p1, p2, p3]).then(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res, <span class="string">'res success'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.warn(err, <span class="string">'err'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 第二种实现</span></span><br><span class="line"><span class="built_in">Promise</span>.myAllSettled = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> promiseAll = [...arr]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promiseAll.map(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(e).then(</span><br><span class="line">            res =&gt; &#123;<span class="keyword">return</span> &#123;<span class="attr">status</span>: <span class="string">'fifilled'</span>, <span class="attr">value</span>: res&#125;&#125;,</span><br><span class="line">            err =&gt; &#123;<span class="keyword">return</span> &#123;<span class="attr">status</span>: <span class="string">'rejected'</span>, <span class="attr">reason</span>: err&#125;&#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;))  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的结果格式</span></span><br><span class="line">[</span><br><span class="line">  &#123;<span class="attr">status</span>: <span class="string">'fulfilled'</span>, <span class="attr">value</span>: <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">status</span>: <span class="string">'fulfilled'</span>, <span class="attr">value</span>: <span class="string">'111'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">status</span>: <span class="string">'rejected'</span>, <span class="attr">reason</span>: <span class="string">'error'</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.cn/post/6907673648216145928#heading-18" target="_blank" rel="noopener">一次写过瘾」手写Promise全家桶+Generator+async/await</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> promise </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础-手写async/await</title>
      <link href="/2021/01/16/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-%E6%89%8B%E5%86%99async-await/"/>
      <url>/2021/01/16/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-%E6%89%8B%E5%86%99async-await/</url>
      
        <content type="html"><![CDATA[<p>手写之前先学习下async/await</p><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。<br><strong>异步</strong>的简写，用于申明一个函数是异步的，而await用于等待一个异步方法执行完成，await只能出现在async函数中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getData = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'data'</span>), <span class="number">3000</span>))</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> data = <span class="keyword">await</span> getData()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'data: '</span>, data);</span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">await</span> getData()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'data2: '</span>, data2);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'success'</span></span><br><span class="line">&#125;</span><br><span class="line">test().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="comment">// data: data</span></span><br><span class="line"><span class="comment">// data2: data</span></span><br><span class="line"><span class="comment">// success</span></span><br></pre></td></tr></table></figure><p>换成generator函数就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">yield</span> getData()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'data: '</span>, data);</span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">yield</span> getData()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'data2: '</span>, data2);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'success'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>async函数就是将  Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</p><p>async函数对 Generator 函数的改进，体现在以下四点。</p><ul><li>内置执行器。<br>Generator函数的执行必须靠执行器，而async函数自带执行器，不许再跳用next方法</li><li>更好的语义<br>async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</li><li>更广的适用性<br>yield/await</li><li>返回值是 Promise<br>async返回的是<strong>Promise</strong>,你阔以用then指定下一步操作。而Generator返回的是Iterator迭代器对象。<br>async函数完全能理解成多个异步操作，<strong>包装成</strong>一个Promise对象, async函数是Generator函数的语法糖，而<strong>await命令就是内部的then命令的语法糖</strong><br>总的解释就是:<br>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。<h2 id="手写async-单说async"><a href="#手写async-单说async" class="headerlink" title="手写async(单说async)"></a>手写async(单说async)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>模拟实现async<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'foo function'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data = foo()</span><br><span class="line">data.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟async</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_async</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="built_in">Promise</span>.resolve(fn(...args))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'foo function'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data = _async(foo)()</span><br><span class="line">data.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'data'</span>)</span><br><span class="line"><span class="comment">// foo function</span></span><br><span class="line"><span class="comment">// data</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>await使用场景</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(n + <span class="number">200</span>), n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step2 with <span class="subst">$&#123;m&#125;</span> and <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(m + n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">k, m, n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step3 with <span class="subst">$&#123;k&#125;</span>, <span class="subst">$&#123;m&#125;</span> and <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(k + m + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">const</span> time2 = <span class="keyword">await</span> step1(time1);</span><br><span class="line">    <span class="keyword">const</span> time3 = <span class="keyword">await</span> step2(time1, time2);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> step3(time1, time2, time3);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用<em>Promise</em>如何实现1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(n + <span class="number">200</span>), n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step2 with <span class="subst">$&#123;m&#125;</span> and <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(m + n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">k, m, n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step3 with <span class="subst">$&#123;k&#125;</span>, <span class="subst">$&#123;m&#125;</span> and <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(k + m + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    step1(time1)</span><br><span class="line">    .then(<span class="function">(<span class="params">time2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> step2(time1, time2).then(</span><br><span class="line">            time3 =&gt; [time1, time2,time3]</span><br><span class="line">        )</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">rest</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> [time1, time2, time3] = rest</span><br><span class="line">        <span class="keyword">return</span> step3(time1, time2, time3)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Promise解法二</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">"doIt"</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    step1(time1).then(<span class="function">(<span class="params">res1</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> time2 = res1;</span><br><span class="line">        step2(time1, time2).then(<span class="function">(<span class="params">res2</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> time3 = res2;</span><br><span class="line">            step3(time1, time2, time3).then(<span class="function">(<span class="params">res3</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;res3&#125;</span>`</span>);</span><br><span class="line">                <span class="built_in">console</span>.timeEnd(<span class="string">"doIt"</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><p>await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try…catch 代码块中，或者await后的Promise添加catch回调</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> read(<span class="string">'1.txt'</span>,<span class="string">'utf8'</span>)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="手写-await"><a href="#手写-await" class="headerlink" title="手写 await"></a>手写 await</h2><p>如果是手动执行里面的执行器，则需要这么实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getData = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'data'</span>), <span class="number">3000</span>))</span><br><span class="line"><span class="built_in">console</span>.log(getData(), <span class="string">'getData'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">testG</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="keyword">yield</span> getData()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'data1'</span>, data)</span><br><span class="line">    <span class="keyword">var</span> data2 = <span class="keyword">yield</span> getData()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'data2'</span>,data2)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'success'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> gg = testG()</span><br><span class="line"><span class="keyword">var</span> dataPromise = gg.next()</span><br><span class="line">dataPromise.value.then(<span class="function">(<span class="params">val1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data2proimse = gg.next(val1);</span><br><span class="line">    <span class="built_in">console</span>.log(data2proimse, <span class="string">'data2proimse'</span>)</span><br><span class="line">    data2proimse.value.then(<span class="function">(<span class="params">val2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> data3 = gg.next(val2);</span><br><span class="line">        gg.next()</span><br><span class="line">        <span class="built_in">console</span>.log(data3, <span class="string">'da ta3'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p> 大神版模拟async/await</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getData = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'data'</span>), <span class="number">3000</span>))</span><br><span class="line"><span class="built_in">console</span>.log(getData(), <span class="string">'getData'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncToGenerator</span>(<span class="params">generatorFunc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> gen = generatorFunc.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">key, arg</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">let</span> generatorResult</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            generatorResult = gen[key](arg)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">return</span> reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">const</span> &#123; value, done &#125; = generatorResult</span><br><span class="line">          <span class="keyword">if</span> (done) &#123;</span><br><span class="line">            <span class="keyword">return</span> resolve(value)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(value).then(</span><br><span class="line">            val =&gt; step(<span class="string">'next'</span>, val), </span><br><span class="line">            err =&gt; step(<span class="string">'throw'</span>, err))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step(<span class="string">"next"</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> gg = asyncToGenerator(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>* <span class="title">testG</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> data = <span class="keyword">yield</span> getData()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'data1'</span>, data)</span><br><span class="line">        <span class="keyword">var</span> data2 = <span class="keyword">yield</span> getData()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'data2'</span>,data2)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'success'</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">gg().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res, <span class="string">'res'</span>))</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://juejin.cn/post/6844904164133175309" target="_blank" rel="noopener">手写async、await、generator核心逻辑</a></li><li><a href="https://juejin.cn/post/6844904102053281806" target="_blank" rel="noopener">手写async await的最简实现（20行）</a></li><li><a href="https://juejin.cn/post/6844903586481209358" target="_blank" rel="noopener">Async +Await</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> Iterator </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
            <tag> Iterator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶:loader和plugin插件学习</title>
      <link href="/2021/01/09/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-loader%E5%92%8Cplugin%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/01/09/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-loader%E5%92%8Cplugin%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack-loader和plugin配置项"><a href="#webpack-loader和plugin配置项" class="headerlink" title="webpack loader和plugin配置项"></a>webpack loader和plugin配置项</h2><blockquote><p>npx webpack –mode=development</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    <span class="comment">// 转换 ES6 代码，解决浏览器兼容问题</span></span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="string">'/\.js$/'</span>,</span><br><span class="line">      exclude: <span class="string">'/node_modules/'</span>,</span><br><span class="line">      use: [</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'babel-loader'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: path.join(__dirname, <span class="string">'../loader/cpp-loader,js'</span>),</span><br><span class="line">          options: &#123;  </span><br><span class="line">            log: <span class="string">'hello loader'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>简单来说，loader就是一个nodejs模块，loader 是导出为一个函数的 node 模块。该函数在 loader 转换资源的时候调用。给定的函数将调用 <a href="https://www.webpackjs.com/api/loaders/#%E5%90%8C%E6%AD%A5-loader" target="_blank" rel="noopener">API</a>，并通过 this 上下文访问。<br>比如这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>); <span class="comment">// loader 工具库 ，调用loaderUtils.getOptions拿到webpack配置参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'————source'</span>, source);</span><br><span class="line">  <span class="keyword">const</span> options = loaderUtils.getOptions(<span class="keyword">this</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'————options'</span>, options);</span><br><span class="line">  <span class="keyword">return</span> source</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出一个函数</span></span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure><h3 id="loader前置知识"><a href="#loader前置知识" class="headerlink" title="loader前置知识"></a>loader前置知识</h3><ul><li><p>loader 支持链式调用。链中的每个 loader 会将转换应用在已处理过的资源上。一组链式的 loader 将按照相反的顺序执行。链中的第一个 loader 将其结果（也就是应用过转换后的资源）传递给下一个 loader，依此类推。最后，链中的最后一个 loader，返回 webpack 所期望的 JavaScript。</p></li><li><p>loader 可以是同步的，也可以是异步的。</p></li><li><p>loader 运行在 Node.js 中，并且能够执行任何操作。</p></li><li><p>loader 可以通过 options 对象配置（仍然支持使用 query 参数来设置选项，但是这种方式已被废弃）。</p></li><li><p>除了常见的通过 package.json 的 main 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 loader 字段直接引用一个模块。<br>插件(plugin)可以为 loader 带来更多特性。</p></li><li><p>loader 能够产生额外的任意文件</p></li></ul><h3 id="手写loader"><a href="#手写loader" class="headerlink" title="手写loader"></a>手写loader</h3><h4 id="4种本地开发测试的方法"><a href="#4种本地开发测试的方法" class="headerlink" title="4种本地开发测试的方法"></a>4种本地开发测试的方法</h4><ul><li><p>匹配(test)单个 loader，你可以简单通过在 rule 对象设置 <em>path.resolve</em> 指向这个本地文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          <span class="comment">// loader: path.join(__dirname, '../loader/cpp-loader,js'),</span></span><br><span class="line">          <span class="comment">// loader: 'cpp-test-loader',</span></span><br><span class="line">          loader: path.resolve(<span class="string">'./loader/cpp-test-loader.js'</span>),</span><br><span class="line">          options: &#123;  </span><br><span class="line">            log: <span class="string">'hello 这是我目前用的loader'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li><li><p>匹配(test)多个 loaders，你可以使用 <em>resolveLoader.modules</em> 配置，webpack 将会从这些目录中搜索这些 loaders。例如，如果你的项目中有一个 /loaders 本地目录：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolveLoader: &#123;</span><br><span class="line">   modules: [<span class="string">'node_modules'</span>, path.resolve(__dirname, <span class="string">'loader'</span>)]</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></li><li><p>还阔以通过<strong>resolveLoader</strong>配置别名的方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">resolveLoader: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="string">'a-loader'</span>: path.resolve(__dirname, <span class="string">'loader/a.js'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'a-loader'</span>,</span><br><span class="line">        options: &#123;  </span><br><span class="line">          test: <span class="string">'hello this is options'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>npm link 软连接的方式调试独立库和包，来将其关联到你要测试的项目。node模块根目录下 运行 <strong>npm link</strong>,项目里使用 <em>npm link cpp-test-loader</em>。其实跟调试单独的npm包一模一样。</p></li></ul><h4 id="使用-loader-utils-能够编译-loader-的配置，还可以通过-schema-utils-对传递的配置进行验证"><a href="#使用-loader-utils-能够编译-loader-的配置，还可以通过-schema-utils-对传递的配置进行验证" class="headerlink" title="使用 loader-utils 能够编译 loader 的配置，还可以通过 schema-utils 对传递的配置进行验证"></a>使用 <em>loader-utils</em> 能够编译 loader 的配置，还可以通过 <em>schema-utils</em> 对传递的配置进行验证</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'a-loader'</span>,</span><br><span class="line">          options: &#123;  </span><br><span class="line">            test: <span class="string">'hello this is options'</span> <span class="comment">// test: string 跟下面的schema数据结构对应</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cpp-test-loader.js</span></span><br><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</span><br><span class="line"><span class="keyword">const</span> validateOptions = <span class="built_in">require</span>(<span class="string">'schema-utils'</span>);</span><br><span class="line"><span class="comment">// 定义loader里的options选项数据结构</span></span><br><span class="line"><span class="keyword">const</span> schema = &#123;</span><br><span class="line">  type: <span class="string">'object'</span>,</span><br><span class="line">  properties: &#123;</span><br><span class="line">    test: &#123;</span><br><span class="line">      type: <span class="string">'string'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// source: 表示源文件字符串或者buffer</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loader</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options = loaderUtils.getOptions(<span class="keyword">this</span>)</span><br><span class="line">  validateOptions(schema, options, <span class="string">'Example Loader'</span>); <span class="comment">// 若当前传入的option不符合预期的数据结构 则会报错</span></span><br><span class="line">  <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = loader</span><br></pre></td></tr></table></figure><h3 id="同步-loader"><a href="#同步-loader" class="headerlink" title="同步 loader"></a>同步 loader</h3><p>无论是 return 还是 <strong>this.callback</strong> 都可以同步地返回转换后的 content 内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content, map, meta</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//一些同步操作</span></span><br><span class="line">  outputContent = someSyncOperation(content)</span><br><span class="line">  <span class="keyword">return</span> outputContent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this.callback灵活 支持多个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content, map, meta</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.callback(<span class="literal">null</span>, someSyncOperation(content), map, meta);</span><br><span class="line">  <span class="keyword">return</span>; <span class="comment">// 当调用 callback() 时总是返回 undefined</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="异步-loader"><a href="#异步-loader" class="headerlink" title="异步 loader"></a>异步 loader</h3><p>对于异步 loader，使用 <strong>this.async</strong> 来获取 callback 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content, map, meta</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 做异步的任务</span></span><br><span class="line">  <span class="keyword">var</span> callback = <span class="keyword">this</span>.async();</span><br><span class="line">  someAsyncOperation(content, <span class="function"><span class="keyword">function</span>(<span class="params">err, result, sourceMaps, meta</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">    callback(<span class="literal">null</span>, result, sourceMaps, meta);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><p>为社区用户提供一种强大方式来触及webpack编译过程(compilation process),插件能够 钩入(hook) 到在每个编译(compilation)中触发的所有关键事件。在编译的每一步，插件都具备完全访问 compiler 对象的能力，如果情况合适，还可以访问当前 compilation 对象。</p><p>在插件开发中最重要的两个资源就是 compiler 和 compilation 对象。理解它们的角色是扩展 webpack 引擎重要的第一步。</p><p>compiler 对象代表了<strong>完整的 webpack 环境配置</strong>。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。</p><p>compilation 对象代表了<strong>一次资源版本构</strong>建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。</p><p>这两个组件是任何 webpack 插件不可或缺的部分（特别是 compilation），因此，开发者在阅读源码，并熟悉它们之后，会感到获益匪浅：</p><h3 id="plugin前置知识"><a href="#plugin前置知识" class="headerlink" title="plugin前置知识"></a>plugin前置知识</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="function">(<span class="params">options</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> compiler = <span class="keyword">new</span> Compiler();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> plugin <span class="keyword">of</span> options.plugins) &#123;</span><br><span class="line">    plugin.apply(compiler) <span class="comment">// 将plugin注册到compiler</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册结束</span></span><br><span class="line">  <span class="comment">// 开始执行</span></span><br><span class="line">  compiler.run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MyFirstWebpckPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 走一个</span></span><br><span class="line">webpack(options)</span><br></pre></td></tr></table></figure><h3 id="手写plugin"><a href="#手写plugin" class="headerlink" title="手写plugin"></a>手写plugin</h3><p>webpack 插件由以下组成：</p><ul><li>一个 JavaScript 命名函数，构造函数。</li><li>在插件函数的 prototype 上定义一个 apply 方法。</li><li>指定一个绑定到 webpack 自身的事件钩子。(compiler.hooks.emit // Compiler.emit() 输出到dist目录)</li><li>处理 webpack 内部实例的特定数据。(主要是处理compilation，比如检索遍历资源(asset)、chunk、模块和依赖、监听 chunk 的修改)</li><li>功能完成后调用 webpack 提供的回调</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plugin.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyFirstWebpckPlugin</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我的首个插件————————'</span>, options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> pluginName = <span class="string">'MyFirstWebpckPlugin'</span></span><br><span class="line">MyFirstWebpckPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// compiler对象代表了完整的webpack环境配置</span></span><br><span class="line">  <span class="comment">// 指定挂载到webpack自身的事件钩子</span></span><br><span class="line">  <span class="comment">// compiler.hooks.compile.tap(pluginName, function(compilationParams) &#123;</span></span><br><span class="line">  <span class="comment">//   console.log('环境准备好了', Object.keys(compilationParams))</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line">  compiler.hooks.emit.tap(pluginName, <span class="function"><span class="keyword">function</span>(<span class="params">compilation</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理内部实例的特定数据</span></span><br><span class="line">    <span class="comment">// console.log('————compilation————', Object.keys(compilation))</span></span><br><span class="line">    <span class="comment">// console.log('————compilation.hooks————', Object.keys(compilation.hooks))</span></span><br><span class="line">    <span class="keyword">if</span> (compilation.chunks &amp;&amp; compilation.chunks.length) &#123;</span><br><span class="line">      compilation.chunks.forEach(<span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 检索chunk模块</span></span><br><span class="line">        <span class="keyword">if</span> (chunk &amp;&amp; chunk.files &amp;&amp; chunk.files.length) &#123;</span><br><span class="line">          chunk.files.forEach(<span class="function">(<span class="params">fileName</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'fileName_____'</span>, fileName)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// compilation 代表一次资源版本构建</span></span><br><span class="line">    compilation.hooks.finishModules.tap(pluginName, (<span class="built_in">module</span>) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'——————chunks——————'</span>, <span class="built_in">module</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = MyFirstWebpckPlugin</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line"><span class="keyword">const</span> MyFirstWebpckPlugin = <span class="built_in">require</span>(<span class="string">'../plugin/plugin'</span>)</span><br><span class="line">  ...</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> MyFirstWebpckPlugin(&#123;</span><br><span class="line">      options: <span class="literal">true</span>,</span><br><span class="line">      name: <span class="string">'common'</span>,</span><br><span class="line">      mode: <span class="string">'Test'</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h3 id="plugin实例"><a href="#plugin实例" class="headerlink" title="plugin实例"></a>plugin实例</h3><p><em>island-webpack-plugin</em> 是一个在 bundle 中添加作者信息的插件，这个插件同样是在 emit 这个钩子上触发的，同样是获取 source 后对 source 添加作者信息的字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthorPlugin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">        <span class="keyword">this</span>.options = options;</span><br><span class="line">    &#125;</span><br><span class="line">    apply(compiler) &#123;</span><br><span class="line">        compiler.hooks.emit.tap(<span class="string">'author-plugin'</span>, (compilation) =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> options = <span class="keyword">this</span>.options</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> assets = compilation.assets</span><br><span class="line">                <span class="built_in">Object</span>.keys(assets).forEach(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> source = assets[e].source()</span><br><span class="line">                    <span class="keyword">let</span> info = []</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (options.author) info.push(<span class="string">`@Author: <span class="subst">$&#123;options.author&#125;</span>`</span>)</span><br><span class="line">                    <span class="keyword">if</span> (options.email) info.push(<span class="string">`@Email: <span class="subst">$&#123;options.email&#125;</span>`</span>)</span><br><span class="line">                    <span class="keyword">if</span> (options.homepage) info.push(<span class="string">`@Homepage: <span class="subst">$&#123;options.homepage&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (info.length) &#123;</span><br><span class="line">                        info.push(<span class="string">`@Date: <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;</span>`</span>)</span><br><span class="line">                        source = <span class="string">`/*\n  <span class="subst">$&#123;info.join(<span class="string">'\n\n  '</span>)&#125;</span>\n*/\n<span class="subst">$&#123;source&#125;</span>`</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    compilation.assets[e].source = <span class="function"><span class="params">()</span> =&gt;</span> source</span><br><span class="line">                    compilation.assets[e].size = <span class="function"><span class="params">()</span> =&gt;</span> source.size</span><br><span class="line">                &#125;)</span><br><span class="line">                resolve()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = AuthorPlugin</span><br></pre></td></tr></table></figure><p>令人执行的compiler里的钩子函数<br><img src= "/img/loading.gif" data-src="/images/webpack/syncHook.png" alt="Tapable"></p><h2 id="参考文件"><a href="#参考文件" class="headerlink" title="参考文件"></a>参考文件</h2><ul><li><a href="https://webpack.docschina.org/concepts/loaders/#example" target="_blank" rel="noopener">loader</a></li><li><a href="https://imweb.io/topic/5baca58079ddc80f36592f1a" target="_blank" rel="noopener">Webpack揭秘——走向高阶前端的必经之路</a></li><li><a href="https://mp.weixin.qq.com/s/f200Q62XL50d0a_DgI6UlA" target="_blank" rel="noopener">webpack的几个常见loader源码浅析，以及动手实现一个md2html-loader</a></li><li><a href="https://www.webpackjs.com/api/loaders/#%E5%90%8C%E6%AD%A5-loader" target="_blank" rel="noopener">loader API</a></li><li><a href="https://www.webpackjs.com/contribute/writing-a-plugin/" target="_blank" rel="noopener">plugin</a></li><li><a href="https://blog.csdn.net/qdmoment/article/details/102833305" target="_blank" rel="noopener">基于数据结构从源码解析webpack核心模块tapable</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
          <category> node </category>
          
          <category> loader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> webpack </tag>
            
            <tag> loader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法基础-排序</title>
      <link href="/2021/01/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/01/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>感觉自己好磨蹭，1月3号建的文章题目，2个月之后还是没有深得精髓，对自己好失望！！</p><h3 id="冒泡排序-bubbleSort"><a href="#冒泡排序-bubbleSort" class="headerlink" title="冒泡排序 bubbleSort"></a>冒泡排序 bubbleSort</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bubbleSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;length&#125; = arr</span><br><span class="line">  <span class="comment">// let flag = false</span></span><br><span class="line">  <span class="keyword">if</span> (length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i ++) &#123;</span><br><span class="line">    <span class="comment">// flag = false</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j ++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        swap(arr, j, j + <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// flag = true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if (!flag) break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序-selectionSort"><a href="#选择排序-selectionSort" class="headerlink" title="选择排序 selectionSort"></a>选择排序 selectionSort</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序 找到数据结构中的最小的那个并将放到首位，接着找第二个放到第二位</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> selectionBubble = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;length&#125; = arr</span><br><span class="line">  <span class="keyword">let</span> indexMin</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">    indexMin = i</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; length; j ++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[indexMin] &gt; arr[j]) &#123;</span><br><span class="line">        indexMin = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( i !== indexMin) &#123;</span><br><span class="line">      swap(arr, i, indexMin)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序-insertionSort"><a href="#插入排序-insertionSort" class="headerlink" title="插入排序 insertionSort"></a>插入排序 insertionSort</h3><p>复杂度 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> insertionSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.length</span><br><span class="line">  <span class="keyword">let</span> temp</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i ++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'i'</span>, i)</span><br><span class="line">    <span class="keyword">let</span> j = i</span><br><span class="line">    temp = arr[i]</span><br><span class="line">    <span class="keyword">while</span>( j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">      arr[j] = arr[j - <span class="number">1</span>]</span><br><span class="line">      j --</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j] = temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序-mergeSort"><a href="#归并排序-mergeSort" class="headerlink" title="归并排序 mergeSort"></a>归并排序 mergeSort</h3><p>复杂度O(nlog(n))</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mergeSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length</span><br><span class="line">    <span class="keyword">const</span> middle = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">const</span> left = mergeSort(arr.slice(<span class="number">0</span>, middle))</span><br><span class="line">    <span class="keyword">const</span> right = mergeSort(arr.slice(middle, length))</span><br><span class="line">    arr = merge(left, right)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">left, right</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  <span class="keyword">while</span>(i &lt; left.length &amp;&amp; j &lt; right.length) &#123;</span><br><span class="line">    res.push(</span><br><span class="line">      left[i] &lt; right[j] ? left[i ++] : right[j ++]</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [...res, ...(i &lt; left.length ? left.slice(i) : right.slice(j))]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序-qucikSort"><a href="#快速排序-qucikSort" class="headerlink" title="快速排序 qucikSort"></a>快速排序 qucikSort</h3><h3 id="计数排序-countingSort"><a href="#计数排序-countingSort" class="headerlink" title="计数排序 countingSort"></a>计数排序 countingSort</h3><p>第一个分布式排序，一个整数排序算法，事件复杂度O(n+k), K是临时计数数组的大小，需要更多的内存来存放临时数组</p><h3 id="桶排序-bucketSort"><a href="#桶排序-bucketSort" class="headerlink" title="桶排序 bucketSort"></a>桶排序 bucketSort</h3><p>箱排序，也是分布式排序算法</p><h3 id="基数排序-radixSort"><a href="#基数排序-radixSort" class="headerlink" title="基数排序 radixSort"></a>基数排序 radixSort</h3><p>分布式排序算法，根据数字的有效位或基数将整数分不到桶中</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法基础: 链表</title>
      <link href="/2021/01/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/01/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的，每个元素由<strong>一个存储元素本身的节点和一个指向下一个元素</strong>的引用组成。<br>相当于传统数组，链表的好处在于，<em>添加或者移除元素的时候不需要移动</em>其他元素。然而链表需要使用指针，因此实现链表时要额外注意。在数组中，我们阔以访问任何位置的任何元素，而想要访问链表中的一个元素，则需要<strong>从头开始迭代链表</strong>直到找到所需的元素。</p><h3 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h3><h4 id="前置基础"><a href="#前置基础" class="headerlink" title="前置基础"></a>前置基础</h4><p>表示链表中的第一个以及其他元素，需要一个 助手类 Node</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Node &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">element</span>) &#123;</span><br><span class="line">    <span class="comment">// this.element = element</span></span><br><span class="line">    <span class="comment">// this.next = undefined</span></span><br><span class="line">    [<span class="keyword">this</span>.element, <span class="keyword">this</span>.next] = [element, <span class="literal">null</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defaultEquals</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a === b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建链表-1"><a href="#创建链表-1" class="headerlink" title="创建链表"></a>创建链表</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> LinkedList &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">equalsFn = defaultEquals</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.head = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.equalsFn = equalsFn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表尾部添加元素"><a href="#链表尾部添加元素" class="headerlink" title="链表尾部添加元素"></a>链表尾部添加元素</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">push(element) &#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element)</span><br><span class="line">  <span class="keyword">let</span> current</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.head = node</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">while</span>(current.next != <span class="literal">null</span>) &#123;</span><br><span class="line">      current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    current.next = nide</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.count ++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表中移除元素"><a href="#链表中移除元素" class="headerlink" title="链表中移除元素"></a>链表中移除元素</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">removeAt(index) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">this</span>.count ) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.head = current.next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> previous</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; index; i ++) &#123;</span><br><span class="line">        previous = current</span><br><span class="line">        current = current.next</span><br><span class="line">      &#125;</span><br><span class="line">      previous.next = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count --</span><br><span class="line">    <span class="keyword">return</span> current.element</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环迭代链表直到找到目标位置"><a href="#循环迭代链表直到找到目标位置" class="headerlink" title="循环迭代链表直到找到目标位置"></a>循环迭代链表直到找到目标位置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getElementAt(index) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">this</span>.count ) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; index;  i++) &#123;</span><br><span class="line">      current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重构下remove方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">removeAt(index) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">this</span>.count ) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.head = current.next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> previous = <span class="keyword">this</span>.getElementAt(index)</span><br><span class="line">      current = previous.next</span><br><span class="line">      previous.next = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count --</span><br><span class="line">    <span class="keyword">return</span> current.element</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在任意位置插入元素"><a href="#在任意位置插入元素" class="headerlink" title="在任意位置插入元素"></a>在任意位置插入元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">insert(element, index) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">this</span>.count) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> Node(element) </span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> current = <span class="keyword">this</span>.head</span><br><span class="line">      node.next = current</span><br><span class="line">      <span class="keyword">this</span>.head = node</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> previous = <span class="keyword">this</span>.getElementAt(index - <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">const</span> current = previous.next</span><br><span class="line">      node.next = current</span><br><span class="line">      previous.next = node</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count ++</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回一个元素的位置"><a href="#返回一个元素的位置" class="headerlink" title="返回一个元素的位置"></a>返回一个元素的位置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">indexOf(element) &#123;</span><br><span class="line">  <span class="keyword">const</span> current = <span class="keyword">this</span>.head</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.count &amp;&amp; current != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.equalsFn(element, current.element)) &#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    current = current.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从链表中移除元素"><a href="#从链表中移除元素" class="headerlink" title="从链表中移除元素"></a>从链表中移除元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">remove(element) &#123;</span><br><span class="line">  <span class="keyword">const</span> index = <span class="keyword">this</span>.indexOf(element);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.removeAt(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>和普通链表的区别在于，在链表中 一个节点只有链向下一个节点的链接，而双向链表中，链接是双向的，一个链向下一个元素，一个链向前一个元素</p><p>工具类Node需要拓展DoublyLinkedList</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">DoublyNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element, next, prev) &#123; <span class="comment">// next好像没啥用</span></span><br><span class="line">    <span class="keyword">super</span>(element)</span><br><span class="line">    <span class="keyword">this</span>.prev = prev</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">DoublyLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(equalsFn = defaultEquals) &#123;</span><br><span class="line">    <span class="keyword">super</span>(equalsFn)</span><br><span class="line">    <span class="keyword">this</span>.tail = <span class="literal">undefined</span>; <span class="comment">// 最后一个元素的引用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="向链表尾部添加元素"><a href="#向链表尾部添加元素" class="headerlink" title="向链表尾部添加元素"></a>向链表尾部添加元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">push(element) &#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> DoublyNode(element);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.head = node;</span><br><span class="line">    <span class="keyword">this</span>.tail = node; <span class="comment">// NEW</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// attach to the tail node // NEW</span></span><br><span class="line">    <span class="keyword">this</span>.tail.next = node;</span><br><span class="line">    node.prev = <span class="keyword">this</span>.tail;</span><br><span class="line">    <span class="keyword">this</span>.tail = node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在任意位置插入新元素"><a href="#在任意位置插入新元素" class="headerlink" title="在任意位置插入新元素"></a>在任意位置插入新元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">insert(element, index) &#123;</span><br><span class="line">  <span class="keyword">if</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="keyword">this</span>.count) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> DoublyNode(element)</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="comment">// 起点位置插入一个新元素</span></span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果双向链表为空 只需要把head和tail执行这个新节点</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.head = node</span><br><span class="line">        <span class="keyword">this</span>.tail = node</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// current变量将是链表中第一个元素的引用</span></span><br><span class="line">        node.next = <span class="keyword">this</span>.head</span><br><span class="line">        current.prev = node</span><br><span class="line">        <span class="keyword">this</span>.head = node</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="keyword">this</span>.count) &#123;</span><br><span class="line">      current = <span class="keyword">this</span>.tail</span><br><span class="line">      current.next = node</span><br><span class="line">      node.prev = current</span><br><span class="line">      <span class="keyword">this</span>.tail = node</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> previous = <span class="keyword">this</span>.getElementAt(index - <span class="number">1</span>)</span><br><span class="line">      current = previous.next</span><br><span class="line">      node.next = current</span><br><span class="line">      previous.next = node</span><br><span class="line">      node.prev = previous</span><br><span class="line">      current.prev = node</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count ++</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表尾部的next引用指向头部节点，定义<em>CircularLinkedList</em>类的insert方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(equalsFn = defaultEquals) &#123;</span><br><span class="line">    <span class="keyword">super</span>(equalsFn)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 链表尾部的next指向head</span></span><br><span class="line">  insert(element, index) &#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="keyword">this</span>.count) &#123;</span><br><span class="line">      <span class="keyword">let</span> node = <span class="keyword">new</span> DoublyNode(element)</span><br><span class="line">      <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">      <span class="comment">// 起点位置插入一个新元素</span></span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果双向链表为空 只需要把head和tail执行这个新节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.head = node</span><br><span class="line">          node.next = <span class="keyword">this</span>.head</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// current变量将是链表中第一个元素的引用</span></span><br><span class="line">          node.next = current</span><br><span class="line">          current = <span class="keyword">this</span>.getElementAt(<span class="keyword">this</span>.size())</span><br><span class="line">          <span class="keyword">this</span>.head = node</span><br><span class="line">          current.next = <span class="keyword">this</span>.head</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> previous = <span class="keyword">this</span>.getElementAt(index - <span class="number">1</span>)</span><br><span class="line">        node.next = previous.next</span><br><span class="line">        previous.next = node</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.count ++</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从任意位置移除元素"><a href="#从任意位置移除元素" class="headerlink" title="从任意位置移除元素"></a>从任意位置移除元素</h4><p>考虑修改循环链表的head元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">removeAt(index) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= <span class="keyword">this</span>.count) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.size() === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="literal">undefined</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> removed = <span class="keyword">this</span>.head</span><br><span class="line">        current = <span class="keyword">this</span>.getElementAt(<span class="keyword">this</span>.size())</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next</span><br><span class="line">        current.next = <span class="keyword">this</span>.head</span><br><span class="line">        current = removed</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> previous = <span class="keyword">this</span>.getElementAt(index - <span class="number">1</span>)</span><br><span class="line">      current = previous.next</span><br><span class="line">      previous.next = current.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count --</span><br><span class="line">    <span class="keyword">return</span> current.element</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有序链表"><a href="#有序链表" class="headerlink" title="有序链表"></a>有序链表</h3><p>保持元素有序的链表结构,除了使用排序算法之外，我们还阔以将元素插入到正确的位置来保证链表的有序性</p><ul><li>声明SortedLinkedList类</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Compare = &#123;</span><br><span class="line">  LESS_THAN: <span class="number">-1</span>,</span><br><span class="line">  BIGGER_THAN: <span class="number">1</span>,</span><br><span class="line">  EQUALS: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defaultCompare</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a === b) &#123;</span><br><span class="line">    <span class="keyword">return</span> Compare.EQUALS</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedLinkedList</span> <span class="keyword">extends</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(equalsFn = defaultEquals, compareFn = defaultCompare) &#123;</span><br><span class="line">    <span class="keyword">super</span>(equalsFn)</span><br><span class="line">    <span class="keyword">this</span>.equalsFn = equalsFn;</span><br><span class="line">    <span class="keyword">this</span>.compareFn = compareFn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有序插入元素"><a href="#有序插入元素" class="headerlink" title="有序插入元素"></a>有序插入元素</h4><p>会用下面代码覆盖insert方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">getIndexNextSortedElement(element) &#123;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="keyword">this</span>.head</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; <span class="keyword">this</span>.size() &amp;&amp; current; i ++) &#123;</span><br><span class="line">    <span class="keyword">const</span> comp = <span class="keyword">this</span>.compareFn(element, current.element)</span><br><span class="line">    <span class="keyword">if</span> (comp === Compare.LESS_THAN) &#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    current = current.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">insert(element, index = <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.insert(element, index === <span class="number">0</span> ? index : <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> pos = <span class="keyword">this</span>.getIndexNextSortedElement(element) </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.insert(element, pos)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表内是否存在环"><a href="#链表内是否存在环" class="headerlink" title="链表内是否存在环"></a>链表内是否存在环</h3><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://github.com/PacktPublishing/Learning-JavaScript-Data-Structures-and-Algorithms-Third-Edition" target="_blank" rel="noopener">Learning-JavaScript-Data-Structures</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶-大杂烩2</title>
      <link href="/2021/01/01/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E5%A4%A7%E6%9D%82%E7%83%A92/"/>
      <url>/2021/01/01/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E5%A4%A7%E6%9D%82%E7%83%A92/</url>
      
        <content type="html"><![CDATA[<p>虽然早有准备，但还是被无情按在地上摩擦摩擦</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域是指程序源代码中定义变量的区域。<br>作用域规定了<em>如何查找变量</em>，也就是确定当前执行代码对<strong>变量的访问权限</strong>。<br>JavaScript 采用<em>词法作用域(lexical scoping)</em>，也就是静态作用域</p><h3 id="词法作用域-需要安静的理解下"><a href="#词法作用域-需要安静的理解下" class="headerlink" title="词法作用域(需要安静的理解下)"></a>词法作用域(需要安静的理解下)</h3><p>词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将<strong>变量和块作用域</strong>写在哪里来决定的，不是在执行它们的作用域里运行，因此当词法分析器处理代码时会保持作用域不变(大部分情况下是这样的)。而JavaScript采用的就是词法作用域，也称为<em>静态作用域</em>。<br>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够完全知道全部标识符在哪里以及如何声明的，从而能够预测在执行过程中如何对他们进行查找</p><p>因为 JavaScript 采用的是词法作用域，函数的作用域在<em>函数定义</em>的时候就决定了。</p><p>而与词法作用域相对的是动态作用域，函数的作用域是在<em>函数调用</em>的时候才决定的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Mr.Han'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(name);<span class="comment">//undefined</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Mrs.Han'</span>;</span><br><span class="line">  alert(name);<span class="comment">//'Mrs.Han'</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();<span class="comment">//1</span></span><br></pre></td></tr></table></figure><ul><li>假设JavaScript采用静态作用域，让我们分析下执行过程：</li></ul><p>执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。</p><p>假设JavaScript采用动态作用域，让我们分析下执行过程：</p><p>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</p><p>前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。</p><h3 id="闭包特性"><a href="#闭包特性" class="headerlink" title="闭包特性"></a>闭包特性</h3><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>利用js计算，最后一次性修改DOM，大大减少DOM交互，减少回流和重绘，提升网页性能，还能减少内存占用，使用事件委托，只要对元素的父级指定事件处理函数即可</p><h4 id="事件委托原理"><a href="#事件委托原理" class="headerlink" title="事件委托原理"></a>事件委托原理</h4><p>依赖事件冒泡原理实现的，事件冒泡指的是事件会从最深的节点处开始逐步往上传播事件，由于有这样的机制，我们可以只给最外面的元素添加事件，当内层的标签触发了某个事件，该事件会通过事件冒泡传播到最外层标签，从而触发真正的事件处理函数。这也就是事件委托的过程，子元素委托父级元素代为执行事件。</p><h4 id="如何阻止冒泡-amp-amp-取消默认事件"><a href="#如何阻止冒泡-amp-amp-取消默认事件" class="headerlink" title="如何阻止冒泡 &amp;&amp; 取消默认事件"></a>如何阻止冒泡 &amp;&amp; 取消默认事件</h4><p>w3c是event.stopPropagation，IE则是event.cancelBulle,事件的一个方法，作用是阻止目标元素的事件冒泡，但是不会阻止事件的默认行为，</p><p>W3c是event.preventDefault,IE则是event.rerturnValuee = false, 作用是取消一个目标元素的默认行为。只有元素本身有默认行为取消才有意义，什么元素具有默认行为呢?<br>比如<a href=''> 提交按钮<button type='submit'>等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">event.stopPropagation() <span class="comment">// 阻止事件冒泡</span></span><br><span class="line">event.preventDefault <span class="comment">// 取消事件的默认行为</span></span><br></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://juejin.cn/post/6850418111242305544" target="_blank" rel="noopener">深入理解事件委托（事件代理）以及取消冒泡和默认事件</a></li></ul><h3 id="实现new操作符"><a href="#实现new操作符" class="headerlink" title="实现new操作符"></a>实现new操作符</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现</span></span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">const</span> newOperator = <span class="function">(<span class="params">ctor: <span class="built_in">Function</span>, ...args: <span class="built_in">any</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> ctor !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span>(<span class="string">'第一个参数必须为函数'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建一个对象，同时继承构造函数上的原型属性</span></span><br><span class="line">  <span class="keyword">const</span> newObj = <span class="built_in">Object</span>.create(ctor.prototype);</span><br><span class="line">  <span class="comment">// 调用构造函数，绑定到构造函数上this对象上，并且传入剩余的参数</span></span><br><span class="line">  <span class="keyword">const</span> returnObj = ctor.apply(newObj, args)</span><br><span class="line">  <span class="comment">// 默认返回this，如果手动定义返回原始值不影响，返回对象需要正常处理</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> returnObj === <span class="string">'object'</span> ? returnObj : newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 vue文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; mockNewFn, newOperator &#125; <span class="keyword">from</span> <span class="string">'../utils/mockBind'</span></span><br><span class="line"><span class="keyword">const</span> girl3 = newOperator(Girl, <span class="string">'测试下我的小女生3'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'gril3 —————— newOperator'</span>, girl3, girl3.greetName());</span><br></pre></td></tr></table></figure><h3 id="模拟实现apply-call"><a href="#模拟实现apply-call" class="headerlink" title="模拟实现apply/call"></a>模拟实现apply/call</h3><p>两者区别在于apply第二个参数传入的是数组，而call是一个一个参数传入的</p><p>模拟的时候注意:</p><ul><li>this 参数可以传 null，当为 null 的时候，视为指向 window</li><li>函数是可以有返回值的！</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟实现apply</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mockApply = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, thisArg: <span class="built_in">any</span>, rest: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>&#125;</span>.mockApply is not a function`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> newObj = <span class="built_in">Object</span>.create(thisArg) || <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// 首先要获取调用apply的函数，用this可以获取</span></span><br><span class="line">  newObj[<span class="string">'anyFn'</span>] = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> res = newObj[<span class="string">'anyFn'</span>](...rest)</span><br><span class="line">  <span class="keyword">delete</span> newObj[<span class="string">'anyFn'</span>]</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟实现call</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mockCall = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, thisArg: <span class="built_in">any</span>, ...rest: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>&#125;</span>.mockCall is not a function`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> newObj = <span class="built_in">Object</span>.create(thisArg) || <span class="built_in">window</span>;</span><br><span class="line">  newObj[<span class="string">'anyFn'</span>] = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> res = newObj[<span class="string">'anyFn'</span>](...rest)</span><br><span class="line">  <span class="keyword">delete</span> newObj[<span class="string">'anyFn'</span>]</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="keyword">import</span> &#123; mockApply, mockCall &#125; <span class="keyword">from</span> <span class="string">'../utils/mockBind'</span></span><br><span class="line"></span><br><span class="line">(<span class="built_in">Function</span>.prototype <span class="keyword">as</span> <span class="built_in">any</span>).mockApply = mockApply;</span><br><span class="line">(<span class="built_in">Function</span>.prototype <span class="keyword">as</span> <span class="built_in">any</span>).mockCall = mockCall;</span><br><span class="line"><span class="keyword">const</span> test1 = (sayName <span class="keyword">as</span> <span class="built_in">any</span>).mockApply(TestObj, [<span class="string">'chendaoeng mockApply'</span>, <span class="number">30</span>])</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test1- mockApply'</span>, test1);</span><br><span class="line"><span class="keyword">const</span> testMockCall = (sayName <span class="keyword">as</span> <span class="built_in">any</span>).mockCall(TestObj, <span class="string">'chendaoeng mockCall'</span>, <span class="number">30</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'testMockCall- mockCall'</span>, testMockCall);</span><br></pre></td></tr></table></figure><h3 id="实现bind函数"><a href="#实现bind函数" class="headerlink" title="实现bind函数"></a>实现bind函数</h3><p>bind函数: bind()会创建一个方法，当这个新函数被调用的时候，bind()的第一个参数将作为它运行时的this,之后的序列参数会在传入的实参前传入作为它的参数。<br>需要理解下，bind函数有两种；</p><h4 id="手写mockBind"><a href="#手写mockBind" class="headerlink" title="手写mockBind"></a>手写mockBind</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mockBind = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, obj: <span class="built_in">any</span>, ...firstArgs: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>&#125;</span>.bind is not a function`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> context = obj || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">const</span> bindFn = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, ...bindFnArg: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 作为构造函数 this指向实例 self 指向绑定函数 this,因为下面一句 bindFn.prototype = this.prototype 已经修改了bindFn.prototype为绑定函数的prototype</span></span><br><span class="line">    <span class="comment">// instanceof self: true this指向实例</span></span><br><span class="line">    <span class="comment">// 作为普通函数 this指向window self 指向绑定函数 this instanceof self: false</span></span><br><span class="line">    <span class="comment">// instanceof self: true this指向window</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'context传入的————'</span>, context);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this————'</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'self————'</span>, self);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this instanceof self'</span>, <span class="keyword">this</span> <span class="keyword">instanceof</span> self);</span><br><span class="line">    <span class="keyword">return</span> self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> self ? <span class="keyword">this</span> : context, [...firstArgs, ...bindFnArg])</span><br><span class="line">  &#125;</span><br><span class="line">  bindFn.prototype = <span class="keyword">this</span>.prototype</span><br><span class="line">  <span class="keyword">return</span> bindFn</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TestObj = &#123;</span><br><span class="line">  name: <span class="string">'cpp'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str =  <span class="string">`我的名字是<span class="subst">$&#123;name&#125;</span>,年龄是<span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    tip: str</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="built_in">Function</span>.prototype <span class="keyword">as</span> <span class="built_in">any</span>).mockBind = mockBind</span><br><span class="line"><span class="keyword">const</span> bindName = sayName.bind(TestObj, <span class="string">'niaogege bind'</span>);</span><br><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">const</span> testBind1 = bindName(<span class="number">29</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'第一种'</span>, testBind1); <span class="comment">// &#123;tip: "我的名字是niaogege bind,年龄是29"&#125;</span></span><br><span class="line"><span class="keyword">const</span> bindName2 = (sayName <span class="keyword">as</span> <span class="built_in">any</span>).mockBind(TestObj, <span class="string">'niaogege bind'</span>);</span><br><span class="line"><span class="keyword">const</span> testBind2 = bindName2(<span class="number">29</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'第一种'</span>, testBind2); <span class="comment">// &#123;tip: "我的名字是niaogege bind,年龄是29"&#125;</span></span><br></pre></td></tr></table></figure><h4 id="mockBind之后new操作符调用"><a href="#mockBind之后new操作符调用" class="headerlink" title="mockBind之后new操作符调用"></a>mockBind之后new操作符调用</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">const</span> newTestBind1 = <span class="keyword">new</span> (bindName <span class="keyword">as</span> <span class="built_in">any</span>)(<span class="number">30</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newTestBind1, <span class="string">'newTestBind1'</span>, <span class="built_in">Object</span>.prototype.toString.call(newTestBind1))</span><br><span class="line"><span class="keyword">const</span> mockBindName = (sayName <span class="keyword">as</span> <span class="built_in">any</span>).mockBind(TestObj, <span class="string">'niaogege mockBind'</span>)</span><br><span class="line"><span class="keyword">const</span> newTestBind2 = <span class="keyword">new</span> mockBindName(<span class="number">30</span>);</span><br><span class="line"><span class="built_in">console</span>.log(newTestBind2, <span class="string">'newTestBind2'</span>, <span class="built_in">Object</span>.prototype.toString.call(newTestBind2));</span><br></pre></td></tr></table></figure><h3 id="vue渲染原理"><a href="#vue渲染原理" class="headerlink" title="vue渲染原理"></a>vue渲染原理</h3><h3 id="vue数据双向绑定"><a href="#vue数据双向绑定" class="headerlink" title="vue数据双向绑定"></a>vue数据双向绑定</h3><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://segmentfault.com/a/1190000009257663" target="_blank" rel="noopener">JavaScript深入之call和apply的模拟实现</a></li><li><a href="https://mp.weixin.qq.com/s/TG87bWiLyv1b8Ho4afaNUA" target="_blank" rel="noopener">面试系列——手写代码实现（一）</a></li><li><a href="https://segmentfault.com/a/1190000009271416" target="_blank" rel="noopener">JavaScript深入之bind的模拟实现</a></li><li><a href="https://segmentfault.com/a/1190000008972987" target="_blank" rel="noopener">JavaScript深入之词法作用域和动态作用域</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端基础: Iterator</title>
      <link href="/2020/12/29/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-Iterator/"/>
      <url>/2020/12/29/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-Iterator/</url>
      
        <content type="html"><![CDATA[<h3 id="面试题，给出一个对象，如何封装一个类使其可遍历，就是算是手写一个Generator函数吧"><a href="#面试题，给出一个对象，如何封装一个类使其可遍历，就是算是手写一个Generator函数吧" class="headerlink" title="面试题，给出一个对象，如何封装一个类使其可遍历，就是算是手写一个Generator函数吧"></a>面试题，给出一个对象，如何封装一个类使其可遍历，就是算是手写一个Generator函数吧</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'chen'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'da'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'peng'</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考一会，小试牛刀！！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'chen'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'da'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'peng'</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MakeIterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(obj) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = <span class="built_in">Object</span>.keys(obj).length;</span><br><span class="line">        <span class="keyword">this</span>.index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">this</span>.obj = obj</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;<span class="keyword">return</span> <span class="keyword">this</span>&#125;; <span class="comment">// 这个是难点也是最重要的一点</span></span><br><span class="line">    next() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.index &lt; <span class="keyword">this</span>.length</span><br><span class="line">        ? &#123;<span class="attr">value</span>: <span class="keyword">this</span>.obj[<span class="keyword">this</span>.index ++], <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">        : &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(item <span class="keyword">of</span> <span class="keyword">new</span> MakeIterator(test)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>遍历器(Iterator)是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就阔以完成遍历操作；</p><h4 id="模拟next方法返回值的例子"><a href="#模拟next方法返回值的例子" class="headerlink" title="模拟next方法返回值的例子"></a>模拟next方法返回值的例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">it.next() <span class="comment">// &#123;value: 'a', done: false&#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123;value: 'b', done: false&#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index &lt; array.length ?</span><br><span class="line">      &#123;<span class="attr">value</span>: array[index++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">      &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认-Iterator-接口"><a href="#默认-Iterator-接口" class="headerlink" title="默认 Iterator 接口"></a>默认 Iterator 接口</h3><p>Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即<strong>for…of</strong>循环。当使用for…of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。<br>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。<br>ES6 规定，默认的 Iterator 接口部署在数据结构的<strong>Symbol.iterator</strong>属性，或者说，一个数据结构只要具有<strong>Symbol.iterator</strong>属性，就可以认为是<em>可遍历的</em>（iterable）。<br>Symbol.iterator本身是一个函数，数据结构默认的遍历器生成函数，执行这个函数就会返回一个遍历器。<br>原生具备 Iterator 接口的数据结构如下:</p><ul><li><p>Array</p></li><li><p>Set</p></li><li><p>Arguments</p></li><li><p>Map</p></li><li><p>String</p></li><li><p>NodeList对象</p></li><li><p>typedArray</p><p>对于类似数组的对象（存在数值键名和length属性），部署 Iterator 接口，有一个简便方法，就是Symbol.iterator方法直接引用数组的 Iterator 接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> it = arr[<span class="built_in">Symbol</span>.iterator](); <span class="comment">// 得到遍历器对象</span></span><br><span class="line">it.next()</span><br><span class="line">it.next()</span><br><span class="line">it.next()</span><br></pre></td></tr></table></figure><p>变量arr是一个数组，原生就具有遍历器接口，部署在arr的Symbol.iterator属性上面。所以，调用这个属性，就得到<strong>遍历器对象</strong>。</p></li></ul><p>类似数组的对象调用数组的Symbol.iterator方法的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iterable = &#123;</span><br><span class="line"> <span class="number">0</span>: <span class="string">'a'</span>,</span><br><span class="line"> <span class="number">1</span>: <span class="string">'b'</span>,</span><br><span class="line"> <span class="number">2</span>: <span class="string">'c'</span>,</span><br><span class="line"> length: <span class="number">3</span>,</span><br><span class="line"> [<span class="built_in">Symbol</span>.iterator]: [][<span class="built_in">Symbol</span>.iterator]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item, <span class="string">'eee'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a eee</span></span><br><span class="line"><span class="comment">// b eee</span></span><br><span class="line"><span class="comment">// c eee</span></span><br></pre></td></tr></table></figure><p>若没有部署[].Symbol.iterator则会报错 <em>iterable is not iterable</em></p><h4 id="普通对象部署数组的Symbol-iterator方法无效"><a href="#普通对象部署数组的Symbol-iterator方法无效" class="headerlink" title="普通对象部署数组的Symbol.iterator方法无效"></a>普通对象部署数组的Symbol.iterator方法无效</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iterable = &#123;</span><br><span class="line"> a: <span class="string">'a'</span>,</span><br><span class="line"> b: <span class="string">'b'</span>,</span><br><span class="line"> c: <span class="string">'c'</span>,</span><br><span class="line"> length: <span class="number">3</span>,</span><br><span class="line"> [<span class="built_in">Symbol</span>.iterator]: [][<span class="built_in">Symbol</span>.iterator]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item, <span class="string">'eee'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// undefined "eee"</span></span><br></pre></td></tr></table></figure><blockquote><p>手动部署iterator属性的时候记得是 [Symbol.iterator]: [][Symbol.iterator] 这种写法</p></blockquote><h3 id="手写实现一个遍历器"><a href="#手写实现一个遍历器" class="headerlink" title="手写实现一个遍历器"></a>手写实现一个遍历器</h3><p>目的: 定义一个对象，通过调用类Iterator实现可遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">"a"</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">"b"</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">"c"</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  Uncaught TypeError: obj is not iterable</span></span><br></pre></td></tr></table></figure><p>如何调用类Iterator实现可遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIterator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(obj) &#123;</span><br><span class="line">      <span class="keyword">this</span>.obj = obj;</span><br><span class="line">      <span class="keyword">this</span>.length = <span class="built_in">Object</span>.keys(obj).length;</span><br><span class="line">      <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;<span class="keyword">return</span> <span class="keyword">this</span>&#125;</span><br><span class="line">  next() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.index &lt; <span class="keyword">this</span>.length</span><br><span class="line">      ? &#123;<span class="attr">value</span>: <span class="keyword">this</span>.obj[<span class="keyword">this</span>.index ++], <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">      : &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">"a"</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">"b"</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">"c"</span>,</span><br><span class="line">  length: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> <span class="keyword">new</span> MyIterator(obj)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法），除了下文会介绍的for…of循环，还有其他场合</p><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">set</span> = new Set().add('a').add('b').add('c')</span><br><span class="line">var [x, ...y] = <span class="keyword">set</span>;</span><br><span class="line">console.log(x, y) // a ['b', 'c']</span><br></pre></td></tr></table></figure><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">[<span class="string">'a'</span>, ...arr, <span class="string">'d'</span>] <span class="comment">// a b c d</span></span><br></pre></td></tr></table></figure><p>上面代码的扩展运算符内部就调用 Iterator 接口。<br>只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</p><h4 id="yield"><a href="#yield" class="headerlink" title="yield*"></a>yield*</h4><p>yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ge = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">55</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ite = ge();</span><br><span class="line">ite.next() <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">ite.next() <span class="comment">// &#123;value: [2, 3, 4], done: false&#125;</span></span><br><span class="line">ite.next() <span class="comment">// &#123;value: 55, done: false&#125;</span></span><br><span class="line">ite.next() <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>思考 如何让第二个next里的数据遍历呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ge = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">55</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ite = ge();</span><br></pre></td></tr></table></figure><h4 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h4><p>由于数组的遍历回调用遍历器接口，所以任何接受数组作为参数的场景都会调用遍历器</p><ul><li>for…of</li><li>Array.from()</li><li>Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])）</li><li>Promise.all()</li><li>Promise.race()</li></ul><h3 id="字符串的-Iterator-接口"><a href="#字符串的-Iterator-接口" class="headerlink" title="字符串的 Iterator 接口"></a>字符串的 Iterator 接口</h3><p>字符串是一个类似数组的对象，也原生具有 Iterator 接口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someString = <span class="string">"hi"</span>;</span><br><span class="line"><span class="keyword">typeof</span> someString[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line"><span class="comment">// "function"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = someString[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: "h", done: false &#125;</span></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: "i", done: false &#125;</span></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中 调用<strong>Symbol.iterator</strong>方法返回一个遍历器对象，在这个遍历器上可以调用 <strong>next</strong> 方法，实现对于字符串的遍历</p><h3 id="Iterator与Generator"><a href="#Iterator与Generator" class="headerlink" title="Iterator与Generator"></a>Iterator与Generator</h3><p>Symbol.iterator()方法的最简单实现, 两者关系</p><p>任意一个对象的<strong>Symbol.iterator</strong>方法 === 该对象的遍历器生成函数<strong>Generator</strong>，调用该函数会生成该对象的遍历器对象.<br>Generator函数就是遍历器生成函数，因此能把Generator赋值给对象的Symbol.iterator属性，从而使该对象具有iterator接口</p><ul><li>第一种<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = &#123;</span><br><span class="line">   [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log([...it]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></li><li>第二种<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it2 = &#123;</span><br><span class="line">    * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(...it2) <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h3><p>一个结构只要部署了Symbol.iterator属性，就被视为具体Iterator接口，就能用for of 循环遍历成员，也就是for of 循环内部调用的是数据结构的Symbol.iterator属性</p><p>for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、Generator 对象，以及字符串</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>1.所有的模拟数据结构，用到的<em>Symbol.iterator</em> ，再用的时候都需要加上方括号，不管是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it2 = &#123;</span><br><span class="line">    * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.面试的时候如何用大白话说清楚，Iterator跟Generator俩者之间的关系</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://es6.ruanyifeng.com/#docs/iterator" target="_blank" rel="noopener">Iterator 和 for…of 循环</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> Iterator </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
            <tag> Iterator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: generator-1</title>
      <link href="/2020/12/29/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-generator-1/"/>
      <url>/2020/12/29/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-generator-1/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Generator(生成器) 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p><p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><p>形式上，Generator 函数是一个普通函数，但是有两个特征。</p><ul><li>function关键字与函数名之间有一个<strong>星号</strong></li><li>函数体内部使用<strong>yield</strong>表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'cpp'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'专注'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hG = hello()</span><br><span class="line"><span class="built_in">console</span>.log(hG, <span class="built_in">Object</span>.prototype.toString.call(hG)); <span class="comment">// hello &#123;&lt;suspended&gt;&#125;  "[object Generator]"</span></span><br><span class="line">hG.next() <span class="comment">// &#123;value: "hello", done: false&#125;</span></span><br></pre></td></tr></table></figure><h3 id="yield-表达式，暂停标记"><a href="#yield-表达式，暂停标记" class="headerlink" title="yield 表达式，暂停标记"></a>yield 表达式，暂停标记</h3><p>由于 Generator 函数返回的遍历器对象，只有调用<strong>next</strong>方法才会遍历下一个内部状态<br>遍历器对象的next方法的运行逻辑如下。</p><ul><li>遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</li><li>下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。</li><li>如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</li><li>如果该函数没有return语句，则返回的对象的value属性值为undefined。</li></ul><blockquote><p>另外需要注意，yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。</p></blockquote><p>yield表达式如果用在另一个表达式之中，必须放在圆括号里面;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">hello2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>+ (<span class="keyword">yield</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'专注'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hG = hello2()</span><br><span class="line">hG.next(); <span class="comment">// &#123;value: undefined, done: false&#125;</span></span><br><span class="line">hG.next(); <span class="comment">// helloundefined &#123;value: "专注", done: true&#125;</span></span><br><span class="line">hG.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><h4 id="return-amp-yield区别"><a href="#return-amp-yield区别" class="headerlink" title="return &amp; yield区别"></a>return &amp; yield区别</h4><ul><li>相似之处在于，都能返回紧跟在语句后面的那个表达式的值</li><li>不同:<br>a: return语句不具备位置记忆的功能,每次遇到yield函数暂停执行，并将紧跟yield后面的表达式的值作为返回对象的value属性值<br>b：一个函数只能执行一个return语句，而能执行多个yield语句</li></ul><h4 id="如何模拟-yield关键词？"><a href="#如何模拟-yield关键词？" class="headerlink" title="如何模拟 yield关键词？"></a>如何模拟 yield关键词？</h4><h3 id="与-Iterator-接口的关系"><a href="#与-Iterator-接口的关系" class="headerlink" title="与 Iterator 接口的关系"></a>与 Iterator 接口的关系</h3><p>Iterator Generator<br>It/Gen erator 从命名上有点关系哈</p><p>任意一个对象的<strong>Symbol.iterator</strong>方法 === 该对象的遍历器生成函数Generator，调用该函数会生成该对象的遍历器对象.<br>Generator函数就是遍历器生成函数，因此能把Generator赋值给对象的Symbol.iterator属性，从而使该对象具有iterator接口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterator = &#123;&#125;</span><br><span class="line">myIterator[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log([...myIterator]) <span class="comment">//  [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>Generator函数执行后返回一个遍历器对象，该对象本身也具有Symbol.iterator属性，所以执行后返回自身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> gg = gen()</span><br><span class="line">gg[<span class="built_in">Symbol</span>.iterator]() === gg <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">var</span> gg = (<span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;&#125;)()</span><br><span class="line">gg[<span class="built_in">Symbol</span>.iterator]() === gg</span><br></pre></td></tr></table></figure><h3 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a>next 方法的参数</h3><p>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作<strong>上一个yield</strong>表达式的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> reset = <span class="keyword">yield</span> i; <span class="comment">// yield i 上一次的结果</span></span><br><span class="line">    <span class="keyword">if</span>(reset) &#123; i = <span class="number">-1</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f();</span><br><span class="line"></span><br><span class="line">g.next() <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next(<span class="literal">true</span>) <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br></pre></td></tr></table></figure><p>当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。</p><p>注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的<br>再看一个通过next方法的参数，向 Generator 函数内部输入值的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">dataConsumer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Started'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`1. <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`2. <span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'result'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> genObj = dataConsumer();</span><br><span class="line">genObj.next(); <span class="comment">// started &#123;value: undefined, done: false&#125;</span></span><br><span class="line">genObj.next(<span class="string">'a'</span>); <span class="comment">//  1. a &#123;value: undefined, done: false&#125;</span></span><br><span class="line">genObj.next(<span class="string">'b'</span>); <span class="comment">// 2. b  &#123;value: "result", done: true&#125;</span></span><br></pre></td></tr></table></figure><h3 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for of 循环"></a>for of 循环</h3><p>for of 阔以自动遍历Generator函数生成的遍历器对象，不需要next方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'end'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的end，不包括在for…of循环之中。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">Generator 函数的语法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> generator </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
            <tag> generator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶-手写promise</title>
      <link href="/2020/12/27/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E6%89%8B%E5%86%99promise/"/>
      <url>/2020/12/27/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E6%89%8B%E5%86%99promise/</url>
      
        <content type="html"><![CDATA[<p>promise基本用法以及手写</p><h2 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h2><h3 id="20行手写promise"><a href="#20行手写promise" class="headerlink" title="20行手写promise"></a>20行手写promise</h3><p>目前见过最容易理解的promise</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Promise resolve时的回调函数集</span></span><br><span class="line">  <span class="keyword">this</span>.callbacks = []</span><br><span class="line">  <span class="keyword">const</span> resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 注意promise的then函数需要异步执行</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.data = val;</span><br><span class="line">      <span class="comment">// cbs里用户传入的函数执行一遍</span></span><br><span class="line">      <span class="keyword">this</span>.callbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">        cb(val)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  executor(resolve)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// promise2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this指的是promise1</span></span><br><span class="line">    <span class="keyword">this</span>.callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// onResolved对应用户在then里传入的函数</span></span><br><span class="line">      <span class="keyword">const</span> res = onResolved(<span class="keyword">this</span>.data)</span><br><span class="line">      <span class="keyword">if</span> (res <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">        <span class="comment">// 只有promise2被resolve以后</span></span><br><span class="line">        <span class="comment">// then下面的链式调用函数才会继续执行</span></span><br><span class="line">        res.then(resolve)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// onResolved</span></span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">2</span>);</span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="built_in">console</span>.log);</span><br><span class="line">  <span class="comment">// 500s后输出 1</span></span><br><span class="line">  <span class="comment">// 500s后输出 2</span></span><br></pre></td></tr></table></figure><h2 id="面试版"><a href="#面试版" class="headerlink" title="面试版"></a>面试版</h2><p>在基础版基础上增加reject部分功能; </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进阶版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cppPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 收集链式调用的函数集合cb</span></span><br><span class="line">  <span class="keyword">this</span>.onResolvedCallbacks = [];</span><br><span class="line">  <span class="keyword">this</span>.onRejectedCallbacks = [];</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">this</span>.reason = <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">this</span>.status = <span class="string">'pending'</span></span><br><span class="line">  <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.status = <span class="string">'fulfilled'</span></span><br><span class="line">      <span class="keyword">this</span>.value = value</span><br><span class="line">      <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">        cb(<span class="keyword">this</span>.value)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> reject = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.status = <span class="string">'rejected'</span></span><br><span class="line">      <span class="keyword">this</span>.reason = val</span><br><span class="line">      <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">        cb(<span class="keyword">this</span>.reason)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  executor(resolve, reject)</span><br><span class="line">&#125;</span><br><span class="line">handleResolve(resolve, reject, onFulledFn) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> cppPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = onFulledFn(<span class="keyword">this</span>.value);</span><br><span class="line">        <span class="keyword">if</span> (res <span class="keyword">instanceof</span> cppPromise) &#123;</span><br><span class="line">          res.then(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(res)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">handleReject(resolve, reject, onRejectedFn) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> cppPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = onRejectedFn(<span class="keyword">this</span>.reason);</span><br><span class="line">        <span class="keyword">if</span> (res <span class="keyword">instanceof</span> cppPromise) &#123;</span><br><span class="line">          res.then(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(res)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">cppPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulledFn, onRejectedFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> cppPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 收集成功的回调</span></span><br><span class="line">      <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        handleResolve(resolve, reject, onFulledFn)</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 收集失败的回调</span></span><br><span class="line">      <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        handleReject(resolve, reject, onRejectedFn)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'fulfilled'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> cppPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        handleResolve(resolve, reject, onFulledFn)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> cppPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        handleReject(resolve, reject, onRejectedFn)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例调用2</span></span><br><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> cppPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'promise1'</span>, promise1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'promise2'</span>, promise2)</span><br></pre></td></tr></table></figure><h2 id="专业版1"><a href="#专业版1" class="headerlink" title="专业版1"></a>专业版1</h2><h3 id="手写MockPromise"><a href="#手写MockPromise" class="headerlink" title="手写MockPromise"></a>手写MockPromise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.status = <span class="string">'pending'</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">this</span>.onResolvedCallbacks = []</span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallbacks = []</span><br><span class="line">    <span class="comment">// 定义resolve</span></span><br><span class="line">    <span class="keyword">let</span> resolve = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'resolve'</span></span><br><span class="line">        <span class="keyword">this</span>.value = data</span><br><span class="line">        <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reject</span></span><br><span class="line">    <span class="keyword">let</span> reject = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = <span class="string">'reject'</span></span><br><span class="line">        <span class="keyword">this</span>.reason = data</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description </span>then函数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;function&#125;</span> </span>onFufilled </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;function&#125;</span> </span>onRejected </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  then(onFufilled, onRejected) &#123;</span><br><span class="line">    <span class="comment">// console.log(`onFufilled`, onFufilled);</span></span><br><span class="line">    <span class="comment">// console.log(`onRejected`, onRejected);</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> onFufilled !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      onFufilled = <span class="function"><span class="params">res</span> =&gt;</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      onRejected = <span class="function"><span class="params">res</span> =&gt;</span> MockPromise.reject(res)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> promise2</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'resolve'</span>) &#123;</span><br><span class="line">      promise2 = <span class="keyword">new</span> MockPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onFufilled(<span class="keyword">this</span>.value)</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'reject'</span>) &#123;</span><br><span class="line">      promise2 = <span class="keyword">new</span> MockPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      promise2 = <span class="keyword">new</span> MockPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onFufilled(<span class="keyword">this</span>.value);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">` onFufilled x pending`</span>, x);</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">` onRejected x pending`</span>, x);</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise2</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span>(cb) &#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">this</span>.constructor</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">      val =&gt; P.resolve(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> val),</span><br><span class="line">      reason = P.reject(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> resolve(val) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MockPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      resolve(val)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MockPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      reject(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当数组中每个实例都成功时才会返回，返回的也是一个数组，每个参数为对应的promise返回的结果，如果有一项失败了，all方法都会返回失败</span></span><br><span class="line">  <span class="comment">// 谁跑得慢以谁为准 如果有一个失败 则返回失败结果</span></span><br><span class="line">  <span class="keyword">static</span> all(promiseList) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MockPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">      <span class="keyword">const</span> results = []</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promiseList.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">const</span> item = promiseList[i]</span><br><span class="line">        <span class="keyword">if</span> (!item <span class="keyword">instanceof</span> MockPromise) <span class="keyword">return</span></span><br><span class="line">        item.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">          index ++</span><br><span class="line">          results[i] = result</span><br><span class="line">          <span class="keyword">if</span> (index === promiseList.length) &#123;</span><br><span class="line">            resolve(results)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">reason</span> =&gt;</span> reject(reason))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Promise.all示例</span></span><br><span class="line">  <span class="comment">// 谁跑得快 以谁为准</span></span><br><span class="line">  <span class="keyword">static</span> race(promiseList) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MockPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      promiseList.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!item <span class="keyword">instanceof</span> MockPromise) <span class="keyword">return</span></span><br><span class="line">        item.then(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">          resolve(val)</span><br><span class="line">        &#125;, (err) =&gt; &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> <span class="variable">promise2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;any&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> </span>resolve reject 最外层的resolve reject</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x === promise2) &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环了'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> called</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.then</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`x then`</span>, then);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一个参数是将x这个promise方法作为this指向，后两个参数分别为成功失败回调</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`called`</span>, called);</span><br><span class="line">        then.call(x,</span><br><span class="line">          (</span><br><span class="line">            y =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">              called = <span class="literal">true</span></span><br><span class="line">              <span class="comment">//因为可能promise中还有promise，所以需要递归</span></span><br><span class="line">              <span class="comment">// this.resolvePromise(promise2, y, resolve, reject)</span></span><br><span class="line">              resolve(y)</span><br><span class="line">            &#125;,</span><br><span class="line">            err =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">              called = <span class="literal">true</span></span><br><span class="line">              reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">          )</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用MockPromise"><a href="#使用MockPromise" class="headerlink" title="使用MockPromise"></a>使用MockPromise</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = MockPromise.resolve(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = MockPromise.resolve(p1)</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> MockPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">'cpp MockPromise'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(p1)</span><br><span class="line"><span class="built_in">console</span>.log(p2)</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p1) <span class="comment">// trye</span></span><br><span class="line">p3.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`p3: <span class="subst">$&#123;val&#125;</span> then1 ————`</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;val&#125;</span> then3 ————`</span>);</span><br><span class="line">  <span class="comment">// then返回的mockPromise还是有问题!!循环引用</span></span><br><span class="line">  <span class="keyword">return</span> MockPromise.reject(<span class="string">'then is reject'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;val&#125;</span> then4 ————`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="专业版-2"><a href="#专业版-2" class="headerlink" title="专业版 2"></a>专业版 2</h2><h3 id="手写-cppPromise"><a href="#手写-cppPromise" class="headerlink" title="手写 cppPromise"></a>手写 cppPromise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 专业版2</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">myPromise</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">      <span class="keyword">this</span>.status = <span class="string">'pending'</span>;</span><br><span class="line">      <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">this</span>.onResolvedCallbacks = []</span><br><span class="line">      <span class="keyword">this</span>.onRejectedCallbacks = []</span><br><span class="line">      <span class="keyword">const</span> resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.status = <span class="string">'fulfilled'</span></span><br><span class="line">          <span class="keyword">this</span>.value = val</span><br><span class="line">          <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              cb(val)</span><br><span class="line">            &#125;, <span class="number">0</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> reject = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.status = <span class="string">'rejected'</span></span><br><span class="line">          <span class="keyword">this</span>.reason = val;</span><br><span class="line">          <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              cb(val)</span><br><span class="line">            &#125;, <span class="number">0</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 使用者传入的参数</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fn(resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造器中resolve和reject的结果传入onFufilled和onRejected中</span></span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">      onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function">(<span class="params">v</span>) =&gt;</span> v;</span><br><span class="line">      onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;<span class="keyword">throw</span> e&#125;;</span><br><span class="line">      <span class="keyword">let</span> promise2</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'fulfilled'</span>) &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> value = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">                resolvePromise(promise2, value, resolve, reject)</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">              reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.onRejectedCallbacks(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> reason = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">                resolvePromise(promise2, reason, resolve, reject)</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">              reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">        promise2 = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 成功回调的收集 </span></span><br><span class="line">          <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> value = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">            resolvePromise(promise2, value, resolve, reject)  </span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="comment">// 失败回调的收集</span></span><br><span class="line">          <span class="keyword">this</span>.onRejectedCallbacks(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> reason = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">            resolvePromise(promise2, reason, resolve, reject) </span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> promise2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统一处理</span></span><br><span class="line">    resolvePromise(myPromise, val, resolve, reject) &#123;</span><br><span class="line">      <span class="keyword">if</span> (myPromise === val) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>)) </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (val &amp;&amp; (<span class="keyword">typeof</span> val === <span class="string">'object'</span> || <span class="keyword">typeof</span> val === <span class="string">'function'</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (val <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">            val.then(resolve)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(val)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">let</span> thenFn = val.then</span><br><span class="line">          <span class="keyword">let</span> called</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> thenFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">            thenFn.call(val, value =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">              called = <span class="literal">true</span></span><br><span class="line">              resolvePromise(promise2, value, resolve, reject)</span><br><span class="line">            &#125;, err =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">              called = <span class="literal">true</span></span><br><span class="line">              reject(err)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 其实就相当于</span></span><br><span class="line">            <span class="comment">// if (val instanceof myPromise) &#123;</span></span><br><span class="line">            <span class="comment">//   val.then(resolve, reject)</span></span><br><span class="line">            <span class="comment">// &#125; else &#123;</span></span><br><span class="line">            <span class="comment">//   resolve(val)</span></span><br><span class="line">            <span class="comment">//   reject(val)</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(val)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">          called = <span class="literal">true</span></span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  myPromise.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(val)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  myPromise.reject = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(val)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 入参是个由Promise实例组成的数组</span></span><br><span class="line">  <span class="comment">// 返回值是个promise，因为可以使用.then</span></span><br><span class="line">  <span class="comment">// 如果全部成功，状态变为resolved, 并且返回值组成一个数组传给回调</span></span><br><span class="line">  <span class="comment">// 但凡有一个失败，状态变为rejected, 并将error返回给回调</span></span><br><span class="line">  myPromise.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = []</span><br><span class="line">      <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> promises) &#123;</span><br><span class="line">        item.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          result[index] = res</span><br><span class="line">          index ++ </span><br><span class="line">          <span class="keyword">if</span> (index === promises.length) &#123;</span><br><span class="line">            resolve(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, (err) =&gt; &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myPromise.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">        promise.then(resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="专业版2-示例"><a href="#专业版2-示例" class="headerlink" title="专业版2 示例"></a>专业版2 示例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myPromise.all示例</span></span><br><span class="line"><span class="keyword">let</span> p1 = myPromise.resolve(<span class="number">1</span>),</span><br><span class="line">p2 = myPromise.resolve(<span class="number">2</span>),</span><br><span class="line">p3 = myPromise.resolve(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">myPromise.all([p1, p2, p3]).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="string">'res'</span>)</span><br><span class="line">&#125;, (err)=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err, <span class="string">'err'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://juejin.cn/post/6844904094079926286" target="_blank" rel="noopener">最简实现Promise，支持异步链式调用（20行）</a> </li><li><a href="https://juejin.cn/post/6844903629187448845#heading-12" target="_blank" rel="noopener">Promise之你看得懂的Promise</a></li><li><a href="https://juejin.cn/post/6844903509934997511" target="_blank" rel="noopener">Promise 必知必会（十道题）</a></li><li><a href="https://mp.weixin.qq.com/s/PhZrP1gCn_VxLub7-oh1_w" target="_blank" rel="noopener">15道ES6 Promise实战练习题，助你快速理解Promise</a></li><li><a href="https://juejin.cn/post/6844903488695042062#heading-6" target="_blank" rel="noopener">八段代码彻底掌握 Promise</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> promise </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: js执行机制</title>
      <link href="/2020/12/26/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/12/26/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="js执行是单线程的"><a href="#js执行是单线程的" class="headerlink" title="js执行是单线程的"></a>js执行是单线程的</h3><p>单线程是指Js引擎执行Js时只分了一个线程给他执行，也就是执行js时是单线程的。说白点就是一个时间点只能做一件事，这里只是说javascript,浏览器可不是单线程的，浏览器可是多进程的</p><h3 id="js引擎"><a href="#js引擎" class="headerlink" title="js引擎"></a>js引擎</h3><p>JS引擎是浏览器的重要组成部分，主要用于读取并执行js。js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</p><p>各大浏览器的JS引擎:</p><table><thead><tr><th>浏览器</th><th>Js引擎</th></tr></thead><tbody><tr><td>Chrome</td><td><em>V8</em></td></tr><tr><td>Firefox</td><td>SpiderMonkey</td></tr><tr><td>IE</td><td>Chakra（查克拉）</td></tr><tr><td>Safari</td><td>Nitro/JavaScript Core</td></tr></tbody></table><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>浏览器（多进程）包含了Browser进程（浏览器的主进程）、第三方插件进程和GPU进程以及浏览器渲染进程，</p><ul><li>浏览器进程<br>浏览器最核心的进程，负责管理各个标签页的创建和销毁、页面显示和功能（前进，后退，收藏等）、网络资源的管理，下载等。</li><li>插件进程<br>负责每个第三方插件的使用，每个第三方插件使用时候都会创建一个对应的进程、这可以避免第三方插件crash影响整个浏览器、也方便使用沙盒模型隔离插件进程，提高浏览器稳定性。</li><li>GPU进程<br>负责3D绘制和硬件加速</li><li>渲染进程即 浏览器内核<br>浏览器会为每个窗口分配一个渲染进程、也就是我们常说的浏览器内核，这可以避免单个 page crash 影响整个浏览器。</li></ul><p>其中浏览器渲染进程（多线程）和Web前端密切相关，包含以下线程</p><ul><li>GUI渲染线程<br> GUI 渲染线程负责渲染浏览器页面， 解析HTML元素, DOM Tree,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。</li><li>JS引擎线程<br> Javascript引擎，也可以称为JS内核，主要负责处理 Javascript 脚本程序，例如V8引擎。Javascript 引擎线程理所当然是负责解析 Javascript 脚本，运行代码。</li><li>事件触发线程（和EventLoop密切相关）<br> 当一个事件被触发时该线程会把事件添加到事件队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。</li><li>定时器触发器线程<br> 浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。</li><li>异步HTTP请求线程<br> 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。</li></ul><blockquote><p>GUI渲染线程和JS引擎线程是互斥的，为了防止DOM渲染的不一致性，其中一个线程执行时另一个线程会被挂起。</p></blockquote><p>那么既然 JavaScript 本身被设计为单线程，为何还会有像 WebWorker 这样的多线程 API 呢？我们来看一下 WebWorker 的核心特点就明白了？</p><ul><li>创建 Worker 时， JS 引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</li><li>JS 引擎线程与 worker 线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）</li></ul><h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><p>为了实现js执行时的单线程，js引擎维护一个<strong>执行栈(先进后出)</strong> FILO,(想象下桌子上的一摞书，最上面的先被拿走，最下面的后面才能拿走)(栈数据结构特点)，主线程运行js代码时，会生成执行栈，能处理嵌套的函数，入栈出栈等操作。</p><h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><p>task queue任务队列是不是一个队列? </p><blockquote><p>他是一个set 集合, 因为不是在取任务的时候不是像队列那般先进先出就完了, 而是先把最老的任务获取, 执行, 执行完毕之后才删除.</p></blockquote><p>任务队列中分微任务和宏任务，且都是已经完成的<em>异步操作</em>. 这里要重点说明一下，<em>宏任务并非全是异步任务，主代码块就是属于宏任务的一种!!XHR也是宏任务的一种</em>如果当前的微任务没有执行完成时，是不会执行下一个宏任务的!</p><ul><li><p>宏任务是每次执行栈执行的代码（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）</p></li><li><p>浏览器为了能够使得JS引擎线程与GUI渲染线程有序切换，会在当前宏任务结束之后，下一个宏任务执行开始之前，对页面进行重新渲染（宏任务 &gt; 渲染  &gt; 宏任务 &gt; …）</p></li><li><p>微任务是在当前宏任务执行结束之后立即执行的任务（在当前 宏任务执行之后，UI渲染之前执行的任务）。微任务的响应速度相比setTimeout（下一个宏任务）会更快，因为无需等待UI渲染。</p></li><li><p>当前宏任务执行后，会将在它执行期间产生的所有微任务都执行一遍。</p><h4 id="微任务的产生时机"><a href="#微任务的产生时机" class="headerlink" title="微任务的产生时机"></a>微任务的产生时机</h4><p>主要有两种方式</p><ul><li>MutationObserver 监控某个DOM节点的变化, 绑定回调, 然后通过js来修改这个节点时(包括添加删除部分子节点)即会将回调函数放入微任务队列中</li><li>Promise 当调用Promise.resolve()或Promise.reject()时会产生微任务放入到微任务队列中(分别对应then的第一个和第二个参数, 以及catch)</li></ul></li></ul><ul><li>宏任务中的事件是由<strong>事件触发线程</strong>来维护的</li><li>微任务中的所有任务是由<strong>JS引擎线程</strong>维护的</li></ul><blockquote><p>下一个宏任务必然是在上一个微任务之后才会执行的</p></blockquote><table><thead><tr><th>macroTask宏任务</th><th>浏览器</th><th>node</th></tr></thead><tbody><tr><td>I/O用户交互(点击, 拖动, 触摸,放大缩小)</td><td>✅</td><td>✅</td></tr><tr><td>setTimeout</td><td>✅</td><td>✅</td></tr><tr><td>setImmediate</td><td>X</td><td>✅</td></tr><tr><td>requestAnimationFrame</td><td>✅</td><td>X</td></tr><tr><td>XMLHttpRequest</td><td>✅</td><td>✅</td></tr><tr><td>js脚本执行</td><td>✅</td><td>✅</td></tr></tbody></table><table><thead><tr><th>microTask微任务</th><th>浏览器</th><th>node</th></tr></thead><tbody><tr><td>process.nextTick</td><td>X</td><td>✅</td></tr><tr><td>MutationObserver</td><td>✅</td><td>X</td></tr><tr><td>Promise.then catch finally</td><td>✅</td><td>✅</td></tr></tbody></table><h3 id="js执行机制"><a href="#js执行机制" class="headerlink" title="js执行机制"></a>js执行机制</h3><p><img src= "/img/loading.gif" data-src="/images/eventLoop.png" alt="事件循环"></p><h4 id="大概过程"><a href="#大概过程" class="headerlink" title="大概过程:"></a>大概过程:</h4><ul><li><p>任务进入执行栈,js代码分同步任务和异步任务</p></li><li><p>所有同步任务都在<em>主线程</em>执行。所有异步任务进入 <em>EventTable(事件表)</em>，执行异步任务，当事件表中的异步任务执行完成之后，会在<em>事件队列(event queue)</em>中注册回调函数(函数移入event Queue)</p></li><li><p>主线程里的同步任务全部完成之后，会读取事件队列(event Queue)中的异步任务,进入主线程执行</p></li><li><p>js解析器会不断重复检查主线程执行栈是否为空，然后重复第三步，即<em>Event Loop(事件循环)</em></p><blockquote><p>js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空</p></blockquote><blockquote><p>在事件循环中，每进行一次循环操作称为tick</p></blockquote></li></ul><h4 id="JS引擎线程和事件触发线程"><a href="#JS引擎线程和事件触发线程" class="headerlink" title="JS引擎线程和事件触发线程"></a>JS引擎线程和事件触发线程</h4><p>浏览器页面初次渲染完毕后，JS引擎线程结合事件触发线程的工作流程如下：<br>（1）同步任务在JS引擎线程（主线程）上执行，形成执行栈（Execution Context Stack）。<br>（2）主线程之外，事件触发线程管理着一个任务队列（Task Queue）。只要异步任务有了运行结果，就在任务队列之中放置一个事件。<br>（3）执行栈中的同步任务执行完毕，系统就会读取任务队列，如果有异步任务需要执行，将其加到主线程的执行栈并执行相应的异步任务。</p><p><img src= "/img/loading.gif" data-src="/images/macroTask.png" alt="执行过程"></p><h4 id="根据事件循环机制以及宏任务和微任务，重新梳理一下流程"><a href="#根据事件循环机制以及宏任务和微任务，重新梳理一下流程" class="headerlink" title="根据事件循环机制以及宏任务和微任务，重新梳理一下流程"></a>根据事件循环机制以及宏任务和微任务，重新梳理一下流程</h4><ul><li>执行一个宏任务（首次执行的主代码块 script 或者任务队列中的回调函数）</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有任务（依次执行）</li><li>JS引擎线程挂起，GUI线程执行渲染</li><li>GUI线程渲染完毕后挂起，JS引擎线程执行任务队列中的下一个宏任务</li></ul><h3 id="结合Promise实例看看执行机制"><a href="#结合Promise实例看看执行机制" class="headerlink" title="结合Promise实例看看执行机制"></a>结合Promise实例看看执行机制</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = <span class="function"><span class="params">()</span> =&gt;</span> <span class="function">(<span class="params"><span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">            resolve(<span class="number">6</span>);</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">        resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">    p.then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arg);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">first().then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>第一轮 事件循环，先执行宏任务，即主script,即new Promise立即执行，打印3 ，然后执行p这个new Promise,输出7，发现setTimeout,将回调函数放入下一轮宏任务队列中，p的then(then1),放入微任务队列，first的then(then2)放入微任务队列，执行打印4，第一轮tick执行结束<br>现在Event Queue中存在三个任务: 1个宏任务: setTimeout；2个微任务: then1.then2<br>执行微任务，先执行p.then打印1, 在执行first.then打印2</p><p>第一轮 事件循环结束，开始第二轮事件循环，先执行宏任务里面，打印5， resolve(6)不会生效，因为Promise状态一旦改变就不会发生变化,所以最终的打印顺序你都答对了吗</p><p>另外一个题目:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> rand = <span class="built_in">Math</span>.random()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>, rand);</span><br><span class="line">    <span class="keyword">if</span>(rand &gt; <span class="number">0.5</span>) resolve()</span><br><span class="line">    reject(rand)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(executor).then(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success-0'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(executor)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">_</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'success-1'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(executor)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">er</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>, er)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="面试题之-了解v8引擎吗，一段js代码如何执行的-题外"><a href="#面试题之-了解v8引擎吗，一段js代码如何执行的-题外" class="headerlink" title="面试题之 了解v8引擎吗，一段js代码如何执行的(题外)"></a>面试题之 了解v8引擎吗，一段js代码如何执行的(题外)</h3><ul><li>在执行一段代码时，JS 引擎会首先创建一个执行栈，JS引擎会创建一个全局执行上下文，并push到执行栈中, 这个过程JS引擎会为这段代码中所有变量分配内存并赋一个初始值（undefined），在创建完成后，JS引擎会进入执行阶段，这个过程JS引擎会逐行的执行代码，即为之前分配好内存的变量逐个赋值(真实值)。</li><li>如果这段代码中存在function的声明和调用，那么JS引擎会创建一个函数执行上下文，并push到执行栈中，其创建和执行过程跟全局执行上下文一样。但有特殊情况，即当函数中存在对其它函数的调用时，JS引擎会在父函数执行的过程中，将子函数的全局执行上下文push到执行栈，这也是为什么子函数能够访问到父函数内所声明的变量。<br>还有一种特殊情况是，在子函数执行的过程中，父函数已经return了，这种情况下，JS引擎会将父函数的上下文从执行栈中移除，与此同时，JS引擎会为还在执行的子函数上下文创建一个闭包，这个闭包里保存了父函数内声明的变量及其赋值，子函数仍然能够在其上下文中访问并使用这边变量/常量。当子函数执行完毕，JS引擎才会将子函数的上下文及闭包一并从执行栈中移除。</li><li>last JS引擎是单线程的，那么它是如何处理高并发的呢？即当代码中存在异步调用时JS是如何执行的。比如setTimeout或fetch请求都是non-blocking的，当异步调用代码触发时，JS引擎会将需要异步执行的代码移出调用栈，直到等待到返回结果，JS引擎会立即将与之对应的回调函数push进任务队列中等待被调用，当调用(执行)栈中已经没有需要被执行的代码时，JS引擎会立刻将任务队列中的回调函数逐个push进调用栈并执行。这个过程我们也称之为事件循环。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>浏览器（多进程）包含了GPU进程（浏览器渲染进程），其中GPU进程（多线程）包含一下几个线程<br>  1.GUI渲染线程<br>  2.JS引擎线程<br>  3.事件触发线程（和EventLoop密切相关）<br>  4.定时触发器线程<br>  5.异步HTTP请求线程</li><li>javascript是一门单线程语言</li><li>Event Loop是javascript的执行机制</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.cn/post/6844903561164242952" target="_blank" rel="noopener">深入理解JavaScript执行（单线程的JS）</a></li><li><a href="https://juejin.cn/post/6844903667301089288" target="_blank" rel="noopener">图解JS执行机制</a></li><li><a href="https://juejin.cn/post/6844903512845860872" target="_blank" rel="noopener">这一次，彻底弄懂 JavaScript 执行机制</a></li><li><a href="https://juejin.cn/post/6844903843197616136" target="_blank" rel="noopener">你真的理解$nextTick么</a></li><li><a href="https://mp.weixin.qq.com/s/bkSmKYGHk0V5eZIfuSTNyQ" target="_blank" rel="noopener">浏览器是如何调度进程和线程的？</a></li><li><a href="https://juejin.cn/post/6844904115537969165" target="_blank" rel="noopener">任务队列,宏任务与微任务</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> 单线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
            <tag> 执行机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: promise-2</title>
      <link href="/2020/12/26/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-promise-2/"/>
      <url>/2020/12/26/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-promise-2/</url>
      
        <content type="html"><![CDATA[<p>先通过刷题熟悉下Promise的基本用法</p><h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="function"><span class="params">()</span> =&gt;</span> <span class="function">(<span class="params"><span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">            resolve(<span class="number">6</span>);</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">        resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">    p.then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arg);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;));</span><br><span class="line">first().then(<span class="function">(<span class="params">arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  3 7 4 1 2 5</span></span><br></pre></td></tr></table></figure><h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'once'</span>)</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="built_in">Date</span>.now() - start)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res, <span class="built_in">Date</span>.now() - start)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// once</span></span><br><span class="line"><span class="comment">// success 1001</span></span><br><span class="line"><span class="comment">// success 1001</span></span><br></pre></td></tr></table></figure><h3 id="03"><a href="#03" class="headerlink" title="03"></a>03</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then: '</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'catch: '</span>, err)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// then Error: error!!!</span></span><br><span class="line">  <span class="comment">// at &lt;anonymous&gt;</span></span><br></pre></td></tr></table></figure><p>.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获，需要改成其中一种：</p><ul><li>return Promise.reject(new Error(‘error!!!’))</li><li>throw new Error(‘error!!!’)</li></ul><p>因为返回任意一个<em>非 promise</em> 的值都会被包裹成 promise 对象，即 return new Error(‘error!!!’) 等价于 <strong>return Promise.resolve(new Error(‘error!!!’))</strong>。</p><h3 id="04"><a href="#04" class="headerlink" title="04"></a>04</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> <span class="title">success</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> <span class="title">fail1</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'fail1: '</span>, e)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> <span class="title">fail2</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'fail2: '</span>, e)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//  fail2:  Error: error</span></span><br><span class="line">  <span class="comment">//  at success (&lt;anonymous&gt;:3:11)</span></span><br></pre></td></tr></table></figure><h3 id="05"><a href="#05" class="headerlink" title="05"></a>05</h3><p>请实现一个mergePromise函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组data中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timeout = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;, ms);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax1 = <span class="function"><span class="params">()</span> =&gt;</span> timeout(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax2 = <span class="function"><span class="params">()</span> =&gt;</span> timeout(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax3 = <span class="function"><span class="params">()</span> =&gt;</span> timeout(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mergePromise = <span class="function"><span class="params">ajaxArray</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里实现你的代码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mergePromise([ajax1, ajax2, ajax3]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// data 为 [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> promise </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的2020年度总结</title>
      <link href="/2020/12/20/%E6%88%91%E7%9A%842020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2020/12/20/%E6%88%91%E7%9A%842020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[  <h4 style='color: green;font-style:italic'> 人生最曼妙的风景，是内心的淡定和从容</h4><pre><code>2020年一眨眼的功夫就没了，越来越觉得时间的重要性。人都是被逼出来的，我发现自己做事越来越专注，这是一种很好的趋势，希望自己能保持出。刚过去的2020年，是值得永远铭记的一年，两位至亲突然离世让我一时难以接受现实，总以为时间还很长很长。病魔说来就来，人在这方面太过于渺小，毫无还手之力，难以改变命运。每个人都有走到终点的那一天，我只希望自己在行将就木的时候，能坦然面对。2021年给自己提出的小目标就是身体健康永远是摆在第一位的，活一天就要健健康康一天。</code></pre><h2 id="工作和学习"><a href="#工作和学习" class="headerlink" title="工作和学习"></a>工作和学习</h2><p>  有一种感觉，到了2020年才感觉自己真正走进前端。以前总觉得很难理解的名词术语，现在慢慢开始理解了，刚开始第一遍不理解，过俩月，第二遍就理解加深一点，第三遍再去看的时候，是不是更加融会贯通一点，所以2021年给自己的目标是重学前端，从最基础的js/es6/css学起，到前端框架vue源码学习，前端工程化，如果有精力，nodejs这块，部署一个网站也是要学会和理解的。<br>  不能再像以前一样，埋头苦干业务，干五年和干一年都一个样，很没有意义。要着眼于未来，所以，哪怕是在忙，也要抽时间学习。学什么呢，什么不会就学什么，直到深刻领悟的地步。<br>  之前看过一篇文章，说程序员如何阅读源码，我觉得说得很有道理，原文是这么说的<br>    - 领悟思想：只需体会作者设计框架的初衷和目的<br>    - 把握设计：只需体会代码的接口和抽象类以及宏观的设计<br>    - 体会细节：是基于顶层的抽象接口设计，逐渐展开代码的画卷<br>  很有指导意义，希望能按照这几点，好好品读 vue/webpack/axios等生态相关库框架源码，并通过文字记录下来。内心其实是很想进大厂看看，不想老了后悔，但无奈不是科班出身，加上这两年的岁月蹉跎，结果就是(苦笑)！最近这几个月，好好苦读和学习吧。每天学习一点点，哪怕是一点点，坚持几个月也是不错的收获，真希望自己能厚积薄发一次</p><p>  今年开始学习前端基础知识，写了几篇入门的文章，但总感觉有些东西还是不能立马说出来</p><ul><li>Class 和 继承</li><li>手写代码系列(这部分现在让我说我感觉自己又忘了，不能深刻理解这很头疼啊)</li><li>Webpack初始化项目</li><li>Vscode插件学习</li><li>自己的脚手架搭建cpp-cli-test</li><li>设计模式之装饰器学习</li></ul><p>我发现自己还是比较喜欢前端<em>工程化</em>，所以有时间就好好研究一下吧.前几天看了一篇文章，说的是大龄海龟硕士求职前端故事，<a href="https://mp.weixin.qq.com/s/G0c3gGAvM8YQXCD4EiwLlg" target="_blank" rel="noopener">面试一位硕士海龟前端小姐姐有感</a>,其中的辛酸感觉就像发生在自己身上，况且我还没有人家这么高的学历，更应该提升技术深度。但什么技术深度呢？看源码吗？有点找不到答案，说不上什么感觉</p><h2 id="生活和书法"><a href="#生活和书法" class="headerlink" title="生活和书法"></a>生活和书法</h2><p>  生活不止有代码还有书法和健身，希望自己能够在坚持住自己的爱好，好好领悟生活的真谛</p><h2 id="理财和基金"><a href="#理财和基金" class="headerlink" title="理财和基金"></a>理财和基金</h2><p>  现在的职业不可能一直干下去，顶多也就还有五年的光阴，考虑后续的工作很有必要，除了现在的程序员，自己还能做什么？又是苦笑不得，确实目前还找不到答案。2021年，希望自己能学习一下理财方面的知识，虽然也没多少财阔以理的，技多不压身，学习到了总比没有强。</p><h2 id="后续安排"><a href="#后续安排" class="headerlink" title="后续安排"></a>后续安排</h2><p>  js基础永远不会过时，犹如内功，不管学什么招数都是手到擒来</p><ul><li><p>事件循环</p></li><li><p>promise/generator/async await(promise最难实现的是哪个点)</p></li><li><p>ts 泛型 装饰器</p></li><li><p>webpack plugin loader</p></li><li><p>nodejs </p></li><li><p>vue</p></li><li><p>算法</p></li><li><p>渲染器原理</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2></li><li><p><a href="http://www.ruanyifeng.com/blog/2015/04/generator.html" target="_blank" rel="noopener">Generator 函数的含义与用法</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 前端 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 前端 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端之装饰者模式以及装饰器</title>
      <link href="/2020/12/13/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2020/12/13/%E5%89%8D%E7%AB%AF%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-src="/images/Decorator2.jpeg" alt="Decorator"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>给对象动态增加职责的方式称为装饰者模式。该模式能够在不改变对象自身的基础上，在程序运行期间给对象动态增加指责</p><h3 id="装饰函数"><a href="#装饰函数" class="headerlink" title="装饰函数"></a>装饰函数</h3><p>想要为函数增加额外功能，最简单粗暴的方式直接改写函数，但这很不友好，违反封闭-开放原则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="number">1</span>)&#125;</span><br><span class="line"><span class="comment">// 改成</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  alert(<span class="number">1</span>);</span><br><span class="line">  alert(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br></pre></td></tr></table></figure><p>在不改变函数源代码的方式能给函数增加功能，这正是开放-封闭原则。通过保存原引用的方式改写函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;alert(<span class="number">1</span>)&#125;</span><br><span class="line"><span class="keyword">var</span> _a = a</span><br><span class="line">a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  _a()</span><br><span class="line">  alert(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br></pre></td></tr></table></figure><h3 id="编写装饰器"><a href="#编写装饰器" class="headerlink" title="编写装饰器"></a>编写装饰器</h3><p>class decorator 类装饰器<br>method decorator 方法装饰器<br>property decorator 属性装饰器<br>parameter decorator 参数装饰器</p><p>装饰器是一种特殊类型的声明，它能够被附加到<em>类声明，方法， 访问符，属性或参数</em>上。 装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。</p><h4 id="装饰器工厂"><a href="#装饰器工厂" class="headerlink" title="装饰器工厂"></a>装饰器工厂</h4><p>如果我们要定制一个修饰器如何应用到一个声明上，我们得写一个装饰器工厂函数。 装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thinFace</span>(<span class="params">name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, <span class="string">'开启瘦脸'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"thinFace(): called"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increaseEye</span>(<span class="params">name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, <span class="string">'增大眼睛'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target: <span class="built_in">string</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"increaseEye(): called"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@thinFace</span>(<span class="string">'cpp'</span>)</span><br><span class="line"><span class="meta">@increaseEye</span>(<span class="string">'niaogege'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Girl &#123;&#125;</span><br><span class="line"><span class="comment">// 打印参数</span></span><br><span class="line"></span><br><span class="line">cpp 开启瘦脸</span><br><span class="line">niaogege 增大眼睛</span><br><span class="line">increaseEye(): called</span><br><span class="line">thinFace(): called</span><br></pre></td></tr></table></figure><p>在TypeScript里，当多个装饰器应用在一个声明上时会进行如下步骤的操作：</p><ul><li>由上至下依次对装饰器表达式求值。</li><li>求值的结果会被当作函数，由下至上依次调用(装饰器函数)。</li></ul><h4 id="类装饰器-class-decorator-类装饰器"><a href="#类装饰器-class-decorator-类装饰器" class="headerlink" title="类装饰器 class decorator 类装饰器"></a>类装饰器 class decorator 类装饰器</h4><p>类装饰器在类声明之前被声明（紧靠着类声明）。 类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。即在执行装饰器函数时，会把类构造函数传递给装饰器函数。<br>如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thinFace</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  onsole.log(<span class="string">'thinFace Before'</span>, <span class="keyword">constructor</span>); <span class="comment">// 把Girl类构造函数传递给装饰器函数</span></span><br><span class="line">  <span class="keyword">constructor</span>.prototype.thinFaceF = function (<span class="params">params: <span class="built_in">any</span></span>) &#123; <span class="comment">// 给构造函数原型上增加新的方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'become thinFace'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classDecorator</span>(<span class="params">value: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'类的装饰器 Before'</span>, value);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'接受一个构造函数'</span>, value); <span class="comment">// 如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@thinFace</span></span><br><span class="line"><span class="meta">@classDecorator</span>(<span class="string">'cpp'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Girl &#123;</span><br><span class="line">  <span class="keyword">private</span> greeting: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">msg: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = msg</span><br><span class="line">  &#125;</span><br><span class="line">  greetName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello!, <span class="subst">$&#123;<span class="keyword">this</span>.greeting&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">  thinFaceF() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Grid 类里的函数'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> Girl(<span class="string">'wmh'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Girl类的实例'</span>, g);</span><br><span class="line">g.thinFaceF();</span><br><span class="line"><span class="comment">// 类的装饰器 Before</span></span><br><span class="line"><span class="comment">// 接受一个构造函数 cpp</span></span><br><span class="line"><span class="comment">// thinFace Before class Girl</span></span><br><span class="line"><span class="comment">// become thinFace</span></span><br></pre></td></tr></table></figure><h3 id="ts项目的运用"><a href="#ts项目的运用" class="headerlink" title="ts项目的运用"></a>ts项目的运用</h3><ul><li><a href="https://www.tslang.cn/docs/handbook/decorators.html" target="_blank" rel="noopener">装饰器</a></li></ul><h3 id="Ts项目中的’vue-property-decorator’拆解"><a href="#Ts项目中的’vue-property-decorator’拆解" class="headerlink" title="Ts项目中的’vue-property-decorator’拆解"></a>Ts项目中的’vue-property-decorator’拆解</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h3 id="ts报错信息"><a href="#ts报错信息" class="headerlink" title="ts报错信息"></a>ts报错信息</h3><ul><li><p>Unable to resolve signature of class decorator when called as an expression.<br>This expression is not callable.<br>  Type ‘void’ has no call signatures.</p></li><li><p>signature 签名</p></li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.tslang.cn/docs/handbook/decorators.html" target="_blank" rel="noopener">ts中的装饰器</a></li><li><a href="https://zhuanlan.zhihu.com/p/271226380" target="_blank" rel="noopener">设计模式大冒险第二关：装饰者模式，煎饼果子的主场</a></li><li><a href="https://segmentfault.com/a/1190000022415199" target="_blank" rel="noopener">装饰者模式和TypeScript装饰器</a></li><li><a href="https://juejin.cn/post/6895350355219972109" target="_blank" rel="noopener">从Typescript装饰器浅谈装饰者模式</a></li><li><a href="https://www.softwhy.com/article-9203-1.html" target="_blank" rel="noopener">Object.seal &amp; Object.freeze</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> Decorator </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> Decorator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node包里的package.json文件</title>
      <link href="/2020/12/13/node%E5%8C%85%E9%87%8C%E7%9A%84package-json%E6%96%87%E4%BB%B6/"/>
      <url>/2020/12/13/node%E5%8C%85%E9%87%8C%E7%9A%84package-json%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>敲了两年业务代码，从来不会去留意node包里的配置，一般业务用到哪个包就去直接<em>npm i XX -D</em>, 也不会去想这包里都有啥，这样浑浑噩噩过了好长时间。其实这样很不好，就是一个单纯的切图仔，我可不想一直这样，所以最近就开始捣鼓node包，开始看的时候 对 <em>package.json</em> 里的配置项不是很熟悉，现阶段就是看一点理解了就记录一点。<br>先看下目前node包里的<em>package.json</em>文件配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"webpack-learn"</span>, <span class="comment">// 包名 一般采用中划线或者下划线，不建议采用小驼峰的形式命名</span></span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>, <span class="comment">// 版本</span></span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"vue webpack"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"dist/main.js"</span>,</span><br><span class="line">  <span class="attr">"module"</span>: <span class="string">"dist/main.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"webpack-dev-server --progress --config build/webpack.config.dev.js --inline --hot"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --progress --config build/webpack.config.prod.js"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [</span><br><span class="line">    <span class="string">"webpack init project"</span>,</span><br><span class="line">    <span class="string">"webpack"</span>,</span><br><span class="line">    <span class="string">"init Project"</span>,</span><br><span class="line">    <span class="string">"vue"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"engines"</span>: &#123;</span><br><span class="line">    <span class="attr">"node"</span>: <span class="string">"&gt;= 6"</span> <span class="comment">// node环境要求</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"cpp"</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"homepage"</span>: <span class="string">"https://github.com/niaogege/webpack-learn"</span>, <span class="comment">// 项目介绍主页</span></span><br><span class="line">  <span class="attr">"repository"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"git"</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"https://github.com/niaogege/webpack-learn.git"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"files"</span>: [</span><br><span class="line">    <span class="string">"dist"</span>,</span><br><span class="line">    <span class="string">"src"</span>,</span><br><span class="line">    <span class="string">"public"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"vue"</span>: <span class="string">"^2.6.12"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"babel-core"</span>: <span class="string">"^6.26.3"</span>,</span><br><span class="line">    <span class="attr">"babel-loader"</span>: <span class="string">"^8.2.2"</span>,</span><br><span class="line">    <span class="attr">"clean-webpack-plugin"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main-module"><a href="#main-module" class="headerlink" title="main / module"></a>main / module</h3><p><em>Main property in package.json defines package entry point 定义包的出口</em><br>简单说: 供项目用import导入的入口，主要作用是暴露此依赖包的出口，比如vue源码里的package.json中这么定义的</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">"main": "dist/vue.runtime.common.js", // 运行时用的common版本</span><br><span class="line">"module": "dist/vue.runtime.esm.js", // 运行用的es版本</span><br></pre></td></tr></table></figure><p>如果不定义main，项目中运用依赖包需要这样引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin.js'</span>);</span><br></pre></td></tr></table></figure><p>看了下vue-loader中该文件的出口定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">let</span> VueLoaderPlugin = <span class="literal">null</span></span><br><span class="line"><span class="keyword">if</span> (webpack.version &amp;&amp; webpack.version[<span class="number">0</span>] &gt; <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="comment">// webpack5 and upper</span></span><br><span class="line">  VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'./plugin-webpack5'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// webpack4 and lower</span></span><br><span class="line">  VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'./plugin-webpack4'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = VueLoaderPlugin</span><br></pre></td></tr></table></figure><h3 id="devDependencies-dependencies"><a href="#devDependencies-dependencies" class="headerlink" title="devDependencies / dependencies"></a>devDependencies / dependencies</h3><p>运行 <em>–save-dev</em> 或者 -D 安装的 插件，被写入到 <em>devDependencies</em> 域里面去，而使用 <em>–save</em> 或者 -S 安装的插件，则是被写入到 <em>dependencies</em> 区块里面去.<br>npm install 【插件名】或 npm install 【插件名】–save 归属dependencies，表示代码运行时所需要的包。</p><p>npm install 【插件名】–save-dev 归属 devDependencies，表示开发时依赖的插件（即不会打包至线上）。</p><p>dependencies, 生产环境依赖，也就是依赖会被打包到web就用中<br>devDependencies, 开发环境依赖，不会被打包，是保证web就用能运行起来的根本。</p><p>区别: </p><p>假设我是一名npm包的开发者，那么我发布的包的package.json就需要认真分好所依赖的包到底是dependencies还是devDependencies。因为我发布的包是给别人使用的，别人不会去管你是用什么环境开发的，别人要的是最终开发出来的源码。所以，当别人npm命令去安装时：</p><p><code>npm install xxx -D</code></p><p>只会把xxx里的dependencies的包下载下来，而不会去下载devDependencies里面的包。所以在发布npm包的时候，dependencies和devDependencies一定要严格区分开来!!</p><h3 id="files"><a href="#files" class="headerlink" title="files"></a>files</h3><p>这个就好理解，下载的依赖包里包含的文件名数组，像我在cpp-cli-test这个npm包里的files就是<br><code>files: [    &quot;dist&quot;,    &quot;src&quot;,    &quot;public&quot;]</code><br>因为我不想把npm包里的node_modules文件也上传，所以这里就只包含了三个文件夹</p><h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p>本人开发的脚手架会用到bin字段, 包的命令，比如<em>cpp -V</em>,</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"main": "./bin/index.js",</span><br><span class="line">"bin": &#123;</span><br><span class="line">  "cpp": "./bin/index.js" // 全局注册cpp命令</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><ul><li>废弃版本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm deprecate &lt;pkg-name&gt;[@&lt;version&gt;] &lt;message&gt;</span><br><span class="line">示例</span><br><span class="line">npm deprecate cpp-cli-test@&quot; &lt;1.0.1&quot; &quot;sorry 这个包已经被废弃了&quot;</span><br></pre></td></tr></table></figure></li><li>包的维护者和添加维护者<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm owner ls cpp-cli-test</span><br><span class="line"></span><br><span class="line">npm owner add 用户名字 包名</span><br></pre></td></tr></table></figure></li><li>打开一个模块的主页<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm home 包名</span><br></pre></td></tr></table></figure></li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><p><a href="https://bytearcher.com/articles/main-property-in-package.json-defines-entry-point/" target="_blank" rel="noopener">Main property in package.json defines package entry point</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/59601665" target="_blank" rel="noopener">package.json中的dependencies和devDependencies区别</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/z9hyaOf85DFMweBmtm1YRA" target="_blank" rel="noopener">发布NPM包</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
          <category> package.json </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> package.json </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>辅助开发工具和调试</title>
      <link href="/2020/12/12/%E8%BE%85%E5%8A%A9%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%92%8C%E8%B0%83%E8%AF%95/"/>
      <url>/2020/12/12/%E8%BE%85%E5%8A%A9%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%92%8C%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="安装-sourceTree"><a href="#安装-sourceTree" class="headerlink" title="安装 sourceTree"></a>安装 sourceTree</h3><ul><li><p>打开企业版<a href="https://www.sourcetreeapp.com/enterprise" target="_blank" rel="noopener">链接</a>,先下载，然后找到<em>C:\Program Files (x86)\Atlassian\Sourcetree</em>目录安装</p></li><li><p>在查询文件里输入 <em>%LocalAppData%\Atlassian\SourceTree\accounts.json</em>，编辑成以下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"$id"</span>: <span class="string">"1"</span>,</span><br><span class="line">    <span class="attr">"$type"</span>: <span class="string">"SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity"</span>,</span><br><span class="line">    <span class="attr">"Authenticate"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"HostInstance"</span>: &#123;</span><br><span class="line">      <span class="attr">"$id"</span>: <span class="string">"2"</span>,</span><br><span class="line">      <span class="attr">"$type"</span>: <span class="string">"SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount"</span>,</span><br><span class="line">      <span class="attr">"Host"</span>: &#123;</span><br><span class="line">        <span class="attr">"$id"</span>: <span class="string">"3"</span>,</span><br><span class="line">        <span class="attr">"$type"</span>: <span class="string">"SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount"</span>,</span><br><span class="line">        <span class="attr">"Id"</span>: <span class="string">"atlassian account"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"BaseUrl"</span>: <span class="string">"https://id.atlassian.com/"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"Credentials"</span>: &#123;</span><br><span class="line">      <span class="attr">"$id"</span>: <span class="string">"4"</span>,</span><br><span class="line">      <span class="attr">"$type"</span>: <span class="string">"SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account"</span>,</span><br><span class="line">      <span class="attr">"Username"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"Email"</span>: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"IsDefault"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>工具 -&gt; 选项 -&gt; 选择 <em>Dark</em> 主题</p></li></ul><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>如若遇到ssh-key已经生效 但每次git push的时候还需要登录github弹框，这时候受到删除 <strong>C:\Users%USERNAME%\AppData\Local\Atlassian\SourceTree 目录下的passwd文件</strong>,然后再通过命令行推送，第一次的时候还是需要手动push</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/qq_36735629/article/details/86422488" target="_blank" rel="noopener">企业版sourcetree</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> sourceTree </category>
          
          <category> git </category>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
            <tag> sourceTree </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶-vue-2</title>
      <link href="/2020/12/12/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-vue-2/"/>
      <url>/2020/12/12/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-vue-2/</url>
      
        <content type="html"><![CDATA[<ul><li>封装自己的vue组件</li><li></li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.cn/post/6844903636938522638" target="_blank" rel="noopener">vue中extend，mixins，extends，components,install的几个操作</a></li><li><a href="https://juejin.cn/post/6844904181443067912" target="_blank" rel="noopener">学习vue源码（5） 手写Vue.use、Vue.minxin、Vue.compile</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> vue </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶-大杂烩-1</title>
      <link href="/2020/12/05/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E5%A4%A7%E6%9D%82%E7%83%A9-1/"/>
      <url>/2020/12/05/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E5%A4%A7%E6%9D%82%E7%83%A9-1/</url>
      
        <content type="html"><![CDATA[<p>本周涉及内容</p><ul><li>vue 插槽</li><li>函数柯里化</li><li>装饰者模式 &amp;&amp; 装饰器</li><li>函数式编程 &amp;&amp; 命令式编程</li><li>proxy</li><li>css加速</li><li>cdn缓存</li></ul><h3 id="vue插槽slot"><a href="#vue插槽slot" class="headerlink" title="vue插槽slot"></a>vue插槽slot</h3><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><ul><li>函数参数固定<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry2 = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">judge</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length === fn.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn(...args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> judge(...args, ...arg)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> add2 = <span class="function">(<span class="params">a,b,c</span>) =&gt;</span> a + b + c;</span><br><span class="line"><span class="keyword">const</span> curryAdd2 = curry2(add2)</span><br><span class="line"><span class="built_in">console</span>.log(curryAdd2(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(curryAdd2(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(curryAdd2(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)) <span class="comment">// curryAdd2(...)(...) is not a function</span></span><br></pre></td></tr></table></figure></li><li>参数不固定<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> addFn = <span class="function">(<span class="params">...arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr, <span class="string">'arr'</span>, <span class="built_in">Object</span>.prototype.toString.call(arr));</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a +b )</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = []</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">temp</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length) &#123;</span><br><span class="line">      arr = [...arr, ...args]</span><br><span class="line">      <span class="keyword">return</span> temp</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`arr`</span>, arr);</span><br><span class="line">      <span class="keyword">const</span> val = fn.apply(<span class="keyword">this</span>, arr)</span><br><span class="line">      arr = []</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> curryAdd = curry(addFn)</span><br><span class="line"><span class="keyword">const</span> test1 = curryAdd(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)()</span><br><span class="line"><span class="keyword">const</span> test2 = curryAdd(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)()</span><br><span class="line"><span class="keyword">const</span> test3 = curryAdd(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)(<span class="number">5</span>, <span class="number">6</span>)()</span><br><span class="line"><span class="built_in">console</span>.log(test1) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(test2) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(test3); <span class="comment">// 21</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="装饰者模式-amp-amp-装饰器-Decorator"><a href="#装饰者模式-amp-amp-装饰器-Decorator" class="headerlink" title="装饰者模式 &amp;&amp; 装饰器(Decorator)"></a>装饰者模式 &amp;&amp; 装饰器(Decorator)</h3>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> vue </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> vue </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 在学es6之class</title>
      <link href="/2020/11/15/%E5%9F%BA%E7%A1%80-%E5%9C%A8%E5%AD%A6es6%E4%B9%8Bclass/"/>
      <url>/2020/11/15/%E5%9F%BA%E7%A1%80-%E5%9C%A8%E5%AD%A6es6%E4%B9%8Bclass/</url>
      
        <content type="html"><![CDATA[<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>class是一个语法糖，其底层还是通过 构造函数 去创建的。新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><h4 id="es5实现"><a href="#es5实现" class="headerlink" title="es5实现"></a>es5实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h4 id="es6实现"><a href="#es6实现" class="headerlink" title="es6实现"></a>es6实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125; </span><br><span class="line">  toString () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>上面代码定义了一个“类”，可以看到里面有一个<strong>constructor</strong>方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5 的构造函数Point，对应 ES6 的Point类的构造方法。</p><h4 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h4><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> A()) <span class="keyword">instanceof</span> A);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h4><ul><li>生成类的实例的写法，与 ES5 完全一样，也是使用 new 命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。</li><li>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在<em>this</em>对象上），否则都是定义在原型上(即定义在<em>class</em>类上)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CppPerson</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(&#123;name, age, fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.showFn = fn</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="keyword">this</span>.name</span><br><span class="line">    <span class="keyword">return</span> name.charAt(<span class="number">0</span>).toUpperCase() + name.slice(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> CppPerson(&#123;</span><br><span class="line">  name: <span class="string">'cpp'</span>,</span><br><span class="line">  age: <span class="string">'30'</span>,</span><br><span class="line">  fn: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is fn'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">person.getName() </span><br><span class="line">person.showFn()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'person'</span>, person);</span><br><span class="line">person.hasOwnProperty(<span class="string">'name'</span>) <span class="comment">// true</span></span><br><span class="line">person.hasOwnProperty(<span class="string">'age'</span>) <span class="comment">// true</span></span><br><span class="line">person.hasOwnProperty(<span class="string">'getName'</span>) <span class="comment">// false</span></span><br><span class="line">person.__proto__.hasOwnProperty(<span class="string">'getName'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>与 ES5 一样，类的所有实例共享一个原型对象。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Foo.classMethod() <span class="comment">// 'hello'</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()<span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure><h3 id="实例属性的新写法"><a href="#实例属性的新写法" class="headerlink" title="实例属性的新写法"></a>实例属性的新写法</h3><p>实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncreasingCounter</span> </span>&#123;</span><br><span class="line">  _count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">get</span> value() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Getting the current value!'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._count;</span><br><span class="line">  &#125;</span><br><span class="line">  increment() &#123;</span><br><span class="line">    <span class="keyword">this</span>._count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>突然联想到目前的业务项目，做了2年才发现也是这样的写法，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> item: <span class="built_in">number</span> = <span class="number">0</span> <span class="comment">// 快捷导航选中index</span></span><br><span class="line"><span class="keyword">private</span> url: <span class="built_in">any</span> = &#123;&#125;; <span class="comment">// 默认url赋值</span></span><br></pre></td></tr></table></figure><p>上面代码中，实例属性item与原型上的方法，处于同一个层级。这时，不需要在实例属性前面加上this。<br>这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。<br>原本应该是这样写的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">class</span> VueGrid <span class="keyword">extends</span> Vue &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.item = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.url = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line">Foo.prop <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面的写法为Foo类定义了一个静态属性prop。</p><p>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个提案提供了类的静态属性，写法是在实例属性的前面，加上static关键字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> myStaticProp = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(MyClass.myStaticProp); <span class="comment">// 42</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个新写法大大方便了静态属性的表达。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> prop = <span class="number">1</span>; <span class="comment">// 新写法是显式声明（declarative），而不是赋值处理，语义更好。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="extends继承"><a href="#extends继承" class="headerlink" title="extends继承"></a>extends继承</h3><p>Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。<br>这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。</p><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>在 super() 执行时，它指向的是 子类 B 的构造函数，而不是父类 A 的构造函数。也就是说，super() 内部的 this 指向的是 B<br><em>super()<em>相当于</em>Parent.prototype.constructor.call(this. props)</em><br>super本身是指向父类的构造函数但做函数调用后返回的是子类的实例，实际上做了<em>parent.prototype.constructor.call(this)</em>，做对象调用时指向父类 parent.prototype,从而实现继承</p><p>super这个关键字，既可以当作函数 Function 使用，也可以当作对象 Object 使用。在这两种情况下，它的用法完全不同。</p><h4 id="作函数-Function-使用"><a href="#作函数-Function-使用" class="headerlink" title="作函数 Function 使用"></a>作函数 Function 使用</h4><p>代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> A() <span class="comment">// A</span></span><br><span class="line"><span class="keyword">new</span> B() <span class="comment">// B</span></span><br></pre></td></tr></table></figure><p>虽然代表父类的构造函数，但是返回的是子类的实例，即super内部的this指的是B的实例，因此super()在这里相当于A.prototype.constructor.call(this)。</p><blockquote><p>有点绕！！！</p></blockquote><h4 id="当作对象-Object-使用"><a href="#当作对象-Object-使用" class="headerlink" title="当作对象 Object 使用"></a>当作对象 Object 使用</h4><p>super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  p() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.p()); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure><p>子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。注意是A类原型对象上的方法。<br>这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    name() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'cpp'</span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果属性定义在父类的原型对象上，super就可以取到。</span></span><br><span class="line">Test.prototype.age = <span class="number">29</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">super</span>.name())</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">super</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Test1()) <span class="comment">// 'cpp' 29</span></span><br></pre></td></tr></table></figure><p>实例属性和方法: constructor里的，就是绑定的this，比如this.name<br>原型属性和方法: class里除了构造函数以内，其他的方法就是原型方法，原型属性需要用到Test.prototype来定义<br>静态属性和方法: static关键字标识，只能类本身调用，类的实例不能调用<br>私有属性和方法: ts里的private关键字</p><h4 id="ES6-规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例"><a href="#ES6-规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例" class="headerlink" title="ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例"></a>ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  m() &#123;</span><br><span class="line">    <span class="keyword">super</span>.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.m() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。"><a href="#如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。" class="headerlink" title="如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。"></a>如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> myMethod(msg) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'static'</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'instance'</span>, msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> myMethod(msg) &#123;</span><br><span class="line">    <span class="keyword">super</span>.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  myMethod(msg) &#123;</span><br><span class="line">    <span class="keyword">super</span>.myMethod(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.myMethod(<span class="number">1</span>); <span class="comment">// static 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child();</span><br><span class="line">child.myMethod(<span class="number">2</span>); <span class="comment">// instance 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p><h3 id="ES5-和-ES6继承区别"><a href="#ES5-和-ES6继承区别" class="headerlink" title="ES5 和 ES6继承区别"></a><a href="https://es6.ruanyifeng.com/#docs/class-extends" target="_blank" rel="noopener">ES5 和 ES6继承区别</a></h3><p>ES5 的继承，通过prototype或构造函数机制来实现, 实质是先创造子类的实例对象this，再将父类的方法添加到this上面（Parent.apply(this)）。<br>ES6 的继承机制完全不同，实质是先创建父类的实例对象this(所以必须先调用父类的super()方法)，然后再用子类的构造函数修改this。</p><p>另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y, color) &#123;</span><br><span class="line">    <span class="keyword">this</span>.color = color; <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="keyword">super</span>(x, y);</span><br><span class="line">    <span class="keyword">this</span>.color = color; <span class="comment">// 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">Class 的基本语法</a></li><li><a href="https://juejin.im/post/6844904086089760775" target="_blank" rel="noopener">详解ES6中的class</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> class </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础-基于webpack搭建vue项目</title>
      <link href="/2020/11/14/%E5%9F%BA%E7%A1%80-webpack%E6%90%AD%E5%BB%BAvue%E9%A1%B9%E7%9B%AE/"/>
      <url>/2020/11/14/%E5%9F%BA%E7%A1%80-webpack%E6%90%AD%E5%BB%BAvue%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>学习如何用webpack搭建项目，成为模板，为后面的脚手架做准备，需要学习的有</p><ul><li>webpack</li><li>node</li><li>学会手写自己的loader</li><li>手写plugin</li><li>webpack的异步加载如何实现</li><li>webpack的分包策略</li></ul><h3 id="什么是webpack？"><a href="#什么是webpack？" class="headerlink" title="什么是webpack？"></a>什么是webpack？</h3><p>官网是这么描述的: </p><blockquote><p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p></blockquote><p>先理解四个核心概念：</p><ul><li>入口(entry)</li><li>输出(output)</li><li>加载器(loader)</li><li>插件(plugins)</li></ul><h3 id="webpack搭建vue项目"><a href="#webpack搭建vue项目" class="headerlink" title="webpack搭建vue项目"></a>webpack搭建vue项目</h3><p>即<a href="https://github.com/niaogege/webpack-learn" target="_blank" rel="noopener">webpack搭建vue</a></p><h4 id="本地项目涉及的webpack版本"><a href="#本地项目涉及的webpack版本" class="headerlink" title="本地项目涉及的webpack版本"></a>本地项目涉及的webpack版本</h4><p>webpack版本众多，有时会被这些琐粹的玩意搞得头晕</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"webpack"</span>: <span class="string">"^4.41.2"</span>,</span><br><span class="line">  <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.9"</span>,</span><br><span class="line">  <span class="attr">"webpack-dev-server"</span>: <span class="string">"^3.9.0"</span>,</span><br><span class="line">  <span class="attr">"webpack-merge"</span>: <span class="string">"^5.4.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="本项目文件结构"><a href="#本项目文件结构" class="headerlink" title="本项目文件结构"></a>本项目文件结构</h4><h4 id="引入babel"><a href="#引入babel" class="headerlink" title="引入babel"></a>引入babel</h4><p><em>npm i -D babel-core babel-loader</em><br>复制代码由于在使用vue时会用到很多es6的语法，但是现在很多浏览器对es6的支持不是很好，所以在编译时需要将这些语法转换es5的语法，此时我们使用babel来进行编译。<br>babel的使用请阅读官网文档<a href="http://babeljs.cn/" target="_blank" rel="noopener">http://babeljs.cn/</a></p><h4 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h4><p>这个插件可以自动为我们生成HTML并插入对应的js和css文件。这样子是很方便的，尤其是当文件名中包含了hash值，而这个hash值在webpack每次编译的时候都会发生改变的。下面我们就逐一来介绍HtmlWebpackPlugin的用法。<br>配置参数:</p><ul><li><p>filename<br>filename表示生成html文件的名字，如果没有设置的话默认为index.html。</p></li><li><p>template<br>　当webpack自动生成html文件的时候，会基于某个模板来进行。当然你也可以自定义自己的模板，如果没有定义webpack会使用默认的模板。但是需要指出的是，当你使用了其他模板类型（比如jade），那么你需要安装对应的loader。默认情况下webpack使用ejs模板。</p></li><li><p>inject<br>inject主要是设置将js和css文件插入在html的哪个位置，由于js的加载时同步进行的，所以它的位置对网页的加载速度是有影响的。inject共有四个可选项：true、body、head和false。</p></li><li><p>true：默认值，将js文件插入body的底部。注意这里是bool类型的true，并不是字符串。设置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">　　inject: <span class="literal">true</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure></li><li><p>body：和true的功能是一样的。需要设置为字符串body。设置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  inject: <span class="string">'body'</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure></li><li><p>head：表示将js文件插入在head标签内，这里是字符串head。</p></li><li><p>false：表示不插入生成的js文件，也不插入css文件。因为其他三个可选项css文件都是插入在head标签内的。</p></li><li><p><a href="https://www.npmjs.com/package/html-webpack-plugin" target="_blank" rel="noopener">htmlWebpackPlugin</a></p></li></ul><h4 id="区分生产环境和本地开发环境"><a href="#区分生产环境和本地开发环境" class="headerlink" title="区分生产环境和本地开发环境"></a>区分生产环境和本地开发环境</h4><p>采用<em><a href="https://www.npmjs.com/package/webpack-merge" target="_blank" rel="noopener">webpck-merge</a></em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;merge&#125; = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    port: <span class="number">3000</span>,</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    contentBase: path.join(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">    overlay: &#123;</span><br><span class="line">      errors: <span class="literal">true</span>,</span><br><span class="line">      warnings: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>此处栽了一个大坑，打印common就是一个包含dev环境的配置对象，因为之前写法有误 导致vue-loader一直报错</p></blockquote><h4 id="本地项目运行"><a href="#本地项目运行" class="headerlink" title="本地项目运行"></a>本地项目运行</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  hot: <span class="literal">true</span>,</span><br><span class="line">  contentBase: path.join(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">  overlay: &#123;</span><br><span class="line">    errors: <span class="literal">true</span>,</span><br><span class="line">    warnings: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>output的 <em>publicPath</em> 是用来给生成的静态资源路径添加前缀的；</li><li>devServer中的 <em>publicPath</em> 是用来本地服务拦截带publicPath开头的请求的；</li><li><em>contentBase</em> 是用来指定被访问html页面所在目录的；</li></ul><h3 id="针对已有项目git初始化"><a href="#针对已有项目git初始化" class="headerlink" title="针对已有项目git初始化"></a>针对已有项目git初始化</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m "first commit"</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/niaogege/XXX.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://ddrv.cn/a/314373" target="_blank" rel="noopener">配置vue+webpack踩过的坑</a></li><li><a href="https://www.webpackjs.com/concepts/" target="_blank" rel="noopener">weboack官网</a></li><li><a href="https://juejin.cn/post/6844903541962702855" target="_blank" rel="noopener">webpack 搭建 vue 项目</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode插件开发和学习</title>
      <link href="/2020/11/08/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%92%8C%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/11/08/vscode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%92%8C%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>vsCode插件实现</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://mp.weixin.qq.com/s/rXL1qU4h7Ugy6o9YjM6PaQ" target="_blank" rel="noopener">手摸手带你从零实现VS Code基金插件</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vscode </category>
          
          <category> node </category>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> vscode </tag>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔: 秋天来了</title>
      <link href="/2020/10/18/%E9%9A%8F%E7%AC%94-%E7%A7%8B%E5%A4%A9%E6%9D%A5%E4%BA%86/"/>
      <url>/2020/10/18/%E9%9A%8F%E7%AC%94-%E7%A7%8B%E5%A4%A9%E6%9D%A5%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h3 id="湖人夺冠"><a href="#湖人夺冠" class="headerlink" title="湖人夺冠"></a>湖人夺冠</h3><p><img src= "/img/loading.gif" data-src="/images/lakes/101202.jpg" alt="lakes champions"></p><!-- ![lakes champions](/images/lakes/101205.jpg) --><p>看到上次更博是0718，一晃，三个月，从盛夏到深秋，难得周末清闲，好久没有静下心来写点东西了(虽然也不知道自己在写啥， hhhh)。<br>最近因为练字发了几条抖音有点着迷这玩意，果断卸载，还是得聚焦现实主要任务，有些东西，随着时间的流逝就很难追回来。最主要的任务是啥呢，说实话，我自己也有点蒙，最近都在忙啥呢，我自己也不知道忙啥。</p><ul><li>看看自己手机里收藏的微信好文，是否自己都仔细阅读过了？是否读完都明白了？明白了是否自己都能在现在的项目中熟练运用？</li><li>今年再不做打算的话，程序员这一站就到头了，还得想想自己的后路。30岁的中年烦恼，提前准备，提前应对，35岁之后，我能做啥？</li><li>自己得学习起来，1.搭建脚手架 2.vscode插件 3.webpack(从0开始配置项目) 4.<a href="https://juejin.im/post/6856410900577026061" target="_blank" rel="noopener">ts使用</a> 5.算法,上面这几块得干起来，少看手机，多思考思考</li><li>基础知识还得继续夯实，主要是继承/Promise</li><li>拉勾教育上也得看起来</li><li>现在所处的项目改造，减少代码的重复</li></ul><p><img src= "/img/loading.gif" data-src="/images/lakes/101204.jpg" alt="lakes champions"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 健康 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue: 常用技巧2</title>
      <link href="/2020/07/18/vue-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A72/"/>
      <url>/2020/07/18/vue-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A72/</url>
      
        <content type="html"><![CDATA[<p><strong>hook</strong>用法<br>源码涉及hook的较多，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function callHook (vm, hook) &#123;</span><br><span class="line">  &#x2F;&#x2F; #7573 disable dep collection when invoking lifecycle hooks</span><br><span class="line">  pushTarget();</span><br><span class="line">  var handlers &#x3D; vm.$options[hook];</span><br><span class="line">  var info &#x3D; hook + &quot; hook&quot;;</span><br><span class="line">  if (handlers) &#123;</span><br><span class="line">    for (var i &#x3D; 0, j &#x3D; handlers.length; i &lt; j; i++) &#123;</span><br><span class="line">      invokeWithErrorHandling(handlers[i], vm, null, vm, info);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (vm._hasHookEvent) &#123;</span><br><span class="line">    vm.$emit(&#39;hook:&#39; + hook);</span><br><span class="line">  &#125;</span><br><span class="line">  popTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="监听组件的生命周期"><a href="#监听组件的生命周期" class="headerlink" title="监听组件的生命周期"></a>监听组件的生命周期</h3><p>Before</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; child.vue</span><br><span class="line">privte mounted() &#123;</span><br><span class="line">  this.$emit(&#39;parentClick&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; parent.vue</span><br><span class="line">&lt;Child @mounted&#x3D;&#39;parentClick&#39;&gt;</span><br></pre></td></tr></table></figure><p>After</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;child.vue</span><br><span class="line">子组件不需要任何处理</span><br><span class="line">&#x2F;&#x2F;parent.vue</span><br><span class="line">&lt;Child @hook:mounted&#x3D;&#39;parentClick&#39;&gt;</span><br><span class="line">or</span><br><span class="line">&lt;Child @hook:created&#x3D;&#39;parentClick&#39;&gt;</span><br></pre></td></tr></table></figure><h3 id="事件侦听器"><a href="#事件侦听器" class="headerlink" title="事件侦听器"></a>事件侦听器</h3><p>问: 页面中定义一个定时器，在哪个阶段清除<br>答: 在beforeDestory中销毁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Before</span><br><span class="line">mounted() &#123;</span><br><span class="line">  this.timer &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">  &#125;, 3000)</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestory() &#123;</span><br><span class="line">  clearInterval(this.timer)</span><br><span class="line">&#125;</span><br><span class="line">After</span><br><span class="line">mounted() &#123;</span><br><span class="line">  const timer &#x3D; setInterval(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">  &#125;, 3000)</span><br><span class="line">  this.$once(&#39;hook:beforeDestory&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    clearInterval(timer)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件销毁"><a href="#事件销毁" class="headerlink" title="事件销毁"></a>事件销毁</h3><p>通过$mounted绑定的第三方实例组件销毁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">  var picker &#x3D; new Picker(&#123;</span><br><span class="line">    field: this.$refs.input,</span><br><span class="line">    format: &#39;YYYY-MM-DD&#39;</span><br><span class="line">  &#125;)</span><br><span class="line">  this.$once(&#39;hook: beforeDestory&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    picker.destory()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue: 常用技巧1</title>
      <link href="/2020/07/18/vue-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A71/"/>
      <url>/2020/07/18/vue-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A71/</url>
      
        <content type="html"><![CDATA[<p>如果存在组件之间层级大于2层，中间需要一个过渡层的时候，属性和事件的上传下达越简洁越好，重点就是采用vue里的<strong>$atts</strong> 和事件 <strong>$listeners</strong>,先打印看看这两者是什么玩意，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$attrs: object,</span><br><span class="line">$listeners: object</span><br></pre></td></tr></table></figure><p>两者都是绑定在组件里的，且是对象类型，所以在组件阔以之间用<code>this.$attrs.info</code>去获取祖父组件传来的info信息。</p><a id="more"></a><p>以下有三个组件，三者之间都是相关有联系的，阔以称之为 祖父组件、父组件以及子组件。<br>伪代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; grandParent.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;home&quot;&gt;</span><br><span class="line">    &lt;Parent </span><br><span class="line">     :childMsg&#x3D;&#39;childMsg&#39;</span><br><span class="line">     @triggerClickChild&#x3D;&#39;triggerClickChild&#39;</span><br><span class="line">     info&#x3D;&#39;父组件&#39;</span><br><span class="line">    &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import &#123; Component, Vue &#125; from &#39;vue-property-decorator&#39;;</span><br><span class="line">import Parent from &#39;..&#x2F;components&#x2F;parent.vue&#39;; &#x2F;&#x2F; @ is an alias to &#x2F;src</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Parent,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; parent.vue</span><br><span class="line">&lt;Child</span><br><span class="line">      label&#x3D;&#39;子组件信息&#39;</span><br><span class="line">      class&#x3D;&#39;child&#39;</span><br><span class="line">      v-bind&#x3D;&#39;$attrs&#39;</span><br><span class="line">      v-on&#x3D;&#39;$listeners&#39;</span><br><span class="line">      @triggerClickChild&#x3D;&#39;parentC&#39;</span><br><span class="line">    &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">import Child from &#39;.&#x2F;child.vue&#39;</span><br><span class="line">@Component(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">export default class Parent extends Vue &#123;</span><br><span class="line">  @Prop() private childMsg!: any; &#x2F;&#x2F; 此时childMsg信息已用所以不会传递到子组件</span><br><span class="line">  private parentC(key: string) &#123;</span><br><span class="line">    console.log(key, &#39;中间层截胡&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  private mounted() &#123;</span><br><span class="line">    console.log(this.childMsg, &#39;props&#39;)</span><br><span class="line">    console.log(this, &#39;中间组件&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; child本身的组件</span><br><span class="line">  &lt;div class&#x3D;&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h1 @click&#x3D;&#39;triggerClickChild&#39;&gt;&#123;&#123;$attrs&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  inheritAttrs: false</span><br><span class="line">&#125;)</span><br><span class="line">export default class HelloWorld extends Vue &#123;</span><br><span class="line">  private triggerClickChild() &#123;</span><br><span class="line">    this.$emit(&#39;triggerClickChild&#39;, &#39;triggerClickChild子孙组件&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">  private mounted() &#123;</span><br><span class="line">    console.log(this, &#39;attrs&#39;) &#x2F;&#x2F; &#123;info: &#39;&#39;,label: &#39;&#39;,  &#125;</span><br><span class="line">    console.log(this.$listeners) &#x2F;&#x2F; fn triggerClickChild</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>梳理以上几个组件发现这几点：<br>1.v-bind=’$atts’ 和 v-on=’$listeners’只能用于中间组件的传递，也就是起到承上启下的作用<br>2.中间组件接受的props，一旦被采用，也就无法传递到下一层。but事件，中间层阔以截胡，因为事件是由下往上，父组件和祖父组件都能接收到<br>3.有个弊端，如果中间层需要对数据进行二次加工，$attrs也就无用武之地，所以最好就是在顶层组件进行处理，如果处理不了就只能Props一层层传<br>4.当然最大的优势还是免除一层层传递，事件和属性这样简写一下高效了许多。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: 搭建脚手架</title>
      <link href="/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E6%90%AD%E5%BB%BA%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
      <url>/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-%E6%90%AD%E5%BB%BA%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>全局安装，<em>cpp-cli-test</em>脚手架，shell执行<em>npm i -g cpp-cli-test</em>即可，<em>cpp</em>即被注册到全局bin里,<br>本脚手架已发布到npm上，npm包地址 <a href="https://www.npmjs.com/package/cpp-cli-test" target="_blank" rel="noopener">cpp-cli-test</a></p><h3 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h3><p><code>cpp rm &lt;dir&gt;</code> 删除文件夹命令</p><h3 id="升级模板"><a href="#升级模板" class="headerlink" title="升级模板"></a>升级模板</h3><p><em>cpp upgrade</em></p><h3 id="设置自己镜像"><a href="#设置自己镜像" class="headerlink" title="设置自己镜像"></a>设置自己镜像</h3><p><em>cpp mirror <template_mirror></em></p><p>这里的镜像地址，也就是模板的下载地址，比如: <code>https://github.com/mengdu/vue-element-admin-tpl/archive/master.zip</code>以zip为结尾的文件，执行命令行 <code>cpp mirror https://github.com/mengdu/vue-element-admin-tpl/archive/master.zip</code>就是把该模板下载下来.</p><p>需要先将自己的镜像写入本地的<em>config.json</em>文件中，代码逻辑就是根据输入的镜像写入到<em>config.json</em>。写入的时候判断有没有<em>config.json</em>，如果没有则初始化生成<em>config.json</em>，有的话，则先读取，然后设置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取 config.json 文件</span></span><br><span class="line"><span class="keyword">const</span> jsonConfig = <span class="keyword">await</span> fse.readJson(cfgPath);</span><br><span class="line">jsonConfig.mirror = link</span><br><span class="line"><span class="comment">// 再写入 config.json 文件</span></span><br><span class="line"><span class="keyword">await</span> fse.writeJson(cfgPath, jsonConfig)</span><br></pre></td></tr></table></figure><h3 id="下载模板"><a href="#下载模板" class="headerlink" title="下载模板"></a>下载模板</h3><p><em>cpp template</em></p><p>下载模板的时候，先判断当前根目录下是否存在<em>config.json</em>文件，如果不存在则去生成，存在的话，先删除模板文件夹，然后读取<em>config.json</em>文件中的<code>jsonConfig.mirror</code>,然后再根据设置好的路径去远程下载，放到<em>templateTemp</em>里，下载完还需要解压<br>核心代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> download(</span><br><span class="line">  jsonConfig.mirror, <span class="comment">// 远程连接,就是前一步设置的镜像地址</span></span><br><span class="line">  path.resolve(__dirname, <span class="string">'../templateTemp/'</span>), <span class="comment">// 模板存放位置</span></span><br><span class="line">  &#123;</span><br><span class="line">    extract: <span class="literal">true</span>, <span class="comment">// 解压模板</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>先下载到<em>templateTemp</em>到文件夹，然后开始一系列文件剪切操作，找到<em>templateTemp</em>里的文件夹，即从远程下载的文件夹，然后剪切到<em>template</em>里去。</p><h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><p><em>cpp init <project_name></em><br>最重要的部分, 通过<a href="https://www.npmjs.com/package/inquirer" target="_blank" rel="noopener">inquirer</a>来与控制台交互,获取用户所输的文件夹名和设置包名来初始化，主要还是文件夹的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> multiFiles = <span class="string">`<span class="subst">$&#123;targetPath&#125;</span>/package.json`</span></span><br><span class="line"><span class="comment">// 用条件循环把模板字符替换到文件去</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 等待读取文件</span></span><br><span class="line">  <span class="keyword">const</span> multiFilesContent = fse.readFileSync(multiFiles, <span class="string">'utf8'</span>).toString()</span><br><span class="line">  <span class="comment">// 等待替换文件，handlebars.compile(原文件内容)(模板字符)</span></span><br><span class="line">  <span class="keyword">const</span> multiFilesResult = handlebars.compile(multiFilesContent)(multiMeta)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'multiFilesResult'</span>, multiFilesResult);</span><br><span class="line">  <span class="comment">// 等待输出文件</span></span><br><span class="line">  <span class="keyword">await</span> fse.outputFile(multiFiles, multiFilesResult)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="comment">// 如果出错，Spinner 就改变文字信息</span></span><br><span class="line">  initSpinner.text = chalk.red(<span class="string">`Initialize project failed. <span class="subst">$&#123;err&#125;</span>`</span>)</span><br><span class="line">  <span class="comment">// 终止等待动画并显示 X 标志</span></span><br><span class="line">  initSpinner.fail()</span><br><span class="line">  <span class="comment">// 退出进程</span></span><br><span class="line">  process.exit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中有一个坑的地方就是<em>handlebars</em>库，用于替换模板字符的，这个比较坑的就是源文件夹里的属性，必须写成这种样式才能替换模板<br>比如</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"&#123;&#123;name&#125;&#125;"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"8.8.8"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"&#123;&#123;description&#125;&#125;"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"./index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"&#123;&#123;author&#125;&#125;"</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前我以为会直接替代<em>package.json</em>里的包名和描述等等。<br>最高级的应该是用户按照所输入的名称、包名以及依赖名等汇总到<em>package.json</em>里</p><h3 id="本地调试模块，不是项目哦"><a href="#本地调试模块，不是项目哦" class="headerlink" title="本地调试模块，不是项目哦"></a>本地调试模块，不是项目哦</h3><p>添加了bin命令之后，需要执行<em>npm link</em>将 npm 模块链接到对应的运行项目中去，方便地对模块进行调试和测试</p><h3 id="接下来需要做的事"><a href="#接下来需要做的事" class="headerlink" title="接下来需要做的事"></a>接下来需要做的事</h3><ul><li>动态修改模板里的<em>package.json</em>里的name和作者<br>已经解决，</li><li>运用webpack搭建自己的需要的模板</li><li>完善<em>cpp-cli-test</em>脚手架里的命令行和帮助文档</li><li>涉及到的几个包，学习下基本的api<br>已经解决，还需要继续学习</li></ul><h3 id="npm其他操作"><a href="#npm其他操作" class="headerlink" title="npm其他操作"></a>npm其他操作</h3><p>全局删除当前的模块</p><ul><li><p>使用命令<br><code>npm uninstall -g 包名</code></p></li><li><p>直接找到对应包删除<br><code>C:\Users\自己用户的文件夹\AppData\Roaming\npm</code><br>将对应的包删除即可</p></li></ul><h3 id="node里的一些常用的api"><a href="#node里的一些常用的api" class="headerlink" title="node里的一些常用的api"></a>node里的一些常用的api</h3><h4 id="路径拼接"><a href="#路径拼接" class="headerlink" title="路径拼接"></a>路径拼接</h4><ul><li><em>__dirname</em> // 返回当前文件所在的文件夹绝对路径，比如<em>D:\code\cpp-cli\lib</em></li><li><em>path.resolve</em> // 拼接当前文件路径</li><li><em>__filename</em>: 指当前执行文件的带有完整绝对路径的文件名</li><li><em>process.cwd()</em>: 指当前执行node命令时候的文件夹目录名<br>./: 指文件所在目录<br>比如:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> configPath = path.resolve(__dirname, <span class="string">'../config.json'</span>) <span class="comment">// 返回路径</span></span><br><span class="line"><span class="built_in">console</span>.log(configPath) <span class="comment">// configPath D:\code\cpp-cli\config.json</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = path.resolve(<span class="string">'/foo/bar'</span>, <span class="string">'/tmp/file/'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// /foo/bar/tmp/file</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="相关解析"><a href="#相关解析" class="headerlink" title="相关解析"></a>相关解析</h3><p><code>#!/usr/bin/env node</code><br>使用过Linux或者Unix的开发者，对于Shebang应该不陌生，它是一个符号的名称，#！。这个符号通常在Unix系统的基本中第一行开头中出现，用于指明这个脚本文件的解释程序。了解了Shebang之后就可以理解，增加这一行是为了指定用node执行脚本文件。<br>当你输入一个命令的时候，npm是如何识别并执行对应的文件的呢？<br>具体的原理阮一峰大神已经在npm scripts 使用指南中介绍过。简单的理解:<br>就是输入命令后，会有在一个新建的shell中执行指定的脚本，在执行这个脚本的时候，我们需要来指定这个脚本的解释程序是node。<br>在一些情况下，即使你增加了这一行，但还是可能会碰到一下错误，这是为什么呢？<br><code>No such file or directory</code><br>为了解决这个问题，首先需要了解一下/usr/bin/env。我们已经知道，Shebang是为了指定脚本的解释程序，可是不同用户或者不同的脚本解释器有可能安装在不同的目录下，系统如何知道要去哪里找你的解释程序呢？<br>/usr/bin/env就是告诉系统可以在PATH目录中查找。<br>所以配置<code>#!/usr/bin/env node</code>, 就是解决了不同的用户node路径不同的问题，可以让系统动态的去查找node来执行你的脚本文件。<br>看到这里你应该理解，为什么会出现No such file or directory的错误？因为你的node安装路径没有添加到系统的PATH中。所以去进行node环境变量配置就可以了。</p><h3 id="NPM-执行脚本的原理"><a href="#NPM-执行脚本的原理" class="headerlink" title="NPM 执行脚本的原理"></a>NPM 执行脚本的原理</h3><p>npm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。<br>比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/6874815221174075405" target="_blank" rel="noopener">【工具流脚手架cli】用脚手架整合模板和配置</a></li><li><a href="https://juejin.im/post/6844903912080670734#heading-8" target="_blank" rel="noopener">一步一步搭建脚手架</a></li><li><a href="https://mp.weixin.qq.com/s/z9hyaOf85DFMweBmtm1YRA" target="_blank" rel="noopener">发布NPM包</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> cli </category>
          
          <category> node </category>
          
          <category> cpp </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> tool </tag>
            
            <tag> cli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: webpack 配置项output</title>
      <link href="/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-webpack%20%E9%85%8D%E7%BD%AE%E9%A1%B9output/"/>
      <url>/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-webpack%20%E9%85%8D%E7%BD%AE%E9%A1%B9output/</url>
      
        <content type="html"><![CDATA[<h3 id="output配置项"><a href="#output配置项" class="headerlink" title="output配置项"></a>output配置项</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: path.resolve(__dirname, <span class="string">'../src/component/index.js'</span>),</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>), <span class="comment">// 输出的文件位置</span></span><br><span class="line">    filename: <span class="string">'main.js'</span>, <span class="comment">// 输出的文件名</span></span><br><span class="line">    libraryTarget: <span class="string">'umd'</span>, <span class="comment">// 输出格式</span></span><br><span class="line">    library: <span class="string">'cppVue'</span> <span class="comment">// 模块名称</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按不同的模块方式生成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commonjs&#x2F;commonjs2: 将你的library暴露为CommonJS模块</span><br><span class="line">amd: 将你的library暴露为amd模块</span><br><span class="line">umd: 将你的library暴露为所有的模块定义下都可运行的方式</span><br></pre></td></tr></table></figure><blockquote><p>注意：commonjs和commonjs2几乎相同，只不过commonjs只包含exports，而commonjs2还包含module.exports，所以直接使用commonjs2即可。</p></blockquote><h3 id="在实践项目中的运用"><a href="#在实践项目中的运用" class="headerlink" title="在实践项目中的运用"></a>在实践项目中的运用</h3><p>首先得在<em>src</em>中定义想要导出的文件，一般是采用es6里的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://segmentfault.com/a/1190000017960583" target="_blank" rel="noopener">为什么自己写的组件库被引用总是报错——详解webpack的library和libraryTarget</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> umd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> webpack </tag>
            
            <tag> umd </tag>
            
            <tag> output </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: vue</title>
      <link href="/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-vue/"/>
      <url>/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-vue/</url>
      
        <content type="html"><![CDATA[<h2 id="六月第三周-6-22-6-27-的安排"><a href="#六月第三周-6-22-6-27-的安排" class="headerlink" title="六月第三周(6.22-6.27)的安排"></a>六月第三周(6.22-6.27)的安排</h2><ul><li>vue源码学习</li><li>vue初始化流程</li><li>vue响应式原理</li><li>vue中的mvvm</li><li>vue虚拟Dom</li><li>vue生命周期的理解</li><li>vue如何检测数组变化</li><li>vue中如何实现异步渲染？</li></ul><a id="more"></a><p>vue运行机制</p><h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><ul><li>创建Vue实例对象</li><li>init过程会初始化生命周期/初始化事件中心/初始化渲染，执行beforeCreate周期函数</li><li>初始化调用 <em>$mount</em> 方法对Vue实例进行挂载(核心 模板编译 =&gt; 渲染函数 =&gt; 更新)</li><li>如果没有定义render方法，而是定义了template,需要经历编译阶段，需要将模板字符串编译成 <em>render function</em>,步骤如下 <ul><li>parse正则解析成AST</li><li>optimize标记静态节点</li></ul></li><li>编译成render function之后，调用$mount的<em>mountComponent</em>方法，先执行beforeMount钩子函数，然后实例化一个watcher</li><li>调用render方法将render function渲染成虚拟的VNode</li><li>生成虚拟DOM树后，需要将虚拟DOM树转化成真实的DOM节点，此时需要调用update方法，update方法又会调用<em>pacth</em>方法把虚拟DOM转换成真正的DOM节点</li></ul><h3 id="vue生命周期的理解"><a href="#vue生命周期的理解" class="headerlink" title="vue生命周期的理解"></a>vue生命周期的理解</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> LIFECYCLE_HOOKS = [</span><br><span class="line">  <span class="string">'beforeCreate'</span>,</span><br><span class="line">  <span class="string">'created'</span>,</span><br><span class="line">  <span class="string">'beforeMount'</span>,</span><br><span class="line">  <span class="string">'mounted'</span>,</span><br><span class="line">  <span class="string">'beforeUpdate'</span>,</span><br><span class="line">  <span class="string">'updated'</span>,</span><br><span class="line">  <span class="string">'beforeDestroy'</span>,</span><br><span class="line">  <span class="string">'destroyed'</span>,</span><br><span class="line">  <span class="string">'activated'</span>,</span><br><span class="line">  <span class="string">'deactivated'</span>,</span><br><span class="line">  <span class="string">'errorCaptured'</span>,</span><br><span class="line">  <span class="string">'serverPrefetch'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>常规来说 created -&gt; mounted -&gt; updated -&gt; destroyed 创建 挂载 更新 销毁<br>还有keep-alive组件的activated/deactivated 激活和停用还有最新的serverPrefetch,<br>允许我们在渲染过程中“等待”异步数据。可在任何组件中使用，而不仅仅是路由组件</p><h4 id="生命周期的钩子函数合并策略"><a href="#生命周期的钩子函数合并策略" class="headerlink" title="生命周期的钩子函数合并策略"></a>生命周期的钩子函数合并策略</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hooks and props are merged as arrays.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeHook</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentVal,</span></span></span><br><span class="line"><span class="function"><span class="params">  childVal</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = childVal</span><br><span class="line">    ? parentVal</span><br><span class="line">      ? parentVal.concat(childVal)</span><br><span class="line">      : <span class="built_in">Array</span>.isArray(childVal)</span><br><span class="line">        ? childVal</span><br><span class="line">        : [childVal]</span><br><span class="line">    : parentVal;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`res`</span>, dedupeHooks(res));</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">    ? dedupeHooks(res)</span><br><span class="line">    : res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断子组件是否含有对应名字的生命周期钩子，然后再合并父组件的生命周期钩子，还做了去重g，生命周期钩子其实阔以写成数组</p><h4 id="created-amp-amp-mounted-创建和挂载顺序"><a href="#created-amp-amp-mounted-创建和挂载顺序" class="headerlink" title="created &amp;&amp; mounted(创建和挂载顺序)"></a>created &amp;&amp; mounted(创建和挂载顺序)</h4><p>根组件created -&gt; 子组件created<br>子组件mounted -&gt; 父组件mounted </p><h3 id="vue响应式原理-vue双向绑定原理的理解"><a href="#vue响应式原理-vue双向绑定原理的理解" class="headerlink" title="vue响应式原理(vue双向绑定原理的理解)"></a>vue响应式原理(vue双向绑定原理的理解)</h3><p>answer:</p><h4 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h4><p>vue 采用数据劫持+发布者-订阅者模式的方式，通过Object.defineproperty()的方式劫持各个属性的setter/getter,在数据改变时发布消息给订阅者，触发响应的监听回调</p><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><ul><li><strong>监听器Observer</strong> 对需要监听的数据对象进行递归遍历，包括子属性对象的属性，利用Object.defineProperty()对属性都加上setter/getter,一旦某个值赋值，就会触发setter,就能监听到数据变化</li><li><strong>解析器Compiler</strong> 解析Vue模板指令，将模板中的变量都替换成数据，然后初始化页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新</li><li><strong>订阅者Watcher</strong> 订阅者是Observer和Compile之间的通信桥梁，主要任务是订阅Observer中的属性值变化的消息，当收到属性值变化的消息，触发解析器对应的更新函数 1.自身实例化的时候往属性订阅器dep添加自己 2，自身必须有update方法 3.待属性变动dep.notice通知时，调用自身的update方法，并触发Compile中绑定的回调函数</li></ul><p><strong>Last</strong> MVVM作为数据绑定的入口，整合Observe/Compile/Watcher三者，通过Observe来监听自己的model数据变化，通过Compile解析模板编译指令，最终利用Watcher搭起通信桥梁，达到数据变化-&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果</p><p>在init的时候会利用Object.defineProperty方法（不兼容IE8）监听Vue实例的响应式数据的变化从而实现数据劫持能力（利用了JavaScript对象的访问器属性get和set，在未来的Vue3中会使用ES6的Proxy来优化响应式原理）。在初始化流程中的编译阶段，当render function被渲染的时候，会读取Vue实例中和视图相关的响应式数据，此时会触发getter函数进行依赖收集（将观察者Watcher对象存放到当前闭包的订阅者Dep的subs中），此时的数据劫持功能和观察者模式就实现了一个MVVM模式中的Binder，之后就是正常的渲染和更新流程。<br>当数据发生变化或者视图导致的数据发生了变化时，会触发数据劫持的setter函数，setter会通知初始化<em>依赖收集中的Dep</em>中的和视图相应的Watcher，告知需要重新渲染视图，Wather就会再次通过update方法来更新视图。</p><h3 id="vue如何检测数组变化"><a href="#vue如何检测数组变化" class="headerlink" title="vue如何检测数组变化"></a>vue如何检测数组变化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; def &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"><span class="comment">// 原始Array未重写之前的API原型方法</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="comment">// 拷贝原型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"><span class="comment">// 重写原型的方法</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果插入的数据，将再次监听</span></span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">//  触发订阅，像页面更新响应就在这里触发</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>重写之后的数组会在每次在执行数组的原始方法之后手动触发响应页面的效果。<br>Vue2.x中并没有实现将已存在的数组元素做监听，而是去监听造成数组变化的方法，触发这个方法的同时去调用挂载好的响应页面方法，达到页面响应式的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="comment">// 监听数组元素</span></span><br><span class="line">    observe(items[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this.observeArray函数了，它的内部实现非常简单，它对数组元素进行了监听，什么意思呢，就是改变数组里的元素不能监听到，但是数组内的值是对象类型的，修改它依旧能得到监听响应，如改变list[0].val可以得到监听，但是改变list[0]不能，但是依旧没有对数组本身的变化进行监听。</p><h3 id="Vue中如何实现异步渲染？"><a href="#Vue中如何实现异步渲染？" class="headerlink" title="Vue中如何实现异步渲染？"></a>Vue中如何实现异步渲染？</h3><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/5e8b163ff265da47ee3f54a6" target="_blank" rel="noopener">2020年前端面试复习必读文章</a></li><li><a href="https://mp.weixin.qq.com/s/oAlVmZ4Hbt2VhOwFEkNEhw" target="_blank" rel="noopener">虚拟 DOM 到底是什么？(长文建议收藏)</a></li><li><a href="https://juejin.im/post/5cd8a7c1f265da037a3d0992#heading-15" target="_blank" rel="noopener">基于Vue实现一个简易MVVM</a></li><li><a href="https://juejin.im/post/5e778c71518825491d3240fd" target="_blank" rel="noopener">高级前端开发者必会的34道Vue面试题系列（二）</a></li><li><a href="https://juejin.im/post/5e8064c551882573a13777e2" target="_blank" rel="noopener">高级前端开发者必会的34道Vue面试题系列（三）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> 前端框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端进阶: promise-1</title>
      <link href="/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-promise-1/"/>
      <url>/2020/07/18/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6-promise-1/</url>
      
        <content type="html"><![CDATA[<h2 id="六月第三周-6-22-6-27-的安排"><a href="#六月第三周-6-22-6-27-的安排" class="headerlink" title="六月第三周(6.22-6.27)的安排"></a>六月第三周(6.22-6.27)的安排</h2><ul><li>promise用法1</li><li>promise用法2</li><li>promise手写</li></ul><a id="more"></a><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="promise状态不可逆性"><a href="#promise状态不可逆性" class="headerlink" title="promise状态不可逆性"></a>promise状态不可逆性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="string">"success1"</span>);</span><br><span class="line">  resolve(<span class="string">"success2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="string">"success"</span>);</span><br><span class="line">  reject(<span class="string">"reject"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">success1</span><br><span class="line">success</span><br></pre></td></tr></table></figure><h4 id="promise中的异常处理"><a href="#promise中的异常处理" class="headerlink" title="promise中的异常处理"></a>promise中的异常处理</h4><ul><li>first scene<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  foo.bar();</span><br><span class="line">  resolve( <span class="number">1</span> );  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then value: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then value: '</span>+value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 控制台输出</span></span><br><span class="line">p1 then err: <span class="built_in">ReferenceError</span> foo is not defined</span><br><span class="line">p1 then then err:  <span class="literal">undefined</span></span><br></pre></td></tr></table></figure></li><li>second scene<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  resolve( <span class="number">2</span> );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then value: '</span> + value);</span><br><span class="line">    foo.bar();</span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then value: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then err: '</span> + err);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then then value: '</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then then err: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">p2 then value: <span class="number">2</span></span><br><span class="line">p2 then then err: <span class="built_in">ReferenceError</span> foo is not defined</span><br><span class="line">p2 then then then value: resolve</span><br></pre></td></tr></table></figure>知识点</li><li>Promise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。</li><li>then方法接受两个参数，第一个是promise成功的回调，一个是失败的回调，<em>两个函数只能一个被调用</em></li></ul><h4 id="promise-resolve"><a href="#promise-resolve" class="headerlink" title="promise.resolve()"></a>promise.resolve()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve( <span class="number">1</span> );</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve( p1 );</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2); </span><br><span class="line"><span class="built_in">console</span>.log(p1 === p3);</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p4);</span><br><span class="line"><span class="built_in">console</span>.log(p3 === p4);</span><br><span class="line"></span><br><span class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p4='</span> + value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p2='</span> + value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1='</span> + value);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 控制台输出</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">p2=<span class="number">1</span></span><br><span class="line">p1=<span class="number">1</span></span><br><span class="line">p4=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>Promise.resolve()阔以接受一个普通值或者一个Promise对象作为参数<br>当参数是普通值的时候，返回一个resolved状态的promise对象<br>当参数是Promise对象时，直接返回这个promise对象，所以p1 === p2</p><h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;               <span class="comment">//第一个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> value*<span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第二个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第三个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>); </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第四个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第五个then</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve: '</span>+ value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reject: '</span> + err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">resolve</span><br><span class="line">reject: reject</span><br></pre></td></tr></table></figure><p>then两个参数的返回值是以下三种情况的一种</p><ul><li>return 一个同步值或者undefined(没有返回一个值时默认是undefined),then 方法会返回一个resolved状态的promise对象，Promise对象的值就是这个返回值</li><li>return 另一个Promise，then会根据这个Promise的状态和值创建一个新的Promise对象返回</li><li>throw 一个同步异常 then方法返回一个rejected状态的promise,值是该异常</li></ul><h4 id="resolve-vs-reject"><a href="#resolve-vs-reject" class="headerlink" title="resolve vs reject"></a>resolve vs reject</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  reject(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">p2.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">p3.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 控制台输出</span></span><br><span class="line">rejected: [object <span class="built_in">Promise</span>]</span><br><span class="line">fulfilled: resolve</span><br><span class="line">rejected: resolve</span><br></pre></td></tr></table></figure><ul><li>Promise回调函数中的第一个参数resolve，会对Promise执行”拆箱”动作。即当resolve的参数是一个Promise对象时，resolve会”拆箱”获取这个Promise对象的状态和值，但这个过程是异步的。p1”拆箱”后，获取到Promise对象的状态是resolved，因此fulfilled回调被执行；</li><li>p2”拆箱”后，获取到Promise对象的状态是rejected，因此rejected回调被执行。</li><li>但Promise回调函数中的第二个参数reject不具备”拆箱“的能力，reject的参数会直接传递给then方法中的rejected回调。因此，即使p3 reject接收了一个resolved状态的Promise，then方法中被调用的依然是rejected，并且参数就是reject接收到的Promise对象。</li></ul><blockquote><p>拆箱是异步操作，所以不具备拆箱的3执行的是同步操作</p></blockquote><h4 id="扩展——-try-catch"><a href="#扩展——-try-catch" class="headerlink" title="扩展—— try catch"></a>扩展—— try catch</h4><p>问: 用一句话描述js异常是否能被try catch到<br>答: 能捕捉到的异常必须是线程执行已经进入try catch但try catch未执行完成的时候抛出来的</p><h3 id="红绿灯问题"><a href="#红绿灯问题" class="headerlink" title="红绿灯问题"></a>红绿灯问题</h3><p>Qs: 题目：红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次；如何让三个灯不断交替重复亮灯？（用 Promise 实现）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'red'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'green'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'yellow'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用then和递归实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'red'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'green'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'yellow'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> light = <span class="function"><span class="keyword">function</span>(<span class="params">timmer, cb</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            cb();</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, timmer);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> step = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> light(<span class="number">3000</span>, red);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> light(<span class="number">2000</span>, green);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> light(<span class="number">1000</span>, yellow);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        step();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 或者换种写法</span></span><br><span class="line">    <span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        resolve(<span class="string">'i am cpp'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(val) <span class="comment">// i am cpp</span></span><br><span class="line">        <span class="keyword">return</span> light(<span class="number">3000</span>, red);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> light(<span class="number">2000</span>, green);</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> light(<span class="number">1000</span>, yellow);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">step();</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/597724c26fb9a06bb75260e8" target="_blank" rel="noopener">八段代码彻底掌握 Promise</a></li><li><a href="https://juejin.im/post/5e6f4579f265da576429a907" target="_blank" rel="noopener">最简实现Promise，支持异步链式调用（20行）</a></li><li><a href="https://juejin.im/post/5a04066351882517c416715d" target="_blank" rel="noopener">Promise 必知必会（十道题）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
          <category> es6 </category>
          
          <category> promise </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 前端重学(6)</title>
      <link href="/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-6/"/>
      <url>/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-6/</url>
      
        <content type="html"><![CDATA[<h2 id="六月第二周-6-8-6-14-的安排"><a href="#六月第二周-6-8-6-14-的安排" class="headerlink" title="六月第二周(6.8-6.14)的安排"></a>六月第二周(6.8-6.14)的安排</h2><ul><li>观察者模式 vs 发布订阅模式</li><li>函数柯里化</li><li>prefetch 和 preload区别</li><li>实现一个正则表达式(匹配url连接)</li><li>内存溢出</li></ul><a id="more"></a><h2 id="观察者模式-vs-发布订阅模式"><a href="#观察者模式-vs-发布订阅模式" class="headerlink" title="观察者模式 vs 发布订阅模式"></a>观察者模式 vs 发布订阅模式</h2><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式指的是一个对象（Subject）维持一系列依赖于它的对象（Observer），当有关状态发生变更时 Subject 对象则通知一系列 Observer 对象进行更新。<br>在观察者模式中，Subject 对象拥有添加、删除和通知一系列 Observer 的方法等等，而 Observer 对象拥有更新方法(update)等等。<br>简单说，就是数据发生改变，对应的处理函数自动执行。<br>通过一个实例就能很好的明白观察者模式了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义综述主题</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Subject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.observers = []</span><br><span class="line">&#125;</span><br><span class="line">Subject.prototype = &#123;</span><br><span class="line">  <span class="comment">// 添加observe</span></span><br><span class="line">  add(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.observers.push(observer)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 移除observe</span></span><br><span class="line">  remove(observer) &#123;</span><br><span class="line">    <span class="keyword">var</span> observers = <span class="keyword">this</span>.observers</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; observers.length; i ++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (observers[i] === observer) &#123;</span><br><span class="line">        observers.splice(i, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 通知 告诉observe 执行自己的方法</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">var</span> observers = <span class="keyword">this</span>.observers;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; observers.length;i++)&#123;</span><br><span class="line">      observers[i].update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 观察者定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义观察者里的更新方法</span></span><br><span class="line">Observer.prototype = &#123;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`观察者模式下 name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Subject</span></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> Subject()</span><br><span class="line"><span class="keyword">var</span> obs1 = <span class="keyword">new</span> Observer(<span class="string">'cpp'</span>)</span><br><span class="line"><span class="keyword">var</span> obs2 = <span class="keyword">new</span> Observer(<span class="string">'chendapeng'</span>)</span><br><span class="line">sub.add(obs1)</span><br><span class="line">sub.add(obs2)</span><br><span class="line">sub.notify()</span><br></pre></td></tr></table></figure><p>应用:<br>Vue 通过观察者模式触发视图更新。Vue2.x通过Object.defineProperty劫持data数据，当数据变化后触发setter,setter内部通过订阅器notify消息，notify会调用watcher更新视图</p><h3 id="发布订阅模式-Publisher-amp-amp-Subscriber"><a href="#发布订阅模式-Publisher-amp-amp-Subscriber" class="headerlink" title="发布订阅模式(Publisher &amp;&amp; Subscriber)"></a>发布订阅模式(Publisher &amp;&amp; Subscriber)</h3><p>希望接受通知的对象基于一个主题通过自定义事件订阅主题<br>发布者通过调度中心基于一个主题向订阅者发布消息<br>代码示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调度中心</span></span><br><span class="line"><span class="keyword">let</span> pubsub = &#123;</span><br><span class="line">  list: &#123;&#125;, <span class="comment">// 订阅的数组</span></span><br><span class="line">  subscribe(key, fn) &#123; <span class="comment">// 订阅</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.list[key]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.list[key] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.list[key].push(fn)</span><br><span class="line">  &#125;,</span><br><span class="line">  publish(...args) &#123; <span class="comment">// 发布</span></span><br><span class="line">    <span class="built_in">console</span>.log(args);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(args).slice(<span class="number">8</span>, <span class="number">-1</span>))</span><br><span class="line">    <span class="keyword">const</span> key = args[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> fns = <span class="keyword">this</span>.list[key]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fns.length; i ++) &#123;</span><br><span class="line">      fns[i].apply(<span class="keyword">this</span>, [args[<span class="number">1</span>]])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 取消订阅</span></span><br><span class="line">  unSubscribe(key) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.list[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">pubsub.subscribe(<span class="string">'name'</span>, (name) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'订阅在发布模式下 name is'</span>, name);</span><br><span class="line">&#125;)</span><br><span class="line">pubsub.publish(<span class="string">'name'</span>, <span class="string">'cpp'</span>)</span><br><span class="line">pubsub.subscribe(<span class="string">'age'</span>, (age) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'订阅在发布模式下 age is'</span>, age);</span><br><span class="line">&#125;)</span><br><span class="line">pubsub.publish(<span class="string">'age'</span>, <span class="string">'18'</span>)</span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>观察者模式与发布订阅模式都是定义了<em>一个一对多的依赖关系</em>，当有关状态发生变更时则执行相应的更新。<br>不同的是，观察者模式依赖于主题(Subject)对象的一系列Observer对象被通知之后只能执行一个特定的更新方法(比如update等),而发布订阅模式阔以通过调度中心，<strong>基于不同的主题去执行不同的自定义事件</strong>，相对而言，发布订阅模式比观察者模式灵活一些。</p><h3 id="原生实现观察者模式"><a href="#原生实现观察者模式" class="headerlink" title="原生实现观察者模式"></a>原生实现观察者模式</h3><ul><li>es5实现<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> observer(mode: <span class="built_in">any</span>, old: <span class="built_in">any</span>, val: <span class="built_in">any</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;mode&#125;</span> name属性值从<span class="subst">$&#123;old&#125;</span> -&gt; <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> es5Implement() &#123;</span><br><span class="line">  <span class="keyword">const</span> targetObj = &#123;</span><br><span class="line">    age: <span class="number">28</span>,</span><br><span class="line">    name: <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">'cpp'</span></span><br><span class="line">  <span class="comment">// 定义name属性以及其设置方法</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(targetObj, <span class="string">'name'</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> name</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(val) &#123;</span><br><span class="line">      <span class="keyword">this</span>.observer(<span class="string">'es5'</span>, name, val)</span><br><span class="line">      name = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  targetObj.name = <span class="string">'Martin'</span>;</span><br><span class="line">  targetObj.name = <span class="string">'Lucas'</span>;</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">'targetObj:'</span>, targetObj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>es6实现<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TargetObj</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(age, name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> name(val) &#123;</span><br><span class="line">    observer(name, val);</span><br><span class="line">    name = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> targetObj = <span class="keyword">new</span> TargetObj(<span class="number">1</span>, <span class="string">'Martin'</span>);</span><br><span class="line"><span class="comment">// 定义值改变时的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">oldVal, newVal</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 其他处理逻辑...</span></span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">'name属性的值从 '</span>+ oldVal +<span class="string">' 改变为 '</span> + newVal);</span><br><span class="line">&#125;</span><br><span class="line">targetObj.name = <span class="string">'Lucas'</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/5bb1bb616fb9a05d2b6dccfa" target="_blank" rel="noopener">谈谈观察者模式和发布订阅模式</a></li><li><a href="https://blog.csdn.net/lm278858445/article/details/78287492" target="_blank" rel="noopener">原生JavaScript实现观察者模式</a></li></ul><h2 id="函数柯里化-Curry"><a href="#函数柯里化-Curry" class="headerlink" title="函数柯里化(Curry)"></a>函数柯里化(Curry)</h2><h3 id="什么是curry"><a href="#什么是curry" class="headerlink" title="什么是curry"></a>什么是curry</h3><p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>柯里化实际是把简答的问题复杂化了，但是复杂化的同时，我们在使用函数时拥有了更加多的自由度。 而这里对于函数参数的自由处理，正是柯里化的核心所在。 柯里化本质上是降低通用性，提高适用性。</p><h2 id="prefetch-和-preload区别"><a href="#prefetch-和-preload区别" class="headerlink" title="prefetch 和 preload区别"></a>prefetch 和 preload区别</h2><p>通过插入一个页面元素来声明一个资源（比如img、script、link）。这种方式会将资源的加载和执行耦合。</p><p>用AJAX来加载资源。这种方式只有在时机成熟时才会加载资源，解决了执行时机问题。但是浏览器无法预解析，也就无法提前加载。另外如果页面有大量的阻塞脚本，就会造成延迟。<br>有没有办法既提前加载资源，又能解耦加载和执行呢?</p><h3 id="preload"><a href="#preload" class="headerlink" title="preload"></a>preload</h3><p>preload 提供了一种声明式的命令，让浏览器<em>提前加载</em>指定资源(加载后并不执行,加载和执行分离)，在需要执行的时候再执行。提供的好处主要是</p><ul><li>将加载和执行分离开，可不阻塞渲染和 document 的 onload 事件</li><li>提前加载指定资源，不再出现依赖的font字体隔了一段时间才刷出</li></ul><h3 id="如何区分-preload-和-prefetch"><a href="#如何区分-preload-和-prefetch" class="headerlink" title="如何区分 preload 和 prefetch"></a>如何区分 preload 和 prefetch</h3><ul><li>preload 告诉浏览器页面必定需要的资源，browser一定会加载这些资源</li><li>prefetch 告诉浏览器可能需要的资源，browser不一定会加载这些资源</li></ul><h3 id="用link标签创建preload"><a href="#用link标签创建preload" class="headerlink" title="用link标签创建preload"></a>用<code>link</code>标签创建preload</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'preload'</span> <span class="attr">href</span>=<span class="string">'/public/static/theme.css'</span> <span class="attr">as</span>=<span class="string">'style'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'preload'</span> <span class="attr">href</span>=<span class="string">'/public/static/vue.js'</span> <span class="attr">as</span>=<span class="string">'script'</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或者用script创建 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"> <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">'link'</span>)</span></span><br><span class="line"><span class="actionscript"> link.href=<span class="string">'/public/static/vue.js'</span></span></span><br><span class="line"><span class="actionscript"> link.rel = <span class="string">'preload'</span></span></span><br><span class="line"><span class="actionscript"> link.as = <span class="string">'script'</span></span></span><br><span class="line"><span class="javascript"> <span class="built_in">document</span>.head.appendChild(link)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="preload特点"><a href="#preload特点" class="headerlink" title="preload特点"></a>preload特点</h3><ul><li>提前加载资源</li><li>资源的加载和执行分离</li><li>不延迟网页的load事件（除非Preload资源刚好是阻塞 window 加载的资源）</li></ul><h3 id="Preload跟其他提前加载资源以及加载和执行分离的方案有什么区别？"><a href="#Preload跟其他提前加载资源以及加载和执行分离的方案有什么区别？" class="headerlink" title="Preload跟其他提前加载资源以及加载和执行分离的方案有什么区别？"></a>Preload跟其他提前加载资源以及加载和执行分离的方案有什么区别？</h3><h4 id="vs-aysnc"><a href="#vs-aysnc" class="headerlink" title="vs aysnc"></a>vs aysnc</h4><p>async 脚本是一加载完就立即执行，因此会阻塞window的onload事件。而且目前async仅限于脚本资源。<br>Preload可以实现async一样的异步加载功能。且不局限于脚本。比如以下代码实现了加载完CSS文件立即作用到网页的功能：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">as</span>=<span class="string">"style"</span> <span class="attr">onload</span>=<span class="string">"this.rel='stylesheet'"</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注：如果页面存在同步阻塞脚本，等脚本执行完后，样式才会作用到网页。这样是因为Preload的资源不会阻塞window的onload事件。</p></blockquote><h4 id="vs-defer"><a href="#vs-defer" class="headerlink" title="vs defer"></a>vs defer</h4><p>defer实现了资源的加载和执行分离，并且它能保证defer的资源按照在HTML里的出现顺序执行。跟async一样，目前也只能作用于脚本资源。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>典型用例：</p><ul><li><p>在单页应用中，提前加载路由文件，提高切换路由时的渲染速度。现在大型的单页应用通常会异步加载路由文件。当用户切换路由时再异步加载相应的模块存在性能问题。可以用Preload提前加载，提升性能。</p></li><li><p>提前加载字体文件。由于字体文件必须等到CSSOM构建完成并且作用到页面元素了才会开始加载，会导致页面字体样式闪动（FOUT，Flash of Unstyled Text）。所以要用Preload显式告诉浏览器提前加载。假如字体文件在CSS生效之前下载完成，则可以完全消灭FOUT。</p></li></ul><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/5a7fb09bf265da4e8e785c38#heading-12" target="_blank" rel="noopener">用 preload 预加载页面资源</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMTcwOTM4Mg==&mid=2247484163&idx=1&sn=16b9c907971683dd61cee251adcde79b&chksm=f96edaaace1953bcaf65a1adcf30b6d3dd66cf7b648ae59c4bf807d3f8bf460d5cd638e54ca1&token=946370022&lang=zh_CN#rd" target="_blank" rel="noopener">有一种优化，叫Preload</a></li></ul><h2 id="实现一个正则表达式-匹配url连接"><a href="#实现一个正则表达式-匹配url连接" class="headerlink" title="实现一个正则表达式(匹配url连接)"></a>实现一个正则表达式(匹配url连接)</h2><p>url: <a href="http://niaogege.cn:80/index?title=1#more">http://niaogege.cn:80/index?title=1#more</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> patter = <span class="regexp">/^(http?:\/\/)([0-9a-zA-Z.]+)([:0-9]+)?([/0-9a-zA-Z.]+)?(\?[0-9a-zA-Z&amp;=]+)?(#[0-9a-zA-Z])?/</span></span><br><span class="line"><span class="comment">// 不区分大小写</span></span><br><span class="line"><span class="keyword">const</span> pattern = <span class="regexp">/^(http?:\/\/)([0-9a-z.]+)([:0-9]+)?([/0-9a-z.]+)?(\?[0-9a-z&amp;=]+)?(#[0-9a-z])?/i</span></span><br></pre></td></tr></table></figure><h3 id="匹配协议"><a href="#匹配协议" class="headerlink" title="匹配协议"></a>匹配协议</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(http?:\/\/)</span><br></pre></td></tr></table></figure><h3 id="匹配主域"><a href="#匹配主域" class="headerlink" title="匹配主域"></a>匹配主域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([<span class="number">0</span><span class="number">-9</span>a-z.]+)</span><br></pre></td></tr></table></figure><h3 id="匹配端口"><a href="#匹配端口" class="headerlink" title="匹配端口"></a>匹配端口</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([:<span class="number">0</span><span class="number">-9</span>]+)? <span class="comment">// :8080 可有可无 ？</span></span><br></pre></td></tr></table></figure><h3 id="匹配路径"><a href="#匹配路径" class="headerlink" title="匹配路径"></a>匹配路径</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([<span class="regexp">/0-9a-z.]+)? /</span><span class="regexp">/ /i</span>ndex.html 可有可无 ？</span><br></pre></td></tr></table></figure><h3 id="匹配查询"><a href="#匹配查询" class="headerlink" title="匹配查询"></a>匹配查询</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\?[<span class="number">0</span><span class="number">-9</span>a-z&amp;=]+)? <span class="comment">// ?query=1&amp;title=1&amp;keyword=2 可有可无 ？</span></span><br></pre></td></tr></table></figure><h3 id="匹配锚点"><a href="#匹配锚点" class="headerlink" title="匹配锚点"></a>匹配锚点</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(#[0-9a-z])? // #more 可有可无 ？</span><br></pre></td></tr></table></figure><h3 id="常用正则表达"><a href="#常用正则表达" class="headerlink" title="常用正则表达"></a>常用正则表达</h3><ul><li>匹配手机号码 <em>/(+86)1\d{10}/</em> </li><li>匹配身份证号码 <em>/^(\d{17}(\d|x))$/</em></li><li>匹配邮箱 <em>/^(\w)+(.\w+)</em>@(\w)+((.\w+)+)$/*</li></ul><h3 id="参考链接-2"><a href="#参考链接-2" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://louiszhai.github.io/2016/06/13/regexp/#%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">正则表达式前端使用手册</a></li><li><a href="https://blog.csdn.net/wulex/article/details/97050209" target="_blank" rel="noopener">正则匹配地址</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> http </tag>
            
            <tag> RegExp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 前端重学(5)</title>
      <link href="/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-5/"/>
      <url>/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-5/</url>
      
        <content type="html"><![CDATA[<h2 id="6-1-6-7-的安排"><a href="#6-1-6-7-的安排" class="headerlink" title="(6.1-6.7)的安排"></a>(6.1-6.7)的安排</h2><ul><li>vuex手写以及原理</li><li>mvvm理解(拖延症)</li><li>css问题(1px以及清楚浮动原理)</li><li>js基础(es5继承和es6继承的区别)</li></ul><a id="more"></a><h3 id="第二版vuex手写"><a href="#第二版vuex手写" class="headerlink" title="第二版vuex手写"></a>第二版vuex手写</h3><h3 id="mvvm理解"><a href="#mvvm理解" class="headerlink" title="mvvm理解"></a>mvvm理解</h3><h3 id="css之移动端-1px-问题"><a href="#css之移动端-1px-问题" class="headerlink" title="css之移动端 1px 问题"></a>css之移动端 1px 问题</h3><p>两个概念，一个是像素（pixel）可以简写为px，另外一个是设备像素比（DPR）devicePixelRadio</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">像素 ：指在由一个数字序列表示的图像中的一个最小单元，单位是 px，不可再次分割了。</span><br><span class="line">设备像素比（DPR）: 设备像素比 &#x3D; 设备像素 &#x2F; 设备独立像素。</span><br></pre></td></tr></table></figure><p>造成边框变粗的原因<br>其实这个原因很简单，因为css中的1px并不等于移动设备的1px，这些由于不同的手机有不同的像素密度。在window对象中有一个devicePixelRatio属性，他可以反应css中的像素与设备的像素比。</p><p>设计稿上的是<code>物理像素</code>,css中的像素是<code>逻辑像素</code><br>如果window.devicePixelRadio是2.0，即设计稿上的1px等于css中的0.5px<br>目前主流屏幕的DPR是2（8P+），拿2倍屏来说，设备的物理像素要实现1像素，而DPR=2，所以css 像素只能是 0.5。一般设计稿是按照750来设计的，它上面的1px是以750来参照的，而我们写css样式是以设备375为参照的，所以我们应该写0.5px</p><h3 id="主流方案一：利用伪元素（-after-transform）进行缩放"><a href="#主流方案一：利用伪元素（-after-transform）进行缩放" class="headerlink" title="主流方案一：利用伪元素（::after + transform）进行缩放"></a>主流方案一：利用伪元素（<code>::after + transform</code>）进行缩放</h3><p>为什么用伪元素？ 因为伪元素<code>::after或::before</code>是独立于当前元素，可以单独对其缩放而不影响元素本身的缩放<br>实现:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border-1px</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  &amp;::before&#123;</span><br><span class="line">    <span class="selector-tag">content</span>: "";</span><br><span class="line">    <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line">    <span class="selector-tag">left</span>: 0;</span><br><span class="line">    <span class="selector-tag">top</span>: 0;</span><br><span class="line">    <span class="selector-tag">width</span>: 200%;</span><br><span class="line">    <span class="selector-tag">border</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-tag">red</span>;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-tag">red</span>;</span><br><span class="line">    <span class="selector-tag">height</span>: 200%;</span><br><span class="line">    <span class="selector-tag">-webkit-transform-origin</span>: <span class="selector-tag">left</span> <span class="selector-tag">top</span>;</span><br><span class="line">    <span class="selector-tag">transform-origin</span>: <span class="selector-tag">left</span> <span class="selector-tag">top</span>;</span><br><span class="line">    <span class="selector-tag">-webkit-transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.5</span>);</span><br><span class="line">    <span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.5</span>);</span><br><span class="line">    <span class="selector-tag">pointer-events</span>: <span class="selector-tag">none</span>; <span class="comment">/* 防止点击触发 */</span></span><br><span class="line">    <span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>; <span class="comment">/*IE 盒模型 元素内容宽高 == 内容+ 内边距 + 边框*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主流方案二：针对不同的DPR设备增加媒体查询，进行对应的缩放"><a href="#主流方案二：针对不同的DPR设备增加媒体查询，进行对应的缩放" class="headerlink" title="主流方案二：针对不同的DPR设备增加媒体查询，进行对应的缩放"></a>主流方案二：针对不同的DPR设备增加媒体查询，进行对应的缩放</h3><p>实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border-1px</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  &amp;::before&#123;</span><br><span class="line">    <span class="selector-tag">content</span>: "";</span><br><span class="line">    <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line">    <span class="selector-tag">left</span>: 0;</span><br><span class="line">    <span class="selector-tag">top</span>: 0;</span><br><span class="line">    <span class="selector-tag">width</span>: 200%;</span><br><span class="line">    <span class="selector-tag">border</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-tag">red</span>;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-tag">red</span>;</span><br><span class="line">    <span class="selector-tag">height</span>: 200%;</span><br><span class="line">    <span class="selector-tag">-webkit-transform-origin</span>: <span class="selector-tag">left</span> <span class="selector-tag">top</span>;</span><br><span class="line">    <span class="selector-tag">transform-origin</span>: <span class="selector-tag">left</span> <span class="selector-tag">top</span>; <span class="comment">/* 允许改变转换元素的位置 */</span></span><br><span class="line">    <span class="selector-tag">-webkit-transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.5</span>);</span><br><span class="line">    <span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.5</span>);</span><br><span class="line">    <span class="selector-tag">pointer-events</span>: <span class="selector-tag">none</span>; <span class="comment">/* 防止点击触发 */</span></span><br><span class="line">    <span class="selector-tag">box-sizing</span>: <span class="selector-tag">border-box</span>; <span class="comment">/* IE 盒模型 元素内容宽高 == 内容+ 内边距 + 边框 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-device-pixel-ratio:</span><span class="number">3</span>),(<span class="attribute">-webkit-min-device-pixel-ratio:</span><span class="number">3</span>) &#123;</span><br><span class="line">      <span class="selector-tag">width</span>: 300%;</span><br><span class="line">      <span class="selector-tag">height</span>: 300%;</span><br><span class="line">      <span class="selector-tag">-webkit-transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.33</span>);</span><br><span class="line">      <span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.33</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-device-pixel-ratio:</span><span class="number">2.75</span>),(<span class="attribute">-webkit-min-device-pixel-ratio:</span><span class="number">2.75</span>) &#123;</span><br><span class="line">      <span class="selector-tag">width</span>: 300%;</span><br><span class="line">      <span class="selector-tag">height</span>: 300%;</span><br><span class="line">      -webkit-transform: scale(1/2.75);</span><br><span class="line">      transform: scale(1/2.75);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-device-pixel-ratio:</span><span class="number">2</span>),(<span class="attribute">-webkit-min-device-pixel-ratio:</span><span class="number">2</span>)&#123;</span><br><span class="line">      <span class="selector-tag">width</span>: 300%;</span><br><span class="line">      <span class="selector-tag">height</span>: 300%;</span><br><span class="line">      <span class="selector-tag">-webkit-transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.5</span>);</span><br><span class="line">      <span class="selector-tag">transform</span>: <span class="selector-tag">scale</span>(0<span class="selector-class">.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="css之清除浮动原理"><a href="#css之清除浮动原理" class="headerlink" title="css之清除浮动原理"></a>css之清除浮动原理</h2><p>清除浮动主要有两种方式，分别是clear清除浮动和BFC清除浮动</p><h3 id="浮动的三个特点很重要。"><a href="#浮动的三个特点很重要。" class="headerlink" title="浮动的三个特点很重要。"></a>浮动的三个特点很重要。</h3><ol><li>脱离文档流。</li><li>向左/向右浮动直到遇到父元素或者别的浮动元素。</li><li>浮动会导致父元素高度坍塌。</li></ol><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>clear属性不允许被清除浮动的元素的左边/右边挨着浮动元素，底层原理是<em>在被清除浮动的元素上边或者下边添加足够的清除空间</em></p><blockquote><p>要注意了，我们是通过在别的元素上清除浮动来实现撑开高度的，而不是在浮动元素上。</p></blockquote><p>clear浮动元素最佳实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 同时加入:before以解决现代浏览器上边距折叠的问题</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">    *zoom: 1; // 引入了zoom以支持IE6/7</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BFC清除浮动"><a href="#BFC清除浮动" class="headerlink" title="BFC清除浮动"></a>BFC清除浮动</h3><p>原理就是 <em>浮动盒区域不会叠加到BFC上，(BFC区域不会与float的元素区域叠加)</em>,BFC的五条约束规则之一<br>实现就是触发BFC即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 根元素或其它包含它的元素；</span><br><span class="line">- 浮动 (元素的float不为none)；</span><br><span class="line">- 绝对定位元素 (元素的position为absolute或fixed)；</span><br><span class="line">- 行内块inline-blocks(元素的 display: inline-block)；</span><br><span class="line">- 表格单元格(元素的display: table-cell，HTML表格单元格默认属性)；</span><br><span class="line">- overflow的值不为visible的元素；</span><br><span class="line">- 弹性盒 flex boxes (元素的display: flex或inline-flex)；</span><br></pre></td></tr></table></figure><p>平常中，设置<code>overflow: hidden/scroll, float: right/left,position: absolute,display: flex/inline-flex;</code>即当前元素创建了一个BFC</p><h2 id="原型和es5继承和es6继承的区别"><a href="#原型和es5继承和es6继承的区别" class="headerlink" title="原型和es5继承和es6继承的区别"></a>原型和es5继承和es6继承的区别</h2><h3 id="原型-prototype-和-实例属性的-proto"><a href="#原型-prototype-和-实例属性的-proto" class="headerlink" title="原型(prototype) 和 实例属性的(proto)"></a>原型(prototype) 和 实例属性的(<strong>proto</strong>)</h3><ul><li>原型: 给其他对象提供共享属性的对象</li><li>隐式引用(<strong>proto</strong>): 所有实例对象都存在一个隐式引用，指向他的原型</li></ul><p>构造函数(constructor): 它的原型指向实例的原型(Person.prototype === person.<strong>proto</strong>)<br>构造函数和普通函数的区别</p><ul><li>使用new操作符生成实例的函数就是构造函数</li><li>直接调用的就是普通函数</li><li>Symbol是基础类型不是构造函数</li></ul><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p>之前已经详细阐述过es5中的继承，主要是经典继承(构造函数继承)/原型链继承/组合继承以及常用的寄生式组合继承，<a href="http://niaogege.cn/2020/05/05/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6/#more">前文链接</a>,(通过原型链实现原型属性的继承，通过构造函数实现实例属性的继承)</p><p>ES5 的继承，通过prototype或构造函数机制来实现, 实质是先创造子类的实例对象this，再将父类的方法添加到this上面（Parent.apply(this)）。<br>ES6 的继承机制完全不同，实质是先创建父类的实例对象this(所以必须先调用父类的super()方法)，然后再用子类的构造函数修改this。</p><p>ES6中新增了class关键字来定义类，通过保留的关键字<em>extends</em>实现了继承。实际上这些关键字只是一些语法糖，底层实现还是通过原型链之间的委托关联关系实现继承</p><p>如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</p><h3 id="super"><a href="#super" class="headerlink" title="super()"></a>super()</h3><p>在 super() 执行时，它指向的是 子类 B 的构造函数，而不是父类 A 的构造函数。也就是说，super() 内部的 this 指向的是 B<br><em>super()<em>相当于</em>Parent.prototype.constructor.call(this. props)</em><br>super本身是指向父类的构造函数但做函数调用后返回的是子类的实例，实际上做了<em>parent.prototype.constructor.call(this)</em>，做对象调用时指向父类.prototype,从而实现继承</p><h3 id="static-静态属性"><a href="#static-静态属性" class="headerlink" title="static 静态属性"></a>static 静态属性</h3><p>顾名思义是静态方法的意思，类相当于实例的原型，所有在类中定义的方法， 都会被实例继承。<br>如果在一个方法前， 加上static关键字， 就表示该方法不会被实例继承， 而是直接通过类来调用， 这就称为“ 静态方法”。静态方法调用直接在类上进行，而在类的实例上不可被调用。静态方法通常用于创建 实用/工具 函数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">  <span class="keyword">public</span> x!: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">public</span> y!: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">public</span> z!: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">x: <span class="built_in">any</span>, y: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">this</span>.y = <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> print() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类的print方法'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.z = <span class="number">3</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> ColorPoint <span class="keyword">extends</span> Point &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">x: <span class="built_in">any</span>, y: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(x, y)</span><br><span class="line">    <span class="comment">// Point.prototype.constructor.call(this, x, y)</span></span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> m() &#123;</span><br><span class="line">    <span class="comment">// super.print() 难以调用，父类的print是静态属性，只能在类上直接调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，父类的静态方法，也会被子类继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> hello() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.hello()  <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>上面代码中，hello()是A类的静态方法，B继承A，也继承了A的静态方法。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://es6.ruanyifeng.com/#docs/class-extends" target="_blank" rel="noopener">es6之class</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> mvvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> http </tag>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 前端重学(4)</title>
      <link href="/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-4/"/>
      <url>/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-4/</url>
      
        <content type="html"><![CDATA[<p>重点js基础/Vue框架/typescript/Css/node/工具/网络基础</p><ul><li>Mvvm原理的解读以及模拟实现</li><li>Vuex源码以及模拟实现(a week)</li><li>Vue计算属性(原理及相关特性)</li><li>express完整应用(two week)</li></ul><p>前期还是需要在好好学学vue相关的源码知识，特别是mvvm以及vuex的源码阅读，大概领会其思想，目的很简单，就是面试的时候，不能被面试官问倒。<br>后面会尽量往node/webpack/ast靠拢，如果可能有时间的话，算法还是要了解。<br>源码调试不方便，不知道是自己的问题还是没有找到规律，vuex的源码是放在<code>vuex.esm.js</code>中，在2.0版本的时候，源码中还含有<code>src</code>文件夹，里面含有未压缩的各模块代码，现在vuex不是这个样子</p><a id="more"></a><h3 id="Mvvm的模拟实现"><a href="#Mvvm的模拟实现" class="headerlink" title="Mvvm的模拟实现"></a>Mvvm的模拟实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observer 数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现。</span><br><span class="line"></span><br><span class="line">Compile 指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。</span><br><span class="line"></span><br><span class="line">Watcher 订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。</span><br><span class="line"></span><br><span class="line">Dep 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。</span><br></pre></td></tr></table></figure><h2 id="Vuex源码以及模拟实现"><a href="#Vuex源码以及模拟实现" class="headerlink" title="Vuex源码以及模拟实现"></a>Vuex源码以及模拟实现</h2><p>源码这么多，不知道如何下手?不知道主线是什么，谁能告诉我如何把源码理清，其实，有好几篇文章里的思路还是比较明晰的，无奈自己太次，有点理解不了尤大大的用意，老是被一些api打断思路。<br>还有就是对数据结构没啥概念，比如说在deom里定义了两个模块，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    Test,</span><br><span class="line">    Fuck,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>modules</code>所包含的对象即使传入Store中的对象，即源码中的<code>options</code></p><h3 id="手写基础版的vuex"><a href="#手写基础版的vuex" class="headerlink" title="手写基础版的vuex"></a>手写基础版的vuex</h3><ul><li>install</li></ul><p>vuex对外暴露一个是install方法，传入vue，并把$cppStore绑定到组件上，到时候直接调用<code>this.$cppStore.state</code>即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue: any</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">initVue: any</span>) </span>&#123;</span><br><span class="line">  Vue = initVue</span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">      <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'this'</span>, options);</span><br><span class="line">      <span class="keyword">if</span> (options &amp;&amp; options.cppStore) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$cppStore = <span class="keyword">typeof</span> options.cppStore === <span class="string">'function'</span></span><br><span class="line">        ? options.cppStore()</span><br><span class="line">        : options.cppStore;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.$cppStore = options.parent &amp;&amp; options.parent.$cppStore;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CppStore</li></ul><p>第二个是对外暴露一个 <code>CppStore</code> class,这个class需要传入一个对象，一般是这种样子的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  state: &#123;&#125;,</span><br><span class="line">  actions: &#123;&#125;,</span><br><span class="line">  mutations: &#123;&#125;,</span><br><span class="line">  getters: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>安装引入以及使用<!-- main.ts --><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cppStore <span class="keyword">from</span> <span class="string">'./store/cppStore'</span>;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  cppStore: (cppStore <span class="keyword">as</span> <span class="built_in">any</span>),</span><br><span class="line">  render: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure>store/cppStore<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import vue from &#39;vue&#39;</span><br><span class="line">import CppVuex from &#39;.&#x2F;..&#x2F;..&#x2F;utils&#x2F;vuex&#39;</span><br><span class="line">vue.use(CppVuex)</span><br><span class="line">export default new CppVuex.CppStore(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: 10000,</span><br><span class="line">    data: &#123;</span><br><span class="line">      age: 20,</span><br><span class="line">      name: &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    addCount(context: any, val: number) &#123;</span><br><span class="line">      const obj &#x3D; &#123;</span><br><span class="line">        age: val,</span><br><span class="line">        name: &#39;cpp&#39;</span><br><span class="line">      &#125;</span><br><span class="line">      context.commit(&#39;CHANGE_COUNT&#39;, obj)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    CHANGE_COUNT(state: any, val: any) &#123;</span><br><span class="line">      state.count +&#x3D; val.age</span><br><span class="line">      state.data &#x3D; val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    GetCount: (state: any) &#x3D;&gt; &#123;</span><br><span class="line">      return state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="Vuex-乞丐版如下"><a href="#Vuex-乞丐版如下" class="headerlink" title="Vuex 乞丐版如下"></a>Vuex 乞丐版如下</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一版的vuex</span></span><br><span class="line"><span class="keyword">let</span> Vue: <span class="built_in">any</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">initVue: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  Vue = initVue</span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">      <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'this'</span>, options);</span><br><span class="line">      <span class="keyword">if</span> (options &amp;&amp; options.cppStore) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$cppStore = <span class="keyword">typeof</span> options.cppStore === <span class="string">'function'</span></span><br><span class="line">        ? options.cppStore()</span><br><span class="line">        : options.cppStore;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.$cppStore = options.parent &amp;&amp; options.parent.$cppStore;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> CppStore &#123;</span><br><span class="line">  <span class="keyword">protected</span> $options: <span class="built_in">any</span> = &#123;&#125; </span><br><span class="line">  <span class="keyword">protected</span> state: <span class="built_in">any</span> = &#123;&#125;</span><br><span class="line">  <span class="keyword">protected</span> mutations: <span class="built_in">any</span> = &#123;&#125;</span><br><span class="line">  <span class="keyword">protected</span> actions: <span class="built_in">any</span> = &#123;&#125;</span><br><span class="line">  <span class="keyword">protected</span> getters: <span class="built_in">any</span> = &#123;&#125;</span><br><span class="line">  <span class="comment">// dispatch: any = &#123;&#125;</span></span><br><span class="line">  <span class="comment">// commit: any = &#123;&#125;</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">options: <span class="built_in">any</span> = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// 普通传来的对象</span></span><br><span class="line">    <span class="keyword">this</span>.$options = options</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      data: <span class="keyword">this</span>.$options.state</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.$options.getters &amp;&amp; <span class="keyword">this</span>.handleGetters(<span class="keyword">this</span>.$options.getters)</span><br><span class="line">    <span class="keyword">this</span>.actions = <span class="keyword">this</span>.$options.actions</span><br><span class="line">    <span class="keyword">this</span>.mutations = <span class="keyword">this</span>.$options.mutations</span><br><span class="line">    <span class="comment">// this.commit = (type: any, arg: any) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   this.mutations[type](this.state, arg)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">const</span> store = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> &#123; dispatch, commit &#125; = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// this.commit = function boundCommit (type: any, payload: any, options: any) &#123;</span></span><br><span class="line">    <span class="comment">//   return commit.call(store, type, payload, options)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// getters</span></span><br><span class="line">  <span class="keyword">protected</span> handleGetters(getters: <span class="built_in">any</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.getters = &#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(getters).forEach(<span class="function">(<span class="params">key: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>.getters, key, &#123;</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">          <span class="comment">// 执行getters中的方法</span></span><br><span class="line">          <span class="keyword">return</span> getters[key](<span class="keyword">this</span>.state)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发dispatch</span></span><br><span class="line">  <span class="keyword">protected</span> dispatch(<span class="keyword">type</span>: <span class="built_in">any</span>, arg: <span class="built_in">any</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.actions[<span class="keyword">type</span>](&#123; </span><br><span class="line">      commit: <span class="keyword">this</span>.commit, </span><br><span class="line">      state: <span class="keyword">this</span>.state, </span><br><span class="line">      getters: <span class="keyword">this</span>.getters, </span><br><span class="line">      dispatch: <span class="keyword">this</span>.dispatch </span><br><span class="line">    &#125;, arg)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// // 触发commit</span></span><br><span class="line">  <span class="keyword">protected</span> commit = <span class="function">(<span class="params"><span class="keyword">type</span>: <span class="built_in">any</span>, arg: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.mutations[<span class="keyword">type</span>](<span class="keyword">this</span>.state, arg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  CppStore,</span><br><span class="line">  install</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="intstall-vuex安装"><a href="#intstall-vuex安装" class="headerlink" title="intstall vuex安装"></a>intstall vuex安装</h3><p>安装部分，核心就是给Vue注入一个store属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Vuex init hook, injected into each instances init hooks list.</span><br><span class="line"> *&#x2F;</span><br><span class="line">function vuexInit () &#123;</span><br><span class="line">  const options &#x3D; this.$options</span><br><span class="line">  &#x2F;&#x2F; store injection</span><br><span class="line">  if (options.store) &#123;</span><br><span class="line">    this.$store &#x3D; options.store</span><br><span class="line">  &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">    this.$store &#x3D; options.parent.$store</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟action"><a href="#模拟action" class="headerlink" title="模拟action"></a>模拟action</h3><p>vuex中通过dispatch触发action</p><ul><li>知识点<br>如何判断函数是否是async函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;是否是async函数&#39;, this.action[type].constructor);</span><br><span class="line">console.log(&#39;是否是async函数&#39;, this.action[type].constructor.name &#x3D;&#x3D;&#x3D; &#39;AsyncFunction&#39;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/29982815" target="_blank" rel="noopener">Vuex2.0源码解析</a></li></ul><h2 id="手写简单的mvvm"><a href="#手写简单的mvvm" class="headerlink" title="手写简单的mvvm"></a>手写简单的mvvm</h2><p>使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"c"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./MVVM.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> mvvm = <span class="keyword">new</span> Mvvm(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      a: &#123;</span><br><span class="line">        b: 1</span><br><span class="line">      &#125;,</span><br><span class="line">      c: 2,</span><br><span class="line"><span class="actionscript">      message: <span class="string">'this is Message'</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'mvvm'</span>, mvvm);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>具体的实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创造一个实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mvvm</span>(<span class="params">options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$options = options</span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">this</span>._data = <span class="keyword">this</span>.$options.data</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 数据劫持</span></span><br><span class="line">  observe(data)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//this 代理了 this._data</span></span><br><span class="line">  <span class="comment">// mvvm._data.a.b 相等于 mvvm.a.b</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._data[key] <span class="comment">// 访问this.a.b</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">        <span class="keyword">this</span>._data[key] = newValue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initComputed.call(this);     </span></span><br><span class="line">  <span class="comment">// 数据编译</span></span><br><span class="line">  <span class="keyword">new</span> Compile(options.el, <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据劫持 给所有对象增加set get方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observe</span>(<span class="params">data = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="comment">// 给对象添加set get</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">    <span class="comment">// 把data属性通过defineProperty的方式定义属性</span></span><br><span class="line">    <span class="keyword">let</span> val = data[key];</span><br><span class="line">     <span class="comment">// 递归继续向下找，实现深度的数据劫持</span></span><br><span class="line">    observe(val);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="comment">// 将watcher添加到订阅事件中 [watcher]</span></span><br><span class="line">        Dep.target &amp;&amp; dep.addSub(Dep.target)</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val === newVal) <span class="keyword">return</span>;</span><br><span class="line">        val = newVal;</span><br><span class="line">        observe(newVal)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方便递归调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!val || <span class="keyword">typeof</span> val !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observe(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据编译</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compile</span>(<span class="params">el, vm</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将el挂载到实例上</span></span><br><span class="line">  vm.$el = <span class="built_in">document</span>.querySelector(el);</span><br><span class="line">  <span class="comment">// ?</span></span><br><span class="line">  <span class="keyword">let</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">  <span class="keyword">let</span> child</span><br><span class="line">  <span class="keyword">while</span>(child = vm.$el.firstChild) &#123;</span><br><span class="line">    fragment.appendChild(child)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child'</span>, child);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fragment'</span>, fragment);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对 el内容进行替换</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">frag</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Array</span>.from(frag.childNodes).forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> txt = node.textContent;</span><br><span class="line">      <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>;   <span class="comment">// 正则匹配&#123;&#123;&#125;&#125;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'node'</span>, node);</span><br><span class="line">      <span class="keyword">if</span> (node.nodeType === <span class="number">3</span> &amp;&amp; reg.test(txt)) &#123;</span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">replaceTxt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            node.textContent = txt.replace(reg, (matched, placeholder) =&gt; &#123;   </span><br><span class="line">              <span class="built_in">console</span>.log(placeholder);   <span class="comment">// 匹配到的分组 如：song, album.name, singer...</span></span><br><span class="line">              <span class="keyword">new</span> Watcher(vm, placeholder, replaceTxt);   <span class="comment">// 监听变化，进行匹配替换内容</span></span><br><span class="line">              <span class="keyword">return</span> placeholder.split(<span class="string">'.'</span>).reduce(<span class="function">(<span class="params">val, key</span>) =&gt;</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> val[key]; </span><br><span class="line">              &#125;, vm);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;;</span><br><span class="line">        <span class="comment">// 替换</span></span><br><span class="line">        replaceTxt();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.nodeType === <span class="number">1</span>) &#123;  <span class="comment">// 元素节点</span></span><br><span class="line">        <span class="keyword">let</span> nodeAttr = node.attributes; <span class="comment">// 获取dom上的所有属性,是个类数组</span></span><br><span class="line">        <span class="built_in">Array</span>.from(nodeAttr).forEach(<span class="function"><span class="params">attr</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> name = attr.name;   <span class="comment">// v-model  type</span></span><br><span class="line">            <span class="keyword">let</span> exp = attr.value;   <span class="comment">// c        text</span></span><br><span class="line">            <span class="keyword">if</span> (name.includes(<span class="string">'v-'</span>))&#123;</span><br><span class="line">                node.value = vm[exp];   <span class="comment">// this.c 为 2</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 监听变化</span></span><br><span class="line">            <span class="keyword">new</span> Watcher(vm, exp, <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">              node.value = newVal;   <span class="comment">// 当watcher触发时会自动将内容放进输入框中</span></span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            node.addEventListener(<span class="string">'input'</span>, e =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> newVal = e.target.value;</span><br><span class="line">                <span class="comment">// 相当于给this.c赋了一个新值</span></span><br><span class="line">                <span class="comment">// 而值的改变会调用set，set中又会调用notify，notify中调用watcher的update方法实现了更新</span></span><br><span class="line">                vm[exp] = newVal;   </span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果还有子节点，继续递归replace</span></span><br><span class="line">      <span class="keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">        replace(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 替换内容</span></span><br><span class="line">  replace(fragment);</span><br><span class="line">  vm.$el.appendChild(fragment); <span class="comment">// 文档碎片放到el元素中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发布订阅</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subs = []</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="comment">// 订阅就是放入subs</span></span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// this.subs数组里的每一项，都有一个update方法</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this.subs'</span>, <span class="keyword">this</span>.subs);</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听者</span></span><br><span class="line"><span class="comment">// 通过Watcher这个类创建的实例，都拥有update方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm, exp, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!vm &amp;&amp; !exp) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">this</span>.vm = vm;</span><br><span class="line">  <span class="keyword">this</span>.exp = exp;</span><br><span class="line">  <span class="keyword">this</span>.fn = fn;</span><br><span class="line">  Dep.target = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> arr = exp.split(<span class="string">'.'</span>);</span><br><span class="line">  <span class="keyword">let</span> val = vm;</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;    <span class="comment">// 取值</span></span><br><span class="line">     val = val[key];     <span class="comment">// 获取到this.a.b，默认就会调用get方法</span></span><br><span class="line">  &#125;);</span><br><span class="line">  Dep.target = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype.update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// notify的时候值已经更改了</span></span><br><span class="line">  <span class="comment">// 再通过vm, exp来获取新的值</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="keyword">this</span>.exp.split(<span class="string">'.'</span>);</span><br><span class="line">  <span class="keyword">let</span> val = <span class="keyword">this</span>.vm;</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;    </span><br><span class="line">      val = val[key];   <span class="comment">// 通过get获取到新的值</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.fn(val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let watcher = new Watcher(() =&gt; console.log(111));  // </span></span><br><span class="line"><span class="comment">// let dep = new Dep();</span></span><br><span class="line"><span class="comment">// dep.addSub(watcher);    // 将watcher放到数组中,watcher自带update方法， =&gt; [watcher]</span></span><br><span class="line"><span class="comment">// dep.addSub(watcher);</span></span><br><span class="line"><span class="comment">// dep.notify();   //  111, 111</span></span><br></pre></td></tr></table></figure><p>yun….一头雾水，我太难了!!!</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> mvvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> http </tag>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 前端重学(3)</title>
      <link href="/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-3/"/>
      <url>/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-3/</url>
      
        <content type="html"><![CDATA[<h2 id="五一之后第二周-5-11-5-17-的安排"><a href="#五一之后第二周-5-11-5-17-的安排" class="headerlink" title="五一之后第二周(5.11-5.17)的安排"></a>五一之后第二周(5.11-5.17)的安排</h2><p>重点js基础/Vue框架/Css/node</p><ul><li>Vuex模拟实现</li><li>手写一个简单的mvvm</li><li>BFC 以及 清除浮动以及原理</li><li>闭包</li><li>观察者模式</li><li>http1.x和http2.x</li></ul><a id="more"></a><h2 id="Vuex源码以及模拟实现"><a href="#Vuex源码以及模拟实现" class="headerlink" title="Vuex源码以及模拟实现"></a>Vuex源码以及模拟实现</h2><h3 id="vuex的模拟实现"><a href="#vuex的模拟实现" class="headerlink" title="vuex的模拟实现"></a>vuex的模拟实现</h3><h2 id="手写简单的mvvm"><a href="#手写简单的mvvm" class="headerlink" title="手写简单的mvvm"></a>手写简单的mvvm</h2><p>使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"c"</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./MVVM.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> mvvm = <span class="keyword">new</span> Mvvm(&#123;</span></span><br><span class="line"><span class="actionscript">    el: <span class="string">'#app'</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      a: &#123;</span><br><span class="line">        b: 1</span><br><span class="line">      &#125;,</span><br><span class="line">      c: 2,</span><br><span class="line"><span class="actionscript">      message: <span class="string">'this is Message'</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">'mvvm'</span>, mvvm);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>具体的实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创造一个实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mvvm</span>(<span class="params">options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$options = options</span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">this</span>._data = <span class="keyword">this</span>.$options.data</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 数据劫持</span></span><br><span class="line">  observe(data)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//this 代理了 this._data</span></span><br><span class="line">  <span class="comment">// mvvm._data.a.b 相等于 mvvm.a.b</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._data[key] <span class="comment">// 访问this.a.b</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">        <span class="keyword">this</span>._data[key] = newValue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initComputed.call(this);     </span></span><br><span class="line">  <span class="comment">// 数据编译</span></span><br><span class="line">  <span class="keyword">new</span> Compile(options.el, <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据劫持 给所有对象增加set get方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observe</span>(<span class="params">data = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="comment">// 给对象添加set get</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">    <span class="comment">// 把data属性通过defineProperty的方式定义属性</span></span><br><span class="line">    <span class="keyword">let</span> val = data[key];</span><br><span class="line">     <span class="comment">// 递归继续向下找，实现深度的数据劫持</span></span><br><span class="line">    observe(val);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="comment">// 将watcher添加到订阅事件中 [watcher]</span></span><br><span class="line">        Dep.target &amp;&amp; dep.addSub(Dep.target)</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val === newVal) <span class="keyword">return</span>;</span><br><span class="line">        val = newVal;</span><br><span class="line">        observe(newVal)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方便递归调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!val || <span class="keyword">typeof</span> val !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observe(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据编译</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compile</span>(<span class="params">el, vm</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将el挂载到实例上</span></span><br><span class="line">  vm.$el = <span class="built_in">document</span>.querySelector(el);</span><br><span class="line">  <span class="comment">// ?</span></span><br><span class="line">  <span class="keyword">let</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">  <span class="keyword">let</span> child</span><br><span class="line">  <span class="keyword">while</span>(child = vm.$el.firstChild) &#123;</span><br><span class="line">    fragment.appendChild(child)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'child'</span>, child);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fragment'</span>, fragment);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对 el内容进行替换</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">replace</span>(<span class="params">frag</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Array</span>.from(frag.childNodes).forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> txt = node.textContent;</span><br><span class="line">      <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>;   <span class="comment">// 正则匹配&#123;&#123;&#125;&#125;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'node'</span>, node);</span><br><span class="line">      <span class="keyword">if</span> (node.nodeType === <span class="number">3</span> &amp;&amp; reg.test(txt)) &#123;</span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">replaceTxt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            node.textContent = txt.replace(reg, (matched, placeholder) =&gt; &#123;   </span><br><span class="line">              <span class="built_in">console</span>.log(placeholder);   <span class="comment">// 匹配到的分组 如：song, album.name, singer...</span></span><br><span class="line">              <span class="keyword">new</span> Watcher(vm, placeholder, replaceTxt);   <span class="comment">// 监听变化，进行匹配替换内容</span></span><br><span class="line">              <span class="keyword">return</span> placeholder.split(<span class="string">'.'</span>).reduce(<span class="function">(<span class="params">val, key</span>) =&gt;</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> val[key]; </span><br><span class="line">              &#125;, vm);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;;</span><br><span class="line">        <span class="comment">// 替换</span></span><br><span class="line">        replaceTxt();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.nodeType === <span class="number">1</span>) &#123;  <span class="comment">// 元素节点</span></span><br><span class="line">        <span class="keyword">let</span> nodeAttr = node.attributes; <span class="comment">// 获取dom上的所有属性,是个类数组</span></span><br><span class="line">        <span class="built_in">Array</span>.from(nodeAttr).forEach(<span class="function"><span class="params">attr</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> name = attr.name;   <span class="comment">// v-model  type</span></span><br><span class="line">            <span class="keyword">let</span> exp = attr.value;   <span class="comment">// c        text</span></span><br><span class="line">            <span class="keyword">if</span> (name.includes(<span class="string">'v-'</span>))&#123;</span><br><span class="line">                node.value = vm[exp];   <span class="comment">// this.c 为 2</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 监听变化</span></span><br><span class="line">            <span class="keyword">new</span> Watcher(vm, exp, <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">              node.value = newVal;   <span class="comment">// 当watcher触发时会自动将内容放进输入框中</span></span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            node.addEventListener(<span class="string">'input'</span>, e =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> newVal = e.target.value;</span><br><span class="line">                <span class="comment">// 相当于给this.c赋了一个新值</span></span><br><span class="line">                <span class="comment">// 而值的改变会调用set，set中又会调用notify，notify中调用watcher的update方法实现了更新</span></span><br><span class="line">                vm[exp] = newVal;   </span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果还有子节点，继续递归replace</span></span><br><span class="line">      <span class="keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">        replace(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 替换内容</span></span><br><span class="line">  replace(fragment);</span><br><span class="line">  vm.$el.appendChild(fragment); <span class="comment">// 文档碎片放到el元素中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发布订阅</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subs = []</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype = &#123;</span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="comment">// 订阅就是放入subs</span></span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// this.subs数组里的每一项，都有一个update方法</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this.subs'</span>, <span class="keyword">this</span>.subs);</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听者</span></span><br><span class="line"><span class="comment">// 通过Watcher这个类创建的实例，都拥有update方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm, exp, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!vm &amp;&amp; !exp) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">this</span>.vm = vm;</span><br><span class="line">  <span class="keyword">this</span>.exp = exp;</span><br><span class="line">  <span class="keyword">this</span>.fn = fn;</span><br><span class="line">  Dep.target = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">let</span> arr = exp.split(<span class="string">'.'</span>);</span><br><span class="line">  <span class="keyword">let</span> val = vm;</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;    <span class="comment">// 取值</span></span><br><span class="line">     val = val[key];     <span class="comment">// 获取到this.a.b，默认就会调用get方法</span></span><br><span class="line">  &#125;);</span><br><span class="line">  Dep.target = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype.update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// notify的时候值已经更改了</span></span><br><span class="line">  <span class="comment">// 再通过vm, exp来获取新的值</span></span><br><span class="line">  <span class="keyword">let</span> arr = <span class="keyword">this</span>.exp.split(<span class="string">'.'</span>);</span><br><span class="line">  <span class="keyword">let</span> val = <span class="keyword">this</span>.vm;</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;    </span><br><span class="line">      val = val[key];   <span class="comment">// 通过get获取到新的值</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.fn(val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let watcher = new Watcher(() =&gt; console.log(111));  // </span></span><br><span class="line"><span class="comment">// let dep = new Dep();</span></span><br><span class="line"><span class="comment">// dep.addSub(watcher);    // 将watcher放到数组中,watcher自带update方法， =&gt; [watcher]</span></span><br><span class="line"><span class="comment">// dep.addSub(watcher);</span></span><br><span class="line"><span class="comment">// dep.notify();   //  111, 111</span></span><br></pre></td></tr></table></figure><p>yun….一头雾水，我太难了!!!</p><h2 id="BFC-以及-清除浮动以及原理"><a href="#BFC-以及-清除浮动以及原理" class="headerlink" title="BFC 以及 清除浮动以及原理"></a>BFC 以及 清除浮动以及原理</h2><p>BFC(block formatting context) 块级格式化上下文，用于决定块盒子(block box)的<em>布局及浮动</em>相互影响范围的一个区域，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p><h3 id="BFC创建触发条件"><a href="#BFC创建触发条件" class="headerlink" title="BFC创建触发条件"></a>BFC创建触发条件</h3><ul><li>根元素或其它包含它的元素；</li><li>浮动 (元素的float不为none)；</li><li>绝对定位元素 (元素的position为absolute或fixed)；</li><li>行内块inline-blocks(元素的 display: inline-block)；</li><li>表格单元格(元素的display: table-cell，HTML表格单元格默认属性)；</li><li>overflow的值不为visible的元素；</li><li>弹性盒 flex boxes (元素的display: flex或inline-flex)；<br>平常中，设置<code>overflow: hidden/scroll, float: right/left,position: absolute,display: flex/inline-flex;</code>即当前元素创建了一个BFC</li></ul><h3 id="BFC约束规则"><a href="#BFC约束规则" class="headerlink" title="BFC约束规则"></a>BFC约束规则</h3><ul><li>内部的盒会在垂直方向一个接一个排列（可以看作BFC中有一个的常规流）</li><li>处于同一个BFC中的元素相互影响，可能会发生外边距重叠(（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生重叠（塌陷），与方向无关。）)</li><li>每个元素的margin box的左边，与容器块border box的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</li><li>计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算</li><li>浮动盒区域不叠加到BFC上，(BFC区域不会与float的元素区域叠加)</li></ul><h3 id="BFC阔以解决的问题"><a href="#BFC阔以解决的问题" class="headerlink" title="BFC阔以解决的问题"></a>BFC阔以解决的问题</h3><ul><li>垂直外边距重叠问题</li><li>去除浮动 (BFC区域不会与float的元素区域叠加)</li><li>自适用两列布局（float + overflow）</li></ul><h3 id="实例中理解BFC的约束规则"><a href="#实例中理解BFC的约束规则" class="headerlink" title="实例中理解BFC的约束规则"></a>实例中理解BFC的约束规则</h3><ul><li><p>如何实现左侧宽度固定，右侧宽度自适应</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'box'</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'left'</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'right'</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>float + margin</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">10px</span> solid red;</span><br><span class="line">  <span class="attribute">background</span>: green;   </span><br><span class="line">  <span class="attribute">border</span>: <span class="number">3px</span> solid yellow;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;                    </span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">3px</span> solid black;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>:<span class="number">#888</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>float + calc</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left1</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: green;    <span class="comment">/* 绿色 */</span></span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right1</span>&#123;                        <span class="comment">/* 粉色 */</span></span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">200px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>float + overflow(BFC应用场景)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">background</span>: green; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right2</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>利用BFC约束规则第六点:浮动盒区域不叠加到BFC上，(BFC区域不会与float的元素区域叠加)</p></blockquote></li><li><p>最佳选择 flex</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  display: flex; // 触发BFC</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left3</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: green; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right3</span> &#123;</span><br><span class="line">  flex: 1; // flex-grow: 1;flex-shrink: 1;flex-basis: 0%;</span><br><span class="line">  <span class="selector-tag">background</span>: <span class="selector-tag">pink</span>;</span><br><span class="line">  <span class="selector-tag">outline</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">black</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>清除浮动主要有两种方式，分别是clear清除浮动和BFC清除浮动</p></li><li><p>clear清除浮动<br>底层原理是在被清除浮动的元素上边或者下边添加足够的清除空间;</p></li><li><p>浮动的三个特点很重要。</p></li></ul><ol><li>脱离文档流。</li><li>向左/向右浮动直到遇到父元素或者别的浮动元素。</li><li>浮动会导致父元素高度坍塌。</li></ol><ul><li>解决父元素高度坍塌的方式就是清除浮动，常规的方法是clear清除浮动和BFC清除浮动，推荐clearfix的方式</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 全浏览器通用的clearfix方案</span><br><span class="line">// 引入了zoom以支持IE6/7</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">" "</span>;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">  *zoom: 1; // 支持IE6/7</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/59b73d5bf265da064618731d" target="_blank" rel="noopener">学习 BFC (Block Formatting Context)</a></li><li><a href="https://www.jianshu.com/p/09bd5873bed4" target="_blank" rel="noopener">CSS中的浮动和清除浮动，梳理一下！</a></li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h2 id="http1-x和http2-x"><a href="#http1-x和http2-x" class="headerlink" title="http1.x和http2.x"></a>http1.x和http2.x</h2><h3 id="http1-x几大缺陷"><a href="#http1-x几大缺陷" class="headerlink" title="http1.x几大缺陷"></a>http1.x几大缺陷</h3><ul><li>规定客户端对同一域的并发连接最多只能2个(一般是2-8个)</li><li>线头阻塞(head of line block) 同一个连接中的请求，需要一个接一个串行发送和接收</li><li>基于文本协议，请求和响应头信息大，无法压缩</li><li>不能控制响应优先级，必须按照请求顺序响应</li><li>只能单向请求，客户端请求什么，服务器返回什么</li></ul><h3 id="Http2"><a href="#Http2" class="headerlink" title="Http2"></a>Http2</h3><p>HTTP2 的前身是 SPDY协议（一个 Google 主导推行的应用层协议，作为对 HTTP1 的增强）。HTTP2必须在维持原来 HTTP 的范式（不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段等等）前提下，实现突破性能限制，改进传输性能，实现<em>低延迟</em>和<em>高吞吐量</em>。</p><h3 id="Http2-特性"><a href="#Http2-特性" class="headerlink" title="Http2 特性"></a>Http2 特性</h3><ul><li>传输内容使用二进制协议</li><li>使用帧作为最小传输单位</li><li>多路复用</li><li>头压缩</li><li>服务器推送</li><li>优先级与依赖性</li><li>可重置</li><li>流量控制</li><li>HTTPS rfc 规范并没有要求 HTTP2 强制使用 TLS，但是目前世界所有浏览器和服务器实现都基于 HTTPS 来实现 HTTP2</li></ul><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>HTTP1.x 时代，无论是传输内容还是头信息，都是文本/ASCII编码的，虽然这有利于直接从请求从观察出内容，但是却使得想要实现并发传输异常困难（存在空格或其他字符，很难判断消息的起始和结束）。使用二进制传输可以避免这个问题，因为传输内容只有1和0，通过下面第二点的“帧”规范规定格式，即可轻易识别出不同类型内容。同时使用二进制有一个显而易见的好处是：更小的传输体积</p><h3 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h3><p> HTTP2 在维持原有 HTTP 范式的前提下，实现突破性能限制，改进传输性能，实现低延迟和高吞吐量的其中一个关键是：在应用层（HTTP2）和传输层（TCP or UDP）之间增加了二进制分帧层</p><h3 id="多路复用（Multiplexing）和流"><a href="#多路复用（Multiplexing）和流" class="headerlink" title="多路复用（Multiplexing）和流"></a>多路复用（Multiplexing）和流</h3><p>多路复用是解决 HTTP1.x 缺陷第一点（并发问题）和第二点（HOLB线头问题）的核心技术点</p><h3 id="头压缩"><a href="#头压缩" class="headerlink" title="头压缩"></a>头压缩</h3><p><em>HPACK</em>专门为头部压缩设计的算法，还被指定成单独的草案中。<br>HTTP2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送；通信期间几乎不会改变的通用键-值对（用户代理、可接受的媒体类型，等等）只需发送一次</p><h2 id="Http2-0优势"><a href="#Http2-0优势" class="headerlink" title="Http2.0优势"></a>Http2.0优势</h2><ul><li>更小的传输体积，更小或者省略重复的头消息</li><li>突破原有的 TCP 连接并发限制，使用一个 TCP 连接即可实现多请求并发，单链接也能减轻服务端的压力（更少的内存和 CPU 使用）</li><li>解决 HOLB 线头问题，慢的请求或者先发送的请求不会阻塞其他请求的返回</li><li>结合 CDN 提供实时性更高，延迟更低的内容分发代理服务，大大减少白屏时间</li><li>数据传输优先级可控，使网站可以实现更灵活和强大的页面控制</li><li>能在不中断 TCP 连接的情况下停止（重置）数据的发送</li></ul><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://juejin.im/post/5acccf966fb9a028d043c6ec" target="_blank" rel="noopener">HTTP2基本概念学习笔记</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> es6 </category>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> javascript </tag>
            
            <tag> http </tag>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 前端重学(2)</title>
      <link href="/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-2/"/>
      <url>/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-2/</url>
      
        <content type="html"><![CDATA[<h2 id="五一之后第一周-5-6-5-9-的安排"><a href="#五一之后第一周-5-6-5-9-的安排" class="headerlink" title="五一之后第一周(5.6-5.9)的安排"></a>五一之后第一周(5.6-5.9)的安排</h2><ul><li>type 和 interface 区别</li><li>webpack中的externals配置使用</li><li>https和http协议的区别</li></ul><a id="more"></a><blockquote><p>ts语法强烈建议浏览<a href="https://www.tslang.cn/docs/handbook/interfaces.html" target="_blank" rel="noopener">官网</a>,英语理解力强的，阔推荐<a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">英文官网</a></p></blockquote><p>ts运行，本地tslint提示的各种报错有时真让人抓狂!!!(持续完善当中)</p><table><thead><tr><th>序列</th><th>提示</th><th align="center">描述</th></tr></thead><tbody><tr><td>1</td><td>Exceeds maximum line length of 150</td><td align="center">单行超150字符</td></tr><tr><td>2</td><td>expected an assignment or function call</td><td align="center">expected an assignment or function call</td></tr><tr><td>3</td><td>comment must start with a space</td><td align="center">// 注释应以空格开头</td></tr><tr><td>4</td><td>for (… in …) statements must be filtered with an if statement</td><td align="center">for in 循环体内应有if判断属性是否存在</td></tr><tr><td>5</td><td>Declaration of instance field not allowed after declaration of instance method. Instead, this should come at the beginning of the class/interface.</td><td align="center">class/interface的属性定义应放在方法前</td></tr><tr><td>6</td><td>Declaration of static method not allowed after declaration of instance method. Instead, this should come after instance fields.</td><td align="center">class/interface的静态方法定义应放在非静态方法前</td></tr><tr><td>7</td><td>Shadowed variable</td><td align="center">变量名重名</td></tr><tr><td>8</td><td>Missing radix parameter</td><td align="center">parseInt缺少转换基数，直接第二个参数为0即可</td></tr><tr><td>9</td><td>Class name must be in pascal case</td><td align="center">class类命名必须首字母大写</td></tr><tr><td>10</td><td>file should end with a newline</td><td align="center">文件末尾少个空行</td></tr><tr><td>11</td><td>Type ‘string’ is not assignable to type ‘number’</td><td align="center">接口规定的是number类型不是字符串类型</td></tr></tbody></table><blockquote><p>参考链接<a href="http://blog.dongsj.cn/20170715-team-review.html" target="_blank" rel="noopener">目前 Angular2 项目内的 TSLint 设置</a></p></blockquote><h2 id="ts中的type和interface区别"><a href="#ts中的type和interface区别" class="headerlink" title="ts中的type和interface区别"></a>ts中的type和interface区别</h2><p>interface 和 type interface 和 type 都可以用来定义一些复杂的类型结构，最很多情况下是通用的，最初我一直没能理解它们二者之间区别在哪里，后来发现，二者的区别在于：</p><ul><li>type 不能像 interface 那样合并，其在作用域内唯一</li><li>interface创建了一种新的类型，而 type 仅仅是别名，是一种引用；</li><li>如果 type 使用了 union operator （|） 操作符，则不能将 type implements 到 class 上；</li><li>如果 type 使用了 union（|） 操作符 ，则不能被用以 extends interface</li></ul><h2 id="interface阔以，type不行"><a href="#interface阔以，type不行" class="headerlink" title="interface阔以，type不行"></a>interface阔以，type不行</h2><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。</p><ul><li>优点一是可以对可能存在的属性进行预定义</li><li>优点二是可以捕获引用了不存在的属性时的错误<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Chart &#123;</span><br><span class="line">  Num: <span class="built_in">number</span>;</span><br><span class="line">  Type?: <span class="built_in">string</span>[];</span><br></pre></td></tr></table></figure><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3>初次创建的时候赋值，其他时候不允许再次赋值，在属性前用<code>readonly</code>指定<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  readonly x: <span class="built_in">number</span>;</span><br><span class="line">  readonly y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="额外属性检查"><a href="#额外属性检查" class="headerlink" title="额外属性检查"></a>额外属性检查</h3>当你不确定接口会有哪些其他的属性的时候，阔以用一个<code>字符串</code>索引签名<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  readonly x: <span class="built_in">number</span>;</span><br><span class="line">  readonly y: <span class="built_in">number</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Declaration-merging-type-不能像-interface-那样合并"><a href="#Declaration-merging-type-不能像-interface-那样合并" class="headerlink" title="Declaration merging, type 不能像 interface 那样合并"></a>Declaration merging, type 不能像 interface 那样合并</h3>接口阔以定义多次，而类型别名则不行<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> data &#123;</span><br><span class="line">  x: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> data &#123;</span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> serF: SearchFunc</span><br><span class="line">serF = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = source.search(subString);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配,这样也想<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> serF: SearchFunc</span><br><span class="line">serF = <span class="function"><span class="keyword">function</span>(<span class="params">sou: <span class="built_in">string</span>, sub: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = sou.search(sub);</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可索引类型"><a href="#可索引类型" class="headerlink" title="可索引类型"></a>可索引类型</h3>索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> dataArray &#123;</span><br><span class="line">  [index: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr:dataArray = [</span><br><span class="line">  <span class="string">'chen'</span>,</span><br><span class="line">  <span class="string">'peng'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>上面例子里，我们定义了dataArray接口，它具有索引签名。 这个索引签名表示了当用 <code>number</code> 去索引dataArray时会得到string类型的返回值。<blockquote><p>TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberDictionary &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  length: <span class="built_in">number</span>;    <span class="comment">// 可以，length是number类型</span></span><br><span class="line">  name: <span class="built_in">string</span>       <span class="comment">// 错误，`name`的类型与索引类型返回值的类型不匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><ul><li>实现接口<br>TypeScript也能够用它来明确的强制一个类去符合某种契约,用<code>implements</code>实现接口<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">    setTime(d: <span class="built_in">Date</span>); <span class="comment">// 在接口中描述一个方法，在类里实现它，如同下面的setTime方法一样：</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">    setTime(d: <span class="built_in">Date</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.currentTime = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>类静态部分与实例部分的区别<br>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名(new )去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</li></ul><p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只对其实例部分进行类型检查</span></span><br><span class="line"><span class="keyword">interface</span> ClockConstructor &#123;</span><br><span class="line">    <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockConstructor &#123;</span><br><span class="line">    currentTime: <span class="built_in">Date</span>;</span><br><span class="line">    <span class="comment">// constructor存在于类的静态部分，所以不在检查的范围内</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口， ClockConstructor为构造函数所用和ClockInterface为实例方法所用。 为了方便我们定义一个构造函数 createClock，它用传入的类型创建实例。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数所用，这里用interface会报错？类的静态部分</span></span><br><span class="line"><span class="keyword">type</span> PerConstructor = <span class="keyword">new</span> (name: <span class="built_in">string</span>, age: <span class="built_in">number</span>) =&gt; PerInterface;</span><br><span class="line"><span class="comment">// 实例部分</span></span><br><span class="line"><span class="keyword">interface</span> PerInterface &#123;</span><br><span class="line">  sayName(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">ctor: PerConstructor, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>): <span class="title">PerInterface</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ctor(name, age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> P1Type <span class="keyword">implements</span> PerInterface &#123;</span><br><span class="line">  <span class="keyword">public</span> name!: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">public</span> age!: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`call sayName: <span class="subst">$&#123;(<span class="keyword">this</span> <span class="keyword">as</span> <span class="built_in">any</span>).name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为createPerson的第一个参数是PerConstructo类型，在createPerson(P1Type, 7, 32)里，会检查P1Type是否符合构造函数签名。</p><h4 id="访问修饰符：private、public、protected"><a href="#访问修饰符：private、public、protected" class="headerlink" title="访问修饰符：private、public、protected"></a>访问修饰符：private、public、protected</h4><ul><li>默认为public，public规定的属性必须在类的顶层</li><li>当成员被标记为private时，它就不能在声明它的类的外部访问</li><li>protected和private类似，但是，protected成员在派生类(子类)中可以访问。这是protected和privat最大的区别</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">interface</span> ClockInter &#123;</span><br><span class="line">  setTime(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ClockParent <span class="keyword">implements</span> ClockInter &#123;</span><br><span class="line">  <span class="keyword">public</span> currentTime!: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">protected</span> habit = <span class="string">'shufa'</span>; <span class="comment">// 受保护的属性</span></span><br><span class="line">  <span class="comment">// 限定于属性 在定义方法</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentTime = h</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> setTime() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'d'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出一个Clock 类 继承父类 并通过ClockInter实现接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Clock <span class="keyword">extends</span> ClockParent <span class="keyword">implements</span> ClockInter &#123;</span><br><span class="line">  <span class="keyword">public</span> currentTime!: <span class="built_in">any</span>;</span><br><span class="line">  <span class="comment">// 限定于属性 在定义方法</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>((<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime());</span><br><span class="line">    <span class="keyword">this</span>.currentTime = h</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> setTime() &#123;</span><br><span class="line">    <span class="comment">// 能访问受保护的属性 habit</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'d'</span>, <span class="keyword">this</span>.habit);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，Clock是一个 派生类，它派生自 ClockParent 基类，通过 extends关键字。 派生类通常被称作<em>子类</em>，基类通常被称作<em>超类</em>。<br>派生类包含了一个构造函数，它 必须调用 <em>super()</em>，它会执行基类的构造函数。 而且，在构造函数里访问 this的属性之前，我们 一定要调用 super()。 这个是TypeScript强制执行的一条重要规则。</p><blockquote><p>一个ts文件不能同时定义2个及以上的类？添加tslint.json中的规则即可</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"rules": &#123;</span><br><span class="line">  "max-classes-per-file": [</span><br><span class="line">    true,</span><br><span class="line">    <span class="number">2</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。主要<strong>type</strong>类型别名，也阔以继承，语法稍有不同</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape &#123;</span><br><span class="line">  sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> square = &#123;&#125; <span class="keyword">as</span> Square;</span><br><span class="line">square.color = <span class="string">'red'</span>;</span><br><span class="line">square.sideLength1 = <span class="number">10</span>;</span><br><span class="line">square.name = <span class="string">'cpp'</span></span><br></pre></td></tr></table></figure><p>也阔以继承多个接口</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Shape2 &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, Shape2 &#123;</span><br><span class="line">  sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> square = &#123;&#125; <span class="keyword">as</span> Square;</span><br><span class="line">  square.color = <span class="string">'red'</span>;</span><br><span class="line">  square.name = <span class="string">'cpp'</span>;</span><br><span class="line">  square.sideLength = <span class="number">22</span></span><br></pre></td></tr></table></figure><h3 id="关键字implements有什么作用？"><a href="#关键字implements有什么作用？" class="headerlink" title="关键字implements有什么作用？"></a>关键字<code>implements</code>有什么作用？</h3><p>一句话即: 约束接口按照某种契约，举例说明</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implements的实现</span></span><br><span class="line"><span class="keyword">interface</span> ClockInter &#123;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  setTime(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInter &#123;</span><br><span class="line">  <span class="comment">// 如果age = '1111' Type 'string' is not assignable to type 'number'.</span></span><br><span class="line">  <span class="keyword">public</span> age = <span class="number">1111</span>;</span><br><span class="line">  <span class="comment">// !非空断言操作符 能确定变量一定不为空时使用</span></span><br><span class="line">  <span class="comment">// 非空断言操作符不会防止出现 null 或 undefined</span></span><br><span class="line">  <span class="keyword">public</span> currentTime!: <span class="built_in">any</span>;</span><br><span class="line">  <span class="comment">// 限定于属性 在定义方法</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentTime = h</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> setTime() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'d'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中ClockInter约束了age必须是数字类型，所以在通过ClockInter实现Clock这个类的时候，age必须按照接口定义的来约束。<br>如何引用这个<code>Clock</code>这个类呢，在<em>vue</em>文件直接import导入，然后new调用即可，如</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Clock &#125; <span class="keyword">from</span> <span class="string">'../../utils/implementsd2'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> HomeDem <span class="keyword">extends</span> Vue &#123;</span><br><span class="line">  <span class="keyword">private</span> person1: <span class="built_in">any</span> = <span class="string">''</span></span><br><span class="line">  <span class="keyword">private</span> mounted() &#123;</span><br><span class="line">    <span class="keyword">const</span> num =  (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line">    <span class="comment">// 创造一个实例并传入当前的时间戳</span></span><br><span class="line">    <span class="keyword">this</span>.person1 = <span class="keyword">new</span> Clock(num)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1'</span>, <span class="keyword">this</span>.person1);</span><br><span class="line">    <span class="keyword">this</span>.person1.setTime(num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Type类型别名"><a href="#Type类型别名" class="headerlink" title="Type类型别名"></a>Type类型别名</h3><p>type 会给一个类型起个新名字。 type 有时和 interface 很像，但是可以作用于原始值（基本类型），联合类型，元组以及其它任何你需要手写的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数所用，这里用interface会报错？</span></span><br><span class="line"><span class="keyword">type</span> PerConstructor = <span class="keyword">new</span> (name: <span class="built_in">string</span>, age: <span class="built_in">number</span>) =&gt; PerInterface;</span><br><span class="line"><span class="comment">// 实例所用</span></span><br><span class="line"><span class="keyword">interface</span> PerInterface &#123;</span><br><span class="line">  sayName(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>起别名不会新建一个类型 - 它创建了一个<code>新名字</code>来引用那个类型。给基本类型起别名通常没什么用，尽管可以做为文档的一种形式使用。</p><h3 id="interface-vs-type"><a href="#interface-vs-type" class="headerlink" title="interface vs type"></a>interface vs type</h3><ul><li><p>两者都可以用来描述对象或函数的类型，但是语法不同</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SetPoint = <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">interface</span> SetPoint &#123;</span><br><span class="line">   (x: <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tuple</span></span><br><span class="line"><span class="keyword">type</span> Data = [<span class="built_in">number</span>, <span class="built_in">string</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// dom</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">type</span> B = <span class="keyword">typeof</span> div;</span><br></pre></td></tr></table></figure></li><li><p>继承Extend<br>语法有所不同，interface继承用extends,type用 <em>&amp;</em> 继承</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PartialPointX = &#123; x: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="keyword">type</span> Point = PartialPointX &amp; &#123; y: <span class="built_in">number</span>; &#125;;</span><br></pre></td></tr></table></figure></li><li><p>class implements实现接口<br>类可以以相同的方式实现接口或类型别名。但是请注意，类和接口被认为是静态的。因此，它们不能实现/扩展命名联合类型的类型别名。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PartialPoint = &#123; x: <span class="built_in">number</span>; &#125; | &#123; y: <span class="built_in">number</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">FIXME:</span> can not implement a union type</span></span><br><span class="line"><span class="keyword">class</span> SomePartialPoint <span class="keyword">implements</span> PartialPoint &#123;</span><br><span class="line">  x: <span class="number">1</span>;</span><br><span class="line">  y: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>declaration mergeing</p></li></ul><p>与类型别名不同，接口可以定义多次，并将被视为单个接口(合并所有声明的成员)</p><ul><li>计算属性，生成映射类型<br>type 能使用 in 关键字生成映射类型，但 interface 不行。<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Keys = <span class="string">"firstname"</span> | <span class="string">"surname"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DudeType = &#123;</span><br><span class="line">  [key <span class="keyword">in</span> Keys]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test: DudeType = &#123;</span><br><span class="line">  firstname: <span class="string">"Pawel"</span>,</span><br><span class="line">  surname: <span class="string">"Grzybek"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="comment">//interface DudeType2 &#123;</span></span><br><span class="line"><span class="comment">//  [key in keys]: string</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>参考链接</p><ul><li><a href="https://www.tslang.cn/docs/handbook/interfaces.html" target="_blank" rel="noopener">tsHandBook</a></li><li><a href="https://juejin.im/post/5e889626f265da480c0315d8" target="_blank" rel="noopener">TypeScript 中 interface 和 type 使用区别介绍</a></li></ul><h2 id="webpack中的externals配置使用"><a href="#webpack中的externals配置使用" class="headerlink" title="webpack中的externals配置使用"></a>webpack中的externals配置使用</h2><h3 id="官网解释"><a href="#官网解释" class="headerlink" title="官网解释"></a>官网解释</h3><p>webpack 中的 externals 配置提供了不从 bundle 中引用依赖的方式。解决的是，所创建的 bundle 依赖于那些存在于用户环境(consumer environment)中的依赖。</p><p>意思是如果需要引用一个库，但是又不想让webpack打包（减少打包的时间），并且又不影响我们在程序中以CMD、AMD或者window/global全局等方式进行使用（一般都以import方式引用使用），那就可以通过配置externals;</p><h3 id="Vue项目中如何实践"><a href="#Vue项目中如何实践" class="headerlink" title="Vue项目中如何实践"></a>Vue项目中如何实践</h3><ul><li>在vue.config.js中更改<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  configureWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">      config.externals = &#123;</span><br><span class="line">        echarts: <span class="string">'echarts'</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在<em>index.html</em>中引入vue.js,通过cdn方式或者本地资源引入都行</li></ul><h3 id="externals和libraryTarget的关系"><a href="#externals和libraryTarget的关系" class="headerlink" title="externals和libraryTarget的关系"></a>externals和libraryTarget的关系</h3><ul><li>libraryTarget配置如何暴露 library。如果不设置library,那这个library就不暴露。就相当于一个自执行函数</li><li>externals是决定的是以哪种模式去加载所引入的额外的包</li><li>libraryTarget决定了你的library运行在哪个环境，哪个环境也就决定了你哪种模式去加载所引入的额外的包。也就是说，externals应该和libraryTarget保持一致。library运行在浏览器中的，你设置externals的模式为commonjs，那代码肯定就运行不了了。</li><li>如果是应用程序开发，一般是运行在浏览器环境libraryTarget可以不设置，externals默认的模式是global，也就是以全局变量的模式加载所引入外部的库。</li></ul><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://www.jianshu.com/p/283b17d17b3c" target="_blank" rel="noopener">webpack 的externals配置</a></li></ul><h2 id="https和http协议的区别"><a href="#https和http协议的区别" class="headerlink" title="https和http协议的区别"></a>https和http协议的区别</h2><h3 id="HTTP和HTTPS的基本概念"><a href="#HTTP和HTTPS的基本概念" class="headerlink" title="HTTP和HTTPS的基本概念"></a>HTTP和HTTPS的基本概念</h3><p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，是http协议身披一层SSL(Secure Socket Layer，安全套阶 层)协议，SSL这层协议存在于应用层（http层）到TCP层之间:</p><p><strong>应用层(http) =&gt; ssl =&gt; TCP =&gt; IP</strong></p><p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p><h3 id="HTTP缺点"><a href="#HTTP缺点" class="headerlink" title="HTTP缺点"></a>HTTP缺点</h3><ul><li>明文传输，私密信息已被窃取</li><li>无法验证通信者身份，可能存储伪装者(客户端和服务器)</li><li>http协议无法判断通信报文的完整性，通信报文在TCP/IP协议通信中可能会被篡改<br>http协议的缺点，只能是ssl协议来完成</li></ul><h3 id="HTTPS使用SSL（Secure-Scocket-Layer-，安全套阶层）和TLS-Transport-Layer-Secure，安全层传输协议-这两种协议。"><a href="#HTTPS使用SSL（Secure-Scocket-Layer-，安全套阶层）和TLS-Transport-Layer-Secure，安全层传输协议-这两种协议。" class="headerlink" title="HTTPS使用SSL（Secure Scocket Layer ，安全套阶层）和TLS(Transport Layer Secure，安全层传输协议)这两种协议。"></a>HTTPS使用SSL（Secure Scocket Layer ，安全套阶层）和TLS(Transport Layer Secure，安全层传输协议)这两种协议。</h3><p>IETF 以 SSL3.0 为基准，后又制定了 TLS1.0、TLS1.1 和TLS1.2。TSL 是以 SSL 为原型开发的协议，有时会统一称该协议 为 SSL。当前主流的版本是 SSL3.0 和 TLS1.0。由于 SSL1.0 协议在设计之初被发现出了问题，就没有实际投入 使用。SSL2.0 也被发现存在问题，所以很多浏览器直接废除了 该协议版本。</p><p><strong>HTTP + 认证 + 加密 + 完整性保护 = HTTPS</strong></p><h3 id="HTTPS和HTTP的区别主要如下："><a href="#HTTPS和HTTP的区别主要如下：" class="headerlink" title="HTTPS和HTTP的区别主要如下："></a>HTTPS和HTTP的区别主要如下：</h3><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl(Secure Scocket Layer 安全套阶层)加密传输协议。</p><p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者默认是80，后者默认是443。</p><p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h3 id="HTTPS优点"><a href="#HTTPS优点" class="headerlink" title="HTTPS优点"></a>HTTPS优点</h3><ul><li>seo方面<br>采用https的网站在搜索结果的排名中较高</li><li>安全性</li></ul><p>1.使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；<br>2.TTPS协议是由<em>SSL+HTTP</em>协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。<br>3.HTTPS是现行架构下最安全的解决方案，虽然不是<em>绝对安全</em>，但它大幅增加了中间人攻击的成本。</p><h3 id="HTTPS缺点"><a href="#HTTPS缺点" class="headerlink" title="HTTPS缺点"></a>HTTPS缺点</h3><ul><li><p>seo方面<br>使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电，此外，HTTPS协议还会影响缓存，增加数据开销和功耗，甚至已有安全措施也会受到影响也会因此而受到影响</p></li><li><p>经济方面</p></li></ul><p>1.ca证书需要费用<br>2.ssl证书需要绑定ip，不能在同一个IP上绑定多个域名<br>3.https连接缓存不如http高效，大流量网站不一定非要https<br>4.HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本</p><ul><li>使用ssl协议，处理速度会变得很慢<br>一种是指通信慢。另一种是指由于大量消耗CPU 及内存等资源，导致处理速度变慢。<br>由于https还需要做服务器/客户端加密以及解密处理，因此肯定会消耗CPU和内存等硬件资源。</li></ul><p>参考链接</p><ul><li><a href="http://www.mahaixiang.cn/internet/1233.html" target="_blank" rel="noopener">HTTP与HTTPS的区别</a></li><li><a href="https://juejin.im/post/5c1c9b50f265da616e4c695e" target="_blank" rel="noopener">前端面试http和https的区别</a></li><li><a href="https://juejin.im/post/5af3e002f265da0b7c074ada" target="_blank" rel="noopener">http与https的区别我真的知道吗</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> vue </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> vue </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础: 前端重学(1)</title>
      <link href="/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-1/"/>
      <url>/2020/07/18/%E5%9F%BA%E7%A1%80-%E5%89%8D%E7%AB%AF%E9%87%8D%E5%AD%A6-1/</url>
      
        <content type="html"><![CDATA[<p>五一假期安排</p><ul><li>防抖和节流函数</li><li>new 构造函数实例</li><li>手写apply</li><li>单例模式以及vue单组件</li><li>vue3的demo实现</li><li>继承</li></ul><a id="more"></a><h2 id="函数防抖和节流"><a href="#函数防抖和节流" class="headerlink" title="函数防抖和节流"></a>函数防抖和节流</h2><p>都阔以用于持续触发函数的优化中，防抖是，触发事件后n秒内，函数只能执行一次。如果在N秒内又重新触发，则需要重新计时开始。或者简洁点：连续触发的时候，只会执行一次。在停止N秒之后才能继续执行，典型的案例就是防止多次提交的按钮</p><p>而节流呢，是每间隔N秒，只执行一次。就像水龙头里的水，节流只能减缓水流，但事件依然会执行。频率变少了。典型案例是滚动scroll/resize事件</p><p>两者最大的区别就是节流是依然执行，可用于滚动事件。而防抖，如果一直在触发中，只有停下来的时候才会执行一次。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 防抖</span></span><br><span class="line"><span class="comment"> * @param fn </span></span><br><span class="line"><span class="comment"> * @param wait </span></span><br><span class="line"><span class="comment"> * @param immedate 是否立即执行 true 立即执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> debounce = <span class="function">(<span class="params">fn: <span class="built_in">any</span>, wait: <span class="built_in">number</span> = 1000, immedate: <span class="built_in">boolean</span> = <span class="literal">true</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout: <span class="built_in">any</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self: <span class="built_in">any</span> = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">      clearTimeout(timeout)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (immedate) &#123;</span><br><span class="line">      <span class="keyword">const</span> callNow = !timeout</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        timeout = <span class="literal">null</span></span><br><span class="line">      &#125;, wait)</span><br><span class="line">      <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">        fn.apply(self, args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        fn.apply(self, args)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>防抖函数，主要是采用异步线程setTimeout进行延时执行,立即执行，是在触发事件的开始的时候就立即执行。而非立即执行版的防抖，就是执行完N秒之后，不触发事件才会执行<br>箭头函数没有自己的arguments,但是阔以通过命名参数的形式或者rest参数的形式传参</p></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖 非立即执行</span></span><br><span class="line">    <span class="keyword">const</span> DivD: <span class="built_in">any</span> = <span class="built_in">document</span>.getElementById(<span class="string">'Test'</span>)</span><br><span class="line">    DivD.addEventListener(<span class="string">'mousemove'</span>, debounce(<span class="keyword">this</span>.dataSetting, <span class="number">1000</span>, <span class="literal">false</span>), <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><blockquote><p>addEventListener的第二个参数实际上是debounce函数里return回的方法，let timeout = null 这行代码只在addEventListener的时候执行了一次 触发事件的时候不会执行，那么每次触发scroll事件的时候都会清除上次的延时器同时记录一个新的延时器，当scroll事件停止触发后最后一次记录的延时器不会被清除可以延时执行，这是debounce函数的原理</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 函数节流</span></span><br><span class="line"><span class="comment"> * @param fn 执行函数</span></span><br><span class="line"><span class="comment"> * @param wait 等待的时间</span></span><br><span class="line"><span class="comment"> * @param type 默认是1 时间戳版 2定时器版</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn: <span class="built_in">any</span>, wait: <span class="built_in">number</span> = 1000, <span class="keyword">type</span>: <span class="built_in">number</span> = 1</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> timeout: <span class="built_in">any</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 时间戳版</span></span><br><span class="line">      <span class="keyword">const</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">      <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">        fn.apply(context, args);</span><br><span class="line">        previous = now</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">type</span> ===<span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">// 定时器版</span></span><br><span class="line">      <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">        timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          timeout = <span class="literal">null</span></span><br><span class="line">          fn.apply(context, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>节流最大的特点就是减少事件的频率，可能由1毫秒到1000毫秒才能触发事件。事件依然会执行，频率变少。时间戳版和定时器版各有特色，都是满足一个假设条件才能执行事件，执行事件都是用apply绑定</p></blockquote><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节流 定时器版</span></span><br><span class="line"><span class="keyword">const</span> iframe4: <span class="built_in">any</span> = <span class="built_in">document</span>.getElementById(<span class="string">'Test4'</span>)</span><br><span class="line">iframe4.addEventListener(<span class="string">'mousemove'</span>, throttle(<span class="keyword">this</span>.dataSetting, <span class="number">1000</span>, <span class="number">2</span>), <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h2 id="new-构造函数和模拟实现"><a href="#new-构造函数和模拟实现" class="headerlink" title="new 构造函数和模拟实现"></a>new 构造函数和模拟实现</h2><h3 id="如何理解执行上下文"><a href="#如何理解执行上下文" class="headerlink" title="如何理解执行上下文"></a>如何理解执行上下文</h3><p>context主要指代码执行环境，分为</p><ul><li>全局执行环境</li><li>函数执行环境</li><li>eval执行环境</li></ul><p>每一段js代码执行，都会先创建一个上下文环境</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域其实可理解为该上下文中声明的 <em>变量和声明的作用范围</em>。可分为 块级作用域 和 函数作用域</p><h3 id="如何理解作用域链"><a href="#如何理解作用域链" class="headerlink" title="如何理解作用域链"></a>如何理解作用域链</h3><p>我们知道，我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含 父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。</p><p>由两部分组成:</p><ul><li>[[scope]]属性: 指向父级变量对象和作用域链，也就是包含了父级的[[scope]]和AO</li><li>AO: 自身活动对象<br>如此 [[scope]]包含[[scope]]，便自上而下形成一条 链式作用域。</li></ul><p>从当前环境向父级一层一层查找<em>变量</em>的过程</p><ul><li><a href="https://juejin.cn/post/6844903776512393224#heading-18" target="_blank" rel="noopener">参考链接</a></li></ul><h3 id="如何理解原型链"><a href="#如何理解原型链" class="headerlink" title="如何理解原型链"></a>如何理解原型链</h3><p>前期: 每个函数都有prototype属性，每个函数实例对象都有一个<strong>proto</strong>对象，而这个对象指向函数的protoType属性。<br>当我们访问实例对象的属性或者方法时，首先从自身构造函数中查找，如果没有就通过<em><strong>proto</strong></em>去原型上查找，这个查找的过程我们称之为原型链。</p><h3 id="new-做了哪些操作"><a href="#new-做了哪些操作" class="headerlink" title="new 做了哪些操作"></a>new 做了哪些操作</h3><p>1.创建了一个新对象<br>2.这个对象也就是构造函数中的this,阔以访问挂载在this上的任意属性<br>3.这个对象还能访问构造函数原型上的属性，需要将对象与构造函数链接起来<br>4.默认返回this，如果手动定义返回原始值不影响，返回对象需要正常处理</p><p>手动实现一个new 操作符</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 手动实现一个new操作符</span></span><br><span class="line"><span class="comment"> * @param &#123;Funtion&#125; Con 构造函数</span></span><br><span class="line"><span class="comment"> * @param &#123;Array&#125; args 参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Create = <span class="function">(<span class="params">Con: <span class="built_in">any</span>, ...args: <span class="built_in">any</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 验证构造函数是否是函数类型</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> Con !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">'Create Function this first param must be a function'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 继承Con原型上的prototype属性,又称原型上继承</span></span><br><span class="line">  <span class="keyword">const</span> obj: <span class="built_in">any</span> = <span class="built_in">Object</span>.create(Con.prototype);</span><br><span class="line">  <span class="comment">// or obj.__proto__ = Con.prototype</span></span><br><span class="line">  <span class="comment">// or Object.setPrototypeOf(obj, Con.prototype)</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'constructor'</span>, Con);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'obj'</span>, obj);</span><br><span class="line">  <span class="comment">// 除去构造函数的其他参数</span></span><br><span class="line">  <span class="comment">// 生成新的对象要绑定到构造函数上this对象上，并且传入剩余的参数</span></span><br><span class="line">  <span class="keyword">const</span> res = Con.apply(obj, args)</span><br><span class="line">  <span class="comment">// 如果返回是对象就是对象,否则返回obj</span></span><br><span class="line">  <span class="comment">// 默认构造函数返回的是undefined</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">'object'</span> ? res : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="create说明"><a href="#create说明" class="headerlink" title="create说明"></a>create说明</h4><p>1.接受构造函数和其他参数<br>2.创建obj对象，同时要继承构造函数的原型链上的属性和方法，所以我们通过 Object.create(Con.prototype)实现，或者通过<br>setPrototypeOf 将两者联系起来。这段代码等同于 <strong>obj.<strong>proto</strong> = Con.prototype</strong>，即继承构造函数的原型链上的属性和方法有三种</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(Con.prototype)</span><br><span class="line"><span class="comment">// second 原型链继承</span></span><br><span class="line">obj.__proto__ = Con.prototype</span><br><span class="line"><span class="comment">// third</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, Con.prototype)</span><br></pre></td></tr></table></figure><p>3.生成新的对象会绑定到构造函数上this对象上，并且传入剩余的参数即</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Con方法绑定this对象，这里的this即obj</span></span><br><span class="line"><span class="keyword">const</span> res = Con.apply(obj, args)</span><br></pre></td></tr></table></figure><p>4.返回值处理</p><p>用法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private mounted() &#123;</span><br><span class="line">  <span class="comment">// 箭头函数不能通过new关键字调用</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">this: any, name: any</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.habits = <span class="string">'Games'</span></span><br><span class="line">  &#125;</span><br><span class="line">  Person.prototype.age = <span class="number">30</span>;</span><br><span class="line">  Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sayName: i am'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建person1实例</span></span><br><span class="line">  <span class="keyword">this</span>.person1 = <span class="keyword">new</span> (Person <span class="keyword">as</span> any)(<span class="string">'cpp'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'typeof'</span>, <span class="keyword">typeof</span> Person);</span><br><span class="line">  <span class="comment">// 实例对象上的__proto__</span></span><br><span class="line">  <span class="comment">// console.log('__proto__', this.person1.__proto__);</span></span><br><span class="line">  <span class="comment">// console.log('prototype', Person.prototype);</span></span><br><span class="line">  <span class="comment">// 实例对象上的__proto__ 全等于 构造函数的原型</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'==='</span>,  <span class="keyword">this</span>.person1.__proto__ === Person.prototype);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'constructor'</span>, Person.prototype.constructor === Person);</span><br><span class="line">  <span class="keyword">this</span>.person1.sayName();</span><br><span class="line">  <span class="comment">// 模拟new的实现</span></span><br><span class="line">  <span class="keyword">const</span> person2 = Create(Person, <span class="string">'cpp222'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p2'</span>, person2.name);</span><br><span class="line">  person2.sayName()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟new简洁版</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Create</span>(<span class="params">Con, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个对象，继承构造函数上的原型属性</span></span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(Con.prototype);</span><br><span class="line">  <span class="comment">// 绑定到this上</span></span><br><span class="line">  <span class="keyword">const</span> res = Con.apply(obj, agrs)</span><br><span class="line">  <span class="keyword">return</span> res instanceOf <span class="string">'Object'</span> ? res : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="apply-amp-amp-call-amp-amp-bind-手动实现"><a href="#apply-amp-amp-call-amp-amp-bind-手动实现" class="headerlink" title="apply &amp;&amp; call &amp;&amp; bind()手动实现"></a>apply &amp;&amp; call &amp;&amp; bind()手动实现</h2><h3 id="call-用法"><a href="#call-用法" class="headerlink" title="call 用法"></a>call 用法</h3><blockquote><p>call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p></blockquote><p>说起来有点拗口，就是指定this值，调用某个函数<br>举例子:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar函数--this'</span>, <span class="keyword">this</span>); <span class="comment">// &#123;value: 'chendapepeng'&#125; 指向foo</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar函数--this.value'</span>, <span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  value: <span class="string">'cpp'</span>,</span><br><span class="line">&#125;</span><br><span class="line">bar.call(foo, <span class="string">'chendapeng'</span>, <span class="number">30</span>); <span class="comment">// 执行bar函数，且传参</span></span><br></pre></td></tr></table></figure><p>注意两点：</p><ul><li>call 改变了<strong>this</strong>的指向，指向到 foo</li><li>bar 函数执行了</li></ul><h3 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h3><p>假设这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  value: <span class="string">'cpp'</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo.bar(); <span class="comment">// 'cpp'</span></span><br></pre></td></tr></table></figure><p>但是这样多了一个属性，但是阔以删除,大体分为这几步,简单版的myCall</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCall</span>(<span class="params">con</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> context = con || <span class="built_in">window</span>; <span class="comment">// 相当于foo</span></span><br><span class="line">  context.fn = <span class="keyword">this</span> <span class="comment">// foo.bar</span></span><br><span class="line">  context.fn()</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar函数--this'</span>, <span class="keyword">this</span>); <span class="comment">// &#123;value: 'chendapepeng'&#125; 指向foo</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar函数--this.value'</span>, <span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  value: <span class="string">'cpp'</span>,</span><br><span class="line">&#125;</span><br><span class="line">Funtion.prototype.myCall = myCall</span><br><span class="line">bar.myCall(foo)</span><br></pre></td></tr></table></figure><h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><p>call 函数还能给定参数执行函数,直接上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mockCall: <span class="function"><span class="keyword">function</span> (<span class="params">con, ...args</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> context = con || <span class="built_in">window</span>;</span><br><span class="line">   <span class="comment">// 首先获取调用call的函数，比如bar.call(foo),就是bar函数</span></span><br><span class="line">   context.fn = <span class="keyword">this</span>;</span><br><span class="line">   context.fn(...args)</span><br><span class="line">   <span class="comment">// 用完记得删除调用对象里的方法</span></span><br><span class="line">   <span class="keyword">delete</span> context.fn</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><p>bar函数阔以有返回值的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar函数--this'</span>, <span class="keyword">this</span>); <span class="comment">// &#123;value: 'chendapepeng'&#125; 指向foo</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar函数--this.value'</span>, <span class="keyword">this</span>.value);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value: <span class="keyword">this</span>.value,</span><br><span class="line">    name,</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  value: <span class="string">'cpp'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以最终版的就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mockCall: <span class="function"><span class="keyword">function</span> (<span class="params">con, ...args</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> context = con || <span class="built_in">window</span>;</span><br><span class="line">   <span class="comment">// 首先获取调用call的函数，比如bar.call(foo),就是bar函数</span></span><br><span class="line">   context.fn = <span class="keyword">this</span>;</span><br><span class="line">   <span class="keyword">const</span> res = context.fn(...args)</span><br><span class="line">   <span class="comment">// 用完记得删除调用对象里的方法</span></span><br><span class="line">   <span class="keyword">delete</span> context.fn</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><h3 id="bind实现"><a href="#bind实现" class="headerlink" title="bind实现"></a>bind实现</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 模拟bind</span></span><br><span class="line"><span class="comment"> * @param this 调用的方法</span></span><br><span class="line"><span class="comment"> * @param con 当前调用者，对象</span></span><br><span class="line"><span class="comment"> * @param args </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mockBind = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, con: <span class="built_in">any</span>, ...args: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log('mock__this', this);</span></span><br><span class="line">  <span class="comment">// console.log('mock__con', con);</span></span><br><span class="line">  <span class="keyword">const</span> context = con || <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> fbound = <span class="function">(<span class="params">...bindArgs: <span class="built_in">any</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log('context', context);</span></span><br><span class="line">    self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> self ? <span class="keyword">this</span> : context, [...args, ...bindArgs])</span><br><span class="line">  &#125;</span><br><span class="line">  fbound.prototype = <span class="keyword">this</span>.prototype</span><br><span class="line">  <span class="keyword">return</span> fbound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue手动挂载组件"><a href="#Vue手动挂载组件" class="headerlink" title="Vue手动挂载组件"></a>Vue手动挂载组件</h2><p>本文主要有以下内容</p><ul><li><em>Vue.extend()</em></li><li><em>单例模式</em></li><li><em>Vue.use() 和 Vue.prototype.myFunction</em></li></ul><h3 id="挂载组件步骤"><a href="#挂载组件步骤" class="headerlink" title="挂载组件步骤"></a>挂载组件步骤</h3><p>在一些需求中，手动挂载组件能够让我们实现起来更加优雅。比如一个弹窗组件，最理想的用法是通过命令式调用，就像 elementUI 的 this.$message</p><h4 id="vue-extend"><a href="#vue-extend" class="headerlink" title="vue.extend()"></a>vue.extend()</h4><p>使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。预设了部分选项的vue实例构造器，返回一个组件构造器，用来生成组件，可以在实例上扩展方法，从而使用更灵活</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 创建构造器</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> Profile = Vue.extend(&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: '<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123;firstName&#125;&#125;</span><span class="xml"> </span><span class="template-variable">&#123;&#123;lastName&#125;&#125;</span><span class="xml"> aka </span><span class="template-variable">&#123;&#123;alias&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span>',</span></span></span><br><span class="line"><span class="actionscript">    data: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">        firstName: <span class="string">'Walter'</span>,</span></span><br><span class="line"><span class="actionscript">        lastName: <span class="string">'White'</span>,</span></span><br><span class="line"><span class="actionscript">        alias: <span class="string">'Heisenberg'</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="actionscript">  <span class="comment">// 创建 Profile 实例，并挂载到一个app元素上。</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">new</span> Profile().$mount(<span class="string">'#app'</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Walter White aka Heisenberg<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Vue.extend创建的是一个Vue组件构造器，而不是一个具体的组件实例；里面预设了很多vue实例选项</p></blockquote><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>先看一个简单的例子<code>getSingle</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Anima: any = <span class="function"><span class="keyword">function</span>(<span class="params">this: any, name: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> AnimalSingle: any = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> instance: any = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">name: string</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">      <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">return</span> instance = <span class="keyword">new</span> Anima(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">const</span> a1 = <span class="keyword">new</span> AnimalSingle(<span class="string">'cat'</span>)</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="keyword">new</span> AnimalSingle(<span class="string">'dog'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'==='</span>, a1, a2, a1 === a2); <span class="comment">// Anima&#123;name: 'cat'&#125; Anima&#123;name: 'cat'&#125; true</span></span><br></pre></td></tr></table></figure><ul><li>使用闭包封装了instance私有变量并返回一个函数</li><li>利用 || 语法判断如果instance不存在则执行后者的实例化Anima方法，存在则直接返回instance，确保了只存在一个弹框实例<br>实现方式：使用一个变量存储类实例对象（值初始为 null/undefined ）。进行类实例化时，判断类实例对象是否存在，存在则返回该实例，不存在则创建类实例后返回。多次调用类生成实例方法，返回同一个实例对象。</li></ul><h3 id="构建属于自己的封装组件"><a href="#构建属于自己的封装组件" class="headerlink" title="构建属于自己的封装组件"></a>构建属于自己的封装组件</h3><p>用法，首先<em>main.ts</em>中全局引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Toast <span class="keyword">from</span> <span class="string">'./components/Toast/index'</span>;</span><br><span class="line"><span class="comment">// vue.use注册</span></span><br><span class="line"><span class="comment">// Vue.use(Toast);</span></span><br><span class="line">Vue.prototype.$toast = Toast;</span><br></pre></td></tr></table></figure><p>具体的组件用法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private showSuccess() &#123;</span><br><span class="line">  (<span class="keyword">this</span> <span class="keyword">as</span> any).$toast.success(&#123;</span><br><span class="line">    type: <span class="string">'success'</span>,</span><br><span class="line">    content: <span class="string">'这是测试tosat11'</span>,</span><br><span class="line">    duration: <span class="number">2000</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看看如何实现的，主要思路是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> toast <span class="keyword">from</span> <span class="string">'./toast.vue'</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="comment">// Vue.extend()生成一个Vue组件构造器函数，需要new一个实例才行</span></span><br><span class="line"><span class="keyword">const</span> ToastConstructor = Vue.extend(toast);</span><br><span class="line"><span class="keyword">let</span> instance: any = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> Toast: any = <span class="function">(<span class="params">options: any</span>) =&gt;</span> &#123;</span><br><span class="line">  instance = <span class="keyword">new</span> ToastConstructor(&#123;</span><br><span class="line">    data: options</span><br><span class="line">  &#125;).$mount();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'instance'</span>, instance); <span class="comment">// vueCopmponent vue组件实例</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(instance.$el)</span><br><span class="line">&#125;</span><br><span class="line">[<span class="string">'success'</span>, <span class="string">'error'</span>, <span class="string">'info'</span>].forEach(<span class="function">(<span class="params">type: any</span>) =&gt;</span> &#123;</span><br><span class="line">  Toast[type] = <span class="function">(<span class="params">options: any</span>) =&gt;</span> &#123;</span><br><span class="line">    options.type = type;</span><br><span class="line">    <span class="keyword">return</span> Toast(options);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Toast</span><br></pre></td></tr></table></figure><p>如果想在main.ts中Vue.use()引入的话，导出一个传递参数的<code>install</code>方法即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'success'</span>, <span class="string">'error'</span>, <span class="string">'info'</span>].forEach(<span class="function">(<span class="params">type: any</span>) =&gt;</span> &#123;</span><br><span class="line">  Toast[type] = <span class="function">(<span class="params">options: any</span>) =&gt;</span> &#123;</span><br><span class="line">    options.type = type;</span><br><span class="line">    <span class="keyword">return</span> Toast(options);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line">...(上面的都一样，只需暴露一个install方法)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install: <span class="function">(<span class="params">vue</span>) =&gt;</span> &#123;</span><br><span class="line">    vue.prototype.$toast = Toast</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在main.ts中直接引入即可</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Toast <span class="keyword">from</span> <span class="string">'./components/Toast'</span></span><br><span class="line">Vue.use(Toast)</span><br></pre></td></tr></table></figure><p>为啥需要用use才能用，源码看了下，在GlobalAPI下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initUse</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// toast导出的是funtion类型</span></span><br><span class="line">  Vue.use = <span class="function"><span class="keyword">function</span> (<span class="params">plugin: <span class="built_in">Function</span> | <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> installedPlugins = (<span class="keyword">this</span>._installedPlugins || (<span class="keyword">this</span>._installedPlugins = []))</span><br><span class="line">    <span class="comment">// 判断当前的插件是否在installedPlugins集合里，如果有立马返回</span></span><br><span class="line">    <span class="comment">// 解释了多次使用Vue.use()只会运行一次</span></span><br><span class="line">    <span class="keyword">if</span> (installedPlugins.indexOf(plugin) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// additional parameters 额外的参数，像options</span></span><br><span class="line">    <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    args.unshift(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// 如果插件有install，则绑定到plugin,并全传参</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin.install === <span class="string">'function'</span>) &#123;</span><br><span class="line">      plugin.install.apply(plugin, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">'function'</span>) &#123;</span><br><span class="line">      plugin.apply(<span class="literal">null</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    installedPlugins.push(plugin)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert an Array-like object to a real Array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toArray</span> (<span class="params">list, start</span>) </span>&#123;</span><br><span class="line">  start = start || <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> i = list.length - start;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="keyword">new</span> <span class="built_in">Array</span>(i);</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    ret[i] = list[i + start];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Vue.use(plugin)和Vue.prototype.$plugin = Plugin的区别<br>Vue.use(): 插件必须是一个对象，拥有install方法的对象，初始化插件必须有Vue.use()引入。同一个插件多次使用Vue.use()也只会运行一次。且vue.use()必须在new Vue()之前使用。<br>Vue.prototype.$plugin = Plugin: 在Vue组件构造器函数的原型上增加一个方法，运用的是函数原型的特性，即函数原型上的属性和方法，实例都能共享</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p> 与变量解构结合，并隐式返回<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Test1 = <span class="function">(<span class="params">&#123;value, num&#125;: any</span>) =&gt;</span> (&#123;<span class="attr">total</span>: value * num&#125;)</span><br><span class="line"><span class="keyword">const</span> res = Test1(&#123;</span><br><span class="line">  value: <span class="number">100</span>,</span><br><span class="line">  num: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'res'</span>, res);</span><br></pre></td></tr></table></figure><br> 与普通函数的区别</p><h3 id="没有this"><a href="#没有this" class="headerlink" title="没有this"></a>没有this</h3><p>箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值。因为箭头函数没有 this，所以也不能用 call()、apply()、bind() 这些方法改变 this 的指向</p><h3 id="没有arguments"><a href="#没有arguments" class="headerlink" title="没有arguments"></a>没有arguments</h3><p>但命名参数或者 rest 参数的形式访问参数:</p><h3 id="不能通过-new-关键字调用"><a href="#不能通过-new-关键字调用" class="headerlink" title="不能通过 new 关键字调用"></a>不能通过 new 关键字调用</h3><p>当通过 new 调用函数时，执行 <code>[[Construct]]</code> 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上。<br>箭头函数并没有 <code>[[Construct]]</code>方法，不能被用作构造函数，如果通过 new 的方式调用，会报错。<br>于是箭头函数也不存在 prototype 这个属性。</p><h3 id="无new-target"><a href="#无new-target" class="headerlink" title="无new.target"></a>无new.target</h3><p>因为不能使用 new 调用，所以也没有 new.target 值</p><h3 id="哪些场景下不能使用箭头函数"><a href="#哪些场景下不能使用箭头函数" class="headerlink" title="哪些场景下不能使用箭头函数"></a>哪些场景下不能使用箭头函数</h3><p>借鉴知乎大佬王仕军的文章，原文请移步<a href="https://zhuanlan.zhihu.com/p/26540168" target="_blank" rel="noopener">什么时候你不能使用箭头函数？</a></p><h4 id="定义对象里的方法"><a href="#定义对象里的方法" class="headerlink" title="定义对象里的方法"></a>定义对象里的方法</h4><p>在一个对象上，定义一个指向函数的属性，当方法被调用时，方法内的this指向方法所属的对象</p><ul><li><p>定义字面量方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calculator = &#123;</span><br><span class="line">  array: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  sum: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// =&gt; true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.array.reduce(<span class="function">(<span class="params">result, item</span>) =&gt;</span> result + item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="comment">// Throws "TypeError: Cannot read property 'reduce' of undefined"</span></span><br><span class="line">calculator.sum();</span><br></pre></td></tr></table></figure><p>calculator.sum 使用箭头函数来定义，但是调用的时候会抛出 TypeError，因为运行时 this.array 是未定义的，调用 calculator.sum 的时候，执行上下文里面的 this 仍然指向的是 window，原因是箭头函数把函数上下文绑定到了 window 上，this.array 等价于 window.array，显然后者是未定义的。<br>改造普通函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calculator = &#123;</span><br><span class="line">    array: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    sum() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === calculator); <span class="comment">// =&gt; true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.array.reduce(<span class="function">(<span class="params">result, item</span>) =&gt;</span> result + item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">calculator.sum(); <span class="comment">// =&gt; 6</span></span><br></pre></td></tr></table></figure></li><li><p>定义原型方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">any</span>, game: <span class="built_in">string</span> = 'cf'</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.habits = game</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.age = <span class="number">30</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'sayName: i am'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.person1 = <span class="keyword">new</span> (Person <span class="keyword">as</span> <span class="built_in">any</span>)(<span class="string">'cpp'</span>)</span><br></pre></td></tr></table></figure><p>使用传统的函数表达式就能解决问题</p></li></ul><h4 id="定义事件回调函数"><a href="#定义事件回调函数" class="headerlink" title="定义事件回调函数"></a>定义事件回调函数</h4><p>this 是 JS 中很强大的特性，可以通过多种方式改变函数执行上下文，JS 内部也有几种不同的默认上下文指向，但普适的规则是在谁上面调用函数 this 就指向谁，这样代码理解起来也很自然，读起来就像在说，某个对象上正在发生某件事情。</p><p>但是，箭头函数在声明的时候就绑定了执行上下文，要动态改变上下文是不可能的，在需要动态上下文的时候它的弊端就凸显出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'myButton'</span>);</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// =&gt; true</span></span><br><span class="line">    <span class="keyword">this</span>.innerHTML = <span class="string">'Clicked button'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>修正后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'myButton'</span>);</span><br><span class="line">button.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === button); <span class="comment">// =&gt; true</span></span><br><span class="line">    <span class="keyword">this</span>.innerHTML = <span class="string">'Clicked button'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="定义构造函数"><a href="#定义构造函数" class="headerlink" title="定义构造函数"></a>定义构造函数</h4><p>构造新的 Person 实例时，JS 引擎抛了错误,tslint也直接给出了提示<code>An arrow function cannot have a &#39;this&#39; parameter</code>,还有<code>Property &#39;name&#39; does not exist on type &#39;Home&#39;</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person =  <span class="function">(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">any</span>, game: <span class="built_in">string</span> = 'cf'</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.habits = game</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.age = <span class="number">30</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'sayName: i am'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.person1 = <span class="keyword">new</span> (Person <span class="keyword">as</span> <span class="built_in">any</span>)(<span class="string">'cpp'</span>)</span><br></pre></td></tr></table></figure><p>改成普通函数即可</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="借助原型链实现继承"><a href="#借助原型链实现继承" class="headerlink" title="借助原型链实现继承"></a>借助原型链实现继承</h3><p>子类Child的原型属性等价于父类的一个实例，并且传参</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> extendPrototype() &#123;</span><br><span class="line">  <span class="keyword">const</span> Parent: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> Child: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//重点在这句 子类的原型指向的父类的实例</span></span><br><span class="line">  Child.prototype = <span class="keyword">new</span> Parent(<span class="string">'chendapeng'</span>)</span><br><span class="line">  <span class="keyword">const</span> p1 = <span class="keyword">new</span> Parent(<span class="string">'wmh'</span>);</span><br><span class="line">  <span class="keyword">const</span> c1 = <span class="keyword">new</span> Child(<span class="string">'cpp'</span>, <span class="number">30</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1,'</span>, p1);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'c1,'</span>, c1);</span><br><span class="line">  p1.sayName() <span class="comment">// wmh ——this.name——</span></span><br><span class="line">  c1.sayName() <span class="comment">// chendapeng ——this.name——</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类能继承父类的属性和方法<br>缺点:</p><ul><li>创建child类的时候，不能像Parent传参</li><li>子类创建的实例所在的原型链上的属性共享<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private extendPrototype() &#123;</span><br><span class="line">  <span class="keyword">const</span> Parent: any = <span class="function"><span class="keyword">function</span>(<span class="params">this: any, name: string, arr: any</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.arr = arr</span><br><span class="line">  &#125;</span><br><span class="line">  Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="string">'——this.name——'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> Child: any = <span class="function"><span class="keyword">function</span> (<span class="params">this: any, name: string, age: number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  Child.prototype = <span class="keyword">new</span> Parent(<span class="string">'chendapeng'</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">  <span class="keyword">const</span> p1 = <span class="keyword">new</span> Parent(<span class="string">'wmh'</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">  <span class="keyword">const</span> c1 = <span class="keyword">new</span> Child(<span class="string">'cpp'</span>, <span class="number">30</span>);</span><br><span class="line">  c1.arr.push(<span class="number">4</span>)</span><br><span class="line">  <span class="keyword">const</span> c2 = <span class="keyword">new</span> Child(<span class="string">'pp'</span>, <span class="number">99</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1,'</span>, p1.arr); [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'c1,'</span>, c1.arr); <span class="comment">// [1,2,3,4]</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'c2,'</span>, c2.arr); <span class="comment">// [1,2,3,4]</span></span><br><span class="line">  <span class="comment">// p1.sayName() // wmh ——this.name——</span></span><br><span class="line">  <span class="comment">// c1.sayName() // c1.sayName is not a function</span></span><br><span class="line">&#125;</span><br><span class="line">子类实例c1和c2上的arr属性都是从父类继承过来的，改了c1.arr属性,c2.arr也发生了变化</span><br></pre></td></tr></table></figure><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A= &#123;<span class="attr">n</span>: <span class="number">4399</span>&#125;</span><br><span class="line"><span class="keyword">var</span> B = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">this</span>.n = <span class="number">9999</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> C = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">var</span> n = <span class="number">8888</span>&#125;;</span><br><span class="line">B.prototype = A;</span><br><span class="line">C.prototype = A</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B()</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> C()</span><br><span class="line">A.n ++;</span><br><span class="line"><span class="built_in">console</span>.log(b.n) <span class="comment">// 9999</span></span><br><span class="line"><span class="built_in">console</span>.log(c.n) <span class="comment">// 4400</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="借助构造函数继承-经典继承"><a href="#借助构造函数继承-经典继承" class="headerlink" title="借助构造函数继承(经典继承)"></a>借助构造函数继承(经典继承)</h3><p>先看代码，Parent 是父类，Child 是子类。通过 Parent1.call(this, name)  改变了 this 指向，使子类继承了父类的属性，即 Child 也有了 name 属性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> extendConstructor() &#123;</span><br><span class="line">  <span class="keyword">const</span> Parent: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="string">'——this.name——'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> Child: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="comment">// 这里是重点</span></span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> p1 = <span class="keyword">new</span> Parent(<span class="string">'wmh'</span>);</span><br><span class="line">  <span class="keyword">const</span> c1 = <span class="keyword">new</span> Child(<span class="string">'cpp'</span>, <span class="number">30</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'p1,'</span>, p1);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'c1,'</span>, c1);</span><br><span class="line">  p1.sayName() <span class="comment">// wmh ——this.name——</span></span><br><span class="line">  c1.sayName() <span class="comment">// c1.sayName is not a function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点</p><ul><li>这种方式不能继承父类原型链上的属性，只能继承在父类显式声明的属性</li><li>方法都在构造函数中定义，每次创建实例都会创建一遍方法。</li></ul><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> extendTwo() &#123;</span><br><span class="line">   <span class="keyword">const</span> Parent: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.name = name</span><br><span class="line">     <span class="keyword">this</span>.arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   &#125;</span><br><span class="line">   Parent.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="string">'——this.name——'</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">const</span> Child: <span class="built_in">any</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">this</span>: <span class="built_in">any</span>, name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">     Parent.call(<span class="keyword">this</span>, name)</span><br><span class="line">     <span class="keyword">this</span>.age = age</span><br><span class="line">   &#125;</span><br><span class="line">   Child.prototype = <span class="keyword">new</span> Parent(<span class="string">'cpp'</span>)</span><br><span class="line">   <span class="keyword">const</span> c1 = <span class="keyword">new</span> Child(<span class="string">'wmh'</span>, <span class="number">22</span>);</span><br><span class="line">   c1.arr.push(<span class="number">5</span>)  </span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'c1'</span>, c1); <span class="comment">// [1,2,3, 5]</span></span><br><span class="line">   <span class="keyword">const</span> c2 = <span class="keyword">new</span> Child(<span class="string">'cpp'</span>, <span class="number">30</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'c2'</span>, c2); <span class="comment">// [1,2,3,</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p> ES5 <code>Object.create()</code> 的模拟实现，将传入的对象作为创建的对象的原型。根据自己的业务需求，定义自己的原型对象。<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">funtion createObj(o) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 测试下<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.create(&#123;<span class="attr">name</span>: <span class="string">'cpp'</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// name属性放在了首层下的__proto__属性上，</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> &#123;&#125;</span></span><br><span class="line"><span class="comment"> __proto__:</span></span><br><span class="line"><span class="comment">  name: 'cpp'</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">接着用 createObj测试</span><br><span class="line"><span class="keyword">var</span> b = createObj(&#123;<span class="attr">name</span>: <span class="string">'cpp'</span>&#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> &#123;&#125;</span></span><br><span class="line"><span class="comment"> __proto__:</span></span><br><span class="line"><span class="comment">  name: 'cpp'</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1)</span><br></pre></td></tr></table></figure><p>组合继承最大的缺点就是会两次调用父构造函数，<br>一次是子类型实例的原型的时候</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure><p>另外一次是创建子类型的实例的时候</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br></pre></td></tr></table></figure><p>如何避免一次重复调用呢</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line">Child.prototype.constructor = Child</span><br></pre></td></tr></table></figure><p>最后实现寄生组合继承如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child.prototype = new Parent();</span></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">'kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1)</span><br></pre></td></tr></table></figure><blockquote><p><strong>proto</strong>是隐式原型，prototype是显式原型</p></blockquote><h3 id="原型总结"><a href="#原型总结" class="headerlink" title="原型总结"></a>原型总结</h3><p>每个对象都有一个隐式原型，指向该对象的原型。实例化后通过<strong>proto</strong>属性指向构造函数的显式原型prototype,原型链是由原型对象组成，每个对象都有<strong>proto</strong>属性，指向创建该对象的构造函数的原型，通过隐式原型<strong>proto</strong>属性将对象链起来，组成原型链，用来实现属性继承和共享属性</p><h3 id="参考文件"><a href="#参考文件" class="headerlink" title="参考文件"></a>参考文件</h3><ul><li><a href="https://segmentfault.com/a/1190000009389979" target="_blank" rel="noopener">JavaScript深入之继承的多种方式和优缺点</a></li><li><a href="http://louiszhai.github.io/2015/12/15/prototypeChain/#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">详解JS原型链与继承</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
          <category> vue </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> vue </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My First blog</title>
      <link href="/2020/07/05/My-First-blog/"/>
      <url>/2020/07/05/My-First-blog/</url>
      
        <content type="html"><![CDATA[<p>  感谢<a href="https://jerryc.me/posts/21cfbf15/" target="_blank" rel="noopener">Butterfly</a>提供的技术支持,希望自己也能参与到其，<br>  Jerryc个人博客有各种关于主题色彩的设置，<a href="https://demo.jerryc.me/posts/ceeb73f/#CDN" target="_blank" rel="noopener">请移步</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 主题 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/07/05/hello-world/"/>
      <url>/2020/07/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
