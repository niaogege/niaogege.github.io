{"title":"基础知识:前端重学7","slug":"前端基础-汇总","date":"2020-06-20T05:43:12.000Z","updated":"2020-07-05T09:11:15.614Z","comments":true,"path":"api/articles/前端基础-汇总.json","photos":[],"link":"","excerpt":"六月第二周(6.15-6.19)的安排如何利用原型实现继承异步加载js方式有哪些Vue3 compositionApiasync/awaitwebpack初始化工程","covers":null,"content":"<h2 id=\"六月第二周-6-15-6-19-的安排\"><a href=\"#六月第二周-6-15-6-19-的安排\" class=\"headerlink\" title=\"六月第二周(6.15-6.19)的安排\"></a>六月第二周(6.15-6.19)的安排</h2><ul>\n<li>如何利用原型实现继承</li>\n<li>异步加载js方式有哪些</li>\n<li>Vue3 compositionApi</li>\n<li>async/await</li>\n<li>webpack初始化工程<a id=\"more\"></a>\n<h2 id=\"如何利用原型实现继承\"><a href=\"#如何利用原型实现继承\" class=\"headerlink\" title=\"如何利用原型实现继承\"></a>如何利用原型实现继承</h2><h3 id=\"原型式继承\"><a href=\"#原型式继承\" class=\"headerlink\" title=\"原型式继承\"></a>原型式继承</h3>基本思想:<br>借助原型阔以基于已有的对象创建新对象<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createObj</span>(<span class=\"params\">o</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    F.prototype = o.prototype</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\nes5<br>示例:<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">hobbies: [<span class=\"string\">'read'</span>, <span class=\"string\">'watch'</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"built_in\">Object</span>.create(person)</span><br><span class=\"line\">person1.hobbies.push(<span class=\"string\">'shufa'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> p2 = <span class=\"built_in\">Object</span>.create(person)</span><br><span class=\"line\">p2.hobbies.push(<span class=\"string\">'sleep'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.hobbies) <span class=\"comment\">// [\"read\", \"watch\", \"shufa\", \"sleep\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p2.hobbies) <span class=\"comment\">// [\"read\", \"watch\", \"shufa\", \"sleep\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person1.prototype === p2.prototype) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></div></li>\n<li>优点: 在没必要创建构造函数的情况下，仅让一个对象与另一个对象保持相似的情况下，原型式继承不错.新创建的对象原型跟原对象的原型指向同一个指针，所以<strong>person1.prototype === p2.prototype</strong>是true</li>\n<li>缺点: 同原型链实现继承一样，包含引用类型值得属性会被所有实例共享(比如例子里得p2中的hobbies)<h3 id=\"寄生式继承\"><a href=\"#寄生式继承\" class=\"headerlink\" title=\"寄生式继承\"></a>寄生式继承</h3>基本思想: 即创建一个仅用于封装继承过程的函数，该函数在内部已某种方式来增强对象，然后返回该对象<br>实现<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createA</span>(<span class=\"params\">original, name</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">var</span> clone = <span class=\"built_in\">Object</span>.create(original)</span><br><span class=\"line\"> clone.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name, <span class=\"string\">'name'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> clone</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'chenpp'</span>,</span><br><span class=\"line\">    hobbies: [<span class=\"string\">'reading'</span>, <span class=\"string\">'sleep'</span>]</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = createA(person)</span><br><span class=\"line\">p1.sayName(person.name) <span class=\"comment\">// 'chenpp' name</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p1) <span class=\"comment\">// &#123;sayName: f&#125;</span></span><br></pre></td></tr></table></figure></div></li>\n<li>优点: 在考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。</li>\n<li>缺点: 1.使用寄生式继承来为对象添加函数，会由于不能做到函数复用而效率低下。2.同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。<h3 id=\"寄生组合继承\"><a href=\"#寄生组合继承\" class=\"headerlink\" title=\"寄生组合继承\"></a>寄生组合继承</h3>所谓寄生组合式继承，即通过借用构造函数来继承实例属性，通过原型链的混成形式来继承原型属性，基本思路：<br>实例一<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.colors = [<span class=\"string\">'red'</span>, <span class=\"string\">'blue'</span>, <span class=\"string\">'green'</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span> (<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">    Parent.call(<span class=\"keyword\">this</span>, name);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 关键的三步</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">F.prototype = Parent.prototype; <span class=\"comment\">// 原型对原型</span></span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> F(); <span class=\"comment\">// 子类原型指向F类的实例</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">'kevin'</span>, <span class=\"string\">'18'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child1);</span><br></pre></td></tr></table></figure></div>\n封装就是: <div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inheritPrototype</span>(<span class=\"params\">child, parent</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> prototype = <span class=\"built_in\">Object</span>.create(parent.prototype) <span class=\"comment\">// 创建基于父类原型的新对象</span></span><br><span class=\"line\">    prototype.constructor = child <span class=\"comment\">// 借用构造函数继承</span></span><br><span class=\"line\">    child.prototype = prototype <span class=\"comment\">// 原型链继承</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">inheritPrototype(Child, Parent)</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3></li>\n<li><a href=\"https://juejin.im/post/5d124a12f265da1b9163a28d\" target=\"_blank\" rel=\"noopener\">这儿有20道大厂面试题等你查收</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000009389979#item-7\" target=\"_blank\" rel=\"noopener\">JavaScript深入之继承的多种方式和优缺点</a><h2 id=\"异步加载js方式有哪些\"><a href=\"#异步加载js方式有哪些\" class=\"headerlink\" title=\"异步加载js方式有哪些\"></a>异步加载js方式有哪些</h2>js延迟加载有助于提供也没得加载速度<br>answer: <strong><script> 标签中增加 async(html5) 或者 defer(html4) 属性,脚本就会异步加载。</strong><br><code>&lt;script src=&quot;../XXX.js&quot; defer async&gt;&lt;/script&gt;</code><br>defer和async区别<ul>\n<li>defer: 延迟脚本，立即下载，但延迟执行，要等到整个页面在内存中正常渲染结束(DOM结构完全生成，即DOMContentLoaded事件之后，window.onload事件之前),<br>如果有多个 defer 脚本，会按照它们在页面出现的顺序加载</li>\n<li>async: 异步脚本，下载完立即执行，渲染引擎会中断渲染，执行完这个脚本以后，再继续渲染，不能保证按照脚本出现得先后顺序执行。<br>还有一种就说动态创建标签<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"JS\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>)</span><br><span class=\"line\">script.src = <span class=\"string\">'XX.js'</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(script)</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"vue3-composition-api\"><a href=\"#vue3-composition-api\" class=\"headerlink\" title=\"vue3 composition api\"></a>vue3 composition api</h2></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async/await\"></a>async/await</h2>","categories":[{"name":"vue","slug":"vue","count":1,"path":"api/categories/vue.json"},{"name":"js","slug":"vue/js","count":1,"path":"api/categories/vue/js.json"},{"name":"前端","slug":"vue/js/前端","count":1,"path":"api/categories/vue/js/前端.json"}],"tags":[{"name":"js","slug":"js","count":1,"path":"api/tags/js.json"},{"name":"typescript","slug":"typescript","count":1,"path":"api/tags/typescript.json"},{"name":"基础","slug":"基础","count":1,"path":"api/tags/基础.json"}]}